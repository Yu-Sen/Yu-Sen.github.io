<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yu-sen.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="hive运算符和函数，hive中DQL">
<meta property="og:type" content="article">
<meta property="og:title" content="【数据分析】第四阶段：大数据查询利器Hive（二）下">
<meta property="og:url" content="https://yu-sen.github.io/20210602153407/index.html">
<meta property="og:site_name" content="昱森笔记">
<meta property="og:description" content="hive运算符和函数，hive中DQL">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-06-02T07:34:07.000Z">
<meta property="article:modified_time" content="2021-06-06T07:56:22.816Z">
<meta property="article:author" content="昱森">
<meta property="article:tag" content="数据分析">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://yu-sen.github.io/20210602153407/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;yu-sen.github.io&#x2F;20210602153407&#x2F;&quot;,&quot;path&quot;:&quot;20210602153407&#x2F;&quot;,&quot;title&quot;:&quot;【数据分析】第四阶段：大数据查询利器Hive（二）下&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>【数据分析】第四阶段：大数据查询利器Hive（二）下 | 昱森笔记</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">昱森笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#hive%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">hive运算符和函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.1.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.2.</span> <span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.1.4.</span> <span class="nav-text">复杂运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">数学函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">日期函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">条件判断函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">字符串函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.5.</span> <span class="nav-text">统计函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E6%9E%84%E5%BB%BA%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.6.</span> <span class="nav-text">复合类型构建访问函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hive%E4%B8%ADDQL%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">hive中DQL数据查询语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Select%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">Select语句结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#explain%E6%9F%A5%E7%9C%8Bhive%E4%B8%AD%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.2.</span> <span class="nav-text">explain查看hive中语句执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hive%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.3.</span> <span class="nav-text">hive参数介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8Fhive-mapred-mode"><span class="nav-number">2.4.</span> <span class="nav-text">严格模式hive.mapred.mode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">查看当前是否为严格模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%BA%E9%9D%9E%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%88%96%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.4.2.</span> <span class="nav-text">修改为非严格模式或严格模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hive-remove-orderby-in-subquery"><span class="nav-number">2.5.</span> <span class="nav-text">hive.remove.orderby.in.subquery</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.6.</span> <span class="nav-text">普通查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2array"><span class="nav-number">2.7.</span> <span class="nav-text">查询array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9Earray%E5%AD%97%E6%AE%B5%E7%9A%84%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">2.7.1.</span> <span class="nav-text">返回array字段的某个元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explode-%E5%B1%95%E5%BC%80array%E6%88%90%E4%B8%80%E8%A1%8C"><span class="nav-number">2.7.2.</span> <span class="nav-text">explode()展开array成一行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lateral-view%E6%B5%8B%E8%AF%95%E5%9B%BE%E6%90%AD%E9%85%8Dexplode-%E8%BE%93%E5%87%BAarray%E5%AD%97%E6%AE%B5%E5%AE%8C%E6%95%B4%E5%B1%95%E5%BC%80%E7%BB%93%E6%9E%9C"><span class="nav-number">2.7.3.</span> <span class="nav-text">lateral view测试图搭配explode()输出array字段完整展开结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#collect-set-collect-list-%E8%BF%98%E5%8E%9F%E5%B1%95%E5%BC%80%E5%90%8E%E7%9A%84array"><span class="nav-number">2.7.4.</span> <span class="nav-text">collect_set(),collect_list()还原展开后的array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concat-ws-%E6%95%B0%E7%BB%84%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8Csplit-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">2.7.5.</span> <span class="nav-text">concat_ws()数组转字符串，split()字符串转数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2map"><span class="nav-number">2.8.</span> <span class="nav-text">查询map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9Emap%E5%AD%97%E6%AE%B5%E6%9F%90%E4%B8%AAkey%E7%9A%84value"><span class="nav-number">2.8.1.</span> <span class="nav-text">返回map字段某个key的value</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explode-%E5%B1%95%E5%BC%80map%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B8%80%E8%A1%8C%EF%BC%8Ckey%E3%80%81value%E5%90%84%E4%B8%80%E5%88%97"><span class="nav-number">2.8.2.</span> <span class="nav-text">explode()展开map，每个元素一行，key、value各一列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lateral-view%E6%B5%8B%E8%AF%95%E5%9B%BE%E6%90%AD%E9%85%8Dexplode-%E8%BE%93%E5%87%BAmap%E5%AD%97%E6%AE%B5%E5%AE%8C%E6%95%B4%E5%B1%95%E5%BC%80%E7%BB%93%E6%9E%9C"><span class="nav-number">2.8.3.</span> <span class="nav-text">lateral view测试图搭配explode()输出map字段完整展开结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-keys-%E8%BF%94%E5%9B%9Emap%E5%AD%97%E6%AE%B5%E5%85%A8%E9%83%A8key%E6%95%B0%E6%8D%AE"><span class="nav-number">2.8.4.</span> <span class="nav-text">map_keys()返回map字段全部key数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-values-%E8%BF%94%E5%9B%9Emap%E5%AD%97%E6%AE%B5%E5%85%A8%E9%83%A8%E5%80%BC%E6%95%B0%E6%8D%AE"><span class="nav-number">2.8.5.</span> <span class="nav-text">map_values()返回map字段全部值数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#array-contains-%E5%88%A4%E6%96%ADmap-keys-%E8%BF%94%E5%9B%9E%E7%9A%84key%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E6%9F%90%E4%B8%AAkey"><span class="nav-number">2.8.6.</span> <span class="nav-text">array_contains()判断map_keys()返回的key数组中是否含有某个key</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2struct%E7%B1%BB%E5%9E%8B%E4%B8%AD%E6%9F%90%E4%B8%AA%E5%AD%97%E6%AE%B5%E7%9A%84%E5%80%BC"><span class="nav-number">2.9.</span> <span class="nav-text">查询struct类型中某个字段的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#where%E5%90%84%E7%A7%8D%E4%BD%BF%E7%94%A8"><span class="nav-number">2.10.</span> <span class="nav-text">where各种使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#like-rlike-instr-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">2.10.1.</span> <span class="nav-text">like,rlike,instr()字符串中是否包含某个字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#in-or-find-in-set-%E5%80%BC%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%9F%90%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%AD"><span class="nav-number">2.10.2.</span> <span class="nav-text">in(),or,find_in_set()值是否存在某个集合中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#is-null-size-1%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E3%80%81%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%90%A6%E4%B8%BAnull"><span class="nav-number">2.10.3.</span> <span class="nav-text">is null,size()&#x3D;-1基本类型、数组类型是否为null</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#between-and-gt-and-lt-%E5%80%BC%E6%98%AF%E5%90%A6%E5%9C%A8%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85"><span class="nav-number">2.10.4.</span> <span class="nav-text">between and, &gt;&#x3D; and &lt;&#x3D;值是否在某个范围内</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#array-contains-find-in-set-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E6%9F%90%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">2.10.5.</span> <span class="nav-text">array_contains(),find_in_set()数组中是否含有某个元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concat-ws-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E5%85%83%E7%B4%A0%E5%90%AB%E6%9C%89%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">2.10.6.</span> <span class="nav-text">concat_ws()数组中是否有元素含有某个字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#array-contains-map%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E6%9F%90%E4%B8%AAkey"><span class="nav-number">2.10.7.</span> <span class="nav-text">array_contains()map中是否含有某个key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#not-%E5%8F%96%E5%8F%8D"><span class="nav-number">2.10.8.</span> <span class="nav-text">not, ! 取反</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E4%B8%AD%E6%9F%90%E4%B8%AAkey%E7%9A%84%E5%80%BC%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">2.10.9.</span> <span class="nav-text">map中某个key的值包含某个字符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#group-by%E5%92%8C%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="nav-number">2.11.</span> <span class="nav-text">group by和聚合函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#having%E5%92%8Cwhere"><span class="nav-number">2.11.1.</span> <span class="nav-text">having和where</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#group-by%E7%94%A8%E6%B3%95"><span class="nav-number">2.11.2.</span> <span class="nav-text">group by用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5struct%E3%80%81map%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%AAkey%E5%88%86%E7%BB%84"><span class="nav-number">2.11.3.</span> <span class="nav-text">以struct、map类型数据中的某个key分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5array%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%90%AB%E6%9C%89%E6%9F%90%E4%B8%AA%E5%80%BC%E5%88%86%E7%BB%84"><span class="nav-number">2.11.4.</span> <span class="nav-text">以array类型数据中是否含有某个值分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5%E5%88%86%E5%8C%BA%E8%A1%A8%E5%90%84%E5%88%86%E5%8C%BA%E5%88%86%E7%BB%84"><span class="nav-number">2.11.5.</span> <span class="nav-text">以分区表各分区分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1order-data%E8%A1%A8%EF%BC%8C%E6%AF%8F%E5%B9%B4%E4%B8%8B%E5%8D%8A%E5%B9%B4%E7%9A%84%E8%AE%A2%E5%8D%95%E9%87%8F"><span class="nav-number">2.11.6.</span> <span class="nav-text">统计order_data表，每年下半年的订单量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#limit"><span class="nav-number">2.12.</span> <span class="nav-text">limit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hive%E4%B8%AD%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.13.</span> <span class="nav-text">hive中排序介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#order-by%E6%8E%92%E5%BA%8F"><span class="nav-number">2.14.</span> <span class="nav-text">order by排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sort-by%E6%8E%92%E5%BA%8F"><span class="nav-number">2.15.</span> <span class="nav-text">sort by排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#distribute-by%E5%88%92%E5%88%86reduce"><span class="nav-number">2.16.</span> <span class="nav-text">distribute by划分reduce</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cluster-by"><span class="nav-number">2.17.</span> <span class="nav-text">cluster by</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A8%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="nav-number">3.</span> <span class="nav-text">表关联查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#inner-join%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.1.</span> <span class="nav-text">inner join内连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#left-join%E5%B7%A6%E8%BF%9E%E6%8E%A5%EF%BC%8Cright-join%E5%8F%B3%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.2.</span> <span class="nav-text">left join左连接，right join右连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#full-join%E5%85%A8%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.3.</span> <span class="nav-text">full join全连接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E9%9B%86%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">4.</span> <span class="nav-text">结果集的合并</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#union-union-all%E5%B9%B6%E9%9B%86"><span class="nav-number">4.1.</span> <span class="nav-text">union,union all并集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#intersect%E4%BA%A4%E9%9B%86"><span class="nav-number">4.2.</span> <span class="nav-text">intersect交集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#minus%E5%B7%AE%E9%9B%86"><span class="nav-number">4.3.</span> <span class="nav-text">minus差集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">5.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">窗口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">6.1.</span> <span class="nav-text">聚合窗口函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E7%A7%BB%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">偏移窗口函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">排序窗口函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hive%E4%B8%AD%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">7.</span> <span class="nav-text">hive中的子查询</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8A%BD%E6%A0%B7%E6%9F%A5%E8%AF%A2"><span class="nav-number">8.</span> <span class="nav-text">抽样查询</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%8A%BD%E6%A0%B7-rand-%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.</span> <span class="nav-text">随机抽样 rand()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%9D%97%E6%8A%BD%E6%A0%B7-tablesample-%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">数据块抽样 tablesample()函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%E4%B8%80%EF%BC%9Atablesample-n-percent"><span class="nav-number">8.2.1.</span> <span class="nav-text">用法一：tablesample(n percent)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%E4%BA%8C%EF%BC%9Atablesample-nM"><span class="nav-number">8.2.2.</span> <span class="nav-text">用法二：tablesample(nM)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%E4%B8%89%EF%BC%9Atablesample-n-rows"><span class="nav-number">8.2.3.</span> <span class="nav-text">用法三：tablesample(n rows)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%A1%B6%E6%8A%BD%E6%A0%B7"><span class="nav-number">8.3.</span> <span class="nav-text">分桶抽样</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">9.</span> <span class="nav-text">自定义函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hive%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">hive语句优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#group-by%E4%BB%A3%E6%9B%BFdistinct%E5%8E%BB%E9%87%8D"><span class="nav-number">10.1.</span> <span class="nav-text">group by代替distinct去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#grouping-sets-%E5%87%BD%E6%95%B0"><span class="nav-number">10.2.</span> <span class="nav-text">grouping sets()函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#grouping-sets-%E5%87%BD%E6%95%B0%EF%BC%88%E8%BD%AC%EF%BC%89"><span class="nav-number">10.3.</span> <span class="nav-text">grouping sets()函数（转）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CUBE%E5%87%BD%E6%95%B0"><span class="nav-number">10.4.</span> <span class="nav-text">CUBE函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ROLL-UP%E5%87%BD%E6%95%B0"><span class="nav-number">10.5.</span> <span class="nav-text">ROLL UP函数</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="昱森"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">昱森</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yu-sen.github.io/20210602153407/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="昱森">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="昱森笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【数据分析】第四阶段：大数据查询利器Hive（二）下
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-06-02 15:34:07" itemprop="dateCreated datePublished" datetime="2021-06-02T15:34:07+08:00">2021-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-06 15:56:22" itemprop="dateModified" datetime="2021-06-06T15:56:22+08:00">2021-06-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">hive运算符和函数，hive中DQL</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="hive运算符和函数"><a href="#hive运算符和函数" class="headerlink" title="hive运算符和函数"></a>hive运算符和函数</h1><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A =B</td>
<td>所有基本类型</td>
<td>如果表达A等于表达B，结果TRUE ，否则FALSE。</td>
</tr>
<tr>
<td>A != B</td>
<td>所有基本类型</td>
<td>如果A不等于表达式B表达返回TRUE ，否则FALSE。</td>
</tr>
<tr>
<td>A &lt;B</td>
<td>所有基本类型</td>
<td>如果表达式A小于表达式B为TRUE，否则FALSE。</td>
</tr>
<tr>
<td>A &lt;= B</td>
<td>所有基本类型</td>
<td>如果表达式A小于或等于表达式B为TRUE，否则FALSE</td>
</tr>
<tr>
<td>A &gt;B</td>
<td>所有基本类型</td>
<td>如果表达式A大于表达式B为TRUE，否则FALSE。</td>
</tr>
<tr>
<td>A &gt;= B</td>
<td>所有基本类型</td>
<td>如果表达式A大于或等于表达式B为TRUE，否则FALSE。</td>
</tr>
<tr>
<td>A [NOT] BETWEEN B AND C</td>
<td>基本数据类型</td>
<td>如果A，B或者C任一为NULL，则结果为NULL。<br />如果A的值大于等于B而且 小于或等于C，则结果为TRUE，反之为FALSE。<br />如果使用NOT关键字则可 达到相反的效果。</td>
</tr>
<tr>
<td>A IS [NOT] NULL</td>
<td>所有类型</td>
<td>如果A等于NULL，则返回TRUE，反之返回FALSE, NOT 正好相反。</td>
</tr>
<tr>
<td>A IN(数值 1, 数值2)</td>
<td>所有类型</td>
<td>如果A存在指定的数据中，则返回TRUE，反之返回FALSE</td>
</tr>
<tr>
<td>A [NOT] LIKE B</td>
<td>字符串</td>
<td>如果A与B匹配的话，则返回TRUE;反之返回FALSE。<br />%代表任意多个字 符，_代表一个字符</td>
</tr>
<tr>
<td>A RLIKE B</td>
<td>字符串</td>
<td>如果A或B为NULL;如果A任何子字符串匹配Java正则表达式B;否则 FALSE。</td>
</tr>
<tr>
<td>A REGEXP B</td>
<td>字符串</td>
<td>等同于RLIKE.</td>
</tr>
</tbody></table>
<h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A +B</td>
<td>所有数字类型</td>
<td>A加B的结果</td>
</tr>
<tr>
<td>A -B</td>
<td>所有数字类型</td>
<td>A减去B的结果</td>
</tr>
<tr>
<td>A /B</td>
<td>所有数字类型</td>
<td>A除以B的结果</td>
</tr>
<tr>
<td>A %B</td>
<td>所有数字类型</td>
<td>A除以B.产生的余数</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A AND B</td>
<td>boolean</td>
<td>如果A和B都是TRUE，否则FALSE。</td>
</tr>
<tr>
<td>A &amp;&amp; B</td>
<td>boolean</td>
<td>类似于 A AND B.</td>
</tr>
<tr>
<td>A OR B</td>
<td>boolean</td>
<td>TRUE，如果A或B或两者都是TRUE，否则FALSE。</td>
</tr>
<tr>
<td>A ||B</td>
<td>boolean</td>
<td>类似于 A OR B.</td>
</tr>
<tr>
<td>NOT A</td>
<td>boolean</td>
<td>TRUE，如果A是FALSE，否则FALSE。</td>
</tr>
<tr>
<td>!A</td>
<td>boolean</td>
<td>类似于 NOT A.</td>
</tr>
</tbody></table>
<h3 id="复杂运算符"><a href="#复杂运算符" class="headerlink" title="复杂运算符"></a>复杂运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A[n]</td>
<td>A是一个数组，n是一个int</td>
<td>它返回数组A的第n个元素，第一个元素的索引0。</td>
</tr>
<tr>
<td>M[key]</td>
<td>M是一个 Map&lt;K, V&gt;，并且key 的类型为K</td>
<td>它返回对应于映射中关键字的值。</td>
</tr>
<tr>
<td>S.x</td>
<td>S是一个结构</td>
<td>它返回S的s字段</td>
</tr>
</tbody></table>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>round(double a) <br />round(double a, int d)</td>
<td>BIGINT <br />DOUBLE</td>
<td>返回double类型的整数值部分 (遵循四舍五入) 返回 指定精度d的double类型</td>
</tr>
<tr>
<td>floor(double a)</td>
<td>BIGINT</td>
<td>返回等于或者小于该double变量的最大的整数</td>
</tr>
<tr>
<td>ceil(double a)</td>
<td>BIGINT</td>
<td>返回等于或者大于该double变量的最小的整数</td>
</tr>
<tr>
<td>rand()<br /> rand(int seed)</td>
<td>DOUBLE</td>
<td>返回一个0到1范围内的随机数。如果指定种子seed， 则会得到一个稳定的随机数序列.</td>
</tr>
<tr>
<td>pow(double a, double p)</td>
<td>DOUBLE</td>
<td>返回a的p次幂</td>
</tr>
<tr>
<td>sqrt(double a)</td>
<td>DOUBLE</td>
<td>返回a的平方根</td>
</tr>
<tr>
<td>abs(double a) <br />abs(int a)</td>
<td>DOUBLE <br />INT</td>
<td>返回数值a的绝对值</td>
</tr>
</tbody></table>
<h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>from_unixtime(bigint unixtime[, string format])</td>
<td>STRING</td>
<td>转化UNIX时间戳(从1970-01-01 00:00:00 UTC到指 定时间的秒数) 到当前时区的时间格式</td>
</tr>
<tr>
<td>unix_timestamp() unix_timestamp(string date) unix_timestamp(string date, string pattern)</td>
<td>BIGINT</td>
<td>获得当前时区的UNIX时间戳 转换格式为”yyyy-MM-dd HH:mm:ss”的日期到UNIX时间戳。如果转化失败，则 返回0 转换pattern格式的日期到UNIX时间戳。如果转 化失败，则返回0</td>
</tr>
<tr>
<td>to_date(string timestamp)</td>
<td>STRING</td>
<td>返回日期时间字段中的日期部分</td>
</tr>
<tr>
<td>year(string date) <br />month (string date) <br />day (string date)</td>
<td>INT</td>
<td>分别返回日期中的年 月 天</td>
</tr>
<tr>
<td>hour (string date) <br />minute (string date) <br />second (string date)</td>
<td>INT</td>
<td>分别返回日期中的时 分 秒</td>
</tr>
<tr>
<td>weekofyear (string date)</td>
<td>INT</td>
<td>返回日期在当年的第几周</td>
</tr>
<tr>
<td>datediff(string enddate, string startdate)</td>
<td>INT</td>
<td>返回结束日期减去开始日期的天数 日期有格式要求 yyyy-mm-dd hh:MM:ss 或 yyyy-mm-dd</td>
</tr>
<tr>
<td>date_add(string startdate, int days)</td>
<td>STRING</td>
<td>days为正数，返回开始日期startdate增加days天后的日期。<br />days为负数，返回开始日期startdate减少days天前的日期。</td>
</tr>
<tr>
<td>date_sub (string startdate, int days)</td>
<td>STRING</td>
<td>返回开始日期startdate减少days天后的日期</td>
</tr>
<tr>
<td>add_months(string startdate, int months)</td>
<td>STRING</td>
<td>months为正数，返回开始日期startdate增加months月后的日期。<br />months为负数，返回开始日期startdate减少months月前的日期。</td>
</tr>
</tbody></table>
<h3 id="条件判断函数"><a href="#条件判断函数" class="headerlink" title="条件判断函数"></a>条件判断函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>if(boolean testCondition, T valueTrue, T valueFalseOrNull)</td>
<td>T</td>
<td>当条件testCondition为TRUE时，返回 valueTrue;否则返回valueFalseOrNull</td>
</tr>
<tr>
<td>coalesce(T v1, T v2, …)</td>
<td>T</td>
<td>返回参数中的第一个非空值;如果所有值都为 NULL，那么返回NULL</td>
</tr>
<tr>
<td>CASE a WHEN b THEN c [WHEN d THEN e] [ELSE f] END</td>
<td>T</td>
<td>如果a等于b，那么返回c;如果a等于d，那么返 回e;否则返回f</td>
</tr>
<tr>
<td>CASE WHEN a THEN b [WHEN c THEN d] [ELSE e] END</td>
<td>T</td>
<td>如果a为TRUE,则返回b;如果c为TRUE，则返回d;否则返回e</td>
</tr>
</tbody></table>
<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>length(string A)</td>
<td>INT</td>
<td>返回字符串A的长度</td>
</tr>
<tr>
<td>reverse(string A)</td>
<td>STRING</td>
<td>返回字符串A的反转结果</td>
</tr>
<tr>
<td>concat(string A, string B…)</td>
<td>STRING</td>
<td>返回输入字符串连接后的结果，支持任意 个输入字符串</td>
</tr>
<tr>
<td>concat_ws(string SEP, string A, string B…)</td>
<td>STRING</td>
<td>返回输入字符串连接后的结果，SEP表示各个字符串间的分隔符</td>
</tr>
<tr>
<td>substr(string A, int start)<br />substring(string A, int start) <br />substr(string A, int start, int len)<br />substring(string A, int start, int len)</td>
<td>STRING</td>
<td>返回字符串A从start位置到结尾的字符串 返回字符串A从start位置开始，长度为 len的字符串</td>
</tr>
<tr>
<td>upper(string A) ucase(string A)</td>
<td>STRING</td>
<td>返回字符串A的大写格式</td>
</tr>
<tr>
<td>lower(string A) lcase(string A)</td>
<td>STRING</td>
<td>返回字符串A的小写格式</td>
</tr>
<tr>
<td>trim(string A) <br />ltrim(string A)<br />rtrim(string A)</td>
<td>STRING</td>
<td>去除字符串两边的空格 除字符串左边的空格 去除字符串右边的空格</td>
</tr>
<tr>
<td>regexp_replace(string A, string B, string C)</td>
<td>STRING</td>
<td>将字符串A中的符合java正则表达式B的 部分替换为C</td>
</tr>
<tr>
<td>regexp_extract(string subject, string pattern, int index)</td>
<td>STRING</td>
<td>将字符串subject按照pattern正则表达式的规则拆分，返回index指定的字符</td>
</tr>
<tr>
<td>parse_url(string urlString, string partToExtract [, string keyToExtract])</td>
<td>STRING</td>
<td>返回URL中指定的部分。partToExtract 的有效值为:HOST, PATH, QUERY, REF, PROTOCOL, AUTHORITY, FILE, and USERINFO.</td>
</tr>
<tr>
<td>get_json_object(string json_string, string path)</td>
<td>STRING</td>
<td>解析json的字符串json_string,返回path 指定的内容。如果输入的json字符串无 效，那么返回NULL</td>
</tr>
<tr>
<td>space(int n)</td>
<td>STRING</td>
<td>返回长度为n的空格字符串</td>
</tr>
<tr>
<td>repeat(string str, int n)</td>
<td>STRING</td>
<td>返回重复n次后的str字符串</td>
</tr>
<tr>
<td>lpad(string str, int len, string pad) rpad(string str, int len, string pad)</td>
<td>STRING</td>
<td>将str进行用pad进行左补足到len位 将str 进行用pad进行右补足到len位</td>
</tr>
<tr>
<td>split(string str, string pat)</td>
<td>ARRAY</td>
<td>按照pat字符串分割str，会返回分割后的 字符串数组</td>
</tr>
<tr>
<td>find_in_set(string str, string strList) find_in_set(‘ab’,’aa,ab,ac’)</td>
<td>INT</td>
<td>返回str在strlist第一次出现的位置， strlist是用逗号分割的字符串。如果没有 找该str字符，则返回0</td>
</tr>
<tr>
<td>instr(string str, string substr) instr(“abcde”,”ab”)</td>
<td>INT</td>
<td>返回substr在str中第一次出现的位置， 未出现则返回0(如果参数为NULL则返 回NULL;位置从1开始)</td>
</tr>
</tbody></table>
<h3 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>count(*)<br />count(expr)<br />count(DISTINCT expr[, expr_.])</td>
<td>INT</td>
<td>count(*)统计检索出的行的个数，包括NULL值的行;<br />count(expr)返回指定字段的非空值的个数;<br />count(DISTINCT expr[, expr_.])返回指定字段的不同的非空值的个数</td>
</tr>
<tr>
<td>sum(col), sum(DISTINCT col)</td>
<td>DOUBLE</td>
<td>sum(col)统计结果集中col的相加的结果;sum(DISTINCT col)统计结果中col不同值相加的结果</td>
</tr>
<tr>
<td>avg(col), avg(DISTINCT col)</td>
<td>DOUBLE</td>
<td>avg(col)统计结果集中col的平均值;avg(DISTINCT col)统计 结果中col不同值相加的平均值</td>
</tr>
<tr>
<td>min(col) max(col)</td>
<td>DOUBLE</td>
<td>统计结果集中col字段的最小值 统计结果集中col字段的最大 值</td>
</tr>
<tr>
<td>var_pop(col) var_samp (col)</td>
<td>DOUBLE</td>
<td>统计结果集中col非空集合的总体方差 统计结果集中col非空 集合的样本变量</td>
</tr>
<tr>
<td>stddev_pop(col) stddev_samp (col)</td>
<td>DOUBLE</td>
<td>统计结果集中col非空集合的总体标准差 统计结果集中col非 空集合的样本标准差</td>
</tr>
<tr>
<td>percentile(BIGINT col, p)</td>
<td>DOUBLE</td>
<td>求准确的第p个百分位数，p必须介于0和1之间，但是col字段 目前只支持整数，不支持浮点数类型</td>
</tr>
<tr>
<td>percentile(BIGINT col, array(p1 [, p2]…))</td>
<td>ARRAY</td>
<td>功能和上述类似，之后后面可以输入多个百分位数，返回类 型也为array，其中为对应的百分位数</td>
</tr>
</tbody></table>
<h3 id="复合类型构建访问函数"><a href="#复合类型构建访问函数" class="headerlink" title="复合类型构建访问函数"></a>复合类型构建访问函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>map (key1, value1, key2, value2, …)</td>
<td>MAP</td>
<td>根据输入的key和value对构建map类型</td>
</tr>
<tr>
<td>struct(val1, val2, val3, …)</td>
<td>STRUCT</td>
<td>根据输入的参数构建结构体struct类型</td>
</tr>
<tr>
<td>array(val1, val2, …)</td>
<td>ARRAY</td>
<td>根据输入的参数构建数组array类型</td>
</tr>
<tr>
<td>A[n]</td>
<td></td>
<td>返回数组A中的第n个变量值。数组的起始下标 为0。</td>
</tr>
<tr>
<td>M[key]</td>
<td></td>
<td>返回map类型M中，key值为指定值的value值</td>
</tr>
<tr>
<td>S.x</td>
<td></td>
<td>返回结构体S中的x字段</td>
</tr>
<tr>
<td>size(Map&lt;K.V&gt;) size(Array)</td>
<td>INT</td>
<td>返回map类型的长度 返回array类型的长度</td>
</tr>
<tr>
<td>explode(map|array)</td>
<td></td>
<td>列变行</td>
</tr>
<tr>
<td>collect_set ( col)</td>
<td>Array</td>
<td>对col行变列并 去重</td>
</tr>
<tr>
<td>collect_list ( col)</td>
<td>Array</td>
<td>对col行变列并 不去重</td>
</tr>
<tr>
<td>map_keys(map)</td>
<td>Array</td>
<td>取map类型的所有Key</td>
</tr>
<tr>
<td>map_values(map)</td>
<td>Array</td>
<td>取map类型的所有value</td>
</tr>
<tr>
<td>array_contains(array,obj)</td>
<td>T</td>
<td>判断指定的obj 是否在数组中</td>
</tr>
</tbody></table>
<h1 id="hive中DQL数据查询语言"><a href="#hive中DQL数据查询语言" class="headerlink" title="hive中DQL数据查询语言"></a>hive中DQL数据查询语言</h1><h2 id="Select语句结构"><a href="#Select语句结构" class="headerlink" title="Select语句结构"></a>Select语句结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT [ALL | DISTINCT] select_expr, select_expr, ... FROM table_reference</span><br><span class="line">[WHERE where_condition]</span><br><span class="line">[GROUP BY col_list]</span><br><span class="line">[HAVING having_condition]</span><br><span class="line">[CLUSTER BY col_list | [DISTRIBUTE BY col_list] [SORT BY col_list]][ORDER BY</span><br><span class="line">col_list]</span><br><span class="line">[LIMIT number];</span><br></pre></td></tr></table></figure>

<p>语句的顺序不能错。</p>
<h2 id="explain查看hive中语句执行顺序"><a href="#explain查看hive中语句执行顺序" class="headerlink" title="explain查看hive中语句执行顺序"></a>explain查看hive中语句执行顺序</h2><p>可以通过explain关键字查看执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from sales_info;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 例如</span><br><span class="line">explain</span><br><span class="line">select basic_info.age, count(1) as renshu </span><br><span class="line">from test_student</span><br><span class="line">where id &gt;3</span><br><span class="line">group by basic_info.age</span><br><span class="line">having renshu &gt; 1</span><br><span class="line">order by renshu desc</span><br><span class="line">limit 10;</span><br></pre></td></tr></table></figure>

<p>hive语句的执行顺序:<br> <strong>from –&gt;where –&gt; select –&gt; group by –&gt;聚合函数–&gt; having –&gt; order by –&gt;limit</strong></p>
<p>hive语句是转化为mapReduce语句执行的。 </p>
<p>Map过程：from，where，select。根据每一个map产生一个本地的reduce，也对本地的数据块进行group by，聚合，但并不进行having。</p>
<p>Reduce过程：再次进行group by，聚合。然后进行having，order by，limit等。 把map产生的reduce进行合并，合并为我们指定的reduce个数。reduce会产生文件输出。</p>
<p>除了select的顺序和mysql不一样，其他都一样。</p>
<h2 id="hive参数介绍"><a href="#hive参数介绍" class="headerlink" title="hive参数介绍"></a>hive参数介绍</h2><h2 id="严格模式hive-mapred-mode"><a href="#严格模式hive-mapred-mode" class="headerlink" title="严格模式hive.mapred.mode"></a>严格模式hive.mapred.mode</h2><h3 id="查看当前是否为严格模式"><a href="#查看当前是否为严格模式" class="headerlink" title="查看当前是否为严格模式"></a>查看当前是否为严格模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set hive.mapred.mode</span><br><span class="line">-- </span><br><span class="line">hive.mapred.mode &#x3D; strict</span><br></pre></td></tr></table></figure>

<h3 id="修改为非严格模式或严格模式"><a href="#修改为非严格模式或严格模式" class="headerlink" title="修改为非严格模式或严格模式"></a>修改为非严格模式或严格模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set hive.mapred.mode &#x3D; strict </span><br><span class="line">set hive.mapred.mode &#x3D; nostrict</span><br></pre></td></tr></table></figure>

<p>严格模式下，这三种情况会报错</p>
<ul>
<li>笛卡尔积不能查询(表关联join不写关联条件)</li>
<li>order by排序，必须加limit语句</li>
<li> 读取partitioned table，但没有指定partition</li>
</ul>
<h2 id="hive-remove-orderby-in-subquery"><a href="#hive-remove-orderby-in-subquery" class="headerlink" title="hive.remove.orderby.in.subquery"></a>hive.remove.orderby.in.subquery</h2><p>Hive 3.0.0以上 hive.remove.orderby.in.subquery为true，subqueries和views中没有limit的Order by将会被optimizer(优化器)移除。</p>
<p>在子查询和查询视图的时候需要设置为false。</p>
<h2 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from sales_info;</span><br><span class="line"></span><br><span class="line">select sku_id from sales_info;</span><br><span class="line"></span><br><span class="line">select sku_id as id from salse_info;</span><br></pre></td></tr></table></figure>

<h2 id="查询array"><a href="#查询array" class="headerlink" title="查询array"></a>查询array</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- sales_info表数据</span><br><span class="line"> 	sku_id	sku_name	id_array</span><br><span class="line">1	123	华为Mate10	[&quot;1235&quot;,&quot;345&quot;]</span><br><span class="line">2	456	华为Mate30	[&quot;89&quot;,&quot;635&quot;]</span><br><span class="line">3	789	小米5	[&quot;452&quot;,&quot;63&quot;]</span><br><span class="line">4	1235	小米6	[&quot;785&quot;,&quot;36&quot;]</span><br><span class="line">5	4562	OPPO Findx	[&quot;7875&quot;,&quot;3563&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="返回array字段的某个元素"><a href="#返回array字段的某个元素" class="headerlink" title="返回array字段的某个元素"></a>返回array字段的某个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询数组字段的第一个元素</span><br><span class="line">select id_array[0] from sales_info;</span><br><span class="line"></span><br><span class="line">1	1235</span><br><span class="line">2	89</span><br><span class="line">3	452</span><br><span class="line">4	785</span><br><span class="line">5	7875</span><br></pre></td></tr></table></figure>

<h3 id="explode-展开array成一行"><a href="#explode-展开array成一行" class="headerlink" title="explode()展开array成一行"></a>explode()展开array成一行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 查询数组字段所有数据，并且将数组展开，每个元素在一行展示</span><br><span class="line">select explode(id_array) from sales_info;</span><br><span class="line"></span><br><span class="line">1	1235</span><br><span class="line">2	345</span><br><span class="line">3	89</span><br><span class="line">4	635</span><br><span class="line">5	452</span><br><span class="line">6	63</span><br><span class="line">7	785</span><br><span class="line">8	36</span><br><span class="line">9	7875</span><br><span class="line">10	3563</span><br></pre></td></tr></table></figure>

<h3 id="lateral-view测试图搭配explode-输出array字段完整展开结果"><a href="#lateral-view测试图搭配explode-输出array字段完整展开结果" class="headerlink" title="lateral view测试图搭配explode()输出array字段完整展开结果"></a>lateral view测试图搭配explode()输出array字段完整展开结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 在explode的基础上，每行数组元素还要展示对应的sku_id, sku_name</span><br><span class="line">select sku_id, sku_name, id_list from sales_info lateral view explode(id_array) ids as id_list;</span><br><span class="line"></span><br><span class="line">1 123	华为Mate10	1235</span><br><span class="line">2	123	华为Mate10	345</span><br><span class="line">3	456	华为Mate30	89</span><br><span class="line">4	456	华为Mate30	635</span><br><span class="line">5	789	小米5	452</span><br><span class="line">6	789	小米5	63</span><br><span class="line">7	1235	小米6	785</span><br><span class="line">8	1235	小米6	36</span><br><span class="line">9	4562	OPPO Findx	7875</span><br><span class="line">10	4562	OPPO Findx	3563</span><br><span class="line"></span><br><span class="line">语法：select 原表字段1, 原表字段2, 虚拟表字段名 from 原表 lateral view explode(原表数组字段名) 虚拟表名 as 虚拟表字段名。</span><br><span class="line">lateral view explode(id_array)ids相当于一个虚拟表，与原表sales_info笛卡尔积关联。也可以多重使用</span><br><span class="line">select ...from ... lateral view ... lateral view ...</span><br><span class="line">lateral view 测试图。侧视图的意义是配合explode（或者其他的UDTF），一个语句生成把单行数据拆解成多行后的数据结果集。</span><br></pre></td></tr></table></figure>

<h3 id="collect-set-collect-list-还原展开后的array"><a href="#collect-set-collect-list-还原展开后的array" class="headerlink" title="collect_set(),collect_list()还原展开后的array"></a>collect_set(),collect_list()还原展开后的array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- sales_info_explode表，sales_info展开后的结果，并且插入了一条重复数据 789 小米5 63</span><br><span class="line"> 	sku_id sku_name	id_list</span><br><span class="line">1	123	华为Mate10	1235</span><br><span class="line">2	123	华为Mate10	345</span><br><span class="line">3	456	华为Mate30	89</span><br><span class="line">4	456	华为Mate30	635</span><br><span class="line">5	789	小米5	452</span><br><span class="line">6	789	小米5	63</span><br><span class="line">7	1235	小米6	785</span><br><span class="line">8	1235	小米6	36</span><br><span class="line">9	4562	OPPO Findx	7875</span><br><span class="line">10	4562	OPPO Findx	3563</span><br><span class="line">11	789	小米5	63</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 通过letaral view explode能将数组展开，也可以通过collect_set() collect_list()将展开的数组元素再合并回去</span><br><span class="line"></span><br><span class="line">-- collect_set()函数 去重</span><br><span class="line">select sku_id,sku_name, collect_set(id_list) from sales_info_explode group by sku_id,sku_name;</span><br><span class="line">-- 结果</span><br><span class="line"> 	sku_id	sku_name	_c2</span><br><span class="line">1	123	华为Mate10	[&quot;1235&quot;,&quot;345&quot;]</span><br><span class="line">2	1235	小米6	[&quot;785&quot;,&quot;36&quot;]</span><br><span class="line">3	456	华为Mate30	[&quot;89&quot;,&quot;635&quot;]</span><br><span class="line">4	4562	OPPO Findx	[&quot;7875&quot;,&quot;3563&quot;]</span><br><span class="line">5	789	小米5	[&quot;452&quot;,&quot;63&quot;] --数据中有两条789 小米5 63，这里去重了</span><br><span class="line"></span><br><span class="line">-- collect_list()函数 不去重</span><br><span class="line">select sku_id,sku_name, collect_list(id_list) from sales_info_explode group by sku_id,sku_name;</span><br><span class="line">-- 结果</span><br><span class="line">	sku_id	sku_name	_c2</span><br><span class="line">1	123	华为Mate10	[&quot;1235&quot;,&quot;345&quot;]</span><br><span class="line">2	1235	小米6	[&quot;785&quot;,&quot;36&quot;]</span><br><span class="line">3	456	华为Mate30	[&quot;89&quot;,&quot;635&quot;]</span><br><span class="line">4	4562	OPPO Findx	[&quot;7875&quot;,&quot;3563&quot;]</span><br><span class="line">5	789	小米5	[&quot;452&quot;,&quot;63&quot;,&quot;63&quot;] -- 没去重</span><br></pre></td></tr></table></figure>

<h3 id="concat-ws-数组转字符串，split-字符串转数组"><a href="#concat-ws-数组转字符串，split-字符串转数组" class="headerlink" title="concat_ws()数组转字符串，split()字符串转数组"></a>concat_ws()数组转字符串，split()字符串转数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- concat_ws(分隔字符,字符串1,字符串2...) split(字符串,分隔字符)</span><br><span class="line">select </span><br><span class="line">	sku_id, sku_name, id_array, </span><br><span class="line">	concat_ws(&#39;_&#39;, id_array) as aryToStr, </span><br><span class="line">	split(concat_ws(&#39;_&#39;, id_array), &#39;_&#39;) as strToAry </span><br><span class="line">from sales_info;</span><br><span class="line"></span><br><span class="line"> 	sku_id	sku_name	id_array	arytostr	strtoary</span><br><span class="line">1	123	华为Mate10	[&quot;1235&quot;,&quot;345&quot;]	1235_345	[&quot;1235&quot;,&quot;345&quot;]</span><br><span class="line">2	456	华为Mate30	[&quot;89&quot;,&quot;635&quot;]	89_635	[&quot;89&quot;,&quot;635&quot;]</span><br><span class="line">3	789	小米5	[&quot;452&quot;,&quot;63&quot;]	452_63	[&quot;452&quot;,&quot;63&quot;]</span><br><span class="line">4	1235	小米6	[&quot;785&quot;,&quot;36&quot;]	785_36	[&quot;785&quot;,&quot;36&quot;]</span><br><span class="line">5	4562	OPPO Findx	[&quot;7875&quot;,&quot;3563&quot;]	7875_3563	[&quot;7875&quot;,&quot;3563&quot;]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查询map"><a href="#查询map" class="headerlink" title="查询map"></a>查询map</h2><h3 id="返回map字段某个key的value"><a href="#返回map字段某个key的value" class="headerlink" title="返回map字段某个key的value"></a>返回map字段某个key的value</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- mapKeys表数据</span><br><span class="line"> 	sku_id	sku_name	state_map</span><br><span class="line">1	123	华为Mate10	&#123;&quot;id&quot;:&quot;1111&quot;,&quot;token&quot;:&quot;2222&quot;,&quot;user_name&quot;:&quot;zhangsan1 &quot;&#125;</span><br><span class="line">2	456	华为Mate30	&#123;&quot;id&quot;:&quot;1113&quot;,&quot;token&quot;:&quot;2224&quot;,&quot;user_name&quot;:&quot;zhangsan3 &quot;&#125;</span><br><span class="line">3	789	小米5	&#123;&quot;id&quot;:&quot;1114&quot;,&quot;token&quot;:&quot;2225&quot;,&quot;user_name&quot;:&quot;zhangsan4 &quot;&#125;</span><br><span class="line">4	1235	小米6	&#123;&quot;id&quot;:&quot;1115&quot;,&quot;token&quot;:&quot;2226&quot;,&quot;user_name&quot;:&quot;zhangsan5 &quot;&#125;</span><br><span class="line">5	4562	OPPO Findx	&#123;&quot;id&quot;:&quot;1116&quot;,&quot;token&quot;:&quot;2227&quot;,&quot;user_name&quot;:&quot;zhangsan6&quot;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">select state_map[&#39;id&#39;] from mapKeys;</span><br><span class="line"></span><br><span class="line"> 	_c0</span><br><span class="line">1	1111</span><br><span class="line">2	1113</span><br><span class="line">3	1114</span><br><span class="line">4	1115</span><br><span class="line">5	1116</span><br><span class="line"></span><br><span class="line">-- 访问不存在的key，会返回null值</span><br><span class="line">select state_map[&#39;user_name&#39;], state_map[&#39;name&#39;] from mapkeys;</span><br><span class="line">1	zhangsan1 	NULL</span><br><span class="line">2	zhangsan3 	NULL</span><br><span class="line">3	zhangsan4 	NULL</span><br><span class="line">4	zhangsan5 	NULL</span><br><span class="line">5	zhangsan6	  NULL</span><br><span class="line"></span><br><span class="line">-- 用if判断，访问不存在的key，返回指定值而非null</span><br><span class="line">select state_map[&#39;user_name&#39;], if(state_map[&#39;name&#39;] is null, &#39;无&#39;, state_map[&#39;name&#39;]) from mapkeys;</span><br><span class="line">1 zhangsan1 	无</span><br><span class="line">2	zhangsan3 	无</span><br><span class="line">3	zhangsan4 	无</span><br><span class="line">4	zhangsan5 	无</span><br><span class="line">5	zhangsan6	  无</span><br></pre></td></tr></table></figure>

<h3 id="explode-展开map，每个元素一行，key、value各一列"><a href="#explode-展开map，每个元素一行，key、value各一列" class="headerlink" title="explode()展开map，每个元素一行，key、value各一列"></a>explode()展开map，每个元素一行，key、value各一列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">select explode(state_map) from mapKeys;</span><br><span class="line"> </span><br><span class="line"> 	key	value</span><br><span class="line">1	id	1111</span><br><span class="line">2	token	2222</span><br><span class="line">3	user_name	zhangsan1 </span><br><span class="line">4	id	1113</span><br><span class="line">5	token	2224</span><br><span class="line">6	user_name	zhangsan3 </span><br><span class="line">7	id	1114</span><br><span class="line">8	token	2225</span><br><span class="line">9	user_name	zhangsan4 </span><br><span class="line">10	id	1115</span><br><span class="line">11	token	2226</span><br><span class="line">12	user_name	zhangsan5 </span><br><span class="line">13	id	1116</span><br><span class="line">14	token	2227</span><br><span class="line">15	user_name	zhangsan6</span><br></pre></td></tr></table></figure>

<h3 id="lateral-view测试图搭配explode-输出map字段完整展开结果"><a href="#lateral-view测试图搭配explode-输出map字段完整展开结果" class="headerlink" title="lateral view测试图搭配explode()输出map字段完整展开结果"></a>lateral view测试图搭配explode()输出map字段完整展开结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">	sku_id, sku_name,stateKey,stateVal </span><br><span class="line">from mapkeys lateral view explode(state_map) lt as stateKey, stateVal;</span><br><span class="line"> </span><br><span class="line"> 	sku_id	sku_name	statekey	stateval</span><br><span class="line">1	123	华为Mate10	id	1111</span><br><span class="line">2	123	华为Mate10	token	2222</span><br><span class="line">3	123	华为Mate10	user_name	zhangsan1 </span><br><span class="line">4	456	华为Mate30	id	1113</span><br><span class="line">5	456	华为Mate30	token	2224</span><br><span class="line">6	456	华为Mate30	user_name	zhangsan3 </span><br><span class="line">7	789	小米5	id	1114</span><br><span class="line">8	789	小米5	token	2225</span><br><span class="line">9	789	小米5	user_name	zhangsan4 </span><br><span class="line">10	1235	小米6	id	1115</span><br><span class="line">11	1235	小米6	token	2226</span><br><span class="line">12	1235	小米6	user_name	zhangsan5 </span><br><span class="line">13	4562	OPPO Findx	id	1116</span><br><span class="line">14	4562	OPPO Findx	token	2227</span><br><span class="line">15	4562	OPPO Findx	user_name	zhangsan6</span><br></pre></td></tr></table></figure>

<h3 id="map-keys-返回map字段全部key数据"><a href="#map-keys-返回map字段全部key数据" class="headerlink" title="map_keys()返回map字段全部key数据"></a>map_keys()返回map字段全部key数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select map_keys(state_map) from mapkeys;</span><br><span class="line"></span><br><span class="line">1	[&quot;id&quot;,&quot;token&quot;,&quot;user_name&quot;]</span><br><span class="line">2	[&quot;id&quot;,&quot;token&quot;,&quot;user_name&quot;]</span><br><span class="line">3	[&quot;id&quot;,&quot;token&quot;,&quot;user_name&quot;]</span><br><span class="line">4	[&quot;id&quot;,&quot;token&quot;,&quot;user_name&quot;]</span><br><span class="line">5	[&quot;id&quot;,&quot;token&quot;,&quot;user_name&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="map-values-返回map字段全部值数据"><a href="#map-values-返回map字段全部值数据" class="headerlink" title="map_values()返回map字段全部值数据"></a>map_values()返回map字段全部值数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select map_values(state_map) from mapkeys;</span><br><span class="line"></span><br><span class="line">1 [&quot;1111&quot;,&quot;2222&quot;,&quot;zhangsan1 &quot;]</span><br><span class="line">2	[&quot;1113&quot;,&quot;2224&quot;,&quot;zhangsan3 &quot;]</span><br><span class="line">3	[&quot;1114&quot;,&quot;2225&quot;,&quot;zhangsan4 &quot;]</span><br><span class="line">4	[&quot;1115&quot;,&quot;2226&quot;,&quot;zhangsan5 &quot;]</span><br><span class="line">5	[&quot;1116&quot;,&quot;2227&quot;,&quot;zhangsan6&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="array-contains-判断map-keys-返回的key数组中是否含有某个key"><a href="#array-contains-判断map-keys-返回的key数组中是否含有某个key" class="headerlink" title="array_contains()判断map_keys()返回的key数组中是否含有某个key"></a>array_contains()判断map_keys()返回的key数组中是否含有某个key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">	array_contains(map_keys(state_map),&quot;id&quot;),</span><br><span class="line">	array_contains(map_keys(state_map),&#39;name&#39;) </span><br><span class="line">from mapkeys;</span><br><span class="line"></span><br><span class="line">1	true	false</span><br><span class="line">2	true	false</span><br><span class="line">3	true	false</span><br><span class="line">4	true	false</span><br><span class="line">5	true	false</span><br></pre></td></tr></table></figure>

<h2 id="查询struct类型中某个字段的值"><a href="#查询struct类型中某个字段的值" class="headerlink" title="查询struct类型中某个字段的值"></a>查询struct类型中某个字段的值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- test_student表中，basic_info字段为struct类型，&#96;basic_info&#96; struct&lt;name:string,age:int&gt;</span><br><span class="line"></span><br><span class="line">select basic_info.name from test_student;</span><br></pre></td></tr></table></figure>

<h2 id="where各种使用"><a href="#where各种使用" class="headerlink" title="where各种使用"></a>where各种使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- sales_info表数据</span><br><span class="line"> 	sku_id sku_name	id_array</span><br><span class="line">1	123	华为Mate10	[&quot;1235&quot;,&quot;345&quot;]</span><br><span class="line">2	456	华为Mate30	[&quot;89&quot;,&quot;635&quot;]</span><br><span class="line">3	789	小米5	[&quot;452&quot;,&quot;63&quot;]</span><br><span class="line">4	1235	小米6	[&quot;785&quot;,&quot;36&quot;]</span><br><span class="line">5	4562	OPPO Findx	[&quot;7875&quot;,&quot;3563&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="like-rlike-instr-字符串中是否包含某个字符"><a href="#like-rlike-instr-字符串中是否包含某个字符" class="headerlink" title="like,rlike,instr()字符串中是否包含某个字符"></a>like,rlike,instr()字符串中是否包含某个字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 选出sku_name包含A的</span><br><span class="line">select * from sales_info where sku_name like &#39;%A%&#39;;</span><br><span class="line"></span><br><span class="line">select * from sales_info where instr(sku_name,&#39;A&#39;)&gt;0;</span><br><span class="line">-- instr(字符串,字符) 返回字符在字符串中首次出现的位置，如果没有返回0</span><br><span class="line"></span><br><span class="line">select * from sales_info where sku_name rlike &#39;A&#39;;</span><br><span class="line">-- rlike 正则表达式。这里用的java正则，和js正则在转义符上不同</span><br><span class="line">在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。</span><br><span class="line">在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。</span><br><span class="line">-- js中 \d 表示 0-9</span><br><span class="line">-- java中 \\d 表示 0-9</span><br></pre></td></tr></table></figure>

<h3 id="in-or-find-in-set-值是否存在某个集合中"><a href="#in-or-find-in-set-值是否存在某个集合中" class="headerlink" title="in(),or,find_in_set()值是否存在某个集合中"></a>in(),or,find_in_set()值是否存在某个集合中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- sku_name为小米5或小米6的</span><br><span class="line">select * from sales_info where sku_name in(&#39;小米5&#39;,&#39;小米6&#39;);</span><br><span class="line"></span><br><span class="line">select * from sales_info where sku_name&#x3D;&#39;小米5&#39; or sku_name&#x3D;&#39;小米6&#39;;</span><br><span class="line"></span><br><span class="line">select * from sales_info where find_in_set(sku_name,&#39;小米5,小米6&#39;)&gt;0;</span><br><span class="line">-- find_in_set(字符串,字符串集) 返回字符串在字符串集中首次出现的位置，没有返回0；字符串集是多个字符串用,间隔的字符串</span><br></pre></td></tr></table></figure>

<h3 id="is-null-size-1基本类型、数组类型是否为null"><a href="#is-null-size-1基本类型、数组类型是否为null" class="headerlink" title="is null,size()=-1基本类型、数组类型是否为null"></a>is null,size()=-1基本类型、数组类型是否为null</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 基本类型是否为null</span><br><span class="line">select * from sales_info where sku_id is null;</span><br><span class="line"></span><br><span class="line">-- 数组类型是否为null</span><br><span class="line">select * from sales_info where size(id_array)&#x3D; -1;</span><br><span class="line">--size(数组) 返回数组长度，也就是数组元素个数。当值为null时，返回-1</span><br><span class="line">size(array(&#39;&#39;)) &#x3D; 0</span><br><span class="line">size(array(&#39;1&#39;)) &#x3D; 1</span><br><span class="line">size(null) &#x3D; -1</span><br></pre></td></tr></table></figure>

<h3 id="between-and-gt-and-lt-值是否在某个范围内"><a href="#between-and-gt-and-lt-值是否在某个范围内" class="headerlink" title="between and, &gt;= and &lt;=值是否在某个范围内"></a>between and, &gt;= and &lt;=值是否在某个范围内</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from sales_info where sku_id between 100 and 800;</span><br><span class="line"></span><br><span class="line">select * from sales_info where sku_id&gt;&#x3D;100 and sku_id&lt;&#x3D;800;</span><br></pre></td></tr></table></figure>

<h3 id="array-contains-find-in-set-数组中是否含有某个元素"><a href="#array-contains-find-in-set-数组中是否含有某个元素" class="headerlink" title="array_contains(),find_in_set()数组中是否含有某个元素"></a>array_contains(),find_in_set()数组中是否含有某个元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- id_array中含有89这个元素的</span><br><span class="line">select * from sales_info where find_in_set(&#39;89&#39;,concat_ws(&#39;,&#39;,id_array))&gt;0;</span><br><span class="line"></span><br><span class="line">select * from sales_info where array_contains(id_array,&#39;89&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="concat-ws-数组中是否有元素含有某个字符"><a href="#concat-ws-数组中是否有元素含有某个字符" class="headerlink" title="concat_ws()数组中是否有元素含有某个字符"></a>concat_ws()数组中是否有元素含有某个字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- id_array中有元素含有8这个字符</span><br><span class="line">select * from sales_info where concat_ws(&#39;&#39;,id_array) like &#39;%8%&#39;;</span><br><span class="line">select * from sales_info where concat_ws(&#39;&#39;,id_array) rlike &#39;8&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="array-contains-map中是否含有某个key"><a href="#array-contains-map中是否含有某个key" class="headerlink" title="array_contains()map中是否含有某个key"></a>array_contains()map中是否含有某个key</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- mapkeys表中，state_map列含有&#39;id&#39;这个key的</span><br><span class="line">select * from mapkeys where array_contains(map_keys(state_map),&#39;id&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="not-取反"><a href="#not-取反" class="headerlink" title="not, ! 取反"></a>not, ! 取反</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- mapkeys表中，state_map列 不 含有&#39;id&#39;这个key的</span><br><span class="line">select * from mapkeys where not array_contains(map_keys(state_map),&#39;id&#39;);</span><br><span class="line">select * from mapkeys where ! array_contains(map_keys(state_map),&#39;id&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="map中某个key的值包含某个字符"><a href="#map中某个key的值包含某个字符" class="headerlink" title="map中某个key的值包含某个字符"></a>map中某个key的值包含某个字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- mapkeys表中，state_map列，user_name(key)的值包含&#39;zhang&#39;的</span><br><span class="line">select * from mapkeys from state_map[&#39;user_name&#39;] rlike &#39;zhang&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="group-by和聚合函数"><a href="#group-by和聚合函数" class="headerlink" title="group by和聚合函数"></a>group by和聚合函数</h2><h3 id="having和where"><a href="#having和where" class="headerlink" title="having和where"></a>having和where</h3><p>与mysql一样，having时对group by的过滤</p>
<h3 id="group-by用法"><a href="#group-by用法" class="headerlink" title="group by用法"></a>group by用法</h3><p>与mysql一样，select后面只能写group by的字段和聚合函数。对于字符串类型的数据，可以用字符串函数聚合，比如collect_set()等。</p>
<h3 id="以struct、map类型数据中的某个key分组"><a href="#以struct、map类型数据中的某个key分组" class="headerlink" title="以struct、map类型数据中的某个key分组"></a>以struct、map类型数据中的某个key分组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- basic_info字段为struct类型，basic_info struct&lt;user_name:string, age:int&gt;</span><br><span class="line">select basic_info.age,count(*) from test_student</span><br><span class="line">group by basic_info.age</span><br><span class="line">having count(*) &gt; 1;</span><br><span class="line"></span><br><span class="line">-- state_map字段为map类型，state_map map&lt;string,string&gt;</span><br><span class="line">select state_map[&#39;id&#39;],count(sku_id) from mapkeys</span><br><span class="line">group by state_map[&#39;id&#39;]</span><br></pre></td></tr></table></figure>

<h3 id="以array类型数据中是否含有某个值分组"><a href="#以array类型数据中是否含有某个值分组" class="headerlink" title="以array类型数据中是否含有某个值分组"></a>以array类型数据中是否含有某个值分组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- id_array字段为array类型，以id_array是否有89这个值分组，有的分一组并统计记录数，没有的分一组并统计记录数</span><br><span class="line">select array_contains(id_array,&#39;89&#39;),count(*) </span><br><span class="line">from sales_info </span><br><span class="line">group by array_contains(id_array,&#39;89&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="以分区表各分区分组"><a href="#以分区表各分区分组" class="headerlink" title="以分区表各分区分组"></a>以分区表各分区分组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- test_partition表为分区表，sku_class为分区字段</span><br><span class="line">-- 按分区分组，统计每个分区的记录数，选出记录数大于1的分区</span><br><span class="line">select sku_class, count(*) num</span><br><span class="line">from test_partition</span><br><span class="line">group by sku_class</span><br><span class="line">having num &gt; 1;</span><br></pre></td></tr></table></figure>

<h3 id="统计order-data表，每年下半年的订单量"><a href="#统计order-data表，每年下半年的订单量" class="headerlink" title="统计order_data表，每年下半年的订单量"></a>统计order_data表，每年下半年的订单量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- 先按年分组，再对分组后的每组数据having筛选月份大于6的</span><br><span class="line">select</span><br><span class="line">	year(order_data),</span><br><span class="line">	sum(订单量)</span><br><span class="line">from order_data </span><br><span class="line">group by year(order_date) </span><br><span class="line">having month(order_date)&gt;6;</span><br><span class="line">-- 先where筛选月份大于6的数据，再对过滤出的数据按年分组</span><br><span class="line">select</span><br><span class="line">	year(order_data),</span><br><span class="line">	sum(订单量)</span><br><span class="line">from order_data</span><br><span class="line">where month(order_date)&gt;6</span><br><span class="line">group by year(order_date);</span><br></pre></td></tr></table></figure>

<h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>和mysql用法相同</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查询emp表中的前5条数据</span><br><span class="line">-- 参数1:起始值,默认是0; 参数2:要查询的条数 </span><br><span class="line">SELECT * FROM emp LIMIT 5;</span><br><span class="line">SELECT * FROM emp LIMIT 0 , 5;</span><br><span class="line"># 查询emp表中 从第4条开始,查询6条 -- 起始值默认是从0开始的.</span><br><span class="line">SELECT * FROM emp LIMIT 3 , 6;</span><br></pre></td></tr></table></figure>

<h2 id="hive中排序介绍"><a href="#hive中排序介绍" class="headerlink" title="hive中排序介绍"></a>hive中排序介绍</h2><p>分区表、分桶表排序，和普通表没有差异。分区表、分桶表虽然物理上数据文件被分到了不同的目录、分成了不同的文件，但逻辑上还是一整张表。</p>
<p>hive中有几种排序方式</p>
<table>
<thead>
<tr>
<th></th>
<th>order by</th>
<th>sort by</th>
<th>distribute by</th>
<th>cluster by</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>order by对输入做全局排序</td>
<td>单独在各自reduce中排序</td>
<td>控制map中的输出在reduce中如何划分</td>
<td>相当于distribute by和sort by合用</td>
</tr>
<tr>
<td>缺点</td>
<td>只有一个reduce，输入规模较大时耗时较长</td>
<td>不能保证全局有序</td>
<td>只负责划分，不能排序，要和sort by一起用</td>
<td>只能升序</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查看当前reduce设置为几个，默认为-1无限制</span><br><span class="line">set mapred.reduce.tasks</span><br><span class="line">-- mapred.reduce.tasks&#x3D;-1</span><br><span class="line"></span><br><span class="line">-- 设置reduce个数</span><br><span class="line">set mapred.reduce.tasks &#x3D; 2</span><br><span class="line"></span><br><span class="line">1个reduce是产生一个文件的</span><br></pre></td></tr></table></figure>

<h2 id="order-by排序"><a href="#order-by排序" class="headerlink" title="order by排序"></a>order by排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 单列排序</span><br><span class="line">select * from tableName order by 字段1;</span><br><span class="line"></span><br><span class="line">-- 多列排序</span><br><span class="line">select * from tableName order by 字段1,字段2;</span><br><span class="line"></span><br><span class="line">-- 别名排序，因为hive中select的执行顺序在order by之前，所以order by可以使用select时字段的别名</span><br><span class="line">select 字段1, 字段2 as 字段2别名 from tableName order by 字段2别名；</span><br><span class="line"></span><br><span class="line">-- 和limit搭配使用</span><br><span class="line">select * from tableName order by 字段1 limit 2,3; -- 从第3条开始取3条，就是3、4、5这三条</span><br><span class="line"></span><br><span class="line">-- order by默认asc升序，</span><br><span class="line">-- 排序字段中有null时，默认是nulls first将null排在第一位，可以改为nulls last将null排在最后</span><br><span class="line">select * from tableName order by 字段1 nulls last;</span><br></pre></td></tr></table></figure>

<ul>
<li>order by</li>
</ul>
<p>不管我们设置几个reduce，order by总是用一个reduce输出，来保证全局排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 设置reduce为2</span><br><span class="line">set mapred.reduce.tasks &#x3D; 2;</span><br><span class="line"></span><br><span class="line">-- 导出数据，reduce设为2，路径下会有2个数据文件。(由于表中数据量太小，这里用group by，让reduce按着设置值生成2个文件)</span><br><span class="line">insert overwrite directory &#39;&#x2F;user&#x2F;Hl1591&#x2F;test_reduce2&#x2F;&#39; </span><br><span class="line">select sku_id from sales_info group by sku_id;</span><br><span class="line"></span><br><span class="line">-- 加上order by，发现只生成一个数据文件</span><br><span class="line">insert overwrite directory &#39;&#x2F;user&#x2F;Hl1591&#x2F;test_reduce2_orderBy&#x2F;&#39;</span><br><span class="line">select sku_id from sales_info group by sku_id</span><br><span class="line">order by sku_id;</span><br></pre></td></tr></table></figure>

<h2 id="sort-by排序"><a href="#sort-by排序" class="headerlink" title="sort by排序"></a>sort by排序</h2><p>sort by只对各reduce内数据排序，全局不排序。</p>
<p>但当我们数据量足够小只生成了1个reduce，或reduce指定为1个的时候，sort by就相当于全局排序了。</p>
<h2 id="distribute-by划分reduce"><a href="#distribute-by划分reduce" class="headerlink" title="distribute by划分reduce"></a>distribute by划分reduce</h2><p>distribute by只有划分reduce功能，没有排序功能。如果要排序，需要和sort by连用。</p>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 设置reduce为6个</span><br><span class="line">set mapred.reduce.tasks&#x3D;6;</span><br><span class="line"></span><br><span class="line">-- order_data表中，order_date字段为日期类型，且只有2018和2019年的数据</span><br><span class="line">-- 现在对order_data表，以order_date的年份使用distribute by划分reduce</span><br><span class="line">-- 并且使用sort by 按 sales销售额字段降序排序</span><br><span class="line">select * from order_data</span><br><span class="line">distribute by year(order_date)</span><br><span class="line">sort by sales desc;</span><br><span class="line"></span><br><span class="line">-- 把查询结构导出成文件，看看reduce为6个，且使用了distribute by，数据文件时如何划分的</span><br><span class="line">insert overwrite directory &#39;&#x2F;user&#x2F;Hl1591&#x2F;test_distribute&#39;</span><br><span class="line">row format delimited</span><br><span class="line">fields ternimated by &#39;\t&#39;</span><br><span class="line">select * from order_data</span><br><span class="line">distribute by year(order_date)</span><br><span class="line">sort by sales desc;</span><br><span class="line"></span><br><span class="line">在test_distribute目录下，可以看到由于reduce被设为6，生成了6个数据文件。</span><br><span class="line">但其中只有两个文件是有数据的，其他文件都没有数据。</span><br><span class="line">这两个数据文件，一个全部是2018年的数据，另一个全部是2019年的数据。</span><br><span class="line">并且，两个文件各自按照sales字段降序排序。</span><br></pre></td></tr></table></figure>

<p>对分区表、分桶表使用distribute by，和普通表完全一样。</p>
<h2 id="cluster-by"><a href="#cluster-by" class="headerlink" title="cluster by"></a>cluster by</h2><p>当distribute by和sort by使用同一个字段，且升序排序时，可以简写为cluster by。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from order_data distribute by quantity sort by quantity;</span><br><span class="line">-- 等于</span><br><span class="line">select * from order_data cluster by quantity;</span><br><span class="line"></span><br><span class="line">通过将查询结果导出成数据文件，发现两种写法结果完全一致。</span><br></pre></td></tr></table></figure>

<h1 id="表关联查询"><a href="#表关联查询" class="headerlink" title="表关联查询"></a>表关联查询</h1><p>hive中关联查询和mysql基本一样，只有以下几点区别：</p>
<ul>
<li>hive只支持等值连接。即hive中不支持join on A != B</li>
<li>on后面的表达式不支持or</li>
</ul>
<h2 id="inner-join内连接"><a href="#inner-join内连接" class="headerlink" title="inner join内连接"></a>inner join内连接</h2><p>和mysql一样，inner可省略，起别名时as可省略</p>
<p>也可以select from a,b where a.xx = b.xx</p>
<h2 id="left-join左连接，right-join右连接"><a href="#left-join左连接，right-join右连接" class="headerlink" title="left join左连接，right join右连接"></a>left join左连接，right join右连接</h2><p>和mysql一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select * from </span><br><span class="line">a left join b</span><br><span class="line">on a.xx &#x3D; b.xx</span><br><span class="line">where a.xx&#x3D;XX and b.xx!&#x3D;XX;</span><br><span class="line"></span><br><span class="line">join和where一起使用，先将表通过on条件join在一起，再对合并后的结果集where过滤。</span><br></pre></td></tr></table></figure>

<h2 id="full-join全连接"><a href="#full-join全连接" class="headerlink" title="full join全连接"></a>full join全连接</h2><p>mysql中不支持full outer join，但可以通过 左连接union右连接实现。</p>
<p>full join就是数据横向的维度的并集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from</span><br><span class="line">a full join b</span><br><span class="line">on a.xx &#x3D; b.xx;</span><br></pre></td></tr></table></figure>

<h1 id="结果集的合并"><a href="#结果集的合并" class="headerlink" title="结果集的合并"></a>结果集的合并</h1><h2 id="union-union-all并集"><a href="#union-union-all并集" class="headerlink" title="union,union all并集"></a>union,union all并集</h2><p>和mysql一样，union去重按查询顺序排序，union all不去重不排序</p>
<p>union，union all是数据纵向的记录的并集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from a</span><br><span class="line">union</span><br><span class="line">select * from b;</span><br></pre></td></tr></table></figure>

<h2 id="intersect交集"><a href="#intersect交集" class="headerlink" title="intersect交集"></a>intersect交集</h2><p>取两个结果集的交集，去重，排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from a</span><br><span class="line">intersect</span><br><span class="line">select * from b;</span><br></pre></td></tr></table></figure>

<h2 id="minus差集"><a href="#minus差集" class="headerlink" title="minus差集"></a>minus差集</h2><p>取两个结果集的差集（第一个减去第二个），去重，排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from a minus select * from b; -- a-b，得出a有b没有的</span><br><span class="line"></span><br><span class="line">select * from b minus select * from a; -- b-a，得出b有a没有的</span><br></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>和mysql的视图基本一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW [IF NOT EXISTS] [db_name.]view_name -- 视图名称 </span><br><span class="line">[(column_name [COMMENT column_comment], ...) ] --列名 </span><br><span class="line">[COMMENT view_comment] --视图注释</span><br><span class="line">[TBLPROPERTIES (property_name &#x3D; property_value, ...)] --额外信息 </span><br><span class="line">AS SELECT ...;</span><br><span class="line"></span><br><span class="line">-- 不写其他参数</span><br><span class="line">create view 视图名 as</span><br><span class="line">select ...;</span><br></pre></td></tr></table></figure>

<p>视图还可以通过视图创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create view view2 as</span><br><span class="line">select * from view1;</span><br></pre></td></tr></table></figure>

<p>查看视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查看视图是否创建成功</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">-- 查看视图</span><br><span class="line">desc 视图名;</span><br><span class="line"></span><br><span class="line">-- 查看视图详细信息</span><br><span class="line">desc formatted 视图名;</span><br></pre></td></tr></table></figure>

<p>删除视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view [if exists] 视图名;</span><br></pre></td></tr></table></figure>

<p>修改视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter view 视图名 as</span><br><span class="line">selec...</span><br></pre></td></tr></table></figure>

<p>在修改指定列的视图后，指定的列名失效 </p>
<p>当基表的数据记录增删时，视图也会生变化 </p>
<p>当基表删除视图引用的列后，视图会失效 </p>
<p>当基表添加列后，视图还是原有的列，对新列不做引用。</p>
<p> 当基表或基视图被删除后，此视图失效</p>
<ul>
<li><p>视图是只读的，不能用作 LOAD / INSERT / ALTER 的目标; </p>
</li>
<li><p>在创建视图时候视图就已经固定，对基表的增加列操作将不会反映在视图，删除视图引用的列，视图会失效;</p>
</li>
<li><p>删除基表并不会删除视图，需要手动删除视图;</p>
</li>
<li><p>视图可能包含 ORDER BY 和 LIMIT 子句。如果引用视图的查询语句也包含这类子句，其执行优先 级低于视图对应字句</p>
</li>
<li><p>创建视图时，如果未提供列名，则将从 SELECT 语句中自动派生列名;</p>
</li>
<li><p>创建视图时，如果 SELECT 语句中包含其他表达式，例如 x + y，则列名称将以<em>C0</em> C1 等形式生成;</p>
</li>
</ul>
<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p>和mysql中的窗口函数基本一样。</p>
<h2 id="聚合窗口函数"><a href="#聚合窗口函数" class="headerlink" title="聚合窗口函数"></a>聚合窗口函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 和mysql一样</span><br><span class="line">sum&#x2F;max&#x2F;min&#x2F;avg&#x2F;count(字段名) over(partition by 分组字段名 order by 排序字段名 rows between and )</span><br><span class="line"></span><br><span class="line">rows between: unbounded,preceding,followning,current row</span><br></pre></td></tr></table></figure>

<h2 id="偏移窗口函数"><a href="#偏移窗口函数" class="headerlink" title="偏移窗口函数"></a>偏移窗口函数</h2><p>lag()，lead()和mysql一样</p>
<p>hive多了个两个：first_value()，last_value()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 取分组内，排序后，截止到当前行，第一个值</span><br><span class="line">first_value(col,default) over(......)</span><br><span class="line"></span><br><span class="line">-- 取分组内，排序后，截止到当前行，最后一个值</span><br><span class="line">last_value(col,default) over(......)</span><br></pre></td></tr></table></figure>

<h2 id="排序窗口函数"><a href="#排序窗口函数" class="headerlink" title="排序窗口函数"></a>排序窗口函数</h2><p>row_number()，rank()，dense_rank()，ntile()和mysql一样</p>
<p>nitle()是等频切片，比如有20条数据，ntile(5)，每片就是4条数据。</p>
<p>hive多了两个：cume_dist()，percent_rank()</p>
<ul>
<li>cume_dist()：小于等于当前值的行数/分组内总行数</li>
<li>percent_rank()：分组内当前行的RANK值-1/分组内总行数-1</li>
</ul>
<h1 id="hive中的子查询"><a href="#hive中的子查询" class="headerlink" title="hive中的子查询"></a>hive中的子查询</h1><p>hive 3.1 支持select，from，where 子句中的子查询 </p>
<p>select 子查询限制：不支持 if / case when 里的子查询 </p>
<p>where 子查询限制：</p>
<p>​    IN/NOT IN 子查询只能选择一列</p>
<p>​    EXISTS/NOT EXISTS 必须有一个或多个相关谓词</p>
<p>​    对父查询的引用仅在子查询的WHERE子句中支持（mysql中支持子查询的其他地方引用父查询）</p>
<p>集合中如果含null数据，不可使用not in, 可以使用in </p>
<p>主查询和子查询可以不是同一张表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 正常运行</span><br><span class="line">select </span><br><span class="line">	user_info.customer_id,</span><br><span class="line">	(select </span><br><span class="line">			count(distinct order_id) </span><br><span class="line">		from test_join_order </span><br><span class="line">		where user_info.customer_id &#x3D; test_join_order.customer_id ) as count </span><br><span class="line">from user_info</span><br><span class="line">where (</span><br><span class="line">	select </span><br><span class="line">		count(distinct order_id) </span><br><span class="line">	from test_join_order </span><br><span class="line">	where user_info.customer_id &#x3D; test_join_order.customer_id )&gt;0;</span><br><span class="line"></span><br><span class="line">-- 报错，父查询where那里使用了子查询的别名count，因为hive执行顺序from-where-select</span><br><span class="line">select </span><br><span class="line">	user_info.customer_id,</span><br><span class="line">	(select </span><br><span class="line">			count(distinct order_id) </span><br><span class="line">		from test_join_order </span><br><span class="line">		where user_info.customer_id &#x3D; test_join_order.customer_id ) as count </span><br><span class="line">from user_info</span><br><span class="line">where count&gt;0;</span><br></pre></td></tr></table></figure>

<h1 id="抽样查询"><a href="#抽样查询" class="headerlink" title="抽样查询"></a>抽样查询</h1><p>在海量数据下进行数据分析任务时，如果对全量数据进行分析会非常耗时耗费资源，因此一般情况下抽取一小部分数据进行分析建模。</p>
<p>当然数据越多，分析肯定越准确，在条件允许的情况下，全量数据分析肯定更好。</p>
<p>hive中三种抽样方式：</p>
<h2 id="随机抽样-rand-函数"><a href="#随机抽样-rand-函数" class="headerlink" title="随机抽样 rand()函数"></a>随机抽样 rand()函数</h2><p>使用rand()函数，与distribute by，sort by，order by结合进行随机抽样。</p>
<p>原理就是通过distribute by，sort by，order by对rand()生成的随机数排序，最后通过limit取部分数据达到随机抽样的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from order_data order by rand() limit 30;</span><br><span class="line"></span><br><span class="line">select * from order_data distribute by rand() sort by rand() limit 30;</span><br></pre></td></tr></table></figure>

<h2 id="数据块抽样-tablesample-函数"><a href="#数据块抽样-tablesample-函数" class="headerlink" title="数据块抽样 tablesample()函数"></a>数据块抽样 tablesample()函数</h2><h3 id="用法一：tablesample-n-percent"><a href="#用法一：tablesample-n-percent" class="headerlink" title="用法一：tablesample(n percent)"></a>用法一：tablesample(n percent)</h3><p>tablesampe(n percent)根据数据文件的大小按百分比抽样。由于hive使用hdfs存储数据文件，hdfs中默认一个数据块大小是128M，所以当数据文件本身小于128M时，使用tablesample无论设置n为多少百分比，都会抽取出全部数据。</p>
<p>可以简单理解为，在hive中，数据文件大小小于128M时，tablesample(n percen)函数抽样不起作用，会抽出全部数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--select语句不能带where条件且不支持子查询</span><br><span class="line">select * from order_data tablesample(10 percent) --抽取数据文件大小10%的数据</span><br></pre></td></tr></table></figure>

<h3 id="用法二：tablesample-nM"><a href="#用法二：tablesample-nM" class="headerlink" title="用法二：tablesample(nM)"></a>用法二：tablesample(nM)</h3><p>和percent一样，还是按照数据文件大小抽样，只不过不是按百分比，而是按具体的多少M(兆)抽样。也存在数据大小小于hive默认数据块大小128M时，不起作用抽出全部数据的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_data tablesample(1M) --抽取1M大小的数据</span><br></pre></td></tr></table></figure>

<h3 id="用法三：tablesample-n-rows"><a href="#用法三：tablesample-n-rows" class="headerlink" title="用法三：tablesample(n rows)"></a>用法三：tablesample(n rows)</h3><p>指定抽样数据的行数，其中n代表每个map任务均取n行数据。</p>
<p>如果现在有3个mapreduce，虽然n设置为1，但是取得的行数是3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_data tablesample(1 rows) --每个map任务抽取1行</span><br></pre></td></tr></table></figure>

<h2 id="分桶抽样"><a href="#分桶抽样" class="headerlink" title="分桶抽样"></a>分桶抽样</h2><p>语法：tablesample(bucket x out of y) 。从第x个桶开始取，取总桶数/y个桶。</p>
<p>y必须是table总bucket数的倍数或者因子。hive根据y的大小，决定抽样的比例</p>
<ul>
<li><p>未分桶表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 未分桶表使用tablesample(bucket x out of y)时，</span><br><span class="line">-- y就是总桶数，后面跟 on 字段名 对表以某个字段分桶</span><br><span class="line">-- x依旧表示从第几个桶开始取</span><br><span class="line">-- 案例里on rand()表示不按某个字段分桶，按rand()产生的随机数分桶，y是10，就是分10个桶</span><br><span class="line">select * from order_data1 tablesample(bucket 1 out of 10 on rand())</span><br></pre></td></tr></table></figure></li>
<li><p>分桶表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- test_bucket分了3个桶</span><br><span class="line">select * from test_bucket </span><br><span class="line">tablesample(bucket 1 out of 6 on sku_id) -- 从第1个桶开始取，取3&#x2F;6&#x3D;0.5个桶的数据</span><br><span class="line"></span><br><span class="line">--test_bucket分了6个桶</span><br><span class="line">select * from test_bucket </span><br><span class="line">tablesample(bucket 1 out of 3 on sku_id) -- 从第1个桶开始取，取6&#x2F;3&#x3D;2个桶的数据，第二个桶是 1+3</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><p>自定义函数分为三个类别:</p>
<p>UDF(User Defined Function):一进一出(upper(), lower())</p>
<p>UDAF(User Defined Aggregation Function):聚集函数，多进一出(例如count/max/min)</p>
<p>UDTF(User Defined Table Generating Function):一进多出，如lateral view explode()</p>
<p>hive中创建自定义函数 需要用java来编写，而不是用传统的SQL来完成</p>
<h1 id="hive语句优化"><a href="#hive语句优化" class="headerlink" title="hive语句优化"></a>hive语句优化</h1><h2 id="group-by代替distinct去重"><a href="#group-by代替distinct去重" class="headerlink" title="group by代替distinct去重"></a>group by代替distinct去重</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select  distinct customer_id</span><br><span class="line">from test_join_order;</span><br><span class="line"></span><br><span class="line">select  customer_id</span><br><span class="line">from test_join_order;</span><br><span class="line">group by customer_id</span><br></pre></td></tr></table></figure>

<h2 id="grouping-sets-函数"><a href="#grouping-sets-函数" class="headerlink" title="grouping sets()函数"></a>grouping sets()函数</h2><p>grouping sets是一种将多个group by 逻辑写在一个sql语句中的便利写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 假设表中有a,b,num三个字段，现在要按照a，b，a,b三种方式分组统计num总和，并将结果集合并</span><br><span class="line">SELECT a,b,sum(num) AS total_num</span><br><span class="line">  FROM DW_AAA.BBB</span><br><span class="line"> GROUP BY a,b</span><br><span class="line"> UNION ALL</span><br><span class="line">SELECT a,sum(num) AS total_num</span><br><span class="line">  FROM DW_AAA.BBB</span><br><span class="line"> GROUP BY a</span><br><span class="line"> UNION ALL </span><br><span class="line">SELECT b,sum(num) AS total_num</span><br><span class="line">  FROM DW_AAA.BBB</span><br><span class="line"> GROUP BY b</span><br><span class="line"> </span><br><span class="line"> -- 等价于</span><br><span class="line">SELECT a</span><br><span class="line">      ,b</span><br><span class="line">      ,sum(num) AS total_num</span><br><span class="line">  FROM DW_AAA.BBB</span><br><span class="line"> GROUP BY a,b</span><br><span class="line"> GROUPING SETS (a,b),(a),(b)</span><br></pre></td></tr></table></figure>

<h2 id="grouping-sets-函数（转）"><a href="#grouping-sets-函数（转）" class="headerlink" title="grouping sets()函数（转）"></a>grouping sets()函数（转）</h2><p>GROUPING SETS作为GROUP BY的子句，允许开发人员在GROUP BY语句后面指定多个统计选项，可以简单理解为多条group by语句通过union all把查询结果聚合起来结合起来。</p>
<p>几个demo帮助大家了解：</p>
<table>
<thead>
<tr>
<th>grouping sets语句</th>
<th>等价hive语句</th>
</tr>
</thead>
<tbody><tr>
<td>select device_id,os_id,app_id,count(user_id) from  test_xinyan_reg group by device_id,os_id,app_id grouping sets((device_id))</td>
<td>SELECT device_id,null,null,count(user_id) FROM test_xinyan_reg group by device_id</td>
</tr>
<tr>
<td>select device_id,os_id,app_id,count(user_id) from  test_xinyan_reg group by device_id,os_id,app_id grouping sets((device_id,os_id))</td>
<td>SELECT device_id,os_id,null,count(user_id) FROM test_xinyan_reg group by device_id,os_id</td>
</tr>
<tr>
<td>select device_id,os_id,app_id,count(user_id) from  test_xinyan_reg group by device_id,os_id,app_id grouping sets((device_id,os_id),(device_id))</td>
<td>SELECT device_id,os_id,null,count(user_id) FROM test_xinyan_reg group by device_id,os_id <br/>UNION ALL <br/>SELECT device_id,null,null,count(user_id) FROM test_xinyan_reg group by device_id</td>
</tr>
<tr>
<td>select device_id,os_id,app_id,count(user_id) from  test_xinyan_reg group by device_id,os_id,app_id grouping sets((device_id),(os_id),(device_id,os_id),())</td>
<td>SELECT device_id,null,null,count(user_id) FROM test_xinyan_reg group by device_id <br/>UNION ALL <br/>SELECT null,os_id,null,count(user_id) FROM test_xinyan_reg group by os_id <br/>UNION ALL <br/>SELECT device_id,os_id,null,count(user_id) FROM test_xinyan_reg group by device_id,os_id  <br/>UNION ALL <br/>SELECT null,null,null,count(user_id) FROM test_xinyan_reg</td>
</tr>
</tbody></table>
<h2 id="CUBE函数"><a href="#CUBE函数" class="headerlink" title="CUBE函数"></a>CUBE函数</h2><p>cube简称数据魔方，可以实现hive多个任意维度的查询，cube(a,b,c)则首先会对(a,b,c)进行group by，然后依次是(a,b),(a,c),(a),(b,c),(b),(c),最后在对全表进行group by，他会统计所选列中值的所有组合的聚合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select device_id,os_id,app_id,client_version,from_id,count(user_id) </span><br><span class="line">from test_xinyan_reg </span><br><span class="line">group by device_id,os_id,app_id,client_version,from_id with cube;</span><br></pre></td></tr></table></figure>

<p>手工实现需要写的hql语句（写个程序自己生成的，手写累死）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">SELECT device_id,null,null,null,null ,count(user_id) FROM test_xinyan_reg group by device_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,os_id,null,null,null ,count(user_id) FROM test_xinyan_reg group by os_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,os_id,null,null,null ,count(user_id) FROM test_xinyan_reg group by device_id,os_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,null,app_id,null,null ,count(user_id) FROM test_xinyan_reg group by app_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,null,app_id,null,null ,count(user_id) FROM test_xinyan_reg group by device_id,app_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,os_id,app_id,null,null ,count(user_id) FROM test_xinyan_reg group by os_id,app_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,os_id,app_id,null,null ,count(user_id) FROM test_xinyan_reg group by device_id,os_id,app_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,null,null,client_version,null ,count(user_id) FROM test_xinyan_reg group by client_version</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,null,null,client_version,null ,count(user_id) FROM test_xinyan_reg group by device_id,client_version</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,os_id,null,client_version,null ,count(user_id) FROM test_xinyan_reg group by os_id,client_version</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,os_id,null,client_version,null ,count(user_id) FROM test_xinyan_reg group by device_id,os_id,client_version</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,null,app_id,client_version,null ,count(user_id) FROM test_xinyan_reg group by app_id,client_version</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,null,app_id,client_version,null ,count(user_id) FROM test_xinyan_reg group by device_id,app_id,client_version</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,os_id,app_id,client_version,null ,count(user_id) FROM test_xinyan_reg group by os_id,app_id,client_version</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,os_id,app_id,client_version,null ,count(user_id) FROM test_xinyan_reg group by device_id,os_id,app_id,client_version</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,null,null,null,from_id ,count(user_id) FROM test_xinyan_reg group by from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,null,null,null,from_id ,count(user_id) FROM test_xinyan_reg group by device_id,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,os_id,null,null,from_id ,count(user_id) FROM test_xinyan_reg group by os_id,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,os_id,null,null,from_id ,count(user_id) FROM test_xinyan_reg group by device_id,os_id,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,null,app_id,null,from_id ,count(user_id) FROM test_xinyan_reg group by app_id,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,null,app_id,null,from_id ,count(user_id) FROM test_xinyan_reg group by device_id,app_id,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,os_id,app_id,null,from_id ,count(user_id) FROM test_xinyan_reg group by os_id,app_id,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,os_id,app_id,null,from_id ,count(user_id) FROM test_xinyan_reg group by device_id,os_id,app_id,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,null,null,client_version,from_id ,count(user_id) FROM test_xinyan_reg group by client_version,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,null,null,client_version,from_id ,count(user_id) FROM test_xinyan_reg group by device_id,client_version,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,os_id,null,client_version,from_id ,count(user_id) FROM test_xinyan_reg group by os_id,client_version,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,os_id,null,client_version,from_id ,count(user_id) FROM test_xinyan_reg group by device_id,os_id,client_version,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,null,app_id,client_version,from_id ,count(user_id) FROM test_xinyan_reg group by app_id,client_version,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,null,app_id,client_version,from_id ,count(user_id) FROM test_xinyan_reg group by device_id,app_id,client_version,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,os_id,app_id,client_version,from_id ,count(user_id) FROM test_xinyan_reg group by os_id,app_id,client_version,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT device_id,os_id,app_id,client_version,from_id ,count(user_id) FROM test_xinyan_reg group by device_id,os_id,app_id,client_version,from_id</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT null,null,null,null,null ,count(user_id) FROM test_xinyan_reg</span><br></pre></td></tr></table></figure>


<p>看着很蛋疼是不是，体会到cube的强大了吗！(低版本hive可以通过union all方式解决，算是没有办法的办法)</p>
<h2 id="ROLL-UP函数"><a href="#ROLL-UP函数" class="headerlink" title="ROLL UP函数"></a>ROLL UP函数</h2><p>rollup可以实现从右到左递减多级的统计，显示统计某一层次结构的聚合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select device_id,os_id,app_id,client_version,from_id,count(user_id) </span><br><span class="line">from test_xinyan_reg </span><br><span class="line">group by device_id,os_id,app_id,client_version,from_id with rollup;</span><br></pre></td></tr></table></figure>

<p>等价以下sql语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select device_id,os_id,app_id,client_version,from_id,count(user_id) </span><br><span class="line">from test_xinyan_reg </span><br><span class="line">group by device_id,os_id,app_id,client_version,from_id </span><br><span class="line">grouping sets ((device_id,os_id,app_id,client_version,from_id),(device_id,os_id,app_id,client_version),(device_id,os_id,app_id),(device_id,os_id),(device_id),());</span><br></pre></td></tr></table></figure>

<p>————————————————<br>版权声明：本文为CSDN博主「扫大街的程序员」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/moon_yang_bj/article/details/17200367">https://blog.csdn.net/moon_yang_bj/article/details/17200367</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" rel="tag"># 数据分析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/20210527235833/" rel="prev" title="【数据分析】第四阶段：大数据查询利器Hive（二）上">
                  <i class="fa fa-chevron-left"></i> 【数据分析】第四阶段：大数据查询利器Hive（二）上
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/20210610203247/" rel="next" title="【数据分析】第五阶段：python（一）Python基础">
                  【数据分析】第五阶段：python（一）Python基础 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">昱森</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
