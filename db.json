{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/css/noscript.styl","path":"css/noscript.styl","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments.js","path":"js/comments.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/config.js","path":"js/config.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/pjax.js","path":"js/pjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schedule.js","path":"js/schedule.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/comments-buttons.js","path":"js/comments-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16.png","path":"images/favicon-16x16.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32.png","path":"images/favicon-32x32.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","path":"images/logo-algolia-nebula-blue-full.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/nprogress.js","path":"js/third-party/nprogress.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/quicklink.js","path":"js/third-party/quicklink.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/rating.js","path":"js/third-party/rating.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/LICENSE","path":"lib/fancybox/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/README.md","path":"lib/fancybox/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/chat/chatra.js","path":"js/third-party/chat/chatra.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","path":"js/third-party/analytics/google-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","path":"js/third-party/analytics/baidu-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","path":"js/third-party/analytics/growingio.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/changyan.js","path":"js/third-party/comments/changyan.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","path":"js/third-party/comments/disqusjs.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","path":"js/third-party/comments/gitalk.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/disqus.js","path":"js/third-party/comments/disqus.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/isso.js","path":"js/third-party/comments/isso.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/livere.js","path":"js/third-party/comments/livere.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/comments/utterances.js","path":"js/third-party/comments/utterances.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/katex.js","path":"js/third-party/math/katex.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","path":"js/third-party/search/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/math/mathjax.js","path":"js/third-party/math/mathjax.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/search/local-search.js","path":"js/third-party/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","path":"js/third-party/statistics/firestore.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","path":"js/third-party/statistics/lean-analytics.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","path":"js/third-party/tags/mermaid.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/third-party/tags/pdf.js","path":"js/third-party/tags/pdf.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","path":"lib/fancybox/source/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","path":"lib/fancybox/source/jquery.fancybox.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Angular4——1.介绍Angular4.md","hash":"099c442bc20c7b327f28ec7a73d45ecf1f954c41","modified":1620486091892},{"_id":"source/_posts/Angular4——2.开始Angular开发.md","hash":"72289288214901174ee33b9e0a85f9eec066352a","modified":1620486081829},{"_id":"source/_posts/.DS_Store","hash":"926050173f847043d1eb28a2a01f2b7592859e51","modified":1620485275689},{"_id":"source/_posts/Angular4——4-依赖注入.md","hash":"2f0f949e08d61b0d11c90af8ad8850136e955b83","modified":1620486059857},{"_id":"source/.DS_Store","hash":"8f0e0f0a83221f9a66f1d057c308c2ade60fe097","modified":1619927392068},{"_id":"source/_posts/Angular4——5-数据绑定、响应式编程和管道.md","hash":"115608595fc31270261f569481609799acc0cc29","modified":1620486049073},{"_id":"source/_posts/Angular4——6-组件间通讯.md","hash":"271edd6680647fd40f21dfb5f7a961b51ee0b4f3","modified":1620486037307},{"_id":"source/_posts/Angular4——8.与服务器通讯.md","hash":"945bf81107ff58982250cd3bc3fd3959bcdb885f","modified":1620486015905},{"_id":"source/_posts/Angular4——7-表单处理.md","hash":"aec41423bbddbfa66edd6cdf90ec94bddd927bd8","modified":1620486026273},{"_id":"source/_posts/Git学习笔记.md","hash":"567ff92531bc6d196a3177768cb8d761e8044fda","modified":1620485968342},{"_id":"source/_posts/ES6学习笔记.md","hash":"48a3ec4f3bae43e6dce4329698529bf3140d71cd","modified":1620485984839},{"_id":"source/_posts/Hexo+GitPages搭建博客.md","hash":"788a6fac0d7667e367c30ebe5856abd0def83088","modified":1620485954558},{"_id":"source/_posts/RxJS.md","hash":"8b7beabadeafd205f19b756cc57b306f98be69b8","modified":1620485857030},{"_id":"source/_posts/node安装开发环境搭建.md","hash":"2772f9183c0ce8a6bde33259d52bc9ec720ec809","modified":1620485932235},{"_id":"source/_posts/TypeScript学习笔记.md","hash":"d877163fd193753c19ab04e418dac65866ba22e2","modified":1620485848475},{"_id":"source/_posts/return-Promise-resolve-res-data-和return-res-data的区别研究.md","hash":"5568c4b7c22fecbfbee85c7a1d81fb8de199cf43","modified":1620485906415},{"_id":"source/_posts/【数据分析】Excel基础知识.md","hash":"3b7d9ca389c13ff9276281af6c96bf797dbaac79","modified":1620486169406},{"_id":"source/_posts/【数据分析】第二阶段：MySQL数据分析实战（一）.md","hash":"587c09ca8f02de975a68e33d404a2b2ccfe3fda3","modified":1620989154400},{"_id":"source/_posts/【数据分析】第二阶段：MySQL数据分析实战（二）.md","hash":"a4282dd31117d8dba2799ea507e7eff73ebbaf9a","modified":1620701001735},{"_id":"source/_posts/【数据分析】第一阶段：数据分析思维与业务流程.md","hash":"a9c5c10599bb485fdae536a249ff008bb99fef38","modified":1620726363537},{"_id":"source/_posts/检测数组重复元素.md","hash":"38bf609de44d0f1101b3b0b5123dea1559c297d9","modified":1620486158020},{"_id":"source/_posts/统计学笔记.md","hash":"745ff1eb9994c9fe404528f06abc52f4fe3fc04a","modified":1620486136318},{"_id":"source/_posts/自建应用字段编辑+JqueryWeUI.md","hash":"0f0296ce65ecea6792c061b695eb3bfbff5ecc7e","modified":1620486121239},{"_id":"source/tags/index.md","hash":"e5ba4d3fd836849de6f608e12b24bc1406bfe4f6","modified":1620485689360},{"_id":"source/categories/index.md","hash":"262b3afcb2f57308888615a2d869381c33811579","modified":1620485724354},{"_id":"source/_imgHost/.DS_Store","hash":"9174cdbb68394c241fd6eb9d9a7a8423effe9bf8","modified":1620818013545},{"_id":"source/_imgHost/Xnip2021-05-10_00-07-31.jpg","hash":"ad6417af67e39634cd720aa62d56eed62e9c8fce","modified":1620576453984},{"_id":"source/_imgHost/Xnip2021-05-10_00-08-38.jpg","hash":"bda561e92741503dedf92115e4b3471a8bb3e836","modified":1620576521128},{"_id":"source/_imgHost/Xnip2021-05-05_19-44-43.jpg","hash":"04ade416528487282b90b7b72b429acbedf7b6f2","modified":1620215115079},{"_id":"source/_imgHost/Xnip2021-05-08_20-39-20.jpg","hash":"7afc8245d14cb9e12610703e2f757b947fe7e10e","modified":1620477565132},{"_id":"source/_imgHost/Xnip2021-05-08_20-52-22.jpg","hash":"67ecedd57085a1650cf084af1e04b5ef80156260","modified":1620478346015},{"_id":"source/_imgHost/Xnip2021-05-08_20-36-59.jpg","hash":"060421121c6070c9741a6feb76b225cfc7fa6859","modified":1620477434519},{"_id":"source/_imgHost/Xnip2021-05-08_20-53-46.jpg","hash":"7cbae114a6fe041ce631c65c11a6b865d4c2caad","modified":1620478429645},{"_id":"source/_imgHost/Xnip2021-05-09_21-42-58.jpg","hash":"62da3d44de898ac4ca8a67974a5474b50924d931","modified":1620567781641},{"_id":"source/_imgHost/Xnip2021-05-09_18-26-26.jpg","hash":"524b9cbdd1eba5149ea1e1159f8c3bad85aab9b8","modified":1620555989819},{"_id":"source/_imgHost/Xnip2021-05-10_00-09-15.jpg","hash":"0285d314b3289b26493e98265d6cd69207f36f0d","modified":1620576558948},{"_id":"source/_posts/Angular4——3.路由导航.md","hash":"71375f345051bcf6ebe4ce77716c6f7d9ee251c9","modified":1620486070401},{"_id":"source/_imgHost/20210429171201_2.jpg","hash":"8adba790c6a865209d3822d483ef4ebfad8623a7","modified":1619968497919},{"_id":"source/_imgHost/Xnip2021-05-08_20-42-02.jpg","hash":"ad04390ee103fe536eb4100896e30aafc13ea906","modified":1620477725153},{"_id":"source/_imgHost/Xnip2021-05-08_20-56-42.jpg","hash":"c04babf3cc5553bf10449d18d4079feb63daae4c","modified":1620478605211},{"_id":"source/_posts/ES5学习笔记.md","hash":"162f228ce07fb041a23fc80e936b12351b9cceb9","modified":1620486375937},{"_id":"source/_imgHost/20210429171201_3.jpg","hash":"b38b9e805908e962327b415973cc70607f141c36","modified":1619970386428},{"_id":"source/_imgHost/Xnip2021-05-09_22-54-39.jpg","hash":"1be496da0948612bc35d147d7e1935101fde84f4","modified":1620572082763},{"_id":"source/_imgHost/20210429171201_1.jpg","hash":"31051366bb12f510052750f31f1c0d62ae2dbf26","modified":1619926994733},{"_id":"source/_imgHost/Xnip2021-05-05_21-50-07.jpg","hash":"37bc614ecc217e6b83436fdafeb44b5e5fb8798c","modified":1620222613336},{"_id":"themes/next/.gitignore","hash":"68d2f59b79fbc9edf358295ac38515c4b32126c1","modified":1619886831066},{"_id":"themes/next/.eslintrc.json","hash":"9c0762486f24a8c5e60f8b6c875e4c4728942649","modified":1619886831061},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1619886831060},{"_id":"themes/next/.gitattributes","hash":"ec43734985e1cafd53d88ded3020103f7416123c","modified":1619886831061},{"_id":"themes/next/LICENSE.md","hash":"68fc9a03d50fd4b5ea97092b05967d1819dea2c4","modified":1619886831066},{"_id":"themes/next/_vendors.yml","hash":"d521221487a080002d15d4d12918d6953327f02e","modified":1619886831067},{"_id":"themes/next/README.md","hash":"3af819b4010438d4821f279205586a7f36c5322b","modified":1619886831066},{"_id":"themes/next/package.json","hash":"16cd47b844b597761035621acdbef658b49a0bef","modified":1619886831098},{"_id":"themes/next/renovate.json","hash":"cb29cc16e61b0b8a6dac34657d76822ae29ad5aa","modified":1619886831098},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1619886831067},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1619886831068},{"_id":"themes/next/docs/LICENSE.txt","hash":"f5b14f791b7cfa1d16da981d929152e088a5d1b8","modified":1619886831068},{"_id":"themes/next/docs/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1619895104311},{"_id":"themes/next/languages/ar.yml","hash":"bca66db21c015dbd32970d8708b898518a773e1e","modified":1619886831070},{"_id":"themes/next/languages/README.md","hash":"b2567e32805dda79601157351a07e5ca9fe01315","modified":1619886831070},{"_id":"themes/next/languages/default.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1619886831070},{"_id":"themes/next/languages/en.yml","hash":"814d81c27fed736055ee300e0a6505b26ff4313c","modified":1619886831070},{"_id":"themes/next/languages/de.yml","hash":"4be7b8b76c81bf1853eb36d2e874b17546a0e792","modified":1619886831070},{"_id":"themes/next/languages/es.yml","hash":"651e3b33d86a7cdb9fd7895ca28279f8b1a24faa","modified":1619886831071},{"_id":"themes/next/languages/fa.yml","hash":"6456d40dd42f44101d9d6e7054e9884e9163f948","modified":1619886831071},{"_id":"themes/next/languages/it.yml","hash":"c1eeab4992c76bfd436bb205ce58b1cfeef55ee6","modified":1619886831072},{"_id":"themes/next/languages/fr.yml","hash":"b15dc05afdc94de02e5d3fee4f8d3dc5594dd37e","modified":1619886831071},{"_id":"themes/next/languages/ko.yml","hash":"6387357ac2dd498e8b8d630d27050a59180d7e8f","modified":1619886831072},{"_id":"themes/next/languages/id.yml","hash":"14e794db4eca36b257994d81eb513e61d1edcbd6","modified":1619886831071},{"_id":"themes/next/languages/nl.yml","hash":"ecb8e39c6225f3c068a5fdd569ee7dafd5c41a1f","modified":1619886831072},{"_id":"themes/next/languages/ja.yml","hash":"d48c4157e0e02e847aac7b513580d3364c81948c","modified":1619886831072},{"_id":"themes/next/languages/pt-BR.yml","hash":"a1f27b3a592fc58f17d247f5563ff4a90a3da5f2","modified":1619886831073},{"_id":"themes/next/languages/ru.yml","hash":"e9af1afe529ca747a04b801401d394b2ad696fde","modified":1619886831073},{"_id":"themes/next/languages/pt.yml","hash":"63a3e1e728ba5e6e22150de7331bb8a654f34960","modified":1619886831073},{"_id":"themes/next/languages/si.yml","hash":"2a9861db4547a524b2609c1e7e1061d2e9d48ee4","modified":1619886831073},{"_id":"themes/next/languages/tr.yml","hash":"55b38c7617c24bdc27c9de6cf39f4b191d154fb8","modified":1619886831074},{"_id":"themes/next/languages/vi.yml","hash":"c669c34da544a563ceae3e196addc9df6a78e024","modified":1619886831074},{"_id":"themes/next/languages/zh-CN.yml","hash":"5a3ab21210304efef736e96bad254f789f42c567","modified":1619886831074},{"_id":"themes/next/languages/uk.yml","hash":"7dd24580c0865c5a7bc4d391855045366a598936","modified":1619886831074},{"_id":"themes/next/languages/zh-HK.yml","hash":"f195bb0502ffe66e850077a1af1033455ea65f93","modified":1619886831075},{"_id":"themes/next/languages/zh-TW.yml","hash":"92256b90028de9a1e79c6bc0e5885b93e7fb4b17","modified":1619886831075},{"_id":"themes/next/layout/_layout.njk","hash":"eb602a9878dfdb4af2a7d82a8836b42777b72bce","modified":1619886831075},{"_id":"themes/next/layout/category.njk","hash":"0a590e87af50e57b15fc37695c9a3bf4a97c3d92","modified":1619886831094},{"_id":"themes/next/layout/archive.njk","hash":"d759f4d2cf5ddc6875ea250113a00662c1caf6d1","modified":1619886831093},{"_id":"themes/next/layout/index.njk","hash":"37ec3d1bcd20b8ac1d18e0d68f990450890b46cd","modified":1619886831094},{"_id":"themes/next/layout/page.njk","hash":"9cd3eca2c468bb46c7c5bf391bea4b025af178f6","modified":1619886831094},{"_id":"themes/next/layout/tag.njk","hash":"6cd707f846bfd6becbcfb060c26958bb4015c31f","modified":1619886831094},{"_id":"themes/next/layout/post.njk","hash":"6abeb85fb3e4c382ed4bb6049b12a807e6226e67","modified":1619886831094},{"_id":"themes/next/test/index.js","hash":"6bf0289846538be3e9a63809af98f00e1fbdd90b","modified":1619886831162},{"_id":"themes/next/docs/ru/README.md","hash":"a1775017150700cdad46dcede6cc53ac9f2fcb70","modified":1619886831068},{"_id":"themes/next/source/.DS_Store","hash":"0fe5a613976ca27561b7466eee72ed08806cc565","modified":1619928922481},{"_id":"themes/next/docs/zh-CN/README.md","hash":"0f40e224307a50a5b1ba62c40cb6e2e0f93a90b0","modified":1619886831069},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7a06d443f374bd1e84294067a0ac796afd9fbe60","modified":1619886831069},{"_id":"themes/next/.githooks/pre-commit","hash":"f473eac1aaaa96c947d67988bbed140bbab1a821","modified":1619886831061},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"8ee5ca39ac4a372a5c0f16e344bbe578af4aeae4","modified":1619886831069},{"_id":"themes/next/.githooks/install.js","hash":"4d77dbddf2eac1f3fc78f151d12ed22208ed655b","modified":1619886831061},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"21cbff565a0445d3a880fff1ee417e309740a9ab","modified":1619886831061},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"3e9fbb78e3dee0ca1dc886d0c28b0148ba0ca499","modified":1619886831063},{"_id":"themes/next/.github/config.yml","hash":"7984e665e9de481a0e0e51fca5668337713f810b","modified":1619886831063},{"_id":"themes/next/.github/label-commenter-config.yml","hash":"1097fc47beeacfc1edb0248c27b17bf64bde3565","modified":1619886831063},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1619886831063},{"_id":"themes/next/.github/release-drafter.yml","hash":"7662e31224a24154c4fe06b95ccbdff51ab8f2cc","modified":1619886831064},{"_id":"themes/next/.github/labeler.yml","hash":"e7033752b1f7c35adb61c2b38aad0a9202cdd19b","modified":1619886831064},{"_id":"themes/next/layout/_macro/post-collapse.njk","hash":"1a30d751871dabfa80940042ddb1f77d07d830b9","modified":1619886831075},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"eefd073dfb68884cd946f7ec6d3b3619031d7650","modified":1619886831062},{"_id":"themes/next/layout/_macro/sidebar.njk","hash":"eb786e8b35e354287cda345c524cd35ec955f692","modified":1619886831076},{"_id":"themes/next/layout/_macro/post.njk","hash":"b106599106285ecd4c0c1e0ed11c46a36b5a69d5","modified":1619886831076},{"_id":"themes/next/layout/_partials/comments.njk","hash":"5451969917c4e79de1d489d92142b44d22e82e43","modified":1619886831076},{"_id":"themes/next/layout/_partials/languages.njk","hash":"e43f22198cccb5f6e306b1ce0d28d12a4fb891f8","modified":1619886831079},{"_id":"themes/next/layout/_partials/pagination.njk","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1619886831080},{"_id":"themes/next/layout/_partials/widgets.njk","hash":"852a750524decf1efa587cd52b09e387ed8315de","modified":1619886831084},{"_id":"themes/next/layout/_partials/footer.njk","hash":"b7687c65d15b9eb72de4be070adaf3c609d31f62","modified":1619886831076},{"_id":"themes/next/layout/_scripts/index.njk","hash":"7de076a40e28d855691d9f622478068f6ad94ec3","modified":1619886831084},{"_id":"themes/next/layout/_scripts/vendors.njk","hash":"bada07da2a47ed6de6081796367b19dd9e906cfb","modified":1619886831084},{"_id":"themes/next/layout/_third-party/nprogress.njk","hash":"80fd1a45e91207fc16df1136e12b8b71b4f65dea","modified":1619886831090},{"_id":"themes/next/layout/_third-party/index.njk","hash":"467b45a4912369bcba77908151e76a3f3ad0fed2","modified":1619886831088},{"_id":"themes/next/layout/_third-party/rating.njk","hash":"1bcdbc7fde26d6d9ef4e7fa43ffcff5a9506b20e","modified":1619886831091},{"_id":"themes/next/scripts/filters/locals.js","hash":"374c9211b3b6a5b2ad31f1bea69a22f2727f633a","modified":1619886831103},{"_id":"themes/next/layout/_third-party/quicklink.njk","hash":"a43d101ddb2579947644a00731b173ef093c84c3","modified":1619886831091},{"_id":"themes/next/scripts/filters/minify.js","hash":"7793c9f7e268c0fca46ad86bf522deb83c2e4a5c","modified":1619886831103},{"_id":"themes/next/scripts/filters/post.js","hash":"42a9b81c5449afa9d67770604478168333c93804","modified":1619886831103},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"872f01cb10e422a648ea505436532e776e92926b","modified":1619886831102},{"_id":"themes/next/scripts/events/index.js","hash":"89091bc943cd8b8c63b8af3d26fb0a027048e9ba","modified":1619886831098},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"935a311142a409c1896b3ae3f01fe7a9e2db1134","modified":1619886831105},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"92c19d796bdb3320df9caea59bf52df7a95d9da9","modified":1619886831105},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"79102d9e9bccff6224e77a77c4d2d363094ae3df","modified":1619886831106},{"_id":"themes/next/scripts/tags/index.js","hash":"17f9451ce1f10f78437f52218757d38d4e1591b0","modified":1619886831106},{"_id":"themes/next/scripts/tags/button.js","hash":"c6ad2ed544fbb25ecb5d820c36e76302504271b7","modified":1619886831105},{"_id":"themes/next/scripts/tags/link-grid.js","hash":"18a483c2d5afd701f6080ffdddf2d1321370336c","modified":1619886831107},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"4fb01ca650fa8b256b8d48f50dc1b18350bd3d6d","modified":1619886831107},{"_id":"themes/next/scripts/tags/note.js","hash":"7b94ddb46b7d4b0fe815f2fbe4bd375f07f55363","modified":1619886831107},{"_id":"themes/next/scripts/tags/label.js","hash":"8a73348186113bae0a51ea2f891c1bb882fab05a","modified":1619886831106},{"_id":"themes/next/scripts/tags/tabs.js","hash":"0eabe51da40b4b13e16419c8fe02452d9a4fef73","modified":1619886831107},{"_id":"themes/next/scripts/tags/video.js","hash":"2ee926448583be8f95af1f2884ae2c9c4830151d","modified":1619886831108},{"_id":"themes/next/scripts/tags/pdf.js","hash":"344636b6fd7e27e8831c1e194039afc0d61931cd","modified":1619886831107},{"_id":"themes/next/scripts/helpers/font.js","hash":"3394185a7f0393c16ce52c8028f90da3e9239c55","modified":1619886831104},{"_id":"themes/next/scripts/helpers/engine.js","hash":"76b9095fccbd86be6ffc337501144c3bfdfa9bb0","modified":1619886831104},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"454ed1fac07be972c7ec911092f0995cd925aab3","modified":1619886831104},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"577c510374cf9bcfa8d3a1027e42411a9324805e","modified":1619886831104},{"_id":"themes/next/scripts/helpers/next-vendors.js","hash":"afdd6a188a74c188f0dd154fac70efd4080ca262","modified":1619886831105},{"_id":"themes/next/source/css/_colors.styl","hash":"b37f9847d2f95632e911df670b51921a7d748068","modified":1619886831108},{"_id":"themes/next/source/css/_mixins.styl","hash":"8b0c0353d360b984d285860697b2ccbec78da462","modified":1619886831134},{"_id":"themes/next/source/css/noscript.styl","hash":"76bba5d7916e9930e68215a0fce3a7d81c44510f","modified":1619886831147},{"_id":"themes/next/source/css/main.styl","hash":"78ce791cc4ac95386cf6839ca72f5f7b51f86ee9","modified":1619886831146},{"_id":"themes/next/source/js/bookmark.js","hash":"e45e1fbb7c6d645e9c410759486216e570d02bef","modified":1619886831151},{"_id":"themes/next/source/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1619886831152},{"_id":"themes/next/source/js/motion.js","hash":"6d4bd07a6f8e1b4083119dca0acb5b289533b619","modified":1619886831153},{"_id":"themes/next/source/js/config.js","hash":"7dad20378e907725e18007ddbad80b3366027240","modified":1619886831152},{"_id":"themes/next/source/js/next-boot.js","hash":"873e52a851a6ce8dc61b870fa7083da4d2304b7b","modified":1619886831153},{"_id":"themes/next/source/js/pjax.js","hash":"5bfc1cea214bd31847adc356f37df8e0b6a449df","modified":1619886831153},{"_id":"themes/next/source/js/schedule.js","hash":"71d62fc3584c47ff2d4cc945226e412264399be9","modified":1619886831154},{"_id":"themes/next/source/js/comments-buttons.js","hash":"1a7344440321713426a0b2ab17e276b5bdf85ade","modified":1619886831152},{"_id":"themes/next/source/js/utils.js","hash":"1ab751556da726960519edcca1f0030c1babe005","modified":1619886831161},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1619886831148},{"_id":"themes/next/source/images/avatar.gif","hash":"8f4e1541c598cf69c62d3365a2b607f446b8335d","modified":1619834488634},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"29bf23bccef6fc85ceafe721dd394bc287770495","modified":1619886831148},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"38478fb29a229a444b9b9e0ebf3a2fd5d943e476","modified":1619886831149},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"b796fa30ced3ddb228af19955fe6491b81f0ccc8","modified":1619886831149},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"c2e9d5ac5d93f63398357016df7a0ba0483aad75","modified":1619886831149},{"_id":"themes/next/source/images/cc-by.svg","hash":"a003f30369698b2a2f45d8c460d2956fb6d1eb15","modified":1619886831150},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"7cf99976f1162a385c2a85eca3a43ce928d4d60e","modified":1619886831149},{"_id":"themes/next/source/images/cc-zero.svg","hash":"bccb103bb13e990db9b0487bb72abaa3d2b09960","modified":1619886831150},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1619886831150},{"_id":"themes/next/source/images/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1619888562709},{"_id":"themes/next/source/images/favicon-16x16.png","hash":"8f4e1541c598cf69c62d3365a2b607f446b8335d","modified":1619834488634},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1619886831150},{"_id":"themes/next/source/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1619886831151},{"_id":"themes/next/source/images/favicon-32x32.png","hash":"8f4e1541c598cf69c62d3365a2b607f446b8335d","modified":1619834488634},{"_id":"themes/next/source/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1619886831151},{"_id":"themes/next/test/helpers/index.js","hash":"63ba28afed697f7b3574436b1133b8ecc9c0c357","modified":1619886831161},{"_id":"themes/next/test/helpers/font.js","hash":"342ef3c6fd2dcca2a8802a516ed6d7f389fd2ca2","modified":1619886831161},{"_id":"themes/next/test/helpers/next-url.js","hash":"abc4ee5149df6172b2c36b6e85d1993ec748ddea","modified":1619886831162},{"_id":"themes/next/test/tags/button.js","hash":"48f2aa4c513e9e24bd6a811410520b74cd7ea88b","modified":1619886831162},{"_id":"themes/next/test/tags/center-quote.js","hash":"7667342fd1a1417eaf6a254012b84ae40e8d13dd","modified":1619886831163},{"_id":"themes/next/test/tags/caniuse.js","hash":"aa5e728445caeaf7c2ccd0f3fcb2cad0c93ca6d1","modified":1619886831162},{"_id":"themes/next/test/tags/group-pictures.js","hash":"f41640e5d0f552c0b0c4ac8876a2edb0fcf54e56","modified":1619886831163},{"_id":"themes/next/test/tags/index.js","hash":"e8779e54f0979b221858f8bb74dd081bb503b910","modified":1619886831163},{"_id":"themes/next/test/tags/label.js","hash":"4ebf3698c258ca978b997acbdd0dece44069c09d","modified":1619886831163},{"_id":"themes/next/test/tags/mermaid.js","hash":"ab77be5f3c6d9a57c7b9dda6decf1906a736fef9","modified":1619886831164},{"_id":"themes/next/test/tags/note.js","hash":"3dcfcd65bf9f326972ea7571fdb1444200f5d07e","modified":1619886831164},{"_id":"themes/next/test/tags/pdf.js","hash":"fd6ea5123560a90f7e7c1eface23dbe1455db25f","modified":1619886831164},{"_id":"themes/next/test/tags/link-grid.js","hash":"43d298fafb7c45a874b766d443843bd26346e689","modified":1619886831163},{"_id":"themes/next/test/tags/tabs.js","hash":"d63722919f9da2e44d6b952801e10a2915ea9c12","modified":1619886831165},{"_id":"themes/next/test/tags/video.js","hash":"b796fc4dceb20a30e730c322bb5474c0162464cc","modified":1619886831165},{"_id":"themes/next/test/validate/index.js","hash":"5a95ccc8598667535bd022e988055c0e019f3670","modified":1619886831165},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"4ecac91716eac59d7c2bc53cf6e95612d44da97b","modified":1619886831063},{"_id":"themes/next/.github/ISSUE_TEMPLATE/config.yml","hash":"c40ae7903b6cc99f94c9d45ac7ba8c2850bb1309","modified":1619886831062},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"8cc5b5c116f6a052865a324512362f145d699202","modified":1619886831063},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"fc4dce84ed9a5d21d3a8833ff6d776c46f876115","modified":1619886831062},{"_id":"themes/next/.github/workflows/label-commenter.yml","hash":"44405477660289d4ed9beba1d054b15bb67bba06","modified":1619886831064},{"_id":"themes/next/.github/workflows/labeler.yml","hash":"8b73c439dc796be141d521a4546bcfb7a5485534","modified":1619886831065},{"_id":"themes/next/.github/workflows/lock.yml","hash":"70bd0be3f33774e4b0ada3a59c901f8f9cff1013","modified":1619886831065},{"_id":"themes/next/.github/workflows/linter.yml","hash":"385e54acf75eb6892e41946d954ce8ec44f0bb46","modified":1619886831065},{"_id":"themes/next/.github/workflows/release-drafter.yml","hash":"4f3af81009cb922be91f718a67425377515ea69d","modified":1619886831065},{"_id":"themes/next/.github/workflows/stale.yml","hash":"e1d9cc9addc35cfb53f971f14d9d04065c941df0","modified":1619886831066},{"_id":"themes/next/layout/_partials/head/head-unique.njk","hash":"49aa8de07918a11399131dfd703418af3f0a1a19","modified":1619886831077},{"_id":"themes/next/.github/workflows/tester.yml","hash":"22aaaa3eba1a7ebcf0f78417fd9a7113ee7b6c6c","modified":1619886831066},{"_id":"themes/next/layout/_partials/head/head.njk","hash":"d73611d6401b143d994878aa851eb0516dd307f5","modified":1619886831077},{"_id":"themes/next/layout/_partials/header/brand.njk","hash":"ffb6c69a9c90793cbe9bf0544b55f7a41c016d8f","modified":1619886831078},{"_id":"themes/next/layout/_partials/header/menu-item.njk","hash":"b46f412c0b4f775fd329d50357f722f5d7c1a3ba","modified":1619886831078},{"_id":"themes/next/layout/_partials/header/index.njk","hash":"53895b3af95667edc5bf5d7356f8a2b4fe091447","modified":1619886831078},{"_id":"themes/next/layout/_partials/header/sub-menu.njk","hash":"75a158a5b54a3a76ee6590f5e0e2dd4a9f0be869","modified":1619886831079},{"_id":"themes/next/layout/_partials/header/menu.njk","hash":"c9390824b57f23b7c8a5c23a9834514123673766","modified":1619886831078},{"_id":"themes/next/layout/_partials/page/categories.njk","hash":"17156d99941f28a225951ffdcfa9a115e20dc2d2","modified":1619886831080},{"_id":"themes/next/layout/_partials/page/breadcrumb.njk","hash":"edb3bb6d644b7407673c5ef3a426a244e98fcf89","modified":1619886831079},{"_id":"themes/next/layout/_partials/page/page-header.njk","hash":"7ed4f102a1825195cff8d7995bf9219f323a9034","modified":1619886831080},{"_id":"themes/next/layout/_partials/page/schedule.njk","hash":"ca2ccf3cf1874c45712f192ad45dea96fbd9920d","modified":1619886831080},{"_id":"themes/next/layout/_partials/page/tags.njk","hash":"a18d1598e36cc72f2b0b24c3cc3c5990dfaa3254","modified":1619886831080},{"_id":"themes/next/layout/_partials/post/post-copyright.njk","hash":"133942922e34abae9e4de7ea5591d77c0caa4b37","modified":1619886831081},{"_id":"themes/next/layout/_partials/post/post-footer.njk","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1619886831081},{"_id":"themes/next/layout/_partials/post/post-followme.njk","hash":"154df0bb323c332d8c25343f258ee865e5553423","modified":1619886831081},{"_id":"themes/next/layout/_partials/post/post-related.njk","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1619886831082},{"_id":"themes/next/layout/_partials/post/post-meta.njk","hash":"cc1a11190b1a55ae8d4252d296803bc19db90bc5","modified":1619886831081},{"_id":"themes/next/layout/_partials/search/algolia-search.njk","hash":"efb2b6f19df02ba5ae623a1f274fff52aed21e6f","modified":1619886831082},{"_id":"themes/next/layout/_partials/post/post-reward.njk","hash":"a9bb52d0537d27cfe670d80e716da6780786ab8a","modified":1619886831082},{"_id":"themes/next/layout/_partials/search/index.njk","hash":"8f6f256ab3b351ffc80f1f3f1d9834e9a7cfac31","modified":1619886831082},{"_id":"themes/next/layout/_partials/search/localsearch.njk","hash":"661f7acae43f0be694266323320f977d84119abe","modified":1619886831083},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.njk","hash":"6215309aee028dcb734452beec448c5afb6c63fc","modified":1619886831085},{"_id":"themes/next/layout/_partials/sidebar/site-overview.njk","hash":"c419158e19805e2db614a5f5651e3e534e4a5e4e","modified":1619886831083},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.njk","hash":"d89066ff53879693f023e540d59c86137172c529","modified":1619886831085},{"_id":"themes/next/layout/_third-party/analytics/cloudflare.njk","hash":"c978e9efd472c4825f93b83524b11f1c4f7efaab","modified":1619886831085},{"_id":"themes/next/layout/_third-party/analytics/growingio.njk","hash":"8afaa772c390bd9d53a5cff9645ac3168334eb98","modified":1619886831085},{"_id":"themes/next/layout/_third-party/analytics/index.njk","hash":"2d36a481a70d5f450f1f166dc556ac1218b18537","modified":1619886831085},{"_id":"themes/next/layout/_third-party/comments/disqus.njk","hash":"9375b19a89b7fa9474e558d085af5448d4c5c50c","modified":1619886831087},{"_id":"themes/next/layout/_third-party/comments/changyan.njk","hash":"d1c950f8fbdf85e7a3eae5463767a89e858e8220","modified":1619886831086},{"_id":"themes/next/layout/_third-party/comments/disqusjs.njk","hash":"ecb7c791c9611f80af66eacef493106c5e9ef6c5","modified":1619886831087},{"_id":"themes/next/layout/_third-party/comments/gitalk.njk","hash":"79bbe1e65a8cfb23a44db8314130fb6a5a4afd21","modified":1619886831087},{"_id":"themes/next/layout/_third-party/comments/livere.njk","hash":"3b13b09fba84ec6000886890a6710736a2b8fafe","modified":1619886831087},{"_id":"themes/next/layout/_third-party/comments/isso.njk","hash":"64cc3bdaf644fd32c0d0a247f29f5b6904da9af3","modified":1619886831087},{"_id":"themes/next/layout/_third-party/math/index.njk","hash":"abf37fc55aa86702118e8fdf5bf2d389dd589aa0","modified":1619886831090},{"_id":"themes/next/layout/_third-party/comments/utterances.njk","hash":"5a94032bc3512a10ad4328fc19ec07b819a1d687","modified":1619886831088},{"_id":"themes/next/layout/_third-party/math/mathjax.njk","hash":"3677017fd4572b158311f5f5d870590ab25184e0","modified":1619886831090},{"_id":"themes/next/layout/_third-party/math/katex.njk","hash":"514a681fadb40e60798c5eb7b7425d2eabae96c2","modified":1619886831090},{"_id":"themes/next/layout/_third-party/search/algolia-search.njk","hash":"686d8c211409acdd0036e6dfac129130f33a8ab4","modified":1619886831091},{"_id":"themes/next/layout/_third-party/search/localsearch.njk","hash":"3fc91aba5b17a5ae60b8e04707a7da87db4d0340","modified":1619886831091},{"_id":"themes/next/layout/_third-party/chat/chatra.njk","hash":"5c54ef9060195c6bdcb3bbd4cc1af938a443fb23","modified":1619886831086},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.njk","hash":"a4bc501da0f22f7e420f0ca47e83988ce90b1368","modified":1619886831092},{"_id":"themes/next/layout/_third-party/chat/tidio.njk","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1619886831086},{"_id":"themes/next/layout/_third-party/statistics/index.njk","hash":"568ddf7955d11d93fb5e842b403a7ac8b1b7fdb1","modified":1619886831092},{"_id":"themes/next/layout/_third-party/statistics/firestore.njk","hash":"6aa758e0f3ade2b952478dbd179ab2b69bb0485b","modified":1619886831092},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.njk","hash":"2446e748cdc102c78492216319ac02148db7daf6","modified":1619886831093},{"_id":"themes/next/layout/_third-party/tags/mermaid.njk","hash":"099e031f52fb8e47b3af5b2684737efc9e643ee7","modified":1619886831093},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1619886831100},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"93ee5f9109dad885dc38c49bcee630c10f9dce6e","modified":1619886831101},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"cc1e2d5921c6990f94f3cf11b1ff7533a21da9b7","modified":1619886831101},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"32a1d9ad50621a78d0243e176c8b05ff7866fd5b","modified":1619886831101},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"7c0533bac4400689a0d5ab3a188ce42b9375de46","modified":1619886831101},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"ecc93ba67af26b6715fc75001fa0c3131b726241","modified":1619886831100},{"_id":"themes/next/scripts/filters/comment/isso.js","hash":"ff8b5b5145220a17d0ecd9508ba9bd2d3b2da47d","modified":1619886831101},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"60be56c9ba590e5bcb80d1607ca7eeedde9fdfaa","modified":1619886831102},{"_id":"themes/next/layout/_third-party/tags/pdf.njk","hash":"2c81984cc4f5123103460442f6e046f5b6c97127","modified":1619886831093},{"_id":"themes/next/scripts/filters/comment/utterances.js","hash":"d3bded697bc32dace689d2a6dfb6eb7514169d15","modified":1619886831102},{"_id":"themes/next/scripts/events/lib/highlight.js","hash":"6aec7b2c38c50989a23bfaa0d560e75c7f553e12","modified":1619886831099},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"7b0ea8d28ced63977dc6539920eb044b1098adcb","modified":1619886831099},{"_id":"themes/next/scripts/events/lib/config.js","hash":"09b58494e9d9d25542d1d218f2d0ffc4d2da9f30","modified":1619886831099},{"_id":"themes/next/scripts/events/lib/utils.js","hash":"b281be775b693f9bf32766c8f6ef703c72ac9b00","modified":1619886831099},{"_id":"themes/next/scripts/events/lib/vendors.js","hash":"d1ecc44f9f6e236bf910e36150767d36be4658b2","modified":1619886831100},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e1fbf169b9b6a194b518240cbd06ec3c48b83d61","modified":1619886831145},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"96e0a7c2a65ce68215e17e369085b2ea2f1334f2","modified":1619886831145},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"e3be898f5ebcf435a26542653a9297ff2c71aeb0","modified":1619886831145},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c65536a128b9bc9dbe2fbb1b235a3cded2891002","modified":1619886831145},{"_id":"themes/next/source/js/schemes/muse.js","hash":"9d15d0d6a58b1df74827288f117af22b4b6aafe5","modified":1619886831154},{"_id":"themes/next/source/css/_variables/base.styl","hash":"32a1b73944561655087d80f025208a84e012b3cf","modified":1619886831146},{"_id":"themes/next/source/js/third-party/quicklink.js","hash":"6f58cd7aa8f6f1ab92d5a96551add293f4e55312","modified":1619886831158},{"_id":"themes/next/source/js/third-party/nprogress.js","hash":"7d56b18a2bdece5468470c70c5f3eb79d4120964","modified":1619886831158},{"_id":"themes/next/source/js/third-party/rating.js","hash":"51a35e9ce91567bfc5efa31007ae694bfdfb68b5","modified":1619886831158},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"d8bf9cb15d9d91c7ad022ba2954b5b4d326f17f7","modified":1619927975422},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1619927975422},{"_id":"themes/next/source/lib/fancybox/README.md","hash":"8286582ed7c338fce8bb03566b769fba378bce83","modified":1619927975423},{"_id":"themes/next/source/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1619927975423},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"4817e77577896ab5c0da434549917ee703a3f4cf","modified":1619886831140},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"357b899ac0f0dfbbbebf1ea972030c7cefa463ce","modified":1619886831140},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"b332868d76d9f1651efd65abfc0d3c9d699b1a45","modified":1619886831140},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"ab16a3dcdc0393b9b582ef59dcc13db9320e917c","modified":1619886831142},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"06080fd963c904d96c00eff098a284e337953013","modified":1619886831142},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"82a29572dd90451f75358a2ee2522b87304a0bb8","modified":1619886831142},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"944364893bd7160d954c10ba931af641c91515a4","modified":1619886831143},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"8a70d51d8f7cd113e5fbc9f0e70c46a072f282c8","modified":1619886831142},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1619886831143},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1619886831143},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"5604ac1e161099a4d3e5657d53507268866dc717","modified":1619886831140},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"be5c46b983df08b9dbac1b4749b1a101b54b6b50","modified":1619886831143},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"2d337a12c5c668ee64447bda5a9ed64eaed5b29e","modified":1619886831144},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"6eee86c8f0175d6c09e434053516cd8556f78d44","modified":1619886831144},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"72dc825c50357402c342d62ab60fc0c478ab6bc1","modified":1619886831144},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"778ed2ad5643b93970c95626b325defeb586733f","modified":1619886831144},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"fd49b521d67eaccc629f77b4e095cb7310327565","modified":1619886831135},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"8000075b227749a7495eaf417cac6ccfbe441580","modified":1619886831144},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"d4809783ded05625675b1b4bbd9e99d7f5f7d7f9","modified":1619886831108},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ece860218125bdb2578f373ed4f5040c9670e4b1","modified":1619886831109},{"_id":"themes/next/source/css/_common/components/index.styl","hash":"3c7ae405dd30b9b46494a6b9a6cb1b7ec6138ba9","modified":1619886831109},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"1cffb9c24eea18090b21b9cb908fe07cfeac0c03","modified":1619886831113},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a042571d85ff7265f799004239a45f36b716b8a6","modified":1619886831121},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"8d7ad58c9086161b05843aa7e44973148be33611","modified":1619886831121},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"e4fecc889ba3317a64e9abba5842c79dff9b7827","modified":1619886831121},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1619886831130},{"_id":"themes/next/source/css/_common/scaffolding/index.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1619886831123},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"41cba8c4c5637a6b8f1b62e67673b33676f5d734","modified":1619886831131},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"e840b23d33023e6d45e018f6e84b683dd56efd8d","modified":1619886831131},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"572a41499391677d84b16d8dbd6a996a3d5ce041","modified":1619886831134},{"_id":"themes/next/source/js/third-party/chat/chatra.js","hash":"106f3f89f46ec96a08df5f14c31dca88a0b9b82f","modified":1619886831155},{"_id":"themes/next/source/js/third-party/analytics/google-analytics.js","hash":"59684383385059dc4f8a1ff85dbbeb703bcdbcb5","modified":1619886831155},{"_id":"themes/next/source/js/third-party/analytics/growingio.js","hash":"78dd3cf04082b7dbe6246e404b2aa8e726922402","modified":1619886831155},{"_id":"themes/next/source/js/third-party/analytics/baidu-analytics.js","hash":"f629acc46ff40c071ffd31b77d5c7616f0fdd778","modified":1619886831154},{"_id":"themes/next/source/js/third-party/comments/changyan.js","hash":"6d9ca074f1df9e9527ec06c2963b1ad6079d821e","modified":1619886831156},{"_id":"themes/next/source/js/third-party/comments/gitalk.js","hash":"0ec038cf83e8ec067534f16a54041e47a3c1e59a","modified":1619886831156},{"_id":"themes/next/source/js/third-party/comments/disqus.js","hash":"0da0ab95471cb73a5d467c5d1b4ce7893ace86fc","modified":1619886831156},{"_id":"themes/next/source/js/third-party/comments/isso.js","hash":"753a873b6f566aff5ba77ca23f91b78eb880ca64","modified":1619886831157},{"_id":"themes/next/source/js/third-party/comments/disqusjs.js","hash":"b6c58f098473b526d6a3cd35655caf34b77f7cff","modified":1619886831156},{"_id":"themes/next/source/js/third-party/comments/livere.js","hash":"2247d88c934c765c43013337860774aaa99f0b31","modified":1619886831157},{"_id":"themes/next/source/js/third-party/comments/utterances.js","hash":"f67f90eb03e284c82da2b8cf2f1e31801813c16d","modified":1619886831157},{"_id":"themes/next/source/js/third-party/math/katex.js","hash":"83c54ee536e487a1031783443fe0cb63b1b4767e","modified":1619886831157},{"_id":"themes/next/source/js/third-party/search/algolia-search.js","hash":"a360423984cdd915d04365c51bcab440e52d7223","modified":1619886831159},{"_id":"themes/next/source/js/third-party/math/mathjax.js","hash":"87406572e6781c79146c217adc46f9199c952bbb","modified":1619886831157},{"_id":"themes/next/source/js/third-party/search/local-search.js","hash":"da2051e7cab184ae4aa64457c5db7476b4645fdc","modified":1619886831159},{"_id":"themes/next/source/js/third-party/statistics/firestore.js","hash":"e1194984b7b41ae232b57bd423c97f36bc7bdd61","modified":1619886831160},{"_id":"themes/next/source/js/third-party/statistics/lean-analytics.js","hash":"34c1f2dbf5c3d4f6e9dad73addb22b648c2053c1","modified":1619886831160},{"_id":"themes/next/source/js/third-party/tags/pdf.js","hash":"af78c22f0e61c8c8aa8794e585e0d632c6d4fcb8","modified":1619886831160},{"_id":"themes/next/source/js/third-party/tags/mermaid.js","hash":"2847a80fa248c9341a049fab3205953460aedefd","modified":1619886831160},{"_id":"themes/next/source/css/_common/outline/index.styl","hash":"0c9f72ad98807521cbdcee7b5bbe2e884311db39","modified":1619886831117},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"9f88d350df8115d26c6adbc2025a27ef9a42d7ff","modified":1619886831117},{"_id":"themes/next/source/lib/fancybox/.git/config","hash":"0bd9061daa1ae14bc8c15ccb2616123858620669","modified":1619927975413},{"_id":"themes/next/source/lib/fancybox/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1619927975408},{"_id":"themes/next/source/lib/fancybox/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1619927974199},{"_id":"themes/next/source/lib/fancybox/.git/index","hash":"5928cf21890e171dec3254b14b4d965152a3b64c","modified":1619927975427},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"8afdc311c6b8db121758371f95cf1c5e77354f42","modified":1619886831109},{"_id":"themes/next/source/lib/fancybox/.git/packed-refs","hash":"f0b53e687e79fcab7e1836dec921908302da45b9","modified":1619927975406},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"b6e2eb1550a7845cb2adf86081a4ab6c7bde1e68","modified":1619886831109},{"_id":"themes/next/source/css/_common/components/pages/index.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1619886831110},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"6b816c2511242ee503fb5f34cd3e4dcdafc06b85","modified":1619886831110},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"1a81d1a71fcf0699629ce6e72dfd0a15f3a2dd0a","modified":1619886831110},{"_id":"themes/next/source/css/_common/components/post/index.styl","hash":"b3fa752f72ca1413289b76c56fbd33a00e3d25d7","modified":1619886831110},{"_id":"themes/next/source/css/_common/components/post/post-body.styl","hash":"5d61dedb3bec1021d52894f9b379e4d0953f6a35","modified":1619886831111},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"76d0dfb3a8b873a6180604ac6daecf38b6a963a2","modified":1619886831111},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"ec37a36e94ba791663607a5022f763915778578f","modified":1619886831111},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"aa366d37389760c8595529b850f461569577a1c5","modified":1619886831112},{"_id":"themes/next/source/css/_common/components/post/post-footer.styl","hash":"1d284f3ea03ba9b4feb76b375e539a8e0bccf1c3","modified":1619886831111},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"2ca4dea5e7785c9b77566d95cabf896d20a42741","modified":1619886831112},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"9ac6f477177264c26a46e8333b8456720a0444dc","modified":1619886831112},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1619886831113},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"b1181c5f12a70b8bf710586fcb0d7959841ee512","modified":1619886831113},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"7102f8e819b62cf7d121fd063dc663fd068feaa6","modified":1619886831113},{"_id":"themes/next/source/css/_common/components/third-party/index.styl","hash":"b457756758f0632767e8a560e3033059cbe4a67b","modified":1619886831114},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"83c6588c51cd418336f4945813410a100ddfe2a4","modified":1619886831114},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"2c534d2b2dbc932ad65d335a720a7ba9612bac04","modified":1619886831114},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"2896840ab8ac8ab2a7f76d18df893f290ac31625","modified":1619886831114},{"_id":"themes/next/source/css/_common/components/third-party/utterances.styl","hash":"bf88d9c585d7b00463c46352402cfea415c29493","modified":1619886831114},{"_id":"themes/next/source/css/_common/scaffolding/highlight/index.styl","hash":"08e79881d58d01afab6dbed37ab4f52356564d7e","modified":1619886831122},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"393ff96234e4196b569d4b11496774eb78e147de","modified":1619886831132},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"83ee4993710fc8daa1c8dbfccd5d5091fd244c30","modified":1619886831122},{"_id":"themes/next/source/css/_common/scaffolding/tags/index.styl","hash":"cef4e779473daa3761709958243c6b8a57bbd814","modified":1619886831132},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"15a5e273a8137550c93c8d2a60f9fcf86e04a89e","modified":1619886831132},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"debee14539272fbe3835a7d3853af2230baa3501","modified":1619886831132},{"_id":"themes/next/source/css/_common/scaffolding/tags/link-grid.styl","hash":"2421500e447822ef1b6826403a3e1df3345641d7","modified":1619886831133},{"_id":"themes/next/source/css/_common/scaffolding/tags/mermaid.styl","hash":"3c029a003e9bf747e1b9cc7c0c127f6028374876","modified":1619886831133},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"f53e6c12bd4805888f696386d00668f23cd335e7","modified":1619886831133},{"_id":"themes/next/source/css/_common/outline/footer/index.styl","hash":"4f482514230c941c9475e1272188e53a54975463","modified":1619886831115},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1619886831133},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"50b00218e854200c4ec0573a841e226d49c45cba","modified":1619886831134},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"cf194bea1c9e67fde871a04de3bc81df72c54277","modified":1619886831115},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"d6d60f02b5e9f89dbfce180b3884030898022664","modified":1619886831115},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"392fd53a8dd4e3f33a853ebb24290a622300e0ff","modified":1619886831116},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"9a47c9045e443b8d20932f9c564a3a05fa4c6b51","modified":1619886831116},{"_id":"themes/next/source/css/_common/outline/header/index.styl","hash":"f1778d2c56974b96dae429456d5c55be325c4946","modified":1619886831116},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"bf3ad8b4268f763a1e26377681644887694bc009","modified":1619886831117},{"_id":"themes/next/source/css/_common/outline/sidebar/index.styl","hash":"d180871d4440090241fc988736c1f3a7efb4b1ba","modified":1619886831118},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"52fc98b1435129eb3edb9293ced9e507741f1350","modified":1619886831118},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"5b38ac4a0f1ade0e681aff0e3366c481d9cf3dcd","modified":1619886831119},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"fbdb63c6a8887d19b7137325ba7d6806f728139c","modified":1619886831120},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"9950c3188a28e1c63b5498b7bdcd14b12ace3e28","modified":1619886831119},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"6394340c28a21f6aa90e786f3bfe24fb26595653","modified":1619886831120},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"ab715dbf2b98bfeb5e7b7c43e92e5c02496cc2ea","modified":1619886831119},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"f7ff85fe6c4efb8ff036fab2c3277b7d8bed69a8","modified":1619886831120},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"432e73bc4f99322af6af1852e0ea6e674919c31a","modified":1619886831121},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"69eb1c282a8fd5dbab606cc09c34c5dc8e44e753","modified":1619886831121},{"_id":"themes/next/source/lib/fancybox/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1619927974204},{"_id":"themes/next/source/lib/fancybox/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1619927974200},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1619927974207},{"_id":"themes/next/source/lib/fancybox/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1619927974206},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1619927974208},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1619927974203},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1619927974205},{"_id":"themes/next/source/lib/fancybox/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1619927974206},{"_id":"themes/next/source/lib/fancybox/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1619927974201},{"_id":"themes/next/source/lib/fancybox/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1619927974208},{"_id":"themes/next/source/lib/fancybox/.git/logs/HEAD","hash":"6f33fd5011e6afc68d19a2544f8ae33b849f09d7","modified":1619927975410},{"_id":"themes/next/source/lib/fancybox/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1619927974199},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1619927975423},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1619927975423},{"_id":"themes/next/source/lib/fancybox/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1619927975422},{"_id":"themes/next/source/lib/fancybox/.git/objects/00/c03f6be011e8878608eec12f68caf42b73f38e","hash":"8516bd35bc8f9223e13de5877778c8d14d49d6db","modified":1619927975393},{"_id":"themes/next/source/lib/fancybox/.git/objects/19/3567a3107003507fafacd255c349857e417926","hash":"ef5eab75e8c6998cb223edb4eb8a26c4cfc9415c","modified":1619927975388},{"_id":"themes/next/source/lib/fancybox/.git/objects/16/b01254a56610f4c6b7721c534ed4fc40ae51dd","hash":"88ca5fd99322d3a4067e0711af79f41c078f2ef5","modified":1619927975340},{"_id":"themes/next/source/lib/fancybox/.git/objects/0c/dada082d621dbfdd00f7020c33dc751129167f","hash":"b490c11cdefde6b331a7d4ddb055e34ad08459d8","modified":1619927975329},{"_id":"themes/next/source/lib/fancybox/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1619927975330},{"_id":"themes/next/source/lib/fancybox/.git/objects/1f/a2c5f332b7e304431213aec21012e53f8781d7","hash":"7632806182aa989d3b7029579d5c03c34b113ee3","modified":1619927975322},{"_id":"themes/next/source/lib/fancybox/.git/objects/36/9bab09306448a2970d378b59bb21c059edad63","hash":"877e0c15623d0d6ff8f09bb627fc60a489f3c105","modified":1619927975333},{"_id":"themes/next/source/lib/fancybox/.git/objects/40/9607f1ba381a64c3ccb8d5440299e8ef868ef8","hash":"a462f7a9efebb70c4051f92c09ccbd9885132c77","modified":1619927975315},{"_id":"themes/next/source/lib/fancybox/.git/objects/47/d427b6c52396bbab53a05f57aaa82b52c805b1","hash":"c5626bbb62f4d1d1e39034e7f44baf4c509410d6","modified":1619927975379},{"_id":"themes/next/source/lib/fancybox/.git/objects/51/cf05811ed7d35e92551db1ba5a6e267ce781a5","hash":"99c009035ea86e3876b586577677d4d62ae12379","modified":1619927975376},{"_id":"themes/next/source/lib/fancybox/.git/objects/54/0a7b36ee26decfc3f0f34bf73bc85c48899128","hash":"2e5447a9dd879d71368e9dddd34d93849d00b934","modified":1619927975394},{"_id":"themes/next/source/lib/fancybox/.git/objects/53/ceaabe0f8677333c5be196778b3e40840a1869","hash":"7bc1c1c42059d5402335b5293bfb5e54bee22557","modified":1619927975326},{"_id":"themes/next/source/lib/fancybox/.git/objects/63/c555caede30ab06d6dba16644a827e9574c8cb","hash":"846603220288272ad5d35ebdc3c917cc4adce424","modified":1619927975318},{"_id":"themes/next/source/lib/fancybox/.git/objects/64/c47e893a0fef71c8c0930975ef114d9812da56","hash":"eaad75fab15724f9c2b069fc1ce9b8216be149d7","modified":1619927975336},{"_id":"themes/next/source/lib/fancybox/.git/objects/78/068b93f813cecbbd50c8247de547035009d512","hash":"4bc2bee779bd7e3cca13ee34801cf1e12585e5ae","modified":1619927975378},{"_id":"themes/next/source/lib/fancybox/.git/objects/7b/15d3cb03fda86241f8b2b335f04e9b9de0e1c4","hash":"d1fe3bd82c90f7d93874798a8ee8ebf1391d7207","modified":1619927975385},{"_id":"themes/next/source/lib/fancybox/.git/objects/7c/c60b295fa2dcb82537a63792c9b3b3c2e74c33","hash":"b2dc23c71b13726c391aaefaa5312227a9b6ab7e","modified":1619927975341},{"_id":"themes/next/source/lib/fancybox/.git/objects/7c/00ef8195b73793d477d22e723ecdac9553ebf3","hash":"fd8c4fd143b32fb3e86367f123feb7c35b305262","modified":1619927975368},{"_id":"themes/next/source/lib/fancybox/.git/objects/89/9d7a75b543fbed2a785f67d995bc77e06eb2e9","hash":"5651e2b80703225f642625c0fb2646543096d2cf","modified":1619927975324},{"_id":"themes/next/source/lib/fancybox/.git/objects/80/6b27034bd69d563e4243c2f12b43c7064b32dd","hash":"b7d3e8020767ae60a2029da8eccb0068623dc618","modified":1619927975375},{"_id":"themes/next/source/lib/fancybox/.git/objects/94/a9ed024d3859793618152ea559a168bbcbb5e2","hash":"1c2d080a86f03eb960e112a94910a5115addf57a","modified":1619927975332},{"_id":"themes/next/source/lib/fancybox/.git/objects/92/4369c371444afb18fb86309229f5b4c24c6cf4","hash":"9eb6fa8ff9081e6650f6bee350d21567df105737","modified":1619927975387},{"_id":"themes/next/source/lib/fancybox/.git/objects/9b/fe9361836240600c1bcc3cab9d42b35e731fad","hash":"3d38ffc7ac1ae85224691ef15d7f32e40c40b3a2","modified":1619927975337},{"_id":"themes/next/source/lib/fancybox/.git/objects/aa/654e17af8c354994f706c4e33bba6b5b70caeb","hash":"22b1bdf0b0974bf5e9022953ac26066056c235ff","modified":1619927975392},{"_id":"themes/next/source/lib/fancybox/.git/objects/ac/97c2cc9f61c52753abe4174a4a74b2064e5af0","hash":"272e74036b0612de83d9d0aa9604d3edf888b249","modified":1619927975384},{"_id":"themes/next/source/lib/fancybox/.git/objects/ad/569256343419017e8832a38faaa1c786716a1d","hash":"0538e4abd112b0a843035f28a511edabbe73f2ce","modified":1619927975320},{"_id":"themes/next/source/lib/fancybox/.git/objects/b6/c361c8dcf2f5a7572e81b956272e4cfe1198c1","hash":"3e160c605dbd94dcef2b9692a4a5a82bddb76264","modified":1619927975335},{"_id":"themes/next/source/lib/fancybox/.git/objects/b3/b3098638624b56be968573e2dab1684f8a7f06","hash":"6fa11a2d904dff2b8f4ae1bd88bdbb66736438a1","modified":1619927975346},{"_id":"themes/next/source/lib/fancybox/.git/objects/c2/fc5def1b6c38369e5e8b849adb956bd79b549e","hash":"27f03b9616e615b2724bac0fa4507d152697f3f1","modified":1619927975325},{"_id":"themes/next/source/lib/fancybox/.git/objects/bd/e1f741357b44b49290d43fdd193125202fef81","hash":"9beefc75cc0c37d04e98dd13b51ad85df40e77b9","modified":1619927975328},{"_id":"themes/next/source/lib/fancybox/.git/objects/ce/c0e316bee5d497ee834dbd29e0c5aad8331052","hash":"3d769fa5f55014841d10bb3bdf1b9725c43e9043","modified":1619927975327},{"_id":"themes/next/source/lib/fancybox/.git/objects/d5/d10f6be62acc10fec6e11e8dc4affe1184a17b","hash":"cec51b2539349d2aba1ec5d11eaded3815eccdc5","modified":1619927975350},{"_id":"themes/next/source/lib/fancybox/.git/refs/heads/master","hash":"0b56bdb897316a3b4ec6c120673249f65f4cb420","modified":1619927975410},{"_id":"themes/next/source/lib/fancybox/.git/objects/f6/bb280a0b2c68256a8e906b35c6976c80c1b3be","hash":"5daaee11fc384fbe0f02c7123036c954ee9a73fd","modified":1619927975328},{"_id":"themes/next/source/lib/fancybox/.git/objects/3d/521bfc64755e348870094e85323dc1b9c96a6b","hash":"e9660fc4f89ecb176b0ab6e4860579c1bfe9f9cb","modified":1619927975377},{"_id":"themes/next/source/lib/fancybox/.git/logs/refs/heads/master","hash":"6f33fd5011e6afc68d19a2544f8ae33b849f09d7","modified":1619927975411},{"_id":"themes/next/source/lib/fancybox/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1619927975407},{"_id":"themes/next/source/lib/fancybox/.git/logs/refs/remotes/origin/HEAD","hash":"6f33fd5011e6afc68d19a2544f8ae33b849f09d7","modified":1619927975407},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1619886831066},{"_id":"themes/next/_config.yml","hash":"847bc148cb0e9c69498a3ff06c03980cc25f8198","modified":1620579118706},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1619927975424},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1619927975425},{"_id":"public/tags/index.html","hash":"78bf0ed5d742207fc46cc15ddfbecb055a3d20e9","modified":1620818075078},{"_id":"public/categories/index.html","hash":"b464d7f8b4653dcef1d45d79bcaa147b789fd5c1","modified":1620818075078},{"_id":"public/20210507225731/index.html","hash":"83297220a52fec7f3c02b1ea24692e8fbf4bad35","modified":1620818075078},{"_id":"public/20210428175535/index.html","hash":"65b55f7308ee5924fecb0d314bc7492c45e960be","modified":1620818075078},{"_id":"public/20180120131523/index.html","hash":"cd138b4b4276825bd05962605c6f99c6725a9003","modified":1620818075078},{"_id":"public/20171004174926/index.html","hash":"40789ff219ac7cfd893cd20e6b69dfcdc88209d8","modified":1620818075078},{"_id":"public/20170616162458/index.html","hash":"d79887479d91e39f8871ed10b0d38687764dee8c","modified":1620818075078},{"_id":"public/20170602170253/index.html","hash":"10c48c2f848a47403c264ddc8cf2bac26ad5b807","modified":1620818075078},{"_id":"public/archives/index.html","hash":"ef15aebeefc736994f7681bd40430098220970a9","modified":1620818075078},{"_id":"public/archives/page/2/index.html","hash":"ad45058cfa0d1687f14bd63f919feb51fc883633","modified":1620818075078},{"_id":"public/archives/page/3/index.html","hash":"2bffa5b3f210a9ca713b5eb8e25f008903d99072","modified":1620818075078},{"_id":"public/archives/2017/index.html","hash":"a8b14a2b0ed9d760b0de82411dbc1c66676e2c26","modified":1620818075078},{"_id":"public/archives/2017/page/2/index.html","hash":"f04c9f54a0bbbcfc962f5f2b531df412fd005bc7","modified":1620818075078},{"_id":"public/archives/2017/10/index.html","hash":"c60faa520221772e7395b5287b3cd410f460d350","modified":1620818075078},{"_id":"public/archives/2017/06/index.html","hash":"437c918b7545a9582587ae95bf73359cd2c6fd21","modified":1620818075078},{"_id":"public/archives/2017/12/index.html","hash":"cb23b7e90fbbb8abe2eee7351c229286b77f6184","modified":1620818075078},{"_id":"public/archives/2017/11/index.html","hash":"1be7483621f4b6f78bf47f1b9931053abd0e1816","modified":1620818075078},{"_id":"public/archives/2018/index.html","hash":"953b4efdb089dc35a8e446c6667b48a37c98f81e","modified":1620818075078},{"_id":"public/archives/2018/01/index.html","hash":"d8806b004bd5da5b99d80f86ddbc02a423246e1e","modified":1620818075078},{"_id":"public/archives/2018/03/index.html","hash":"cf6fc6a0930a58d146fdfbea0c1166980ca18a76","modified":1620818075078},{"_id":"public/archives/2021/index.html","hash":"d6e01395afc98f2ed8475f504ed7d0625d95fe91","modified":1620818075078},{"_id":"public/archives/2021/04/index.html","hash":"fd6b775a93caef5978f2247ad1662abb1bbc672f","modified":1620818075078},{"_id":"public/archives/2021/05/index.html","hash":"81ca8a0b90a16c2ff2105d85b6452d9b743b899a","modified":1620818075078},{"_id":"public/categories/学习笔记/index.html","hash":"385f2ae8d12e491ed328a221e0eb031b6552e599","modified":1620818075078},{"_id":"public/categories/学习笔记/page/2/index.html","hash":"144c681c895c75a4c764014ab8b2ba8402eea839","modified":1620818075078},{"_id":"public/categories/环境搭建/index.html","hash":"37f17db18d55a9b8c0d85321230f5530fe6936ee","modified":1620818075078},{"_id":"public/categories/问题记录/index.html","hash":"abd935b4699fd3286c3ceb3a8e2dbe3dc2a9bf28","modified":1620818075078},{"_id":"public/tags/Angular/index.html","hash":"3c9c5bb4e977e8a880ff4792a568bcc24cde9738","modified":1620818075078},{"_id":"public/tags/hexo/index.html","hash":"a86fdab4d779a86aa1644dd54dfeb3dd964f53d4","modified":1620818075078},{"_id":"public/tags/Rxjs/index.html","hash":"80250579db77b28647410e5f095465eac04d6410","modified":1620818075078},{"_id":"public/tags/typeScript/index.html","hash":"ed3f1bd17d7f4e8cb7de0c7501e99ad34b25c30a","modified":1620818075078},{"_id":"public/tags/Node/index.html","hash":"275cd2707efe7bdda7cdedf23672cef565f14127","modified":1620818075078},{"_id":"public/tags/数据分析/index.html","hash":"31b4064a91b87e00c8eac6247b3982a45d8ff853","modified":1620818075078},{"_id":"public/tags/javaScript/index.html","hash":"89ffebb4326b1702f636336065cd470f54e8518a","modified":1620818075078},{"_id":"public/tags/ES6/index.html","hash":"fc01a729fa7dc9f0ab683f7b04908ef5ba991987","modified":1620818075078},{"_id":"public/tags/WeUI/index.html","hash":"930b69d148be131f8b58a949e68fdc31aa31129d","modified":1620818075078},{"_id":"public/tags/git/index.html","hash":"bd83b9c84d488c1f633e696486029bfae318516b","modified":1620818075078},{"_id":"public/tags/ES5/index.html","hash":"d5db447bc8418620679f2e8426258cb8fa0af9fc","modified":1620818075078},{"_id":"public/page/3/index.html","hash":"75d9de96966c08fa40e751eb555372ea87f3f27b","modified":1620818075078},{"_id":"public/20210508224642/index.html","hash":"3e224d2cf7d0669426bcfb951b03f6b7c75939cc","modified":1620818075078},{"_id":"public/20210504174002/index.html","hash":"36fa7bf44fa1ffb8f2d7ca42bca2ec5150b26534","modified":1620989162719},{"_id":"public/20210429171201/index.html","hash":"12d5f406047e4a7583e8e3ff4cb85595f7796772","modified":1620818075078},{"_id":"public/20180311120553/index.html","hash":"e3cf0ecbaef86cdd4bf236a8e25c7346e5ba3034","modified":1620818075078},{"_id":"public/20180110171525/index.html","hash":"44753e305ba6b63d96eb124daba96ed493993d4e","modified":1620818075078},{"_id":"public/20171226161944/index.html","hash":"83308d7e011491db548ba7f776a9f7c0fcd11002","modified":1620818075078},{"_id":"public/20171222141815/index.html","hash":"fa288e89081ca80324071773e7fbaa8f1dba8e92","modified":1620818075078},{"_id":"public/20171219171005/index.html","hash":"816c873137c9b58e85e948e8f38ba07de146d618","modified":1620818075078},{"_id":"public/20171219145009/index.html","hash":"4d2a57968f2ec2a28e8e7ed507392e1a7844b347","modified":1620818075078},{"_id":"public/20171209152137/index.html","hash":"e5a818eff124839ab67e767af1125e9563021744","modified":1620818075078},{"_id":"public/20171108094341/index.html","hash":"7a1d7793113bdd9b29ce645f97f10fb2fe82116c","modified":1620818075078},{"_id":"public/20171006155021/index.html","hash":"8d93ce05f2a22bdce60ce10cd49bc34a63d2fb87","modified":1620818075078},{"_id":"public/20171004172457/index.html","hash":"d05f0418695266ecf35f0ebeb5202567a636ea05","modified":1620818075078},{"_id":"public/20171003224603/index.html","hash":"0193d4fdaea339ef2d2b6dd8896794bec635b5fc","modified":1620818075078},{"_id":"public/20171003162654/index.html","hash":"db0ee1f72a9e9249d706382e2daaab092beee033","modified":1620818075078},{"_id":"public/20170615165315/index.html","hash":"d93f8fa88d8691625964e238b8bc7a6eff0977fb","modified":1620818075078},{"_id":"public/20170601125228/index.html","hash":"22a4b962cba67b7c8bcd3026fbab2f6394836de7","modified":1620818075078},{"_id":"public/index.html","hash":"b44183b6e28b18fe752850c6891ea4d1d07799de","modified":1620989162719},{"_id":"public/page/2/index.html","hash":"7a868231798f4ba3e7ba3f443a68c37747aafa35","modified":1620818075078},{"_id":"public/images/avatar.gif","hash":"8f4e1541c598cf69c62d3365a2b607f446b8335d","modified":1620579145219},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1620579145219},{"_id":"public/images/cc-by-nc-nd.svg","hash":"29bf23bccef6fc85ceafe721dd394bc287770495","modified":1620579145219},{"_id":"public/images/cc-by-nc-sa.svg","hash":"38478fb29a229a444b9b9e0ebf3a2fd5d943e476","modified":1620579145219},{"_id":"public/images/cc-by-nc.svg","hash":"7cf99976f1162a385c2a85eca3a43ce928d4d60e","modified":1620579145219},{"_id":"public/images/cc-by-sa.svg","hash":"c2e9d5ac5d93f63398357016df7a0ba0483aad75","modified":1620579145219},{"_id":"public/images/cc-by.svg","hash":"a003f30369698b2a2f45d8c460d2956fb6d1eb15","modified":1620579145219},{"_id":"public/images/cc-by-nd.svg","hash":"b796fa30ced3ddb228af19955fe6491b81f0ccc8","modified":1620579145219},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1620579145219},{"_id":"public/images/cc-zero.svg","hash":"bccb103bb13e990db9b0487bb72abaa3d2b09960","modified":1620579145219},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1620579145219},{"_id":"public/images/favicon-16x16.png","hash":"8f4e1541c598cf69c62d3365a2b607f446b8335d","modified":1620579145219},{"_id":"public/images/favicon-32x32.png","hash":"8f4e1541c598cf69c62d3365a2b607f446b8335d","modified":1620579145219},{"_id":"public/images/logo.svg","hash":"2cb74fd3ea2635e015eabc58a8d488aed6cf6417","modified":1620579145219},{"_id":"public/images/logo-algolia-nebula-blue-full.svg","hash":"b85e274207b1392782476a0430feac98db1e7da0","modified":1620579145219},{"_id":"public/lib/fancybox/LICENSE","hash":"8624bcdae55baeef00cd11d5dfcfa60f68710a02","modified":1620579145219},{"_id":"public/css/noscript.css","hash":"54d14cd43dc297950a4a8d39ec9644dd5fc3499f","modified":1620579145219},{"_id":"public/js/comments.js","hash":"66ae2e26ea36a41b72c638ea8b220296638ae952","modified":1620579145219},{"_id":"public/js/config.js","hash":"7dad20378e907725e18007ddbad80b3366027240","modified":1620579145219},{"_id":"public/js/utils.js","hash":"1ab751556da726960519edcca1f0030c1babe005","modified":1620579145219},{"_id":"public/js/next-boot.js","hash":"873e52a851a6ce8dc61b870fa7083da4d2304b7b","modified":1620579145219},{"_id":"public/lib/fancybox/README.html","hash":"a4aaf51e67fb87df01c2a65f9fc2882bc53a8f54","modified":1620579145219},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1620579145219},{"_id":"public/css/main.css","hash":"c9e3a1bb33b4651d8934f6d9fe25cfb31a9f9324","modified":1620579145219},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"e43435fb9eaa918f5b8e35c9e110124b8bd13751","modified":1620579145219},{"_id":"public/lib/fancybox/source/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1620579145219},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"27f034e5db8c32e268e2959b9a7c1258d36e4510","modified":1620579145219},{"_id":"source/_posts/【数据分析】第二阶段：MySQL数据分时实战（三）.md","hash":"01534245fcd490ed8236eeb8a1cb916b42de9ca1","modified":1620979049744},{"_id":"source/_imgHost/Xnip2021-05-12_18-47-58.jpg","hash":"1df024782328f4830206561392667c335b6bf0e9","modified":1620816546581},{"_id":"source/_imgHost/Xnip2021-05-12_19-12-56.jpg","hash":"6db7ff991c9b6a39b5ddab1a607396efec23b6e3","modified":1620817979572},{"_id":"public/20210511111417/index.html","hash":"8c381e63bd786ff12cf4a3b88105608d7c0d4483","modified":1620988596890},{"_id":"source/_imgHost/Xnip2021-05-12_23-06-28.jpg","hash":"a9cd6e79d38daaccadb1082f770f6091b7271d1d","modified":1620831991392},{"_id":"source/_imgHost/Xnip2021-05-12_22-43-07.jpg","hash":"e5dc6b9c85d2fe027c3e3aba2c1910696864b318","modified":1620830589788},{"_id":"source/_imgHost/Xnip2021-05-12_22-42-45.jpg","hash":"6b1d1930cf003af1a7281186b01717f46c4de5e1","modified":1620830568744},{"_id":"source/_imgHost/Xnip2021-05-12_22-52-09.jpg","hash":"26cd7e2695e2f883e15ae82dd74ea457b97ea201","modified":1620831131864},{"_id":"source/_imgHost/Xnip2021-05-12_23-02-23.jpg","hash":"fc78de648f7b7744462acc72cf12cb6d6882ace2","modified":1620831746745},{"_id":"source/_imgHost/Xnip2021-05-13_14-28-07.jpg","hash":"4bb690c6352e05b3f854a95198f6552fda5eb56b","modified":1620887290890},{"_id":"source/_imgHost/Xnip2021-05-14_15-25-13.jpg","hash":"fa35740db13781398b4dc31af36677c8076d8458","modified":1620977117941},{"_id":"source/_imgHost/Xnip2021-05-13_15-57-06.jpg","hash":"209567ad2d69b40a783074b9175bccaa5703b39a","modified":1620892630747},{"_id":"source/_imgHost/Xnip2021-05-14_15-54-59.jpg","hash":"9276ad8ee853b12c025a61c9a34240c7a6a8c5fe","modified":1620978902087}],"Category":[{"name":"学习笔记","_id":"ckohezbo40004wct44xkz40ix"},{"name":"环境搭建","_id":"ckohezboo000owct41bp9di30"},{"name":"问题记录","_id":"ckohezbou0013wct4giv6hoc2"}],"Data":[],"Page":[{"title":"tags","date":"2021-05-08T14:54:05.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2021-05-08 22:54:05\ntype: \"tags\"\n---\n","updated":"2021-05-08T14:54:49.360Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckohezbnu0000wct4fxh787ez","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2021-05-08T14:55:11.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2021-05-08 22:55:11\ntype: \"categories\"\n---\n","updated":"2021-05-08T14:55:24.354Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckohezbo20002wct46b3dbkqi","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Angular4——2.开始Angular开发","date":"2017-10-06T07:50:21.000Z","description":"Angular框架理解，Angular开发环境搭建（node,IDE,angular-cli），Angular项目结构解析","_content":"\n# Angular开发环境搭建\n\n+ 安装nodejs\n\n+ 安装IDE\n\n+ 安装Angular-cli\n\n  `npm install -g @angular/cli`\n\n  推荐使用cnpm安装，npm不稳定，node-sass包被墙极容易导致安装报错\n\n  安装cnpm：\n\n  `$ npm install -g cnpm --registry=https://registry.npm.taobao.org`\n\n+ 使用`ng -v`查看安装结果\n\n+ 使用`ng new <name>`创建项目\n\n  使用ng new初始化项目时，npm安装包也会出错，这里用`ng new <name> —skip-install`跳过自动安装，初始化完成后，再用cnpm安装:\n\n  ```\n  ng new projectname --skip-install\n  cd progjectname\n  cnpm install\n  ```\n\n**在引用安装好的依赖包时，注意cnpm安装的路径名**\n\n# Angular项目结构\n\n**命令行工具是按照一定的规则来生成这些目录和文件的，如果改变这些文件的位置或者重命名文件，有可能导致命令行工具其他的功能出错。所以，除非你明确的知道你在干什么，否则不要改这些文件**\n\n```\nProject/\n|__ e2e（端到端的测试目录，包含基本的测试装，用来做自动测试的）\n|__ src/（应用源代码目录，我们写的所有代码都应该在这里面）\n|\t|__ app/（包含应用的组件和模块，我们要写的代码绝大部分都是在这个目录下）\n|\t|\t|__ app.component.css\n|\t|\t|__ app.component.html\n|\t|\t|__ app.component.spec.ts\n|\t|\t|__ app.component.ts（组件）\n|\t|\t|__ app.module.ts（模块）\n|\t|__ assets（空的文件夹，用来存放静态资源，比如图片）\n|\t|__ environments（环境配置）\n|\t|__ favicon.ico\n|\t|__ index.html（这是整个应用的根html，应用启动第一次访问的就是这个文件，body里有一个<app-root>）\n|\t|__ main.ts（整个应用的脚本执行入口文件，angular通过这个文件启动整个项目）\n|\t|__ polyfills.ts（用来导入一些库，使angular可以运行在老版本的浏览器）\n|\t|__ style.css（放应用的全局的css样式）\n|\t|__ test.ts（用来自动化测试的文件）\n|\t|__ tsconfig.ts（typescript编译器的配置）\n|__ .editorconfig（webstorm的配置文件，与项目无关）\n|__ .gitignore（git的配置文件，与项目无关）\n|__ .angular-cli.json（angular命令行工具的配置文件，引一些第三方的包就是通过修改这个文件来实现的）\n|__ karma.conf.json（karma是单元测试执行器，这是karma的配置文件，他是用来执行自动化测试的）\n|__ package.json（标准的npm工具配置文件，该文件中列明了这个应用所使用的第三方依赖包。在创建项目的时候会有一个installing packages的提示信息，实际上在这里安装包的时候，他就是根据package.json中的内容去下载相应的第三方依赖包，下载下来以后会放到node_modules这个目录中）\n|__ protractor.conf.json（和karma.conf.json类似，也是做自动化测试的）\n|__ README.md（标准的README文件，包含Angular命令行工具生成项目的标准说明）\n|__ tsconfig.json\n|__ tslint.json（tslint的配置文件，他是用来定义TypeScript代码质量检查的规则的）\n```\n\n# Angular框架结构\n\n模型（ngModul）\n\n组件（component）\n\n服务（service）\n\n# Angular组件相关概念\n\n## 必备元素\n\n1. 组件元数据装饰器（@component()）\n\n   简称装饰器，装饰器用来告知angular框架如何处理一个typescript类。\n\n   装饰器包含多个属性，这些属性的值叫做元数据。angular会根据这些元数据的值来渲染组件 并执行组件的逻辑\n\n2. 模版（Template）\n\n   通过组件自带的模版，来定义组件的外观。\n\n   模版以html的形式存在，告诉angular如何渲染组件。\n\n   我们可以在模版中使用angular的数据绑定语法，来呈现控制器中的数据\n\n3. 控制器（Controller）\n\n   控制器就是一个普通的typescript类，他会被装饰器装饰。\n\n   控制器包含组件所有的属性和方法，绝大多数的页面逻辑都是写在控制器里的。\n\n   控制器通过数据绑定，与模版通讯。模版展现控制器里的数据，控制器处理模版上发生的事件","source":"_posts/Angular4——2.开始Angular开发.md","raw":"---\ntitle: Angular4——2.开始Angular开发\ndate: 2017-10-06 15:50:21\ntags:\n- Angular\ncategories:\n- 学习笔记\ndescription: Angular框架理解，Angular开发环境搭建（node,IDE,angular-cli），Angular项目结构解析\n---\n\n# Angular开发环境搭建\n\n+ 安装nodejs\n\n+ 安装IDE\n\n+ 安装Angular-cli\n\n  `npm install -g @angular/cli`\n\n  推荐使用cnpm安装，npm不稳定，node-sass包被墙极容易导致安装报错\n\n  安装cnpm：\n\n  `$ npm install -g cnpm --registry=https://registry.npm.taobao.org`\n\n+ 使用`ng -v`查看安装结果\n\n+ 使用`ng new <name>`创建项目\n\n  使用ng new初始化项目时，npm安装包也会出错，这里用`ng new <name> —skip-install`跳过自动安装，初始化完成后，再用cnpm安装:\n\n  ```\n  ng new projectname --skip-install\n  cd progjectname\n  cnpm install\n  ```\n\n**在引用安装好的依赖包时，注意cnpm安装的路径名**\n\n# Angular项目结构\n\n**命令行工具是按照一定的规则来生成这些目录和文件的，如果改变这些文件的位置或者重命名文件，有可能导致命令行工具其他的功能出错。所以，除非你明确的知道你在干什么，否则不要改这些文件**\n\n```\nProject/\n|__ e2e（端到端的测试目录，包含基本的测试装，用来做自动测试的）\n|__ src/（应用源代码目录，我们写的所有代码都应该在这里面）\n|\t|__ app/（包含应用的组件和模块，我们要写的代码绝大部分都是在这个目录下）\n|\t|\t|__ app.component.css\n|\t|\t|__ app.component.html\n|\t|\t|__ app.component.spec.ts\n|\t|\t|__ app.component.ts（组件）\n|\t|\t|__ app.module.ts（模块）\n|\t|__ assets（空的文件夹，用来存放静态资源，比如图片）\n|\t|__ environments（环境配置）\n|\t|__ favicon.ico\n|\t|__ index.html（这是整个应用的根html，应用启动第一次访问的就是这个文件，body里有一个<app-root>）\n|\t|__ main.ts（整个应用的脚本执行入口文件，angular通过这个文件启动整个项目）\n|\t|__ polyfills.ts（用来导入一些库，使angular可以运行在老版本的浏览器）\n|\t|__ style.css（放应用的全局的css样式）\n|\t|__ test.ts（用来自动化测试的文件）\n|\t|__ tsconfig.ts（typescript编译器的配置）\n|__ .editorconfig（webstorm的配置文件，与项目无关）\n|__ .gitignore（git的配置文件，与项目无关）\n|__ .angular-cli.json（angular命令行工具的配置文件，引一些第三方的包就是通过修改这个文件来实现的）\n|__ karma.conf.json（karma是单元测试执行器，这是karma的配置文件，他是用来执行自动化测试的）\n|__ package.json（标准的npm工具配置文件，该文件中列明了这个应用所使用的第三方依赖包。在创建项目的时候会有一个installing packages的提示信息，实际上在这里安装包的时候，他就是根据package.json中的内容去下载相应的第三方依赖包，下载下来以后会放到node_modules这个目录中）\n|__ protractor.conf.json（和karma.conf.json类似，也是做自动化测试的）\n|__ README.md（标准的README文件，包含Angular命令行工具生成项目的标准说明）\n|__ tsconfig.json\n|__ tslint.json（tslint的配置文件，他是用来定义TypeScript代码质量检查的规则的）\n```\n\n# Angular框架结构\n\n模型（ngModul）\n\n组件（component）\n\n服务（service）\n\n# Angular组件相关概念\n\n## 必备元素\n\n1. 组件元数据装饰器（@component()）\n\n   简称装饰器，装饰器用来告知angular框架如何处理一个typescript类。\n\n   装饰器包含多个属性，这些属性的值叫做元数据。angular会根据这些元数据的值来渲染组件 并执行组件的逻辑\n\n2. 模版（Template）\n\n   通过组件自带的模版，来定义组件的外观。\n\n   模版以html的形式存在，告诉angular如何渲染组件。\n\n   我们可以在模版中使用angular的数据绑定语法，来呈现控制器中的数据\n\n3. 控制器（Controller）\n\n   控制器就是一个普通的typescript类，他会被装饰器装饰。\n\n   控制器包含组件所有的属性和方法，绝大多数的页面逻辑都是写在控制器里的。\n\n   控制器通过数据绑定，与模版通讯。模版展现控制器里的数据，控制器处理模版上发生的事件","slug":"Angular4——2.开始Angular开发","published":1,"updated":"2021-05-08T15:01:21.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbnz0001wct43mj341h4","content":"<h1 id=\"Angular开发环境搭建\"><a href=\"#Angular开发环境搭建\" class=\"headerlink\" title=\"Angular开发环境搭建\"></a>Angular开发环境搭建</h1><ul>\n<li><p>安装nodejs</p>\n</li>\n<li><p>安装IDE</p>\n</li>\n<li><p>安装Angular-cli</p>\n<p><code>npm install -g @angular/cli</code></p>\n<p>推荐使用cnpm安装，npm不稳定，node-sass包被墙极容易导致安装报错</p>\n<p>安装cnpm：</p>\n<p><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>\n</li>\n<li><p>使用<code>ng -v</code>查看安装结果</p>\n</li>\n<li><p>使用<code>ng new &lt;name&gt;</code>创建项目</p>\n<p>使用ng new初始化项目时，npm安装包也会出错，这里用<code>ng new &lt;name&gt; —skip-install</code>跳过自动安装，初始化完成后，再用cnpm安装:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng new projectname --skip-install</span><br><span class=\"line\">cd progjectname</span><br><span class=\"line\">cnpm install</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>在引用安装好的依赖包时，注意cnpm安装的路径名</strong></p>\n<h1 id=\"Angular项目结构\"><a href=\"#Angular项目结构\" class=\"headerlink\" title=\"Angular项目结构\"></a>Angular项目结构</h1><p><strong>命令行工具是按照一定的规则来生成这些目录和文件的，如果改变这些文件的位置或者重命名文件，有可能导致命令行工具其他的功能出错。所以，除非你明确的知道你在干什么，否则不要改这些文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project&#x2F;</span><br><span class=\"line\">|__ e2e（端到端的测试目录，包含基本的测试装，用来做自动测试的）</span><br><span class=\"line\">|__ src&#x2F;（应用源代码目录，我们写的所有代码都应该在这里面）</span><br><span class=\"line\">|\t|__ app&#x2F;（包含应用的组件和模块，我们要写的代码绝大部分都是在这个目录下）</span><br><span class=\"line\">|\t|\t|__ app.component.css</span><br><span class=\"line\">|\t|\t|__ app.component.html</span><br><span class=\"line\">|\t|\t|__ app.component.spec.ts</span><br><span class=\"line\">|\t|\t|__ app.component.ts（组件）</span><br><span class=\"line\">|\t|\t|__ app.module.ts（模块）</span><br><span class=\"line\">|\t|__ assets（空的文件夹，用来存放静态资源，比如图片）</span><br><span class=\"line\">|\t|__ environments（环境配置）</span><br><span class=\"line\">|\t|__ favicon.ico</span><br><span class=\"line\">|\t|__ index.html（这是整个应用的根html，应用启动第一次访问的就是这个文件，body里有一个&lt;app-root&gt;）</span><br><span class=\"line\">|\t|__ main.ts（整个应用的脚本执行入口文件，angular通过这个文件启动整个项目）</span><br><span class=\"line\">|\t|__ polyfills.ts（用来导入一些库，使angular可以运行在老版本的浏览器）</span><br><span class=\"line\">|\t|__ style.css（放应用的全局的css样式）</span><br><span class=\"line\">|\t|__ test.ts（用来自动化测试的文件）</span><br><span class=\"line\">|\t|__ tsconfig.ts（typescript编译器的配置）</span><br><span class=\"line\">|__ .editorconfig（webstorm的配置文件，与项目无关）</span><br><span class=\"line\">|__ .gitignore（git的配置文件，与项目无关）</span><br><span class=\"line\">|__ .angular-cli.json（angular命令行工具的配置文件，引一些第三方的包就是通过修改这个文件来实现的）</span><br><span class=\"line\">|__ karma.conf.json（karma是单元测试执行器，这是karma的配置文件，他是用来执行自动化测试的）</span><br><span class=\"line\">|__ package.json（标准的npm工具配置文件，该文件中列明了这个应用所使用的第三方依赖包。在创建项目的时候会有一个installing packages的提示信息，实际上在这里安装包的时候，他就是根据package.json中的内容去下载相应的第三方依赖包，下载下来以后会放到node_modules这个目录中）</span><br><span class=\"line\">|__ protractor.conf.json（和karma.conf.json类似，也是做自动化测试的）</span><br><span class=\"line\">|__ README.md（标准的README文件，包含Angular命令行工具生成项目的标准说明）</span><br><span class=\"line\">|__ tsconfig.json</span><br><span class=\"line\">|__ tslint.json（tslint的配置文件，他是用来定义TypeScript代码质量检查的规则的）</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Angular框架结构\"><a href=\"#Angular框架结构\" class=\"headerlink\" title=\"Angular框架结构\"></a>Angular框架结构</h1><p>模型（ngModul）</p>\n<p>组件（component）</p>\n<p>服务（service）</p>\n<h1 id=\"Angular组件相关概念\"><a href=\"#Angular组件相关概念\" class=\"headerlink\" title=\"Angular组件相关概念\"></a>Angular组件相关概念</h1><h2 id=\"必备元素\"><a href=\"#必备元素\" class=\"headerlink\" title=\"必备元素\"></a>必备元素</h2><ol>\n<li><p>组件元数据装饰器（@component()）</p>\n<p>简称装饰器，装饰器用来告知angular框架如何处理一个typescript类。</p>\n<p>装饰器包含多个属性，这些属性的值叫做元数据。angular会根据这些元数据的值来渲染组件 并执行组件的逻辑</p>\n</li>\n<li><p>模版（Template）</p>\n<p>通过组件自带的模版，来定义组件的外观。</p>\n<p>模版以html的形式存在，告诉angular如何渲染组件。</p>\n<p>我们可以在模版中使用angular的数据绑定语法，来呈现控制器中的数据</p>\n</li>\n<li><p>控制器（Controller）</p>\n<p>控制器就是一个普通的typescript类，他会被装饰器装饰。</p>\n<p>控制器包含组件所有的属性和方法，绝大多数的页面逻辑都是写在控制器里的。</p>\n<p>控制器通过数据绑定，与模版通讯。模版展现控制器里的数据，控制器处理模版上发生的事件</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Angular开发环境搭建\"><a href=\"#Angular开发环境搭建\" class=\"headerlink\" title=\"Angular开发环境搭建\"></a>Angular开发环境搭建</h1><ul>\n<li><p>安装nodejs</p>\n</li>\n<li><p>安装IDE</p>\n</li>\n<li><p>安装Angular-cli</p>\n<p><code>npm install -g @angular/cli</code></p>\n<p>推荐使用cnpm安装，npm不稳定，node-sass包被墙极容易导致安装报错</p>\n<p>安装cnpm：</p>\n<p><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p>\n</li>\n<li><p>使用<code>ng -v</code>查看安装结果</p>\n</li>\n<li><p>使用<code>ng new &lt;name&gt;</code>创建项目</p>\n<p>使用ng new初始化项目时，npm安装包也会出错，这里用<code>ng new &lt;name&gt; —skip-install</code>跳过自动安装，初始化完成后，再用cnpm安装:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng new projectname --skip-install</span><br><span class=\"line\">cd progjectname</span><br><span class=\"line\">cnpm install</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>在引用安装好的依赖包时，注意cnpm安装的路径名</strong></p>\n<h1 id=\"Angular项目结构\"><a href=\"#Angular项目结构\" class=\"headerlink\" title=\"Angular项目结构\"></a>Angular项目结构</h1><p><strong>命令行工具是按照一定的规则来生成这些目录和文件的，如果改变这些文件的位置或者重命名文件，有可能导致命令行工具其他的功能出错。所以，除非你明确的知道你在干什么，否则不要改这些文件</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Project&#x2F;</span><br><span class=\"line\">|__ e2e（端到端的测试目录，包含基本的测试装，用来做自动测试的）</span><br><span class=\"line\">|__ src&#x2F;（应用源代码目录，我们写的所有代码都应该在这里面）</span><br><span class=\"line\">|\t|__ app&#x2F;（包含应用的组件和模块，我们要写的代码绝大部分都是在这个目录下）</span><br><span class=\"line\">|\t|\t|__ app.component.css</span><br><span class=\"line\">|\t|\t|__ app.component.html</span><br><span class=\"line\">|\t|\t|__ app.component.spec.ts</span><br><span class=\"line\">|\t|\t|__ app.component.ts（组件）</span><br><span class=\"line\">|\t|\t|__ app.module.ts（模块）</span><br><span class=\"line\">|\t|__ assets（空的文件夹，用来存放静态资源，比如图片）</span><br><span class=\"line\">|\t|__ environments（环境配置）</span><br><span class=\"line\">|\t|__ favicon.ico</span><br><span class=\"line\">|\t|__ index.html（这是整个应用的根html，应用启动第一次访问的就是这个文件，body里有一个&lt;app-root&gt;）</span><br><span class=\"line\">|\t|__ main.ts（整个应用的脚本执行入口文件，angular通过这个文件启动整个项目）</span><br><span class=\"line\">|\t|__ polyfills.ts（用来导入一些库，使angular可以运行在老版本的浏览器）</span><br><span class=\"line\">|\t|__ style.css（放应用的全局的css样式）</span><br><span class=\"line\">|\t|__ test.ts（用来自动化测试的文件）</span><br><span class=\"line\">|\t|__ tsconfig.ts（typescript编译器的配置）</span><br><span class=\"line\">|__ .editorconfig（webstorm的配置文件，与项目无关）</span><br><span class=\"line\">|__ .gitignore（git的配置文件，与项目无关）</span><br><span class=\"line\">|__ .angular-cli.json（angular命令行工具的配置文件，引一些第三方的包就是通过修改这个文件来实现的）</span><br><span class=\"line\">|__ karma.conf.json（karma是单元测试执行器，这是karma的配置文件，他是用来执行自动化测试的）</span><br><span class=\"line\">|__ package.json（标准的npm工具配置文件，该文件中列明了这个应用所使用的第三方依赖包。在创建项目的时候会有一个installing packages的提示信息，实际上在这里安装包的时候，他就是根据package.json中的内容去下载相应的第三方依赖包，下载下来以后会放到node_modules这个目录中）</span><br><span class=\"line\">|__ protractor.conf.json（和karma.conf.json类似，也是做自动化测试的）</span><br><span class=\"line\">|__ README.md（标准的README文件，包含Angular命令行工具生成项目的标准说明）</span><br><span class=\"line\">|__ tsconfig.json</span><br><span class=\"line\">|__ tslint.json（tslint的配置文件，他是用来定义TypeScript代码质量检查的规则的）</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Angular框架结构\"><a href=\"#Angular框架结构\" class=\"headerlink\" title=\"Angular框架结构\"></a>Angular框架结构</h1><p>模型（ngModul）</p>\n<p>组件（component）</p>\n<p>服务（service）</p>\n<h1 id=\"Angular组件相关概念\"><a href=\"#Angular组件相关概念\" class=\"headerlink\" title=\"Angular组件相关概念\"></a>Angular组件相关概念</h1><h2 id=\"必备元素\"><a href=\"#必备元素\" class=\"headerlink\" title=\"必备元素\"></a>必备元素</h2><ol>\n<li><p>组件元数据装饰器（@component()）</p>\n<p>简称装饰器，装饰器用来告知angular框架如何处理一个typescript类。</p>\n<p>装饰器包含多个属性，这些属性的值叫做元数据。angular会根据这些元数据的值来渲染组件 并执行组件的逻辑</p>\n</li>\n<li><p>模版（Template）</p>\n<p>通过组件自带的模版，来定义组件的外观。</p>\n<p>模版以html的形式存在，告诉angular如何渲染组件。</p>\n<p>我们可以在模版中使用angular的数据绑定语法，来呈现控制器中的数据</p>\n</li>\n<li><p>控制器（Controller）</p>\n<p>控制器就是一个普通的typescript类，他会被装饰器装饰。</p>\n<p>控制器包含组件所有的属性和方法，绝大多数的页面逻辑都是写在控制器里的。</p>\n<p>控制器通过数据绑定，与模版通讯。模版展现控制器里的数据，控制器处理模版上发生的事件</p>\n</li>\n</ol>\n"},{"title":"Angular4——3.路由导航","date":"2017-12-09T07:21:37.000Z","description":"使用Angular Router模块路由导航","_content":"\n# 基础知识\n\n硬件领域中的路由器是用来帮你找到另一台网络设备的，而Angular的**路由器**能让用户从一个[视图](https://angular.cn/guide/glossary#view)导航到另一个视图。\n\n浏览器具有我们熟悉的导航模式：\n\n- 在地址栏输入URL，浏览器就会导航到相应的页面。\n- 在页面中点击链接，浏览器就会导航到一个新页面。\n- 点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。\n\nAngular的`Router`（即“路由器”）借鉴了这个模型。它把浏览器中的URL看做一个操作指南， 据此导航到一个由客户端生成的视图，并可以把参数传给支撑视图的相应组件，帮它决定具体该展现哪些内容。 我们可以为页面中的链接绑定一个路由，这样，当用户点击链接时，就会导航到应用中相应的视图。\n\n## \\< basehref \\>元素\n\n路由器使用浏览器的[history.pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries)进行导航。我们必须往本应用的`index.html`中**添加一个\\< base href \\> 元素**，这样`pushState`才能正常工作。 当引用CSS文件、脚本和图片时，浏览器会用`<base href>`的值作为*相对*URL的前缀。\n\n```\n// index.html\n<head>\n\t// ...\n\t<base href=\"/\">\n</head>\n```\n\n## 导入路由器\n\nAngular的路由器是一个可选的服务，它用来呈现指定的URL所对应的视图。 它并不是Angular核心库的一部分，而是在它自己的`@angular/router`包中。 像其它Angular包一样，我们可以从它导入所需的一切。\n\n```\n// app.module.ts\nimport { RouterModule, Routes } from '@angular/router';\n```\n\n\n\n# 路由基础\n\n## Routes路由数组\n\ntype [Routes](https://angular.cn/api/router/Routes) = [Route](https://angular.cn/api/router/Route)[];\n\n```\ninterface Route { \n  path?: string\n  pathMatch?: string\n  matcher?: UrlMatcher\n  component?: Type<any>\n  redirectTo?: string\n  outlet?: string\n  canActivate?: any[]\n  canActivateChild?: any[]\n  canDeactivate?: any[]\n  canLoad?: any[]\n  data?: Data\n  resolve?: ResolveData\n  children?: Routes\n  loadChildren?: LoadChildren\n  runGuardsAndResolvers?: RunGuardsAndResolvers\n}\n```\n\n## RouterModule路由器模块\n\n```\nclass RouterModule {\n  constructor(guard: any, router: Router)\n  static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders\n  static forChild(routes: Routes): ModuleWithProviders\n}\n\n```\n\n## RouterOutlet 路由出口\n\n指令，用在html模版中，用来指明路由所匹配的组件应该展示在什么位置。\n\n```\n// app.component.html\n<body>\n\t<a [routerLink]=\"[{ outlets: { popup: ['compose'] } }]\">Contact</a>\n\t<router-outlet></router-outlet>\n\t<router-outlet name=\"popup\"></router-outlet>\n</body>\n```\n\n一个模版中只能有一个未命名的\\<router-outlet>，但可以有多个命名的出口。\n\n```\n// app-routing.module.ts\n{\n  path: 'compose',\n  component: ComposeMessageComponent,\n  outlet: 'popup'\n},\n```\n\n## RouterLink 路由链接\n\n指令。用在html模版中，用于导航路由。\n\n```\n<a routerLink=\"/heroes\" routerLinkActive=\"active\">Heroes</a>\n```\n\nrouterLinkActive指令，绑定css样式。\n\n## Router路由器\n\n对象，用在控制器中，用于路由导航。和routerlink功能一样，用来控制路由导航。\n\n```\n// app.module.ts\nimport {Router} from '@angular/router';\n\nexport class AppComponent{\n  constructor(private router: Router){}\n  toHeroes(){\n    this.router.navigate(['/heroes']);\n  }\n}\n```\n\nrouter.navigate方法等参数和routerLink的参数一样，也是个数组。\n\n```\nclass Router {\n  constructor(rootComponentType: Type<any>|null, urlSerializer: UrlSerializer, rootContexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Routes)\n  events: Observable<Event>\n  routerState: RouterState\n  errorHandler: ErrorHandler\n  navigated: boolean\n  urlHandlingStrategy: UrlHandlingStrategy\n  routeReuseStrategy: RouteReuseStrategy\n  config: Routes\n  initialNavigation(): void\n  setUpLocationChangeListener(): void\n  get url(): string\n  resetConfig(config: Routes): void\n  ngOnDestroy(): void\n  dispose(): void\n  createUrlTree(commands: any[], navigationExtras: NavigationExtras = {}): UrlTree\n  navigateByUrl(url: string|UrlTree, extras: NavigationExtras = {skipLocationChange: false}): Promise<boolean>\n  navigate(commands: any[], extras: NavigationExtras = {skipLocationChange: false}): Promise<boolean>\n  serializeUrl(url: UrlTree): string\n  parseUrl(url: string): UrlTree\n  isActive(url: string|UrlTree, exact: boolean): boolean\n}\n```\n\n## ActivatedRoute激活的路由\n\n对象。保存当前激活的路由信息，如路由地址，路由参数等\n\n```\ninterface ActivatedRoute { \n  snapshot: ActivatedRouteSnapshot\n  url: Observable<UrlSegment[]>\n  params: Observable<Params>\n  queryParams: Observable<Params>\n  fragment: Observable<string>\n  data: Observable<Data>\n  outlet: string\n  component: Type<any>|string|null\n  get routeConfig(): Route|null\n  get root(): ActivatedRoute\n  get parent(): ActivatedRoute|null\n  get firstChild(): ActivatedRoute|null\n  get children(): ActivatedRoute[]\n  get pathFromRoot(): ActivatedRoute[]\n  get paramMap(): Observable<ParamMap>\n  get queryParamMap(): Observable<ParamMap>\n  toString(): string\n}\n```\n\n\n\n# 配置路由\n\n## 配置在app.module.ts文件中\n\n```\n// app.module.ts\nimport {NgModule} from '@angular/core';\nimport {RouterModule, Routes} from '@angular/router';\n\nimport {AppComponent} from 'app.component';\nimport {AComponent} from 'a.component';\nimport {BComponent} from 'b.component';\n\nconst appRoutes: Routes = [\n  {path: 'aaa', component: AComponent},\n  {path: 'bbb', component: BComponent}\n]\n\n@NgModule({\n  imports:[\n    RouterModule.forRoot(appRoutes)\n  ],\n  declarations:[\n    AppComponent,\n    AComponent,\n    BComponent\n  ]\n})\nexport class AppModule{}\n```\n\n## 单独配置一个路由模块\n\n随着应用的成长，我们将需要将路由配置重构到单独的文件，并创建**路由模块** - 一种特别的、专门为特性模块的路由器服务的**服务模块**。\n\n在/app目录下创建一个app-routing.module.ts的路由配置文件。\n\n```\n// src/app/approuting.module.ts\nimport {NgModule} from '@angular/core';\nimport {RouterModule, Routes} from '@angular/router';\n\nimport {AComponent} from 'a.component';\nimport {BComponent} from 'b.component';\n\nconst appRoutes: Routes = [\n  {path: 'aaa', component: AComponent},\n  {path: 'bbb', component: BComponent}\n]\n\n@NgModule({\n  imports:[\n    RouterModule.forRoot(appRoutes)\n  ],\n  export:[\n    RouterModule\n  ]\n})\nexport class AppRoutingModule{}\n```\n\n```\n// app.module.ts\nimport {AppRoutingModule} from 'approuting.module';\n\nimport {AppComponent} from 'app.component';\nimport {AComponent} from 'a.component';\nimport {BComponent} from 'b.component';\n\n@NgModule({\n  import:[\n    AppRoutingModule\n  ],\n  delarations:[\n    AppComponent,\n    AComponent,\n    BComponent\n  ]\n})\n```\n\n在根模块中，RouterModule调用forRoot方法，在其他子模块中，RouterModule调用forChild方法。\n\n##重定向路由\n\n```\n{path: '', redirectTo: '/heroes', pathMatch: 'full'}\n```\n\npathMatch： 描述匹配策略的属性，值为两个字符串，full和prefix\n\nprefix：默认值，只要URL的开始是以path开头的，就进行重定向路由。由于' '空字符串是所有url的前缀，所以不管输入什么都会重定向。\n\nfull：输入的url必须和path完全一致，才会进行重定向。\n\n##通配符路由\n\n```\n{path: '**', component: ....}\n```\n\n可以匹配任何路由，放在路由数组的最后，优先匹配原则。通常用来导航到自定义的404页面。\n\n\n\n# 路由导航\n\n## 使用RouterLink导航\n\n```\n<a routerLink=\"/hero\"></a>\n\n{path:'hero',component:HeroComponent}\n```\n\n## 使用Router导航\n\n```\n<button (click)=\"toHero()\"></button>\n\nconstructor(private router:Router){}\ntoHero(){\n  this.router.navigate(['/hero'])\n}\n```\n\n\n\n# 路由传递数据\n\n## 在查询参数中传递数据\n\n/product?id=1&name=2   =>   ActivatedRoute.quaryParams[id]\n\n```\n<a routerLink=\"/hero\" [queryParams]=\"{id:1}\"></a>\n\nconstructor(private routeInfo: ActivatedRoute){}\nngOnInit(){\n  this.heroId = this.routeInfo.snapshot.queryParams[\"id\"];\n}\n```\n\n## 在路由路径中传递数据\n\n{path: /product/:id}  =>  /product/1  =>  ActivatedRoute.params[id]\n\n```\n{path:'hero/:id', component: HeroComponent}\n\n<a routerLink=\"['/hero',hero.id]\"></a>\n<button (click)=\"toHero()\"></button>\n\nconstructor(private routeInfo: ActivatedRoute, private router: Router){}\nngOnInit(){\n  this.heroId = this.routeInfo.snapshot.params[\"id\"];\n  //\n  this.routeInfo.params.subscribe((params:Params) => this.heroId = params[\"id\"])\n}\ntoHero(){\n  this.router.navigate(['/hero'],2)\n}\n```\n\n## 在路由配置中传递数据\n\n{path: /product, component: ProductComponent, data:[{isProd: true}]}  =>  ActivatedRoute.data\\[0][isProd]\n\n```\n{path: 'hero', component: HeroComponent, data:[{isPro:true}]}\n\nconstructor(private routeInfo: ActivatedRoute){}\nngOnInit(){\n  this.isPro = this.routeInfo.snapshot.data[0][\"isPro\"];\n}\n```\n\n\n\n# 子路由\n\n```\n{\n\tpath:'xxx',\n\tcomponent: XXXX,\n\tchildren:[\n      path: 'YYY',\n      component: YYY\n\t]\n}\n\n<a routerLink=\"./children1\"></a>\n```\n\n根路由用`/`开头\n\n子路由用`./`开头\n\n上级路由用`../`开头\n\n\n\n# 辅助路由\n\n```\n<router-outlet></router-outlet>\n<router-outlet name=\"aux\"></router-outlet>\n\n{path: 'xxxx', component:AuxComponent, outlet: 'aux'}\n\n<a [routerLink]=\"[{outlets:{aux: 'xxxx'}}]\"></a>\n<a [routerLink]=\"[{outlets:{aux: null}}]\"></a>\n```\n\n\n\n# 路由守卫\n\n## CanActivate\n\n处理导航到某路由的情况。\n\n一 写路由守卫\n\n```\n//guard.ts\nimport {CanActivate} from '@angular/router';\n\nexport class GuardName implements CanActivate{\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot){\n    return true; // 返回true，就允许进入导航，返回false就拒绝\n  }\n}\n```\n\n二 把守卫配置到路由上\n\n```\n//app.module.ts\nimport {GuardName} from 'guard';\n\n{ path: 'xxxxx', component: XXXX, canActivate: [GuardName]}\n\n@NgModule({\n  providers:[GuardName]\n})\n```\n\n## CanDeactivate\n\n处理从当前路由离开的情况。\n\n一 写路由守卫\n\n```\n//guard.ts\nimport {CanDeactivate} from '@angular/router';\nimport {XXXComponent} from 'xxx';\n\nexport class GuardName implements CanDeactivate<XXXComponent>{\t//泛型是要守卫的组件\n\t// canDeactivate方法需要把要保护的组件作为参数传进来\n  canDeactivate(component: XXXComponent, route: ActivatedRouteSnapshot, state: RouterStateSnapshot){\n      return component.isTrue; // 返回true，就允许离开导航，返回false就拒绝\n  }\n}\n```\n\n二 把守卫配置到路由上\n\n```\n//app.module.ts\nimport {GuardName} from 'guard';\n\n{ path: 'xxxxx', component: XXXX, canDeactivate: [GuardName]}\n\n@NgModule({\n  providers:[GuardName]\n})\n```\n\n## Resolve\n\n在路由之前获取路由数据。\n\n一 写路由守卫\n\n```\n// guard.ts\nimport {Resolve} from '@angular/router';\nimpot {XXX} from 'xxx';\n\nexport class GuardName implements Resolve<XXX>{\t// 泛型是要获取的数据的类型\n  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot){\n    return route.params[\"id\"];\n  }\n}\n```\n\n二 把守卫配置到路由上\n\n```\n//app.module.ts\nimport {GuardName} from 'guard';\n\n{ path: '....', component: ComponentName, resolve: {xxx: GuardName}}\n\n@NgModule({\n  providers:[GuardName]\n})\n```\n\n三 在目标组件中接收数据\n\n```\n//Component\nngOnInit(){\n  this.activatedRoute.data.subscribe((data:{stock: Stock}) => {\n    this.stock = data.stock;\n  })\n}\n```\n\n","source":"_posts/Angular4——3.路由导航.md","raw":"---\ntitle: Angular4——3.路由导航\ndate: 2017-12-09 15:21:37\ntags:\n- Angular\ncategories:\n- 学习笔记\ndescription: 使用Angular Router模块路由导航\n---\n\n# 基础知识\n\n硬件领域中的路由器是用来帮你找到另一台网络设备的，而Angular的**路由器**能让用户从一个[视图](https://angular.cn/guide/glossary#view)导航到另一个视图。\n\n浏览器具有我们熟悉的导航模式：\n\n- 在地址栏输入URL，浏览器就会导航到相应的页面。\n- 在页面中点击链接，浏览器就会导航到一个新页面。\n- 点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。\n\nAngular的`Router`（即“路由器”）借鉴了这个模型。它把浏览器中的URL看做一个操作指南， 据此导航到一个由客户端生成的视图，并可以把参数传给支撑视图的相应组件，帮它决定具体该展现哪些内容。 我们可以为页面中的链接绑定一个路由，这样，当用户点击链接时，就会导航到应用中相应的视图。\n\n## \\< basehref \\>元素\n\n路由器使用浏览器的[history.pushState](https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries)进行导航。我们必须往本应用的`index.html`中**添加一个\\< base href \\> 元素**，这样`pushState`才能正常工作。 当引用CSS文件、脚本和图片时，浏览器会用`<base href>`的值作为*相对*URL的前缀。\n\n```\n// index.html\n<head>\n\t// ...\n\t<base href=\"/\">\n</head>\n```\n\n## 导入路由器\n\nAngular的路由器是一个可选的服务，它用来呈现指定的URL所对应的视图。 它并不是Angular核心库的一部分，而是在它自己的`@angular/router`包中。 像其它Angular包一样，我们可以从它导入所需的一切。\n\n```\n// app.module.ts\nimport { RouterModule, Routes } from '@angular/router';\n```\n\n\n\n# 路由基础\n\n## Routes路由数组\n\ntype [Routes](https://angular.cn/api/router/Routes) = [Route](https://angular.cn/api/router/Route)[];\n\n```\ninterface Route { \n  path?: string\n  pathMatch?: string\n  matcher?: UrlMatcher\n  component?: Type<any>\n  redirectTo?: string\n  outlet?: string\n  canActivate?: any[]\n  canActivateChild?: any[]\n  canDeactivate?: any[]\n  canLoad?: any[]\n  data?: Data\n  resolve?: ResolveData\n  children?: Routes\n  loadChildren?: LoadChildren\n  runGuardsAndResolvers?: RunGuardsAndResolvers\n}\n```\n\n## RouterModule路由器模块\n\n```\nclass RouterModule {\n  constructor(guard: any, router: Router)\n  static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders\n  static forChild(routes: Routes): ModuleWithProviders\n}\n\n```\n\n## RouterOutlet 路由出口\n\n指令，用在html模版中，用来指明路由所匹配的组件应该展示在什么位置。\n\n```\n// app.component.html\n<body>\n\t<a [routerLink]=\"[{ outlets: { popup: ['compose'] } }]\">Contact</a>\n\t<router-outlet></router-outlet>\n\t<router-outlet name=\"popup\"></router-outlet>\n</body>\n```\n\n一个模版中只能有一个未命名的\\<router-outlet>，但可以有多个命名的出口。\n\n```\n// app-routing.module.ts\n{\n  path: 'compose',\n  component: ComposeMessageComponent,\n  outlet: 'popup'\n},\n```\n\n## RouterLink 路由链接\n\n指令。用在html模版中，用于导航路由。\n\n```\n<a routerLink=\"/heroes\" routerLinkActive=\"active\">Heroes</a>\n```\n\nrouterLinkActive指令，绑定css样式。\n\n## Router路由器\n\n对象，用在控制器中，用于路由导航。和routerlink功能一样，用来控制路由导航。\n\n```\n// app.module.ts\nimport {Router} from '@angular/router';\n\nexport class AppComponent{\n  constructor(private router: Router){}\n  toHeroes(){\n    this.router.navigate(['/heroes']);\n  }\n}\n```\n\nrouter.navigate方法等参数和routerLink的参数一样，也是个数组。\n\n```\nclass Router {\n  constructor(rootComponentType: Type<any>|null, urlSerializer: UrlSerializer, rootContexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Routes)\n  events: Observable<Event>\n  routerState: RouterState\n  errorHandler: ErrorHandler\n  navigated: boolean\n  urlHandlingStrategy: UrlHandlingStrategy\n  routeReuseStrategy: RouteReuseStrategy\n  config: Routes\n  initialNavigation(): void\n  setUpLocationChangeListener(): void\n  get url(): string\n  resetConfig(config: Routes): void\n  ngOnDestroy(): void\n  dispose(): void\n  createUrlTree(commands: any[], navigationExtras: NavigationExtras = {}): UrlTree\n  navigateByUrl(url: string|UrlTree, extras: NavigationExtras = {skipLocationChange: false}): Promise<boolean>\n  navigate(commands: any[], extras: NavigationExtras = {skipLocationChange: false}): Promise<boolean>\n  serializeUrl(url: UrlTree): string\n  parseUrl(url: string): UrlTree\n  isActive(url: string|UrlTree, exact: boolean): boolean\n}\n```\n\n## ActivatedRoute激活的路由\n\n对象。保存当前激活的路由信息，如路由地址，路由参数等\n\n```\ninterface ActivatedRoute { \n  snapshot: ActivatedRouteSnapshot\n  url: Observable<UrlSegment[]>\n  params: Observable<Params>\n  queryParams: Observable<Params>\n  fragment: Observable<string>\n  data: Observable<Data>\n  outlet: string\n  component: Type<any>|string|null\n  get routeConfig(): Route|null\n  get root(): ActivatedRoute\n  get parent(): ActivatedRoute|null\n  get firstChild(): ActivatedRoute|null\n  get children(): ActivatedRoute[]\n  get pathFromRoot(): ActivatedRoute[]\n  get paramMap(): Observable<ParamMap>\n  get queryParamMap(): Observable<ParamMap>\n  toString(): string\n}\n```\n\n\n\n# 配置路由\n\n## 配置在app.module.ts文件中\n\n```\n// app.module.ts\nimport {NgModule} from '@angular/core';\nimport {RouterModule, Routes} from '@angular/router';\n\nimport {AppComponent} from 'app.component';\nimport {AComponent} from 'a.component';\nimport {BComponent} from 'b.component';\n\nconst appRoutes: Routes = [\n  {path: 'aaa', component: AComponent},\n  {path: 'bbb', component: BComponent}\n]\n\n@NgModule({\n  imports:[\n    RouterModule.forRoot(appRoutes)\n  ],\n  declarations:[\n    AppComponent,\n    AComponent,\n    BComponent\n  ]\n})\nexport class AppModule{}\n```\n\n## 单独配置一个路由模块\n\n随着应用的成长，我们将需要将路由配置重构到单独的文件，并创建**路由模块** - 一种特别的、专门为特性模块的路由器服务的**服务模块**。\n\n在/app目录下创建一个app-routing.module.ts的路由配置文件。\n\n```\n// src/app/approuting.module.ts\nimport {NgModule} from '@angular/core';\nimport {RouterModule, Routes} from '@angular/router';\n\nimport {AComponent} from 'a.component';\nimport {BComponent} from 'b.component';\n\nconst appRoutes: Routes = [\n  {path: 'aaa', component: AComponent},\n  {path: 'bbb', component: BComponent}\n]\n\n@NgModule({\n  imports:[\n    RouterModule.forRoot(appRoutes)\n  ],\n  export:[\n    RouterModule\n  ]\n})\nexport class AppRoutingModule{}\n```\n\n```\n// app.module.ts\nimport {AppRoutingModule} from 'approuting.module';\n\nimport {AppComponent} from 'app.component';\nimport {AComponent} from 'a.component';\nimport {BComponent} from 'b.component';\n\n@NgModule({\n  import:[\n    AppRoutingModule\n  ],\n  delarations:[\n    AppComponent,\n    AComponent,\n    BComponent\n  ]\n})\n```\n\n在根模块中，RouterModule调用forRoot方法，在其他子模块中，RouterModule调用forChild方法。\n\n##重定向路由\n\n```\n{path: '', redirectTo: '/heroes', pathMatch: 'full'}\n```\n\npathMatch： 描述匹配策略的属性，值为两个字符串，full和prefix\n\nprefix：默认值，只要URL的开始是以path开头的，就进行重定向路由。由于' '空字符串是所有url的前缀，所以不管输入什么都会重定向。\n\nfull：输入的url必须和path完全一致，才会进行重定向。\n\n##通配符路由\n\n```\n{path: '**', component: ....}\n```\n\n可以匹配任何路由，放在路由数组的最后，优先匹配原则。通常用来导航到自定义的404页面。\n\n\n\n# 路由导航\n\n## 使用RouterLink导航\n\n```\n<a routerLink=\"/hero\"></a>\n\n{path:'hero',component:HeroComponent}\n```\n\n## 使用Router导航\n\n```\n<button (click)=\"toHero()\"></button>\n\nconstructor(private router:Router){}\ntoHero(){\n  this.router.navigate(['/hero'])\n}\n```\n\n\n\n# 路由传递数据\n\n## 在查询参数中传递数据\n\n/product?id=1&name=2   =>   ActivatedRoute.quaryParams[id]\n\n```\n<a routerLink=\"/hero\" [queryParams]=\"{id:1}\"></a>\n\nconstructor(private routeInfo: ActivatedRoute){}\nngOnInit(){\n  this.heroId = this.routeInfo.snapshot.queryParams[\"id\"];\n}\n```\n\n## 在路由路径中传递数据\n\n{path: /product/:id}  =>  /product/1  =>  ActivatedRoute.params[id]\n\n```\n{path:'hero/:id', component: HeroComponent}\n\n<a routerLink=\"['/hero',hero.id]\"></a>\n<button (click)=\"toHero()\"></button>\n\nconstructor(private routeInfo: ActivatedRoute, private router: Router){}\nngOnInit(){\n  this.heroId = this.routeInfo.snapshot.params[\"id\"];\n  //\n  this.routeInfo.params.subscribe((params:Params) => this.heroId = params[\"id\"])\n}\ntoHero(){\n  this.router.navigate(['/hero'],2)\n}\n```\n\n## 在路由配置中传递数据\n\n{path: /product, component: ProductComponent, data:[{isProd: true}]}  =>  ActivatedRoute.data\\[0][isProd]\n\n```\n{path: 'hero', component: HeroComponent, data:[{isPro:true}]}\n\nconstructor(private routeInfo: ActivatedRoute){}\nngOnInit(){\n  this.isPro = this.routeInfo.snapshot.data[0][\"isPro\"];\n}\n```\n\n\n\n# 子路由\n\n```\n{\n\tpath:'xxx',\n\tcomponent: XXXX,\n\tchildren:[\n      path: 'YYY',\n      component: YYY\n\t]\n}\n\n<a routerLink=\"./children1\"></a>\n```\n\n根路由用`/`开头\n\n子路由用`./`开头\n\n上级路由用`../`开头\n\n\n\n# 辅助路由\n\n```\n<router-outlet></router-outlet>\n<router-outlet name=\"aux\"></router-outlet>\n\n{path: 'xxxx', component:AuxComponent, outlet: 'aux'}\n\n<a [routerLink]=\"[{outlets:{aux: 'xxxx'}}]\"></a>\n<a [routerLink]=\"[{outlets:{aux: null}}]\"></a>\n```\n\n\n\n# 路由守卫\n\n## CanActivate\n\n处理导航到某路由的情况。\n\n一 写路由守卫\n\n```\n//guard.ts\nimport {CanActivate} from '@angular/router';\n\nexport class GuardName implements CanActivate{\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot){\n    return true; // 返回true，就允许进入导航，返回false就拒绝\n  }\n}\n```\n\n二 把守卫配置到路由上\n\n```\n//app.module.ts\nimport {GuardName} from 'guard';\n\n{ path: 'xxxxx', component: XXXX, canActivate: [GuardName]}\n\n@NgModule({\n  providers:[GuardName]\n})\n```\n\n## CanDeactivate\n\n处理从当前路由离开的情况。\n\n一 写路由守卫\n\n```\n//guard.ts\nimport {CanDeactivate} from '@angular/router';\nimport {XXXComponent} from 'xxx';\n\nexport class GuardName implements CanDeactivate<XXXComponent>{\t//泛型是要守卫的组件\n\t// canDeactivate方法需要把要保护的组件作为参数传进来\n  canDeactivate(component: XXXComponent, route: ActivatedRouteSnapshot, state: RouterStateSnapshot){\n      return component.isTrue; // 返回true，就允许离开导航，返回false就拒绝\n  }\n}\n```\n\n二 把守卫配置到路由上\n\n```\n//app.module.ts\nimport {GuardName} from 'guard';\n\n{ path: 'xxxxx', component: XXXX, canDeactivate: [GuardName]}\n\n@NgModule({\n  providers:[GuardName]\n})\n```\n\n## Resolve\n\n在路由之前获取路由数据。\n\n一 写路由守卫\n\n```\n// guard.ts\nimport {Resolve} from '@angular/router';\nimpot {XXX} from 'xxx';\n\nexport class GuardName implements Resolve<XXX>{\t// 泛型是要获取的数据的类型\n  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot){\n    return route.params[\"id\"];\n  }\n}\n```\n\n二 把守卫配置到路由上\n\n```\n//app.module.ts\nimport {GuardName} from 'guard';\n\n{ path: '....', component: ComponentName, resolve: {xxx: GuardName}}\n\n@NgModule({\n  providers:[GuardName]\n})\n```\n\n三 在目标组件中接收数据\n\n```\n//Component\nngOnInit(){\n  this.activatedRoute.data.subscribe((data:{stock: Stock}) => {\n    this.stock = data.stock;\n  })\n}\n```\n\n","slug":"Angular4——3.路由导航","published":1,"updated":"2021-05-08T15:01:10.401Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbo30003wct4hkpq7nd0","content":"<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><p>硬件领域中的路由器是用来帮你找到另一台网络设备的，而Angular的<strong>路由器</strong>能让用户从一个<a href=\"https://angular.cn/guide/glossary#view\">视图</a>导航到另一个视图。</p>\n<p>浏览器具有我们熟悉的导航模式：</p>\n<ul>\n<li>在地址栏输入URL，浏览器就会导航到相应的页面。</li>\n<li>在页面中点击链接，浏览器就会导航到一个新页面。</li>\n<li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li>\n</ul>\n<p>Angular的<code>Router</code>（即“路由器”）借鉴了这个模型。它把浏览器中的URL看做一个操作指南， 据此导航到一个由客户端生成的视图，并可以把参数传给支撑视图的相应组件，帮它决定具体该展现哪些内容。 我们可以为页面中的链接绑定一个路由，这样，当用户点击链接时，就会导航到应用中相应的视图。</p>\n<h2 id=\"lt-basehref-gt-元素\"><a href=\"#lt-basehref-gt-元素\" class=\"headerlink\" title=\"&lt; basehref &gt;元素\"></a>&lt; basehref &gt;元素</h2><p>路由器使用浏览器的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\">history.pushState</a>进行导航。我们必须往本应用的<code>index.html</code>中<strong>添加一个&lt; base href &gt; 元素</strong>，这样<code>pushState</code>才能正常工作。 当引用CSS文件、脚本和图片时，浏览器会用<code>&lt;base href&gt;</code>的值作为<em>相对</em>URL的前缀。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; index.html</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&#x2F;&#x2F; ...</span><br><span class=\"line\">\t&lt;base href&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"导入路由器\"><a href=\"#导入路由器\" class=\"headerlink\" title=\"导入路由器\"></a>导入路由器</h2><p>Angular的路由器是一个可选的服务，它用来呈现指定的URL所对应的视图。 它并不是Angular核心库的一部分，而是在它自己的<code>@angular/router</code>包中。 像其它Angular包一样，我们可以从它导入所需的一切。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123; RouterModule, Routes &#125; from &#39;@angular&#x2F;router&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"路由基础\"><a href=\"#路由基础\" class=\"headerlink\" title=\"路由基础\"></a>路由基础</h1><h2 id=\"Routes路由数组\"><a href=\"#Routes路由数组\" class=\"headerlink\" title=\"Routes路由数组\"></a>Routes路由数组</h2><p>type <a href=\"https://angular.cn/api/router/Routes\">Routes</a> = <a href=\"https://angular.cn/api/router/Route\">Route</a>[];</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Route &#123; </span><br><span class=\"line\">  path?: string</span><br><span class=\"line\">  pathMatch?: string</span><br><span class=\"line\">  matcher?: UrlMatcher</span><br><span class=\"line\">  component?: Type&lt;any&gt;</span><br><span class=\"line\">  redirectTo?: string</span><br><span class=\"line\">  outlet?: string</span><br><span class=\"line\">  canActivate?: any[]</span><br><span class=\"line\">  canActivateChild?: any[]</span><br><span class=\"line\">  canDeactivate?: any[]</span><br><span class=\"line\">  canLoad?: any[]</span><br><span class=\"line\">  data?: Data</span><br><span class=\"line\">  resolve?: ResolveData</span><br><span class=\"line\">  children?: Routes</span><br><span class=\"line\">  loadChildren?: LoadChildren</span><br><span class=\"line\">  runGuardsAndResolvers?: RunGuardsAndResolvers</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RouterModule路由器模块\"><a href=\"#RouterModule路由器模块\" class=\"headerlink\" title=\"RouterModule路由器模块\"></a>RouterModule路由器模块</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class RouterModule &#123;</span><br><span class=\"line\">  constructor(guard: any, router: Router)</span><br><span class=\"line\">  static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders</span><br><span class=\"line\">  static forChild(routes: Routes): ModuleWithProviders</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RouterOutlet-路由出口\"><a href=\"#RouterOutlet-路由出口\" class=\"headerlink\" title=\"RouterOutlet 路由出口\"></a>RouterOutlet 路由出口</h2><p>指令，用在html模版中，用来指明路由所匹配的组件应该展示在什么位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.component.html</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;a [routerLink]&#x3D;&quot;[&#123; outlets: &#123; popup: [&#39;compose&#39;] &#125; &#125;]&quot;&gt;Contact&lt;&#x2F;a&gt;</span><br><span class=\"line\">\t&lt;router-outlet&gt;&lt;&#x2F;router-outlet&gt;</span><br><span class=\"line\">\t&lt;router-outlet name&#x3D;&quot;popup&quot;&gt;&lt;&#x2F;router-outlet&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一个模版中只能有一个未命名的&lt;router-outlet&gt;，但可以有多个命名的出口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app-routing.module.ts</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  path: &#39;compose&#39;,</span><br><span class=\"line\">  component: ComposeMessageComponent,</span><br><span class=\"line\">  outlet: &#39;popup&#39;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RouterLink-路由链接\"><a href=\"#RouterLink-路由链接\" class=\"headerlink\" title=\"RouterLink 路由链接\"></a>RouterLink 路由链接</h2><p>指令。用在html模版中，用于导航路由。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a routerLink&#x3D;&quot;&#x2F;heroes&quot; routerLinkActive&#x3D;&quot;active&quot;&gt;Heroes&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>routerLinkActive指令，绑定css样式。</p>\n<h2 id=\"Router路由器\"><a href=\"#Router路由器\" class=\"headerlink\" title=\"Router路由器\"></a>Router路由器</h2><p>对象，用在控制器中，用于路由导航。和routerlink功能一样，用来控制路由导航。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123;Router&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export class AppComponent&#123;</span><br><span class=\"line\">  constructor(private router: Router)&#123;&#125;</span><br><span class=\"line\">  toHeroes()&#123;</span><br><span class=\"line\">    this.router.navigate([&#39;&#x2F;heroes&#39;]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>router.navigate方法等参数和routerLink的参数一样，也是个数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Router &#123;</span><br><span class=\"line\">  constructor(rootComponentType: Type&lt;any&gt;|null, urlSerializer: UrlSerializer, rootContexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Routes)</span><br><span class=\"line\">  events: Observable&lt;Event&gt;</span><br><span class=\"line\">  routerState: RouterState</span><br><span class=\"line\">  errorHandler: ErrorHandler</span><br><span class=\"line\">  navigated: boolean</span><br><span class=\"line\">  urlHandlingStrategy: UrlHandlingStrategy</span><br><span class=\"line\">  routeReuseStrategy: RouteReuseStrategy</span><br><span class=\"line\">  config: Routes</span><br><span class=\"line\">  initialNavigation(): void</span><br><span class=\"line\">  setUpLocationChangeListener(): void</span><br><span class=\"line\">  get url(): string</span><br><span class=\"line\">  resetConfig(config: Routes): void</span><br><span class=\"line\">  ngOnDestroy(): void</span><br><span class=\"line\">  dispose(): void</span><br><span class=\"line\">  createUrlTree(commands: any[], navigationExtras: NavigationExtras &#x3D; &#123;&#125;): UrlTree</span><br><span class=\"line\">  navigateByUrl(url: string|UrlTree, extras: NavigationExtras &#x3D; &#123;skipLocationChange: false&#125;): Promise&lt;boolean&gt;</span><br><span class=\"line\">  navigate(commands: any[], extras: NavigationExtras &#x3D; &#123;skipLocationChange: false&#125;): Promise&lt;boolean&gt;</span><br><span class=\"line\">  serializeUrl(url: UrlTree): string</span><br><span class=\"line\">  parseUrl(url: string): UrlTree</span><br><span class=\"line\">  isActive(url: string|UrlTree, exact: boolean): boolean</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ActivatedRoute激活的路由\"><a href=\"#ActivatedRoute激活的路由\" class=\"headerlink\" title=\"ActivatedRoute激活的路由\"></a>ActivatedRoute激活的路由</h2><p>对象。保存当前激活的路由信息，如路由地址，路由参数等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface ActivatedRoute &#123; </span><br><span class=\"line\">  snapshot: ActivatedRouteSnapshot</span><br><span class=\"line\">  url: Observable&lt;UrlSegment[]&gt;</span><br><span class=\"line\">  params: Observable&lt;Params&gt;</span><br><span class=\"line\">  queryParams: Observable&lt;Params&gt;</span><br><span class=\"line\">  fragment: Observable&lt;string&gt;</span><br><span class=\"line\">  data: Observable&lt;Data&gt;</span><br><span class=\"line\">  outlet: string</span><br><span class=\"line\">  component: Type&lt;any&gt;|string|null</span><br><span class=\"line\">  get routeConfig(): Route|null</span><br><span class=\"line\">  get root(): ActivatedRoute</span><br><span class=\"line\">  get parent(): ActivatedRoute|null</span><br><span class=\"line\">  get firstChild(): ActivatedRoute|null</span><br><span class=\"line\">  get children(): ActivatedRoute[]</span><br><span class=\"line\">  get pathFromRoot(): ActivatedRoute[]</span><br><span class=\"line\">  get paramMap(): Observable&lt;ParamMap&gt;</span><br><span class=\"line\">  get queryParamMap(): Observable&lt;ParamMap&gt;</span><br><span class=\"line\">  toString(): string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h1><h2 id=\"配置在app-module-ts文件中\"><a href=\"#配置在app-module-ts文件中\" class=\"headerlink\" title=\"配置在app.module.ts文件中\"></a>配置在app.module.ts文件中</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123;NgModule&#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class=\"line\">import &#123;RouterModule, Routes&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;AppComponent&#125; from &#39;app.component&#39;;</span><br><span class=\"line\">import &#123;AComponent&#125; from &#39;a.component&#39;;</span><br><span class=\"line\">import &#123;BComponent&#125; from &#39;b.component&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const appRoutes: Routes &#x3D; [</span><br><span class=\"line\">  &#123;path: &#39;aaa&#39;, component: AComponent&#125;,</span><br><span class=\"line\">  &#123;path: &#39;bbb&#39;, component: BComponent&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    RouterModule.forRoot(appRoutes)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  declarations:[</span><br><span class=\"line\">    AppComponent,</span><br><span class=\"line\">    AComponent,</span><br><span class=\"line\">    BComponent</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppModule&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单独配置一个路由模块\"><a href=\"#单独配置一个路由模块\" class=\"headerlink\" title=\"单独配置一个路由模块\"></a>单独配置一个路由模块</h2><p>随着应用的成长，我们将需要将路由配置重构到单独的文件，并创建<strong>路由模块</strong> - 一种特别的、专门为特性模块的路由器服务的<strong>服务模块</strong>。</p>\n<p>在/app目录下创建一个app-routing.module.ts的路由配置文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; src&#x2F;app&#x2F;approuting.module.ts</span><br><span class=\"line\">import &#123;NgModule&#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class=\"line\">import &#123;RouterModule, Routes&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;AComponent&#125; from &#39;a.component&#39;;</span><br><span class=\"line\">import &#123;BComponent&#125; from &#39;b.component&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const appRoutes: Routes &#x3D; [</span><br><span class=\"line\">  &#123;path: &#39;aaa&#39;, component: AComponent&#125;,</span><br><span class=\"line\">  &#123;path: &#39;bbb&#39;, component: BComponent&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    RouterModule.forRoot(appRoutes)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  export:[</span><br><span class=\"line\">    RouterModule</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppRoutingModule&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123;AppRoutingModule&#125; from &#39;approuting.module&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;AppComponent&#125; from &#39;app.component&#39;;</span><br><span class=\"line\">import &#123;AComponent&#125; from &#39;a.component&#39;;</span><br><span class=\"line\">import &#123;BComponent&#125; from &#39;b.component&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  import:[</span><br><span class=\"line\">    AppRoutingModule</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  delarations:[</span><br><span class=\"line\">    AppComponent,</span><br><span class=\"line\">    AComponent,</span><br><span class=\"line\">    BComponent</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在根模块中，RouterModule调用forRoot方法，在其他子模块中，RouterModule调用forChild方法。</p>\n<p>##重定向路由</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path: &#39;&#39;, redirectTo: &#39;&#x2F;heroes&#39;, pathMatch: &#39;full&#39;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>pathMatch： 描述匹配策略的属性，值为两个字符串，full和prefix</p>\n<p>prefix：默认值，只要URL的开始是以path开头的，就进行重定向路由。由于’ ‘空字符串是所有url的前缀，所以不管输入什么都会重定向。</p>\n<p>full：输入的url必须和path完全一致，才会进行重定向。</p>\n<p>##通配符路由</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path: &#39;**&#39;, component: ....&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以匹配任何路由，放在路由数组的最后，优先匹配原则。通常用来导航到自定义的404页面。</p>\n<h1 id=\"路由导航\"><a href=\"#路由导航\" class=\"headerlink\" title=\"路由导航\"></a>路由导航</h1><h2 id=\"使用RouterLink导航\"><a href=\"#使用RouterLink导航\" class=\"headerlink\" title=\"使用RouterLink导航\"></a>使用RouterLink导航</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a routerLink&#x3D;&quot;&#x2F;hero&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;path:&#39;hero&#39;,component:HeroComponent&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用Router导航\"><a href=\"#使用Router导航\" class=\"headerlink\" title=\"使用Router导航\"></a>使用Router导航</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button (click)&#x3D;&quot;toHero()&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(private router:Router)&#123;&#125;</span><br><span class=\"line\">toHero()&#123;</span><br><span class=\"line\">  this.router.navigate([&#39;&#x2F;hero&#39;])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"路由传递数据\"><a href=\"#路由传递数据\" class=\"headerlink\" title=\"路由传递数据\"></a>路由传递数据</h1><h2 id=\"在查询参数中传递数据\"><a href=\"#在查询参数中传递数据\" class=\"headerlink\" title=\"在查询参数中传递数据\"></a>在查询参数中传递数据</h2><p>/product?id=1&amp;name=2   =&gt;   ActivatedRoute.quaryParams[id]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a routerLink&#x3D;&quot;&#x2F;hero&quot; [queryParams]&#x3D;&quot;&#123;id:1&#125;&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(private routeInfo: ActivatedRoute)&#123;&#125;</span><br><span class=\"line\">ngOnInit()&#123;</span><br><span class=\"line\">  this.heroId &#x3D; this.routeInfo.snapshot.queryParams[&quot;id&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在路由路径中传递数据\"><a href=\"#在路由路径中传递数据\" class=\"headerlink\" title=\"在路由路径中传递数据\"></a>在路由路径中传递数据</h2><p>{path: /product/:id}  =&gt;  /product/1  =&gt;  ActivatedRoute.params[id]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path:&#39;hero&#x2F;:id&#39;, component: HeroComponent&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;a routerLink&#x3D;&quot;[&#39;&#x2F;hero&#39;,hero.id]&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">&lt;button (click)&#x3D;&quot;toHero()&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(private routeInfo: ActivatedRoute, private router: Router)&#123;&#125;</span><br><span class=\"line\">ngOnInit()&#123;</span><br><span class=\"line\">  this.heroId &#x3D; this.routeInfo.snapshot.params[&quot;id&quot;];</span><br><span class=\"line\">  &#x2F;&#x2F;</span><br><span class=\"line\">  this.routeInfo.params.subscribe((params:Params) &#x3D;&gt; this.heroId &#x3D; params[&quot;id&quot;])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">toHero()&#123;</span><br><span class=\"line\">  this.router.navigate([&#39;&#x2F;hero&#39;],2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在路由配置中传递数据\"><a href=\"#在路由配置中传递数据\" class=\"headerlink\" title=\"在路由配置中传递数据\"></a>在路由配置中传递数据</h2><p>{path: /product, component: ProductComponent, data:[{isProd: true}]}  =&gt;  ActivatedRoute.data[0][isProd]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path: &#39;hero&#39;, component: HeroComponent, data:[&#123;isPro:true&#125;]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(private routeInfo: ActivatedRoute)&#123;&#125;</span><br><span class=\"line\">ngOnInit()&#123;</span><br><span class=\"line\">  this.isPro &#x3D; this.routeInfo.snapshot.data[0][&quot;isPro&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"子路由\"><a href=\"#子路由\" class=\"headerlink\" title=\"子路由\"></a>子路由</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tpath:&#39;xxx&#39;,</span><br><span class=\"line\">\tcomponent: XXXX,</span><br><span class=\"line\">\tchildren:[</span><br><span class=\"line\">      path: &#39;YYY&#39;,</span><br><span class=\"line\">      component: YYY</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;a routerLink&#x3D;&quot;.&#x2F;children1&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>根路由用<code>/</code>开头</p>\n<p>子路由用<code>./</code>开头</p>\n<p>上级路由用<code>../</code>开头</p>\n<h1 id=\"辅助路由\"><a href=\"#辅助路由\" class=\"headerlink\" title=\"辅助路由\"></a>辅助路由</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-outlet&gt;&lt;&#x2F;router-outlet&gt;</span><br><span class=\"line\">&lt;router-outlet name&#x3D;&quot;aux&quot;&gt;&lt;&#x2F;router-outlet&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;path: &#39;xxxx&#39;, component:AuxComponent, outlet: &#39;aux&#39;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;a [routerLink]&#x3D;&quot;[&#123;outlets:&#123;aux: &#39;xxxx&#39;&#125;&#125;]&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">&lt;a [routerLink]&#x3D;&quot;[&#123;outlets:&#123;aux: null&#125;&#125;]&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h1><h2 id=\"CanActivate\"><a href=\"#CanActivate\" class=\"headerlink\" title=\"CanActivate\"></a>CanActivate</h2><p>处理导航到某路由的情况。</p>\n<p>一 写路由守卫</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;guard.ts</span><br><span class=\"line\">import &#123;CanActivate&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export class GuardName implements CanActivate&#123;</span><br><span class=\"line\">  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot)&#123;</span><br><span class=\"line\">    return true; &#x2F;&#x2F; 返回true，就允许进入导航，返回false就拒绝</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二 把守卫配置到路由上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;app.module.ts</span><br><span class=\"line\">import &#123;GuardName&#125; from &#39;guard&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; path: &#39;xxxxx&#39;, component: XXXX, canActivate: [GuardName]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  providers:[GuardName]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CanDeactivate\"><a href=\"#CanDeactivate\" class=\"headerlink\" title=\"CanDeactivate\"></a>CanDeactivate</h2><p>处理从当前路由离开的情况。</p>\n<p>一 写路由守卫</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;guard.ts</span><br><span class=\"line\">import &#123;CanDeactivate&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\">import &#123;XXXComponent&#125; from &#39;xxx&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export class GuardName implements CanDeactivate&lt;XXXComponent&gt;&#123;\t&#x2F;&#x2F;泛型是要守卫的组件</span><br><span class=\"line\">\t&#x2F;&#x2F; canDeactivate方法需要把要保护的组件作为参数传进来</span><br><span class=\"line\">  canDeactivate(component: XXXComponent, route: ActivatedRouteSnapshot, state: RouterStateSnapshot)&#123;</span><br><span class=\"line\">      return component.isTrue; &#x2F;&#x2F; 返回true，就允许离开导航，返回false就拒绝</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二 把守卫配置到路由上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;app.module.ts</span><br><span class=\"line\">import &#123;GuardName&#125; from &#39;guard&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; path: &#39;xxxxx&#39;, component: XXXX, canDeactivate: [GuardName]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  providers:[GuardName]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Resolve\"><a href=\"#Resolve\" class=\"headerlink\" title=\"Resolve\"></a>Resolve</h2><p>在路由之前获取路由数据。</p>\n<p>一 写路由守卫</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; guard.ts</span><br><span class=\"line\">import &#123;Resolve&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\">impot &#123;XXX&#125; from &#39;xxx&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export class GuardName implements Resolve&lt;XXX&gt;&#123;\t&#x2F;&#x2F; 泛型是要获取的数据的类型</span><br><span class=\"line\">  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot)&#123;</span><br><span class=\"line\">    return route.params[&quot;id&quot;];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二 把守卫配置到路由上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;app.module.ts</span><br><span class=\"line\">import &#123;GuardName&#125; from &#39;guard&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; path: &#39;....&#39;, component: ComponentName, resolve: &#123;xxx: GuardName&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  providers:[GuardName]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>三 在目标组件中接收数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Component</span><br><span class=\"line\">ngOnInit()&#123;</span><br><span class=\"line\">  this.activatedRoute.data.subscribe((data:&#123;stock: Stock&#125;) &#x3D;&gt; &#123;</span><br><span class=\"line\">    this.stock &#x3D; data.stock;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h1><p>硬件领域中的路由器是用来帮你找到另一台网络设备的，而Angular的<strong>路由器</strong>能让用户从一个<a href=\"https://angular.cn/guide/glossary#view\">视图</a>导航到另一个视图。</p>\n<p>浏览器具有我们熟悉的导航模式：</p>\n<ul>\n<li>在地址栏输入URL，浏览器就会导航到相应的页面。</li>\n<li>在页面中点击链接，浏览器就会导航到一个新页面。</li>\n<li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li>\n</ul>\n<p>Angular的<code>Router</code>（即“路由器”）借鉴了这个模型。它把浏览器中的URL看做一个操作指南， 据此导航到一个由客户端生成的视图，并可以把参数传给支撑视图的相应组件，帮它决定具体该展现哪些内容。 我们可以为页面中的链接绑定一个路由，这样，当用户点击链接时，就会导航到应用中相应的视图。</p>\n<h2 id=\"lt-basehref-gt-元素\"><a href=\"#lt-basehref-gt-元素\" class=\"headerlink\" title=\"&lt; basehref &gt;元素\"></a>&lt; basehref &gt;元素</h2><p>路由器使用浏览器的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries\">history.pushState</a>进行导航。我们必须往本应用的<code>index.html</code>中<strong>添加一个&lt; base href &gt; 元素</strong>，这样<code>pushState</code>才能正常工作。 当引用CSS文件、脚本和图片时，浏览器会用<code>&lt;base href&gt;</code>的值作为<em>相对</em>URL的前缀。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; index.html</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&#x2F;&#x2F; ...</span><br><span class=\"line\">\t&lt;base href&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class=\"line\">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"导入路由器\"><a href=\"#导入路由器\" class=\"headerlink\" title=\"导入路由器\"></a>导入路由器</h2><p>Angular的路由器是一个可选的服务，它用来呈现指定的URL所对应的视图。 它并不是Angular核心库的一部分，而是在它自己的<code>@angular/router</code>包中。 像其它Angular包一样，我们可以从它导入所需的一切。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123; RouterModule, Routes &#125; from &#39;@angular&#x2F;router&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"路由基础\"><a href=\"#路由基础\" class=\"headerlink\" title=\"路由基础\"></a>路由基础</h1><h2 id=\"Routes路由数组\"><a href=\"#Routes路由数组\" class=\"headerlink\" title=\"Routes路由数组\"></a>Routes路由数组</h2><p>type <a href=\"https://angular.cn/api/router/Routes\">Routes</a> = <a href=\"https://angular.cn/api/router/Route\">Route</a>[];</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Route &#123; </span><br><span class=\"line\">  path?: string</span><br><span class=\"line\">  pathMatch?: string</span><br><span class=\"line\">  matcher?: UrlMatcher</span><br><span class=\"line\">  component?: Type&lt;any&gt;</span><br><span class=\"line\">  redirectTo?: string</span><br><span class=\"line\">  outlet?: string</span><br><span class=\"line\">  canActivate?: any[]</span><br><span class=\"line\">  canActivateChild?: any[]</span><br><span class=\"line\">  canDeactivate?: any[]</span><br><span class=\"line\">  canLoad?: any[]</span><br><span class=\"line\">  data?: Data</span><br><span class=\"line\">  resolve?: ResolveData</span><br><span class=\"line\">  children?: Routes</span><br><span class=\"line\">  loadChildren?: LoadChildren</span><br><span class=\"line\">  runGuardsAndResolvers?: RunGuardsAndResolvers</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RouterModule路由器模块\"><a href=\"#RouterModule路由器模块\" class=\"headerlink\" title=\"RouterModule路由器模块\"></a>RouterModule路由器模块</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class RouterModule &#123;</span><br><span class=\"line\">  constructor(guard: any, router: Router)</span><br><span class=\"line\">  static forRoot(routes: Routes, config?: ExtraOptions): ModuleWithProviders</span><br><span class=\"line\">  static forChild(routes: Routes): ModuleWithProviders</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RouterOutlet-路由出口\"><a href=\"#RouterOutlet-路由出口\" class=\"headerlink\" title=\"RouterOutlet 路由出口\"></a>RouterOutlet 路由出口</h2><p>指令，用在html模版中，用来指明路由所匹配的组件应该展示在什么位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.component.html</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">\t&lt;a [routerLink]&#x3D;&quot;[&#123; outlets: &#123; popup: [&#39;compose&#39;] &#125; &#125;]&quot;&gt;Contact&lt;&#x2F;a&gt;</span><br><span class=\"line\">\t&lt;router-outlet&gt;&lt;&#x2F;router-outlet&gt;</span><br><span class=\"line\">\t&lt;router-outlet name&#x3D;&quot;popup&quot;&gt;&lt;&#x2F;router-outlet&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n\n<p>一个模版中只能有一个未命名的&lt;router-outlet&gt;，但可以有多个命名的出口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app-routing.module.ts</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  path: &#39;compose&#39;,</span><br><span class=\"line\">  component: ComposeMessageComponent,</span><br><span class=\"line\">  outlet: &#39;popup&#39;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"RouterLink-路由链接\"><a href=\"#RouterLink-路由链接\" class=\"headerlink\" title=\"RouterLink 路由链接\"></a>RouterLink 路由链接</h2><p>指令。用在html模版中，用于导航路由。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a routerLink&#x3D;&quot;&#x2F;heroes&quot; routerLinkActive&#x3D;&quot;active&quot;&gt;Heroes&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>routerLinkActive指令，绑定css样式。</p>\n<h2 id=\"Router路由器\"><a href=\"#Router路由器\" class=\"headerlink\" title=\"Router路由器\"></a>Router路由器</h2><p>对象，用在控制器中，用于路由导航。和routerlink功能一样，用来控制路由导航。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123;Router&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export class AppComponent&#123;</span><br><span class=\"line\">  constructor(private router: Router)&#123;&#125;</span><br><span class=\"line\">  toHeroes()&#123;</span><br><span class=\"line\">    this.router.navigate([&#39;&#x2F;heroes&#39;]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>router.navigate方法等参数和routerLink的参数一样，也是个数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Router &#123;</span><br><span class=\"line\">  constructor(rootComponentType: Type&lt;any&gt;|null, urlSerializer: UrlSerializer, rootContexts: ChildrenOutletContexts, location: Location, injector: Injector, loader: NgModuleFactoryLoader, compiler: Compiler, config: Routes)</span><br><span class=\"line\">  events: Observable&lt;Event&gt;</span><br><span class=\"line\">  routerState: RouterState</span><br><span class=\"line\">  errorHandler: ErrorHandler</span><br><span class=\"line\">  navigated: boolean</span><br><span class=\"line\">  urlHandlingStrategy: UrlHandlingStrategy</span><br><span class=\"line\">  routeReuseStrategy: RouteReuseStrategy</span><br><span class=\"line\">  config: Routes</span><br><span class=\"line\">  initialNavigation(): void</span><br><span class=\"line\">  setUpLocationChangeListener(): void</span><br><span class=\"line\">  get url(): string</span><br><span class=\"line\">  resetConfig(config: Routes): void</span><br><span class=\"line\">  ngOnDestroy(): void</span><br><span class=\"line\">  dispose(): void</span><br><span class=\"line\">  createUrlTree(commands: any[], navigationExtras: NavigationExtras &#x3D; &#123;&#125;): UrlTree</span><br><span class=\"line\">  navigateByUrl(url: string|UrlTree, extras: NavigationExtras &#x3D; &#123;skipLocationChange: false&#125;): Promise&lt;boolean&gt;</span><br><span class=\"line\">  navigate(commands: any[], extras: NavigationExtras &#x3D; &#123;skipLocationChange: false&#125;): Promise&lt;boolean&gt;</span><br><span class=\"line\">  serializeUrl(url: UrlTree): string</span><br><span class=\"line\">  parseUrl(url: string): UrlTree</span><br><span class=\"line\">  isActive(url: string|UrlTree, exact: boolean): boolean</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ActivatedRoute激活的路由\"><a href=\"#ActivatedRoute激活的路由\" class=\"headerlink\" title=\"ActivatedRoute激活的路由\"></a>ActivatedRoute激活的路由</h2><p>对象。保存当前激活的路由信息，如路由地址，路由参数等</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface ActivatedRoute &#123; </span><br><span class=\"line\">  snapshot: ActivatedRouteSnapshot</span><br><span class=\"line\">  url: Observable&lt;UrlSegment[]&gt;</span><br><span class=\"line\">  params: Observable&lt;Params&gt;</span><br><span class=\"line\">  queryParams: Observable&lt;Params&gt;</span><br><span class=\"line\">  fragment: Observable&lt;string&gt;</span><br><span class=\"line\">  data: Observable&lt;Data&gt;</span><br><span class=\"line\">  outlet: string</span><br><span class=\"line\">  component: Type&lt;any&gt;|string|null</span><br><span class=\"line\">  get routeConfig(): Route|null</span><br><span class=\"line\">  get root(): ActivatedRoute</span><br><span class=\"line\">  get parent(): ActivatedRoute|null</span><br><span class=\"line\">  get firstChild(): ActivatedRoute|null</span><br><span class=\"line\">  get children(): ActivatedRoute[]</span><br><span class=\"line\">  get pathFromRoot(): ActivatedRoute[]</span><br><span class=\"line\">  get paramMap(): Observable&lt;ParamMap&gt;</span><br><span class=\"line\">  get queryParamMap(): Observable&lt;ParamMap&gt;</span><br><span class=\"line\">  toString(): string</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h1><h2 id=\"配置在app-module-ts文件中\"><a href=\"#配置在app-module-ts文件中\" class=\"headerlink\" title=\"配置在app.module.ts文件中\"></a>配置在app.module.ts文件中</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123;NgModule&#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class=\"line\">import &#123;RouterModule, Routes&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;AppComponent&#125; from &#39;app.component&#39;;</span><br><span class=\"line\">import &#123;AComponent&#125; from &#39;a.component&#39;;</span><br><span class=\"line\">import &#123;BComponent&#125; from &#39;b.component&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const appRoutes: Routes &#x3D; [</span><br><span class=\"line\">  &#123;path: &#39;aaa&#39;, component: AComponent&#125;,</span><br><span class=\"line\">  &#123;path: &#39;bbb&#39;, component: BComponent&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    RouterModule.forRoot(appRoutes)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  declarations:[</span><br><span class=\"line\">    AppComponent,</span><br><span class=\"line\">    AComponent,</span><br><span class=\"line\">    BComponent</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppModule&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单独配置一个路由模块\"><a href=\"#单独配置一个路由模块\" class=\"headerlink\" title=\"单独配置一个路由模块\"></a>单独配置一个路由模块</h2><p>随着应用的成长，我们将需要将路由配置重构到单独的文件，并创建<strong>路由模块</strong> - 一种特别的、专门为特性模块的路由器服务的<strong>服务模块</strong>。</p>\n<p>在/app目录下创建一个app-routing.module.ts的路由配置文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; src&#x2F;app&#x2F;approuting.module.ts</span><br><span class=\"line\">import &#123;NgModule&#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class=\"line\">import &#123;RouterModule, Routes&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;AComponent&#125; from &#39;a.component&#39;;</span><br><span class=\"line\">import &#123;BComponent&#125; from &#39;b.component&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">const appRoutes: Routes &#x3D; [</span><br><span class=\"line\">  &#123;path: &#39;aaa&#39;, component: AComponent&#125;,</span><br><span class=\"line\">  &#123;path: &#39;bbb&#39;, component: BComponent&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    RouterModule.forRoot(appRoutes)</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  export:[</span><br><span class=\"line\">    RouterModule</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class AppRoutingModule&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123;AppRoutingModule&#125; from &#39;approuting.module&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;AppComponent&#125; from &#39;app.component&#39;;</span><br><span class=\"line\">import &#123;AComponent&#125; from &#39;a.component&#39;;</span><br><span class=\"line\">import &#123;BComponent&#125; from &#39;b.component&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  import:[</span><br><span class=\"line\">    AppRoutingModule</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  delarations:[</span><br><span class=\"line\">    AppComponent,</span><br><span class=\"line\">    AComponent,</span><br><span class=\"line\">    BComponent</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在根模块中，RouterModule调用forRoot方法，在其他子模块中，RouterModule调用forChild方法。</p>\n<p>##重定向路由</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path: &#39;&#39;, redirectTo: &#39;&#x2F;heroes&#39;, pathMatch: &#39;full&#39;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>pathMatch： 描述匹配策略的属性，值为两个字符串，full和prefix</p>\n<p>prefix：默认值，只要URL的开始是以path开头的，就进行重定向路由。由于’ ‘空字符串是所有url的前缀，所以不管输入什么都会重定向。</p>\n<p>full：输入的url必须和path完全一致，才会进行重定向。</p>\n<p>##通配符路由</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path: &#39;**&#39;, component: ....&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以匹配任何路由，放在路由数组的最后，优先匹配原则。通常用来导航到自定义的404页面。</p>\n<h1 id=\"路由导航\"><a href=\"#路由导航\" class=\"headerlink\" title=\"路由导航\"></a>路由导航</h1><h2 id=\"使用RouterLink导航\"><a href=\"#使用RouterLink导航\" class=\"headerlink\" title=\"使用RouterLink导航\"></a>使用RouterLink导航</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a routerLink&#x3D;&quot;&#x2F;hero&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;path:&#39;hero&#39;,component:HeroComponent&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用Router导航\"><a href=\"#使用Router导航\" class=\"headerlink\" title=\"使用Router导航\"></a>使用Router导航</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button (click)&#x3D;&quot;toHero()&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(private router:Router)&#123;&#125;</span><br><span class=\"line\">toHero()&#123;</span><br><span class=\"line\">  this.router.navigate([&#39;&#x2F;hero&#39;])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"路由传递数据\"><a href=\"#路由传递数据\" class=\"headerlink\" title=\"路由传递数据\"></a>路由传递数据</h1><h2 id=\"在查询参数中传递数据\"><a href=\"#在查询参数中传递数据\" class=\"headerlink\" title=\"在查询参数中传递数据\"></a>在查询参数中传递数据</h2><p>/product?id=1&amp;name=2   =&gt;   ActivatedRoute.quaryParams[id]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;a routerLink&#x3D;&quot;&#x2F;hero&quot; [queryParams]&#x3D;&quot;&#123;id:1&#125;&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(private routeInfo: ActivatedRoute)&#123;&#125;</span><br><span class=\"line\">ngOnInit()&#123;</span><br><span class=\"line\">  this.heroId &#x3D; this.routeInfo.snapshot.queryParams[&quot;id&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在路由路径中传递数据\"><a href=\"#在路由路径中传递数据\" class=\"headerlink\" title=\"在路由路径中传递数据\"></a>在路由路径中传递数据</h2><p>{path: /product/:id}  =&gt;  /product/1  =&gt;  ActivatedRoute.params[id]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path:&#39;hero&#x2F;:id&#39;, component: HeroComponent&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;a routerLink&#x3D;&quot;[&#39;&#x2F;hero&#39;,hero.id]&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">&lt;button (click)&#x3D;&quot;toHero()&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(private routeInfo: ActivatedRoute, private router: Router)&#123;&#125;</span><br><span class=\"line\">ngOnInit()&#123;</span><br><span class=\"line\">  this.heroId &#x3D; this.routeInfo.snapshot.params[&quot;id&quot;];</span><br><span class=\"line\">  &#x2F;&#x2F;</span><br><span class=\"line\">  this.routeInfo.params.subscribe((params:Params) &#x3D;&gt; this.heroId &#x3D; params[&quot;id&quot;])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">toHero()&#123;</span><br><span class=\"line\">  this.router.navigate([&#39;&#x2F;hero&#39;],2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在路由配置中传递数据\"><a href=\"#在路由配置中传递数据\" class=\"headerlink\" title=\"在路由配置中传递数据\"></a>在路由配置中传递数据</h2><p>{path: /product, component: ProductComponent, data:[{isProd: true}]}  =&gt;  ActivatedRoute.data[0][isProd]</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;path: &#39;hero&#39;, component: HeroComponent, data:[&#123;isPro:true&#125;]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">constructor(private routeInfo: ActivatedRoute)&#123;&#125;</span><br><span class=\"line\">ngOnInit()&#123;</span><br><span class=\"line\">  this.isPro &#x3D; this.routeInfo.snapshot.data[0][&quot;isPro&quot;];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"子路由\"><a href=\"#子路由\" class=\"headerlink\" title=\"子路由\"></a>子路由</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\tpath:&#39;xxx&#39;,</span><br><span class=\"line\">\tcomponent: XXXX,</span><br><span class=\"line\">\tchildren:[</span><br><span class=\"line\">      path: &#39;YYY&#39;,</span><br><span class=\"line\">      component: YYY</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;a routerLink&#x3D;&quot;.&#x2F;children1&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>\n\n<p>根路由用<code>/</code>开头</p>\n<p>子路由用<code>./</code>开头</p>\n<p>上级路由用<code>../</code>开头</p>\n<h1 id=\"辅助路由\"><a href=\"#辅助路由\" class=\"headerlink\" title=\"辅助路由\"></a>辅助路由</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;router-outlet&gt;&lt;&#x2F;router-outlet&gt;</span><br><span class=\"line\">&lt;router-outlet name&#x3D;&quot;aux&quot;&gt;&lt;&#x2F;router-outlet&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;path: &#39;xxxx&#39;, component:AuxComponent, outlet: &#39;aux&#39;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;a [routerLink]&#x3D;&quot;[&#123;outlets:&#123;aux: &#39;xxxx&#39;&#125;&#125;]&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class=\"line\">&lt;a [routerLink]&#x3D;&quot;[&#123;outlets:&#123;aux: null&#125;&#125;]&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h1><h2 id=\"CanActivate\"><a href=\"#CanActivate\" class=\"headerlink\" title=\"CanActivate\"></a>CanActivate</h2><p>处理导航到某路由的情况。</p>\n<p>一 写路由守卫</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;guard.ts</span><br><span class=\"line\">import &#123;CanActivate&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export class GuardName implements CanActivate&#123;</span><br><span class=\"line\">  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot)&#123;</span><br><span class=\"line\">    return true; &#x2F;&#x2F; 返回true，就允许进入导航，返回false就拒绝</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二 把守卫配置到路由上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;app.module.ts</span><br><span class=\"line\">import &#123;GuardName&#125; from &#39;guard&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; path: &#39;xxxxx&#39;, component: XXXX, canActivate: [GuardName]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  providers:[GuardName]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CanDeactivate\"><a href=\"#CanDeactivate\" class=\"headerlink\" title=\"CanDeactivate\"></a>CanDeactivate</h2><p>处理从当前路由离开的情况。</p>\n<p>一 写路由守卫</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;guard.ts</span><br><span class=\"line\">import &#123;CanDeactivate&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\">import &#123;XXXComponent&#125; from &#39;xxx&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export class GuardName implements CanDeactivate&lt;XXXComponent&gt;&#123;\t&#x2F;&#x2F;泛型是要守卫的组件</span><br><span class=\"line\">\t&#x2F;&#x2F; canDeactivate方法需要把要保护的组件作为参数传进来</span><br><span class=\"line\">  canDeactivate(component: XXXComponent, route: ActivatedRouteSnapshot, state: RouterStateSnapshot)&#123;</span><br><span class=\"line\">      return component.isTrue; &#x2F;&#x2F; 返回true，就允许离开导航，返回false就拒绝</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二 把守卫配置到路由上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;app.module.ts</span><br><span class=\"line\">import &#123;GuardName&#125; from &#39;guard&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; path: &#39;xxxxx&#39;, component: XXXX, canDeactivate: [GuardName]&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  providers:[GuardName]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Resolve\"><a href=\"#Resolve\" class=\"headerlink\" title=\"Resolve\"></a>Resolve</h2><p>在路由之前获取路由数据。</p>\n<p>一 写路由守卫</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; guard.ts</span><br><span class=\"line\">import &#123;Resolve&#125; from &#39;@angular&#x2F;router&#39;;</span><br><span class=\"line\">impot &#123;XXX&#125; from &#39;xxx&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">export class GuardName implements Resolve&lt;XXX&gt;&#123;\t&#x2F;&#x2F; 泛型是要获取的数据的类型</span><br><span class=\"line\">  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot)&#123;</span><br><span class=\"line\">    return route.params[&quot;id&quot;];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>二 把守卫配置到路由上</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;app.module.ts</span><br><span class=\"line\">import &#123;GuardName&#125; from &#39;guard&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#123; path: &#39;....&#39;, component: ComponentName, resolve: &#123;xxx: GuardName&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  providers:[GuardName]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>三 在目标组件中接收数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;Component</span><br><span class=\"line\">ngOnInit()&#123;</span><br><span class=\"line\">  this.activatedRoute.data.subscribe((data:&#123;stock: Stock&#125;) &#x3D;&gt; &#123;</span><br><span class=\"line\">    this.stock &#x3D; data.stock;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Angular4——4.依赖注入","date":"2017-12-19T06:50:09.000Z","description":"Angular依赖注入","_content":"\n# 注入器\n\n每一个组件都有一个注入器实例， 负责注入组件需要的对象。注入器是Angular提供的一个服务类，一般情况下不需要直接调用注入器的方法，注入器会自动通过组件的构造函数，将组件所需的对象注入进组件：\n\n```\nconstruncot(private productService: ProductService){...}\n```\n\n# 注入器的层级关系\n\n应用级注入器 -> 住组件注入器 -> 子组件注入器\n\n子组件的构造函数中注入了一个服务，angular会先查找这个子组件自己是否声明了提供器，如果没有，就再向上查找主组件是否声明，如果还没有再向上查找应用级，也就是根模块中是否声明。\n\n# 提供器\n\n为了让注入器知道被注入的对象如何实例化，我们需要提供器。\n\n通过组件活着模块的`providers`属性来声明提供器：\n\n```\nproviders:[ProductService]\nproviders:[{provide: ProductService, useclass: ProductService}]\nproviders:[{provide: ProductService, useclass: AnotherProductService}]\n```\n\nprovide属性指明了提供器的token，这个token就是组件构造函数中的注入器的类型。\n\nuseclass属性指明了提供器具体要实例化的类。\n\n如果注入器的类型和要实例化的类的类型一样，可以简写成`providers:[ProductService]`。\n\n如果用相同的token注入，但是实例化不同的类，要在服务中实现相同的token：\n\n```\nexport class AnotherProductService implements ProductSercice{\n  ...\n}\n```\n\n一个服务实现另一个服务，必须实现另一个服务的所有方法。\n\n# 提供器优先级\n\n提供器`providers`可以声明在根模块，也可以声明在组件。\n\n当一个`providers`声明在根模块这一级的时候，它对所有的组件可见，所有组件都可以注入。\n\n当一个`providers`声明在组件这一级的时候，它只对声明它对组件以及自组件可见，其他组件不能注入。\n\n当声明在模块中的提供器和声明在组件中的提供器使用同样的token时，声明在组件中的提供器会覆盖声明在模块中的提供器。\n\n一般情况下，我们应该把服务声明在模块中。\n\n# @Injectable\n\n服务类中的`@Injectable()`装饰器表示这个服务类可以通过构造函数注入其他服务，而不是表示这个服务可以被注入。\n\n这个服务能否被注入，是由模块或组件中是否声明`providers`提供器决定的。\n\n# 工厂函数提供器\n\n```\nproviders: [{ provide: ProductService, useFactory: () => {\n  if(true){\n    return new ProductService()\n  }else{\n    return new AnotherProductService()\n  }\n}}]\n```\n\n工厂函数提供器，可以把其他提供器作为参数传进来使用，deps属性的值时一个数组，作用是为useFactory属性的匿名函数提供参数。\n\n```\nproviders:[\n\t{\n\t  provide: ProductService, useFactory: (a:XXXX, b:AnotherService) => {\n  \t\tconsole.log(a)\t// {isTrue: true}\n  \t\tconsole.log(b)\n\t  },deps:[\"XXXXX\",AnotherService]\n\t},{\n      provide: 'XXXXX', useValue:{isTrue: true}\n\t},{\n      provide: AnotherService, useFactory()=>{}\n\t}]\n```\n\n# 值提供器\n\n```\nproviders:[{ provide: 'ValueProvider', useValue: true}]\n```\n\n","source":"_posts/Angular4——4-依赖注入.md","raw":"---\ntitle: Angular4——4.依赖注入\ndate: 2017-12-19 14:50:09\ntags:\n- Angular\ncategories:\n- 学习笔记\ndescription: Angular依赖注入\n---\n\n# 注入器\n\n每一个组件都有一个注入器实例， 负责注入组件需要的对象。注入器是Angular提供的一个服务类，一般情况下不需要直接调用注入器的方法，注入器会自动通过组件的构造函数，将组件所需的对象注入进组件：\n\n```\nconstruncot(private productService: ProductService){...}\n```\n\n# 注入器的层级关系\n\n应用级注入器 -> 住组件注入器 -> 子组件注入器\n\n子组件的构造函数中注入了一个服务，angular会先查找这个子组件自己是否声明了提供器，如果没有，就再向上查找主组件是否声明，如果还没有再向上查找应用级，也就是根模块中是否声明。\n\n# 提供器\n\n为了让注入器知道被注入的对象如何实例化，我们需要提供器。\n\n通过组件活着模块的`providers`属性来声明提供器：\n\n```\nproviders:[ProductService]\nproviders:[{provide: ProductService, useclass: ProductService}]\nproviders:[{provide: ProductService, useclass: AnotherProductService}]\n```\n\nprovide属性指明了提供器的token，这个token就是组件构造函数中的注入器的类型。\n\nuseclass属性指明了提供器具体要实例化的类。\n\n如果注入器的类型和要实例化的类的类型一样，可以简写成`providers:[ProductService]`。\n\n如果用相同的token注入，但是实例化不同的类，要在服务中实现相同的token：\n\n```\nexport class AnotherProductService implements ProductSercice{\n  ...\n}\n```\n\n一个服务实现另一个服务，必须实现另一个服务的所有方法。\n\n# 提供器优先级\n\n提供器`providers`可以声明在根模块，也可以声明在组件。\n\n当一个`providers`声明在根模块这一级的时候，它对所有的组件可见，所有组件都可以注入。\n\n当一个`providers`声明在组件这一级的时候，它只对声明它对组件以及自组件可见，其他组件不能注入。\n\n当声明在模块中的提供器和声明在组件中的提供器使用同样的token时，声明在组件中的提供器会覆盖声明在模块中的提供器。\n\n一般情况下，我们应该把服务声明在模块中。\n\n# @Injectable\n\n服务类中的`@Injectable()`装饰器表示这个服务类可以通过构造函数注入其他服务，而不是表示这个服务可以被注入。\n\n这个服务能否被注入，是由模块或组件中是否声明`providers`提供器决定的。\n\n# 工厂函数提供器\n\n```\nproviders: [{ provide: ProductService, useFactory: () => {\n  if(true){\n    return new ProductService()\n  }else{\n    return new AnotherProductService()\n  }\n}}]\n```\n\n工厂函数提供器，可以把其他提供器作为参数传进来使用，deps属性的值时一个数组，作用是为useFactory属性的匿名函数提供参数。\n\n```\nproviders:[\n\t{\n\t  provide: ProductService, useFactory: (a:XXXX, b:AnotherService) => {\n  \t\tconsole.log(a)\t// {isTrue: true}\n  \t\tconsole.log(b)\n\t  },deps:[\"XXXXX\",AnotherService]\n\t},{\n      provide: 'XXXXX', useValue:{isTrue: true}\n\t},{\n      provide: AnotherService, useFactory()=>{}\n\t}]\n```\n\n# 值提供器\n\n```\nproviders:[{ provide: 'ValueProvider', useValue: true}]\n```\n\n","slug":"Angular4——4-依赖注入","published":1,"updated":"2021-05-08T15:00:59.857Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbo60006wct4aeh45isf","content":"<h1 id=\"注入器\"><a href=\"#注入器\" class=\"headerlink\" title=\"注入器\"></a>注入器</h1><p>每一个组件都有一个注入器实例， 负责注入组件需要的对象。注入器是Angular提供的一个服务类，一般情况下不需要直接调用注入器的方法，注入器会自动通过组件的构造函数，将组件所需的对象注入进组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">construncot(private productService: ProductService)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"注入器的层级关系\"><a href=\"#注入器的层级关系\" class=\"headerlink\" title=\"注入器的层级关系\"></a>注入器的层级关系</h1><p>应用级注入器 -&gt; 住组件注入器 -&gt; 子组件注入器</p>\n<p>子组件的构造函数中注入了一个服务，angular会先查找这个子组件自己是否声明了提供器，如果没有，就再向上查找主组件是否声明，如果还没有再向上查找应用级，也就是根模块中是否声明。</p>\n<h1 id=\"提供器\"><a href=\"#提供器\" class=\"headerlink\" title=\"提供器\"></a>提供器</h1><p>为了让注入器知道被注入的对象如何实例化，我们需要提供器。</p>\n<p>通过组件活着模块的<code>providers</code>属性来声明提供器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers:[ProductService]</span><br><span class=\"line\">providers:[&#123;provide: ProductService, useclass: ProductService&#125;]</span><br><span class=\"line\">providers:[&#123;provide: ProductService, useclass: AnotherProductService&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>provide属性指明了提供器的token，这个token就是组件构造函数中的注入器的类型。</p>\n<p>useclass属性指明了提供器具体要实例化的类。</p>\n<p>如果注入器的类型和要实例化的类的类型一样，可以简写成<code>providers:[ProductService]</code>。</p>\n<p>如果用相同的token注入，但是实例化不同的类，要在服务中实现相同的token：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export class AnotherProductService implements ProductSercice&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个服务实现另一个服务，必须实现另一个服务的所有方法。</p>\n<h1 id=\"提供器优先级\"><a href=\"#提供器优先级\" class=\"headerlink\" title=\"提供器优先级\"></a>提供器优先级</h1><p>提供器<code>providers</code>可以声明在根模块，也可以声明在组件。</p>\n<p>当一个<code>providers</code>声明在根模块这一级的时候，它对所有的组件可见，所有组件都可以注入。</p>\n<p>当一个<code>providers</code>声明在组件这一级的时候，它只对声明它对组件以及自组件可见，其他组件不能注入。</p>\n<p>当声明在模块中的提供器和声明在组件中的提供器使用同样的token时，声明在组件中的提供器会覆盖声明在模块中的提供器。</p>\n<p>一般情况下，我们应该把服务声明在模块中。</p>\n<h1 id=\"Injectable\"><a href=\"#Injectable\" class=\"headerlink\" title=\"@Injectable\"></a>@Injectable</h1><p>服务类中的<code>@Injectable()</code>装饰器表示这个服务类可以通过构造函数注入其他服务，而不是表示这个服务可以被注入。</p>\n<p>这个服务能否被注入，是由模块或组件中是否声明<code>providers</code>提供器决定的。</p>\n<h1 id=\"工厂函数提供器\"><a href=\"#工厂函数提供器\" class=\"headerlink\" title=\"工厂函数提供器\"></a>工厂函数提供器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers: [&#123; provide: ProductService, useFactory: () &#x3D;&gt; &#123;</span><br><span class=\"line\">  if(true)&#123;</span><br><span class=\"line\">    return new ProductService()</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    return new AnotherProductService()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>工厂函数提供器，可以把其他提供器作为参数传进来使用，deps属性的值时一个数组，作用是为useFactory属性的匿名函数提供参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers:[</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t  provide: ProductService, useFactory: (a:XXXX, b:AnotherService) &#x3D;&gt; &#123;</span><br><span class=\"line\">  \t\tconsole.log(a)\t&#x2F;&#x2F; &#123;isTrue: true&#125;</span><br><span class=\"line\">  \t\tconsole.log(b)</span><br><span class=\"line\">\t  &#125;,deps:[&quot;XXXXX&quot;,AnotherService]</span><br><span class=\"line\">\t&#125;,&#123;</span><br><span class=\"line\">      provide: &#39;XXXXX&#39;, useValue:&#123;isTrue: true&#125;</span><br><span class=\"line\">\t&#125;,&#123;</span><br><span class=\"line\">      provide: AnotherService, useFactory()&#x3D;&gt;&#123;&#125;</span><br><span class=\"line\">\t&#125;]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"值提供器\"><a href=\"#值提供器\" class=\"headerlink\" title=\"值提供器\"></a>值提供器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers:[&#123; provide: &#39;ValueProvider&#39;, useValue: true&#125;]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"注入器\"><a href=\"#注入器\" class=\"headerlink\" title=\"注入器\"></a>注入器</h1><p>每一个组件都有一个注入器实例， 负责注入组件需要的对象。注入器是Angular提供的一个服务类，一般情况下不需要直接调用注入器的方法，注入器会自动通过组件的构造函数，将组件所需的对象注入进组件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">construncot(private productService: ProductService)&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"注入器的层级关系\"><a href=\"#注入器的层级关系\" class=\"headerlink\" title=\"注入器的层级关系\"></a>注入器的层级关系</h1><p>应用级注入器 -&gt; 住组件注入器 -&gt; 子组件注入器</p>\n<p>子组件的构造函数中注入了一个服务，angular会先查找这个子组件自己是否声明了提供器，如果没有，就再向上查找主组件是否声明，如果还没有再向上查找应用级，也就是根模块中是否声明。</p>\n<h1 id=\"提供器\"><a href=\"#提供器\" class=\"headerlink\" title=\"提供器\"></a>提供器</h1><p>为了让注入器知道被注入的对象如何实例化，我们需要提供器。</p>\n<p>通过组件活着模块的<code>providers</code>属性来声明提供器：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers:[ProductService]</span><br><span class=\"line\">providers:[&#123;provide: ProductService, useclass: ProductService&#125;]</span><br><span class=\"line\">providers:[&#123;provide: ProductService, useclass: AnotherProductService&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>provide属性指明了提供器的token，这个token就是组件构造函数中的注入器的类型。</p>\n<p>useclass属性指明了提供器具体要实例化的类。</p>\n<p>如果注入器的类型和要实例化的类的类型一样，可以简写成<code>providers:[ProductService]</code>。</p>\n<p>如果用相同的token注入，但是实例化不同的类，要在服务中实现相同的token：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export class AnotherProductService implements ProductSercice&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个服务实现另一个服务，必须实现另一个服务的所有方法。</p>\n<h1 id=\"提供器优先级\"><a href=\"#提供器优先级\" class=\"headerlink\" title=\"提供器优先级\"></a>提供器优先级</h1><p>提供器<code>providers</code>可以声明在根模块，也可以声明在组件。</p>\n<p>当一个<code>providers</code>声明在根模块这一级的时候，它对所有的组件可见，所有组件都可以注入。</p>\n<p>当一个<code>providers</code>声明在组件这一级的时候，它只对声明它对组件以及自组件可见，其他组件不能注入。</p>\n<p>当声明在模块中的提供器和声明在组件中的提供器使用同样的token时，声明在组件中的提供器会覆盖声明在模块中的提供器。</p>\n<p>一般情况下，我们应该把服务声明在模块中。</p>\n<h1 id=\"Injectable\"><a href=\"#Injectable\" class=\"headerlink\" title=\"@Injectable\"></a>@Injectable</h1><p>服务类中的<code>@Injectable()</code>装饰器表示这个服务类可以通过构造函数注入其他服务，而不是表示这个服务可以被注入。</p>\n<p>这个服务能否被注入，是由模块或组件中是否声明<code>providers</code>提供器决定的。</p>\n<h1 id=\"工厂函数提供器\"><a href=\"#工厂函数提供器\" class=\"headerlink\" title=\"工厂函数提供器\"></a>工厂函数提供器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers: [&#123; provide: ProductService, useFactory: () &#x3D;&gt; &#123;</span><br><span class=\"line\">  if(true)&#123;</span><br><span class=\"line\">    return new ProductService()</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    return new AnotherProductService()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>工厂函数提供器，可以把其他提供器作为参数传进来使用，deps属性的值时一个数组，作用是为useFactory属性的匿名函数提供参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers:[</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t  provide: ProductService, useFactory: (a:XXXX, b:AnotherService) &#x3D;&gt; &#123;</span><br><span class=\"line\">  \t\tconsole.log(a)\t&#x2F;&#x2F; &#123;isTrue: true&#125;</span><br><span class=\"line\">  \t\tconsole.log(b)</span><br><span class=\"line\">\t  &#125;,deps:[&quot;XXXXX&quot;,AnotherService]</span><br><span class=\"line\">\t&#125;,&#123;</span><br><span class=\"line\">      provide: &#39;XXXXX&#39;, useValue:&#123;isTrue: true&#125;</span><br><span class=\"line\">\t&#125;,&#123;</span><br><span class=\"line\">      provide: AnotherService, useFactory()&#x3D;&gt;&#123;&#125;</span><br><span class=\"line\">\t&#125;]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"值提供器\"><a href=\"#值提供器\" class=\"headerlink\" title=\"值提供器\"></a>值提供器</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">providers:[&#123; provide: &#39;ValueProvider&#39;, useValue: true&#125;]</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Angular4——1.介绍Angular4","date":"2017-10-04T09:49:26.000Z","description":"Angular4学习+项目实战笔记","_content":"\n# Angular介绍\n\nangular是有Google维护的开源JavaScript框架。\n\n目前有两个大的版本，1.5和4.0。\n\nangular4并不是在1的基础上升级而来，而是一个完全重写的版本。\n\n angular1统一叫做**AngularJS**，angular2以后统一叫做**Angular**，这也是官方的叫法。\n\n## AngularJS的问题\n\n**性能**\n\n随着组件的增加，双向数据绑定会带来性能问题。AngularJS通过dirty checking脏检查来跟踪数据的改变来动态更新用户界面 ，在AngularJS的作用域中任何的操作都会引发dirty checking，随着绑定数量的增加性能就会越来越低。\n\n在Angular中，这种检查机制被完全废弃，默认的数据绑定方式也由双向绑定改为了单项绑定，整个检查机制也完全重写，整个性能得到很大提升。\n\n**路由**\n\n在AngularJS中  ，用来做路由的指令`ng-View`只能有一个，不能嵌套多个视图，虽然有第三方模块ui-router可以解决路由问题，但是 UI-router对URL的控制也不是很灵活，它必须是一个嵌套模式的URL。\n\n在Angular中，路由模块作为整个框架的核心模块之一，进行了巨大的提升。\n\n**作用域**\n\n在AngularJS中，有个重要的作用域机制，这个作用域把angular的执行环境和浏览器的环境隔离开，所有原生的事件都不能影响angular的作用域，你无法响应任何原生事件。**比如**，你不能用按钮的click事件，只能用ng-click指令。如果想用原生的事件，必须调用$scope.$apply()来告诉AngularJS我的数据更新了。\n\n在Angular中，$scope不复存在，任何原生的事件都可以被处理\n\n**表单验证**\n\nAngularJS中，显示错误信息这部分很薄弱，需要写很多模版标签\n\n在Angular中，提供了一套全新的表单API，尤其是一种叫响应式表单\n\n**JavaScript**\n\nangularJS中，存在JavaScript语言本身的问题，比如他没有类型系统，面向对象开发的能力不够\n\n在Angular中，使用TypeScript语言开发，他是ES6点超级，带有完善的类型系统\n\n**学习成本**\n\nangularJS需要学习大量的概念，模块、控制器、指令、作用域、模版、数据绑定、链式函数、过滤器、依赖注入......=_=\n\nAngular的核心就是组件，其他的东西都是为组件服务\n\n## Angular的新特性\n\n全新的命令行工具 Angular Cli\n\n服务器端渲染\n\n移动和桌面的兼容\n\n官方UI库","source":"_posts/Angular4——1.介绍Angular4.md","raw":"---\ntitle: Angular4——1.介绍Angular4\ndate: 2017-10-04 17:49:26\ntags:\n- Angular\ncategories:\n- 学习笔记\ndescription: Angular4学习+项目实战笔记\n---\n\n# Angular介绍\n\nangular是有Google维护的开源JavaScript框架。\n\n目前有两个大的版本，1.5和4.0。\n\nangular4并不是在1的基础上升级而来，而是一个完全重写的版本。\n\n angular1统一叫做**AngularJS**，angular2以后统一叫做**Angular**，这也是官方的叫法。\n\n## AngularJS的问题\n\n**性能**\n\n随着组件的增加，双向数据绑定会带来性能问题。AngularJS通过dirty checking脏检查来跟踪数据的改变来动态更新用户界面 ，在AngularJS的作用域中任何的操作都会引发dirty checking，随着绑定数量的增加性能就会越来越低。\n\n在Angular中，这种检查机制被完全废弃，默认的数据绑定方式也由双向绑定改为了单项绑定，整个检查机制也完全重写，整个性能得到很大提升。\n\n**路由**\n\n在AngularJS中  ，用来做路由的指令`ng-View`只能有一个，不能嵌套多个视图，虽然有第三方模块ui-router可以解决路由问题，但是 UI-router对URL的控制也不是很灵活，它必须是一个嵌套模式的URL。\n\n在Angular中，路由模块作为整个框架的核心模块之一，进行了巨大的提升。\n\n**作用域**\n\n在AngularJS中，有个重要的作用域机制，这个作用域把angular的执行环境和浏览器的环境隔离开，所有原生的事件都不能影响angular的作用域，你无法响应任何原生事件。**比如**，你不能用按钮的click事件，只能用ng-click指令。如果想用原生的事件，必须调用$scope.$apply()来告诉AngularJS我的数据更新了。\n\n在Angular中，$scope不复存在，任何原生的事件都可以被处理\n\n**表单验证**\n\nAngularJS中，显示错误信息这部分很薄弱，需要写很多模版标签\n\n在Angular中，提供了一套全新的表单API，尤其是一种叫响应式表单\n\n**JavaScript**\n\nangularJS中，存在JavaScript语言本身的问题，比如他没有类型系统，面向对象开发的能力不够\n\n在Angular中，使用TypeScript语言开发，他是ES6点超级，带有完善的类型系统\n\n**学习成本**\n\nangularJS需要学习大量的概念，模块、控制器、指令、作用域、模版、数据绑定、链式函数、过滤器、依赖注入......=_=\n\nAngular的核心就是组件，其他的东西都是为组件服务\n\n## Angular的新特性\n\n全新的命令行工具 Angular Cli\n\n服务器端渲染\n\n移动和桌面的兼容\n\n官方UI库","slug":"Angular4——1.介绍Angular4","published":1,"updated":"2021-05-08T15:01:31.892Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbo70007wct4b2le0ggg","content":"<h1 id=\"Angular介绍\"><a href=\"#Angular介绍\" class=\"headerlink\" title=\"Angular介绍\"></a>Angular介绍</h1><p>angular是有Google维护的开源JavaScript框架。</p>\n<p>目前有两个大的版本，1.5和4.0。</p>\n<p>angular4并不是在1的基础上升级而来，而是一个完全重写的版本。</p>\n<p> angular1统一叫做<strong>AngularJS</strong>，angular2以后统一叫做<strong>Angular</strong>，这也是官方的叫法。</p>\n<h2 id=\"AngularJS的问题\"><a href=\"#AngularJS的问题\" class=\"headerlink\" title=\"AngularJS的问题\"></a>AngularJS的问题</h2><p><strong>性能</strong></p>\n<p>随着组件的增加，双向数据绑定会带来性能问题。AngularJS通过dirty checking脏检查来跟踪数据的改变来动态更新用户界面 ，在AngularJS的作用域中任何的操作都会引发dirty checking，随着绑定数量的增加性能就会越来越低。</p>\n<p>在Angular中，这种检查机制被完全废弃，默认的数据绑定方式也由双向绑定改为了单项绑定，整个检查机制也完全重写，整个性能得到很大提升。</p>\n<p><strong>路由</strong></p>\n<p>在AngularJS中  ，用来做路由的指令<code>ng-View</code>只能有一个，不能嵌套多个视图，虽然有第三方模块ui-router可以解决路由问题，但是 UI-router对URL的控制也不是很灵活，它必须是一个嵌套模式的URL。</p>\n<p>在Angular中，路由模块作为整个框架的核心模块之一，进行了巨大的提升。</p>\n<p><strong>作用域</strong></p>\n<p>在AngularJS中，有个重要的作用域机制，这个作用域把angular的执行环境和浏览器的环境隔离开，所有原生的事件都不能影响angular的作用域，你无法响应任何原生事件。<strong>比如</strong>，你不能用按钮的click事件，只能用ng-click指令。如果想用原生的事件，必须调用$scope.$apply()来告诉AngularJS我的数据更新了。</p>\n<p>在Angular中，$scope不复存在，任何原生的事件都可以被处理</p>\n<p><strong>表单验证</strong></p>\n<p>AngularJS中，显示错误信息这部分很薄弱，需要写很多模版标签</p>\n<p>在Angular中，提供了一套全新的表单API，尤其是一种叫响应式表单</p>\n<p><strong>JavaScript</strong></p>\n<p>angularJS中，存在JavaScript语言本身的问题，比如他没有类型系统，面向对象开发的能力不够</p>\n<p>在Angular中，使用TypeScript语言开发，他是ES6点超级，带有完善的类型系统</p>\n<p><strong>学习成本</strong></p>\n<p>angularJS需要学习大量的概念，模块、控制器、指令、作用域、模版、数据绑定、链式函数、过滤器、依赖注入……=_=</p>\n<p>Angular的核心就是组件，其他的东西都是为组件服务</p>\n<h2 id=\"Angular的新特性\"><a href=\"#Angular的新特性\" class=\"headerlink\" title=\"Angular的新特性\"></a>Angular的新特性</h2><p>全新的命令行工具 Angular Cli</p>\n<p>服务器端渲染</p>\n<p>移动和桌面的兼容</p>\n<p>官方UI库</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Angular介绍\"><a href=\"#Angular介绍\" class=\"headerlink\" title=\"Angular介绍\"></a>Angular介绍</h1><p>angular是有Google维护的开源JavaScript框架。</p>\n<p>目前有两个大的版本，1.5和4.0。</p>\n<p>angular4并不是在1的基础上升级而来，而是一个完全重写的版本。</p>\n<p> angular1统一叫做<strong>AngularJS</strong>，angular2以后统一叫做<strong>Angular</strong>，这也是官方的叫法。</p>\n<h2 id=\"AngularJS的问题\"><a href=\"#AngularJS的问题\" class=\"headerlink\" title=\"AngularJS的问题\"></a>AngularJS的问题</h2><p><strong>性能</strong></p>\n<p>随着组件的增加，双向数据绑定会带来性能问题。AngularJS通过dirty checking脏检查来跟踪数据的改变来动态更新用户界面 ，在AngularJS的作用域中任何的操作都会引发dirty checking，随着绑定数量的增加性能就会越来越低。</p>\n<p>在Angular中，这种检查机制被完全废弃，默认的数据绑定方式也由双向绑定改为了单项绑定，整个检查机制也完全重写，整个性能得到很大提升。</p>\n<p><strong>路由</strong></p>\n<p>在AngularJS中  ，用来做路由的指令<code>ng-View</code>只能有一个，不能嵌套多个视图，虽然有第三方模块ui-router可以解决路由问题，但是 UI-router对URL的控制也不是很灵活，它必须是一个嵌套模式的URL。</p>\n<p>在Angular中，路由模块作为整个框架的核心模块之一，进行了巨大的提升。</p>\n<p><strong>作用域</strong></p>\n<p>在AngularJS中，有个重要的作用域机制，这个作用域把angular的执行环境和浏览器的环境隔离开，所有原生的事件都不能影响angular的作用域，你无法响应任何原生事件。<strong>比如</strong>，你不能用按钮的click事件，只能用ng-click指令。如果想用原生的事件，必须调用$scope.$apply()来告诉AngularJS我的数据更新了。</p>\n<p>在Angular中，$scope不复存在，任何原生的事件都可以被处理</p>\n<p><strong>表单验证</strong></p>\n<p>AngularJS中，显示错误信息这部分很薄弱，需要写很多模版标签</p>\n<p>在Angular中，提供了一套全新的表单API，尤其是一种叫响应式表单</p>\n<p><strong>JavaScript</strong></p>\n<p>angularJS中，存在JavaScript语言本身的问题，比如他没有类型系统，面向对象开发的能力不够</p>\n<p>在Angular中，使用TypeScript语言开发，他是ES6点超级，带有完善的类型系统</p>\n<p><strong>学习成本</strong></p>\n<p>angularJS需要学习大量的概念，模块、控制器、指令、作用域、模版、数据绑定、链式函数、过滤器、依赖注入……=_=</p>\n<p>Angular的核心就是组件，其他的东西都是为组件服务</p>\n<h2 id=\"Angular的新特性\"><a href=\"#Angular的新特性\" class=\"headerlink\" title=\"Angular的新特性\"></a>Angular的新特性</h2><p>全新的命令行工具 Angular Cli</p>\n<p>服务器端渲染</p>\n<p>移动和桌面的兼容</p>\n<p>官方UI库</p>\n"},{"title":"Angular4——5.数据绑定、响应式编程和管道","date":"2017-12-19T09:10:05.000Z","description":"Angular数据绑定、响应式编程、管道","_content":"\n# 数据绑定\n\nangularJS默认使用双向绑定，angular默认使用单向绑定\n\n## 插值表达式、属性绑定\n\n属性表达式和插值表达式是一个东西。\n\n```\n<img [src]=\"url\">\n//\n<img src=\"{{url}}\">\n```\n\n**Angular的模版绑定是通过DOM属性和事件来工作的，而不是HTML属性。**\n\n### DOM属性绑定\n\n插值表达式是DOM属性绑定。\n\nHtml属性和DOM属性的区别：\n\n```\n<input value=\"Tom\" (change)=\"inputChange($event)\">\n\ninputChange(event:any){\n  console.log(event.target.value);\t\t\t//这是DOM属性，value会随着输入的值而变化。DOM属性表示当前的值，DOM属性的值可以改变\n  console.log(event.target.getAttribute('value'));\t//这是Html属性，value不变。Html属性指定初始值，html属性的值不能改变\n}\n```\n\n### HTML属性绑定\n\n1. 基本html属性绑定\n\n   ```\n   <td [attr.colspan]=\"tableColspan\">Something</td>\n   ```\n\n2. css类绑定\n\n   ```\n   // [class]绑定的样式会替换class的样式，[class]等号右边的表达式的值字符串，内容是要绑定的样式名称\n   <div class=\"aaa bbb\" [class]=\"someExpression\">Something</div>\n\n   //[class.样式名称]不会覆盖已有的样式，等号右边是一个boolean值，为true则绑定样式\n   <div class=\"a b\" [class.special]=\"isSpecial\">Something</div>\n\n   //[ngClass]管理多个样式，等号右边是一个对象，key是样式名，值是表达式，返回true则绑定\n   <div [ngClass]=\"{aaa:isA, bbb:isB}\"></div>\n   ```\n\n3. 样式绑定\n\n   ```\n   <button [style.color]=\"isRed?'red':'blue'\"></button>\n\n   <button [ngStyle]=\"{'color':isRed?'red':'green'}</button>\n   ```\n\n### 什么时候使用HTML属性绑定\n\n应当优先使用DOM属性绑定，没有DOM属性的时候，使用HTML属性绑定。\n\n例如：\n\n表格的colspan属性是HTML属性，DOM属性中没有这个属性，如果使用DOM属性绑定，也就是插值表达式绑定该属性的话，浏览器会报错：\n\n```\n<table>\n\t<tr><td colspan=\"{{2}}\">Hello world</td></tr>\n</table>\n```\n\n由于td的colspan属性不是DOM属性，使用DOM属性绑定当然就会报错。\n\n改成HTML属性绑定就正确了：\n\n```\n<table>\n\t<tr><td [attr.colspan]=\"2\">Hello world</td></tr>\n</table>\n```\n\n## 事件绑定\n\n```\n<button (click)=\"onButtonClick($event)\">\n```\n\n`()`表示这是一个angular的事件绑定；\n\n`(click)`括号中的内容是事件的名称，这里是一个click事件\n\n`=`等号右侧是事件表达式，当绑定的事件触发时，右侧的事件表达式会被执行。表达式是组件控制器中的一个方法；\n\n`$event`是一个浏览器事件对象。如果处理事件的方法需要拿到事件本身这个对象。\n\n```\n<button (click)=\"save = true\">\n```\n\n`=`等号右侧的表达式不用必须是一个函数调用，也可以是一个赋值表达式。\n\n被绑定的事件不一定必须是标准的DOM事件，也可以是一个自定义事件。\n\n## 双向绑定\n\n```\n<input [(ngModel)]=\"name\">{{name}}</input>\n```\n\n\n\n# 响应式编程\n\n## 观察者模式与RxJS\n\n[RxJS中文文档](https://buctwbzs.gitbooks.io/rxjs/content/observer.html)。\n\n观察者模式由可观察对象和观察者对象两个对象组成。\n\n一般在初始化可观察对象时，会向可观察对象中注册一些观察者对象。\n\n当可观察对象发生变化时，会调用观察者对象中相应的方法，来处理这些变化。\n\n这种模式就叫观察者模式。\n\n```\nvar subscription = Observable.from([1,2,3,4])//Observable.from方法从数组[1,2,3,4]中创建一个流\n\t\t\t\t\t.filter((e) => e%2==0) //调用filter方法过滤这个流，把偶数选出来\n\t\t\t\t\t.map((e) => e*e)\t//调用map方法映射这个流，求偶数的平方\n\t\t\t\t\t.subscribe(\t//经过上面操作，此时拿到了一个包含偶数平方的流，订阅这个流，打印出来\n\t\t\t\t\t\te => console.log(e),\t// 4 16\n\t\t\t\t\t\terror => console.error(error),\n\t\t\t\t\t\t() => console.log(\"结束啦“)\n\t\t\t\t\t);\n```\n\n+ 可观察对象Observable（流）：表示一组值或事件的集合。可观察对象也叫流，因为它会像水流一样不停的依次发送值。\n\n  本例中1，2，3，4这四个值组成了一个可观察对象。也可以用事件生成一个可观察对象：\n\n  ```\n  var button = document.querySelector('button');\n  Observable.from(button,'click')\n  ```\n\n+ 观察者对象Observer：一个回调函数的集合，它知道怎样去监听被Observable发送的值。\n\n  在本例中`.subscribe()`方法的参数是三个函数，这三个函数组成的回调函数集合就是可观察对象`[1,2,3,4]`的观察者。当可观察对象发射出`1`这个值的时候，这个值就会被交给观察者的第一个回调函数处理`console.log(1)`。\n\n+ 订阅Subscription：表示一个可观察对象，主要用于取消注册。\n\n  当一个可观察对象调用`subscribe()`方法，也就是被订阅以后，会返回一个可观察对象，本例中就是`subscription`。这个可观察对象可以调用`unsubscribe()`方法取消订阅：\n\n  ```\n  subscription.unsubscribe();\n  ```\n\n  观察者里有三个回调函数，分别表示`next`、`error`、`complete`。\n\n  ```\n  var observer = {\n    next: x => console.log('Observer got a next value: ' + x),\n    error: err => console.error('Observer got an error: ' + err),\n    complete: () => console.log('Observer got a complete notification'),\n  };\n  observable.subscribe(observer);\n  ```\n\n  后两个可以省略。\n\n+ 操作符 Operators：纯粹的函数，使开发者可以以函数编程的方式处理集合。\n\n  在本例中，`filter()`、`map()`都是操作符，它们可以处理流中的数据。\n\nObservable对象是Rxjs库提供的，在angular中使用Observable进行响应式编程时需要引入RxJS库：\n\n```\nimport {Observable} from 'rxjs'\n```\n\n## 模版本地变量\n\nangular中提供了一个叫做*模版本地变量*的语法来方便获得Html元素。\n\n```\n//事件对象\n<input (keyup)=\"onKey($event)\">\nonKey(event:any){\n  console.log(event.target.value)\n}\n\n//模版本地变量\n<input #myFiled (keyup)=\"myFiled.value>\nonKey(value:string){\n  console.log(value);\n}\n```\n\n声明模版本地变量用`#`号，`#myFiled`。\n\n使用模版本地变量时不需要加`#`号，`myFiled`就是input标签。`myFiled.value`就能直接拿到input元素的值。\n\n## 使用响应式编程处理DOM事件\n\n传统JS中，对DOM事件的处理是一次性的。例如click事件，每点击一次鼠标，所对应的方法被调用一次。\n\n在Angular中，将事件作为永不结束的流来处理。\n\n### 1.引入ReactiveFormsModule模块\n\n```\n// app.module.ts\nimport {ReactiveFormsModule} from '@angular/forms';\n\n@NgModule({\n  imports:[ReavtiveFormsModule]\n})\n```\n\n这个模块是angular中用来做响应式编程的模块。\n\n### 2.使用FormControl类绑定Html元素\n\nFormControl是angular进行表单处理时常用的类。\n\n```\n// ex.html\n<input [formControl]=\"searchInput\" (keyup)=\"onKey()\">\n\n// ex.component.ts\nexport class ExComponent implements OnInit{\n  searchInput: FormControl = new FormControl();\n  constructor(){\n    this.searchInput.valueChanges.debounceTime(500).subscribe(\n    \te => console.log(e)\n    )\n  }\n}\n```\n\nvalueChanges是一个Observable可观察对象，每当被控制的元素的值发生变化，valueChanges就会发射一个流。\n\ndebounceTime是Observable可观察对象的方法，作用是延迟。该方法不属于angular，来自RxJS库的Observable对象，因此使用该方法要引入RxJS库。\n\n\n\n# 管道\n\n```\n// ts\nbirthday:Date = new Date();\n\n// html\n<div>我的生日是：{{birthday}}</div>\n\n// 我的生日是：Thu Dec 21 2017 15:01:10 GMT+0800 (CST)\n```\n\n使用管道格式化数据：\n\n```\n// html\n<div>我的生日是：{{birthday | date}}</div>\n\n// 我的生日是：Dec 21,2017\n```\n\n多个管道可以组合使用：\n\n```\n// html\n<div>我的生日是：{{birthday | date | uppercase}}</div>\n\n// 我的生日是：DEC 21,2017\n```\n\nangular内置了一些管道，如date，uppercase，lowercase等。\n\n一些复杂的管道可以接受参数，比如date管道：\n\n```\n// html\n<div>我的生日是：{{birthday | date:'yyyy-MM-dd HH:mm:ss'}}</div>\n\n// 我的生日是：2017-12-21 16:00:00\n```\n\ndate管道接受一个参数，该参数指定当前的日期格式化的形式，yyyy表示年（2017），大写的MM表示月（12），dd表示日（21），大写的HH表示24小时制的时（16），相反小写的hh表示12小时制的时（04），小写的mm表示分（00），ss表示秒（00）。\n\n## 自定义管道\n\n一 生成管道文件\n\n`ng g pipe XXXX`\n\n管道需要声明在模块中\n\n```\n// app.module.ts\n@NgModule({\n  declaration:[XXXXPipe]\n})\n```\n\n```\n// pipeName.pipe.ts\nimport {Pipe,PipeTransform} from '@angular/core';\n\n@Pipe({\n  name: 'XXXX'\n})\nexport class XXXXPipe implements PipeTransform{\n  transform(value: any, arg?: any): any{\n    return undefined\n  }\n}\n```\n\nvalue参数是在模版中，传入管道的原始值。\n\narg参数是管道可接受的参数，比如date管道接受的`'yyyy-MM-dd HH:mm:ss'`。\n\n管道可以接收多个参数：\n\n```\ntransform(value:any, arg?;any, arg2?:any...):any{\n  return undefined\n}\n\n<div>{{value | pipe:arg:arg2:....}}</div> \n```\n\n例子：写一个乘法管道\n\n```\n// multiply.pipe.ts\n@Pipe({\n  name:'multiply'\n})\nexport class MultiplyPipe implements PipeTransform{\n  transform(value:any, arg?:any):any{\n    if(!arg){\n      arg = 1;\n    }\n    return value * arg;\n  }\n}\n\n// ex.component.html\n// 假设num的值为 5\n<div>{{num | multiply}}</div>\t// 5\n<div>{{num | nultiply:'2'}}</div>\t// 10\n```","source":"_posts/Angular4——5-数据绑定、响应式编程和管道.md","raw":"---\ntitle: Angular4——5.数据绑定、响应式编程和管道\ndate: 2017-12-19 17:10:05\ntags:\n- Angular\ncategories:\n- 学习笔记\ndescription: Angular数据绑定、响应式编程、管道\n---\n\n# 数据绑定\n\nangularJS默认使用双向绑定，angular默认使用单向绑定\n\n## 插值表达式、属性绑定\n\n属性表达式和插值表达式是一个东西。\n\n```\n<img [src]=\"url\">\n//\n<img src=\"{{url}}\">\n```\n\n**Angular的模版绑定是通过DOM属性和事件来工作的，而不是HTML属性。**\n\n### DOM属性绑定\n\n插值表达式是DOM属性绑定。\n\nHtml属性和DOM属性的区别：\n\n```\n<input value=\"Tom\" (change)=\"inputChange($event)\">\n\ninputChange(event:any){\n  console.log(event.target.value);\t\t\t//这是DOM属性，value会随着输入的值而变化。DOM属性表示当前的值，DOM属性的值可以改变\n  console.log(event.target.getAttribute('value'));\t//这是Html属性，value不变。Html属性指定初始值，html属性的值不能改变\n}\n```\n\n### HTML属性绑定\n\n1. 基本html属性绑定\n\n   ```\n   <td [attr.colspan]=\"tableColspan\">Something</td>\n   ```\n\n2. css类绑定\n\n   ```\n   // [class]绑定的样式会替换class的样式，[class]等号右边的表达式的值字符串，内容是要绑定的样式名称\n   <div class=\"aaa bbb\" [class]=\"someExpression\">Something</div>\n\n   //[class.样式名称]不会覆盖已有的样式，等号右边是一个boolean值，为true则绑定样式\n   <div class=\"a b\" [class.special]=\"isSpecial\">Something</div>\n\n   //[ngClass]管理多个样式，等号右边是一个对象，key是样式名，值是表达式，返回true则绑定\n   <div [ngClass]=\"{aaa:isA, bbb:isB}\"></div>\n   ```\n\n3. 样式绑定\n\n   ```\n   <button [style.color]=\"isRed?'red':'blue'\"></button>\n\n   <button [ngStyle]=\"{'color':isRed?'red':'green'}</button>\n   ```\n\n### 什么时候使用HTML属性绑定\n\n应当优先使用DOM属性绑定，没有DOM属性的时候，使用HTML属性绑定。\n\n例如：\n\n表格的colspan属性是HTML属性，DOM属性中没有这个属性，如果使用DOM属性绑定，也就是插值表达式绑定该属性的话，浏览器会报错：\n\n```\n<table>\n\t<tr><td colspan=\"{{2}}\">Hello world</td></tr>\n</table>\n```\n\n由于td的colspan属性不是DOM属性，使用DOM属性绑定当然就会报错。\n\n改成HTML属性绑定就正确了：\n\n```\n<table>\n\t<tr><td [attr.colspan]=\"2\">Hello world</td></tr>\n</table>\n```\n\n## 事件绑定\n\n```\n<button (click)=\"onButtonClick($event)\">\n```\n\n`()`表示这是一个angular的事件绑定；\n\n`(click)`括号中的内容是事件的名称，这里是一个click事件\n\n`=`等号右侧是事件表达式，当绑定的事件触发时，右侧的事件表达式会被执行。表达式是组件控制器中的一个方法；\n\n`$event`是一个浏览器事件对象。如果处理事件的方法需要拿到事件本身这个对象。\n\n```\n<button (click)=\"save = true\">\n```\n\n`=`等号右侧的表达式不用必须是一个函数调用，也可以是一个赋值表达式。\n\n被绑定的事件不一定必须是标准的DOM事件，也可以是一个自定义事件。\n\n## 双向绑定\n\n```\n<input [(ngModel)]=\"name\">{{name}}</input>\n```\n\n\n\n# 响应式编程\n\n## 观察者模式与RxJS\n\n[RxJS中文文档](https://buctwbzs.gitbooks.io/rxjs/content/observer.html)。\n\n观察者模式由可观察对象和观察者对象两个对象组成。\n\n一般在初始化可观察对象时，会向可观察对象中注册一些观察者对象。\n\n当可观察对象发生变化时，会调用观察者对象中相应的方法，来处理这些变化。\n\n这种模式就叫观察者模式。\n\n```\nvar subscription = Observable.from([1,2,3,4])//Observable.from方法从数组[1,2,3,4]中创建一个流\n\t\t\t\t\t.filter((e) => e%2==0) //调用filter方法过滤这个流，把偶数选出来\n\t\t\t\t\t.map((e) => e*e)\t//调用map方法映射这个流，求偶数的平方\n\t\t\t\t\t.subscribe(\t//经过上面操作，此时拿到了一个包含偶数平方的流，订阅这个流，打印出来\n\t\t\t\t\t\te => console.log(e),\t// 4 16\n\t\t\t\t\t\terror => console.error(error),\n\t\t\t\t\t\t() => console.log(\"结束啦“)\n\t\t\t\t\t);\n```\n\n+ 可观察对象Observable（流）：表示一组值或事件的集合。可观察对象也叫流，因为它会像水流一样不停的依次发送值。\n\n  本例中1，2，3，4这四个值组成了一个可观察对象。也可以用事件生成一个可观察对象：\n\n  ```\n  var button = document.querySelector('button');\n  Observable.from(button,'click')\n  ```\n\n+ 观察者对象Observer：一个回调函数的集合，它知道怎样去监听被Observable发送的值。\n\n  在本例中`.subscribe()`方法的参数是三个函数，这三个函数组成的回调函数集合就是可观察对象`[1,2,3,4]`的观察者。当可观察对象发射出`1`这个值的时候，这个值就会被交给观察者的第一个回调函数处理`console.log(1)`。\n\n+ 订阅Subscription：表示一个可观察对象，主要用于取消注册。\n\n  当一个可观察对象调用`subscribe()`方法，也就是被订阅以后，会返回一个可观察对象，本例中就是`subscription`。这个可观察对象可以调用`unsubscribe()`方法取消订阅：\n\n  ```\n  subscription.unsubscribe();\n  ```\n\n  观察者里有三个回调函数，分别表示`next`、`error`、`complete`。\n\n  ```\n  var observer = {\n    next: x => console.log('Observer got a next value: ' + x),\n    error: err => console.error('Observer got an error: ' + err),\n    complete: () => console.log('Observer got a complete notification'),\n  };\n  observable.subscribe(observer);\n  ```\n\n  后两个可以省略。\n\n+ 操作符 Operators：纯粹的函数，使开发者可以以函数编程的方式处理集合。\n\n  在本例中，`filter()`、`map()`都是操作符，它们可以处理流中的数据。\n\nObservable对象是Rxjs库提供的，在angular中使用Observable进行响应式编程时需要引入RxJS库：\n\n```\nimport {Observable} from 'rxjs'\n```\n\n## 模版本地变量\n\nangular中提供了一个叫做*模版本地变量*的语法来方便获得Html元素。\n\n```\n//事件对象\n<input (keyup)=\"onKey($event)\">\nonKey(event:any){\n  console.log(event.target.value)\n}\n\n//模版本地变量\n<input #myFiled (keyup)=\"myFiled.value>\nonKey(value:string){\n  console.log(value);\n}\n```\n\n声明模版本地变量用`#`号，`#myFiled`。\n\n使用模版本地变量时不需要加`#`号，`myFiled`就是input标签。`myFiled.value`就能直接拿到input元素的值。\n\n## 使用响应式编程处理DOM事件\n\n传统JS中，对DOM事件的处理是一次性的。例如click事件，每点击一次鼠标，所对应的方法被调用一次。\n\n在Angular中，将事件作为永不结束的流来处理。\n\n### 1.引入ReactiveFormsModule模块\n\n```\n// app.module.ts\nimport {ReactiveFormsModule} from '@angular/forms';\n\n@NgModule({\n  imports:[ReavtiveFormsModule]\n})\n```\n\n这个模块是angular中用来做响应式编程的模块。\n\n### 2.使用FormControl类绑定Html元素\n\nFormControl是angular进行表单处理时常用的类。\n\n```\n// ex.html\n<input [formControl]=\"searchInput\" (keyup)=\"onKey()\">\n\n// ex.component.ts\nexport class ExComponent implements OnInit{\n  searchInput: FormControl = new FormControl();\n  constructor(){\n    this.searchInput.valueChanges.debounceTime(500).subscribe(\n    \te => console.log(e)\n    )\n  }\n}\n```\n\nvalueChanges是一个Observable可观察对象，每当被控制的元素的值发生变化，valueChanges就会发射一个流。\n\ndebounceTime是Observable可观察对象的方法，作用是延迟。该方法不属于angular，来自RxJS库的Observable对象，因此使用该方法要引入RxJS库。\n\n\n\n# 管道\n\n```\n// ts\nbirthday:Date = new Date();\n\n// html\n<div>我的生日是：{{birthday}}</div>\n\n// 我的生日是：Thu Dec 21 2017 15:01:10 GMT+0800 (CST)\n```\n\n使用管道格式化数据：\n\n```\n// html\n<div>我的生日是：{{birthday | date}}</div>\n\n// 我的生日是：Dec 21,2017\n```\n\n多个管道可以组合使用：\n\n```\n// html\n<div>我的生日是：{{birthday | date | uppercase}}</div>\n\n// 我的生日是：DEC 21,2017\n```\n\nangular内置了一些管道，如date，uppercase，lowercase等。\n\n一些复杂的管道可以接受参数，比如date管道：\n\n```\n// html\n<div>我的生日是：{{birthday | date:'yyyy-MM-dd HH:mm:ss'}}</div>\n\n// 我的生日是：2017-12-21 16:00:00\n```\n\ndate管道接受一个参数，该参数指定当前的日期格式化的形式，yyyy表示年（2017），大写的MM表示月（12），dd表示日（21），大写的HH表示24小时制的时（16），相反小写的hh表示12小时制的时（04），小写的mm表示分（00），ss表示秒（00）。\n\n## 自定义管道\n\n一 生成管道文件\n\n`ng g pipe XXXX`\n\n管道需要声明在模块中\n\n```\n// app.module.ts\n@NgModule({\n  declaration:[XXXXPipe]\n})\n```\n\n```\n// pipeName.pipe.ts\nimport {Pipe,PipeTransform} from '@angular/core';\n\n@Pipe({\n  name: 'XXXX'\n})\nexport class XXXXPipe implements PipeTransform{\n  transform(value: any, arg?: any): any{\n    return undefined\n  }\n}\n```\n\nvalue参数是在模版中，传入管道的原始值。\n\narg参数是管道可接受的参数，比如date管道接受的`'yyyy-MM-dd HH:mm:ss'`。\n\n管道可以接收多个参数：\n\n```\ntransform(value:any, arg?;any, arg2?:any...):any{\n  return undefined\n}\n\n<div>{{value | pipe:arg:arg2:....}}</div> \n```\n\n例子：写一个乘法管道\n\n```\n// multiply.pipe.ts\n@Pipe({\n  name:'multiply'\n})\nexport class MultiplyPipe implements PipeTransform{\n  transform(value:any, arg?:any):any{\n    if(!arg){\n      arg = 1;\n    }\n    return value * arg;\n  }\n}\n\n// ex.component.html\n// 假设num的值为 5\n<div>{{num | multiply}}</div>\t// 5\n<div>{{num | nultiply:'2'}}</div>\t// 10\n```","slug":"Angular4——5-数据绑定、响应式编程和管道","published":1,"updated":"2021-05-08T15:00:49.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbo80008wct46l96flbf","content":"<h1 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h1><p>angularJS默认使用双向绑定，angular默认使用单向绑定</p>\n<h2 id=\"插值表达式、属性绑定\"><a href=\"#插值表达式、属性绑定\" class=\"headerlink\" title=\"插值表达式、属性绑定\"></a>插值表达式、属性绑定</h2><p>属性表达式和插值表达式是一个东西。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img [src]&#x3D;&quot;url&quot;&gt;</span><br><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\">&lt;img src&#x3D;&quot;&#123;&#123;url&#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Angular的模版绑定是通过DOM属性和事件来工作的，而不是HTML属性。</strong></p>\n<h3 id=\"DOM属性绑定\"><a href=\"#DOM属性绑定\" class=\"headerlink\" title=\"DOM属性绑定\"></a>DOM属性绑定</h3><p>插值表达式是DOM属性绑定。</p>\n<p>Html属性和DOM属性的区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input value&#x3D;&quot;Tom&quot; (change)&#x3D;&quot;inputChange($event)&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">inputChange(event:any)&#123;</span><br><span class=\"line\">  console.log(event.target.value);\t\t\t&#x2F;&#x2F;这是DOM属性，value会随着输入的值而变化。DOM属性表示当前的值，DOM属性的值可以改变</span><br><span class=\"line\">  console.log(event.target.getAttribute(&#39;value&#39;));\t&#x2F;&#x2F;这是Html属性，value不变。Html属性指定初始值，html属性的值不能改变</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTML属性绑定\"><a href=\"#HTML属性绑定\" class=\"headerlink\" title=\"HTML属性绑定\"></a>HTML属性绑定</h3><ol>\n<li><p>基本html属性绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td [attr.colspan]&#x3D;&quot;tableColspan&quot;&gt;Something&lt;&#x2F;td&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>css类绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; [class]绑定的样式会替换class的样式，[class]等号右边的表达式的值字符串，内容是要绑定的样式名称</span><br><span class=\"line\">&lt;div class&#x3D;&quot;aaa bbb&quot; [class]&#x3D;&quot;someExpression&quot;&gt;Something&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;[class.样式名称]不会覆盖已有的样式，等号右边是一个boolean值，为true则绑定样式</span><br><span class=\"line\">&lt;div class&#x3D;&quot;a b&quot; [class.special]&#x3D;&quot;isSpecial&quot;&gt;Something&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;[ngClass]管理多个样式，等号右边是一个对象，key是样式名，值是表达式，返回true则绑定</span><br><span class=\"line\">&lt;div [ngClass]&#x3D;&quot;&#123;aaa:isA, bbb:isB&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>样式绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button [style.color]&#x3D;&quot;isRed?&#39;red&#39;:&#39;blue&#39;&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;button [ngStyle]&#x3D;&quot;&#123;&#39;color&#39;:isRed?&#39;red&#39;:&#39;green&#39;&#125;&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"什么时候使用HTML属性绑定\"><a href=\"#什么时候使用HTML属性绑定\" class=\"headerlink\" title=\"什么时候使用HTML属性绑定\"></a>什么时候使用HTML属性绑定</h3><p>应当优先使用DOM属性绑定，没有DOM属性的时候，使用HTML属性绑定。</p>\n<p>例如：</p>\n<p>表格的colspan属性是HTML属性，DOM属性中没有这个属性，如果使用DOM属性绑定，也就是插值表达式绑定该属性的话，浏览器会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">\t&lt;tr&gt;&lt;td colspan&#x3D;&quot;&#123;&#123;2&#125;&#125;&quot;&gt;Hello world&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class=\"line\">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>\n\n<p>由于td的colspan属性不是DOM属性，使用DOM属性绑定当然就会报错。</p>\n<p>改成HTML属性绑定就正确了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">\t&lt;tr&gt;&lt;td [attr.colspan]&#x3D;&quot;2&quot;&gt;Hello world&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class=\"line\">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button (click)&#x3D;&quot;onButtonClick($event)&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>()</code>表示这是一个angular的事件绑定；</p>\n<p><code>(click)</code>括号中的内容是事件的名称，这里是一个click事件</p>\n<p><code>=</code>等号右侧是事件表达式，当绑定的事件触发时，右侧的事件表达式会被执行。表达式是组件控制器中的一个方法；</p>\n<p><code>$event</code>是一个浏览器事件对象。如果处理事件的方法需要拿到事件本身这个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button (click)&#x3D;&quot;save &#x3D; true&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>=</code>等号右侧的表达式不用必须是一个函数调用，也可以是一个赋值表达式。</p>\n<p>被绑定的事件不一定必须是标准的DOM事件，也可以是一个自定义事件。</p>\n<h2 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input [(ngModel)]&#x3D;&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h1><h2 id=\"观察者模式与RxJS\"><a href=\"#观察者模式与RxJS\" class=\"headerlink\" title=\"观察者模式与RxJS\"></a>观察者模式与RxJS</h2><p><a href=\"https://buctwbzs.gitbooks.io/rxjs/content/observer.html\">RxJS中文文档</a>。</p>\n<p>观察者模式由可观察对象和观察者对象两个对象组成。</p>\n<p>一般在初始化可观察对象时，会向可观察对象中注册一些观察者对象。</p>\n<p>当可观察对象发生变化时，会调用观察者对象中相应的方法，来处理这些变化。</p>\n<p>这种模式就叫观察者模式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var subscription &#x3D; Observable.from([1,2,3,4])&#x2F;&#x2F;Observable.from方法从数组[1,2,3,4]中创建一个流</span><br><span class=\"line\">\t\t\t\t\t.filter((e) &#x3D;&gt; e%2&#x3D;&#x3D;0) &#x2F;&#x2F;调用filter方法过滤这个流，把偶数选出来</span><br><span class=\"line\">\t\t\t\t\t.map((e) &#x3D;&gt; e*e)\t&#x2F;&#x2F;调用map方法映射这个流，求偶数的平方</span><br><span class=\"line\">\t\t\t\t\t.subscribe(\t&#x2F;&#x2F;经过上面操作，此时拿到了一个包含偶数平方的流，订阅这个流，打印出来</span><br><span class=\"line\">\t\t\t\t\t\te &#x3D;&gt; console.log(e),\t&#x2F;&#x2F; 4 16</span><br><span class=\"line\">\t\t\t\t\t\terror &#x3D;&gt; console.error(error),</span><br><span class=\"line\">\t\t\t\t\t\t() &#x3D;&gt; console.log(&quot;结束啦“)</span><br><span class=\"line\">\t\t\t\t\t);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>可观察对象Observable（流）：表示一组值或事件的集合。可观察对象也叫流，因为它会像水流一样不停的依次发送值。</p>\n<p>本例中1，2，3，4这四个值组成了一个可观察对象。也可以用事件生成一个可观察对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var button &#x3D; document.querySelector(&#39;button&#39;);</span><br><span class=\"line\">Observable.from(button,&#39;click&#39;)</span><br></pre></td></tr></table></figure></li>\n<li><p>观察者对象Observer：一个回调函数的集合，它知道怎样去监听被Observable发送的值。</p>\n<p>在本例中<code>.subscribe()</code>方法的参数是三个函数，这三个函数组成的回调函数集合就是可观察对象<code>[1,2,3,4]</code>的观察者。当可观察对象发射出<code>1</code>这个值的时候，这个值就会被交给观察者的第一个回调函数处理<code>console.log(1)</code>。</p>\n</li>\n<li><p>订阅Subscription：表示一个可观察对象，主要用于取消注册。</p>\n<p>当一个可观察对象调用<code>subscribe()</code>方法，也就是被订阅以后，会返回一个可观察对象，本例中就是<code>subscription</code>。这个可观察对象可以调用<code>unsubscribe()</code>方法取消订阅：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subscription.unsubscribe();</span><br></pre></td></tr></table></figure>\n\n<p>观察者里有三个回调函数，分别表示<code>next</code>、<code>error</code>、<code>complete</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var observer &#x3D; &#123;</span><br><span class=\"line\">  next: x &#x3D;&gt; console.log(&#39;Observer got a next value: &#39; + x),</span><br><span class=\"line\">  error: err &#x3D;&gt; console.error(&#39;Observer got an error: &#39; + err),</span><br><span class=\"line\">  complete: () &#x3D;&gt; console.log(&#39;Observer got a complete notification&#39;),</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">observable.subscribe(observer);</span><br></pre></td></tr></table></figure>\n\n<p>后两个可以省略。</p>\n</li>\n<li><p>操作符 Operators：纯粹的函数，使开发者可以以函数编程的方式处理集合。</p>\n<p>在本例中，<code>filter()</code>、<code>map()</code>都是操作符，它们可以处理流中的数据。</p>\n</li>\n</ul>\n<p>Observable对象是Rxjs库提供的，在angular中使用Observable进行响应式编程时需要引入RxJS库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;Observable&#125; from &#39;rxjs&#39;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模版本地变量\"><a href=\"#模版本地变量\" class=\"headerlink\" title=\"模版本地变量\"></a>模版本地变量</h2><p>angular中提供了一个叫做<em>模版本地变量</em>的语法来方便获得Html元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;事件对象</span><br><span class=\"line\">&lt;input (keyup)&#x3D;&quot;onKey($event)&quot;&gt;</span><br><span class=\"line\">onKey(event:any)&#123;</span><br><span class=\"line\">  console.log(event.target.value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;模版本地变量</span><br><span class=\"line\">&lt;input #myFiled (keyup)&#x3D;&quot;myFiled.value&gt;</span><br><span class=\"line\">onKey(value:string)&#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>声明模版本地变量用<code>#</code>号，<code>#myFiled</code>。</p>\n<p>使用模版本地变量时不需要加<code>#</code>号，<code>myFiled</code>就是input标签。<code>myFiled.value</code>就能直接拿到input元素的值。</p>\n<h2 id=\"使用响应式编程处理DOM事件\"><a href=\"#使用响应式编程处理DOM事件\" class=\"headerlink\" title=\"使用响应式编程处理DOM事件\"></a>使用响应式编程处理DOM事件</h2><p>传统JS中，对DOM事件的处理是一次性的。例如click事件，每点击一次鼠标，所对应的方法被调用一次。</p>\n<p>在Angular中，将事件作为永不结束的流来处理。</p>\n<h3 id=\"1-引入ReactiveFormsModule模块\"><a href=\"#1-引入ReactiveFormsModule模块\" class=\"headerlink\" title=\"1.引入ReactiveFormsModule模块\"></a>1.引入ReactiveFormsModule模块</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123;ReactiveFormsModule&#125; from &#39;@angular&#x2F;forms&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[ReavtiveFormsModule]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这个模块是angular中用来做响应式编程的模块。</p>\n<h3 id=\"2-使用FormControl类绑定Html元素\"><a href=\"#2-使用FormControl类绑定Html元素\" class=\"headerlink\" title=\"2.使用FormControl类绑定Html元素\"></a>2.使用FormControl类绑定Html元素</h3><p>FormControl是angular进行表单处理时常用的类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; ex.html</span><br><span class=\"line\">&lt;input [formControl]&#x3D;&quot;searchInput&quot; (keyup)&#x3D;&quot;onKey()&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; ex.component.ts</span><br><span class=\"line\">export class ExComponent implements OnInit&#123;</span><br><span class=\"line\">  searchInput: FormControl &#x3D; new FormControl();</span><br><span class=\"line\">  constructor()&#123;</span><br><span class=\"line\">    this.searchInput.valueChanges.debounceTime(500).subscribe(</span><br><span class=\"line\">    \te &#x3D;&gt; console.log(e)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>valueChanges是一个Observable可观察对象，每当被控制的元素的值发生变化，valueChanges就会发射一个流。</p>\n<p>debounceTime是Observable可观察对象的方法，作用是延迟。该方法不属于angular，来自RxJS库的Observable对象，因此使用该方法要引入RxJS库。</p>\n<h1 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; ts</span><br><span class=\"line\">birthday:Date &#x3D; new Date();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; html</span><br><span class=\"line\">&lt;div&gt;我的生日是：&#123;&#123;birthday&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 我的生日是：Thu Dec 21 2017 15:01:10 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>\n\n<p>使用管道格式化数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; html</span><br><span class=\"line\">&lt;div&gt;我的生日是：&#123;&#123;birthday | date&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 我的生日是：Dec 21,2017</span><br></pre></td></tr></table></figure>\n\n<p>多个管道可以组合使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; html</span><br><span class=\"line\">&lt;div&gt;我的生日是：&#123;&#123;birthday | date | uppercase&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 我的生日是：DEC 21,2017</span><br></pre></td></tr></table></figure>\n\n<p>angular内置了一些管道，如date，uppercase，lowercase等。</p>\n<p>一些复杂的管道可以接受参数，比如date管道：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; html</span><br><span class=\"line\">&lt;div&gt;我的生日是：&#123;&#123;birthday | date:&#39;yyyy-MM-dd HH:mm:ss&#39;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 我的生日是：2017-12-21 16:00:00</span><br></pre></td></tr></table></figure>\n\n<p>date管道接受一个参数，该参数指定当前的日期格式化的形式，yyyy表示年（2017），大写的MM表示月（12），dd表示日（21），大写的HH表示24小时制的时（16），相反小写的hh表示12小时制的时（04），小写的mm表示分（00），ss表示秒（00）。</p>\n<h2 id=\"自定义管道\"><a href=\"#自定义管道\" class=\"headerlink\" title=\"自定义管道\"></a>自定义管道</h2><p>一 生成管道文件</p>\n<p><code>ng g pipe XXXX</code></p>\n<p>管道需要声明在模块中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  declaration:[XXXXPipe]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; pipeName.pipe.ts</span><br><span class=\"line\">import &#123;Pipe,PipeTransform&#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">@Pipe(&#123;</span><br><span class=\"line\">  name: &#39;XXXX&#39;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class XXXXPipe implements PipeTransform&#123;</span><br><span class=\"line\">  transform(value: any, arg?: any): any&#123;</span><br><span class=\"line\">    return undefined</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>value参数是在模版中，传入管道的原始值。</p>\n<p>arg参数是管道可接受的参数，比如date管道接受的<code>&#39;yyyy-MM-dd HH:mm:ss&#39;</code>。</p>\n<p>管道可以接收多个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform(value:any, arg?;any, arg2?:any...):any&#123;</span><br><span class=\"line\">  return undefined</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123;value | pipe:arg:arg2:....&#125;&#125;&lt;&#x2F;div&gt; </span><br></pre></td></tr></table></figure>\n\n<p>例子：写一个乘法管道</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; multiply.pipe.ts</span><br><span class=\"line\">@Pipe(&#123;</span><br><span class=\"line\">  name:&#39;multiply&#39;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class MultiplyPipe implements PipeTransform&#123;</span><br><span class=\"line\">  transform(value:any, arg?:any):any&#123;</span><br><span class=\"line\">    if(!arg)&#123;</span><br><span class=\"line\">      arg &#x3D; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return value * arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; ex.component.html</span><br><span class=\"line\">&#x2F;&#x2F; 假设num的值为 5</span><br><span class=\"line\">&lt;div&gt;&#123;&#123;num | multiply&#125;&#125;&lt;&#x2F;div&gt;\t&#x2F;&#x2F; 5</span><br><span class=\"line\">&lt;div&gt;&#123;&#123;num | nultiply:&#39;2&#39;&#125;&#125;&lt;&#x2F;div&gt;\t&#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h1><p>angularJS默认使用双向绑定，angular默认使用单向绑定</p>\n<h2 id=\"插值表达式、属性绑定\"><a href=\"#插值表达式、属性绑定\" class=\"headerlink\" title=\"插值表达式、属性绑定\"></a>插值表达式、属性绑定</h2><p>属性表达式和插值表达式是一个东西。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img [src]&#x3D;&quot;url&quot;&gt;</span><br><span class=\"line\">&#x2F;&#x2F;</span><br><span class=\"line\">&lt;img src&#x3D;&quot;&#123;&#123;url&#125;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>Angular的模版绑定是通过DOM属性和事件来工作的，而不是HTML属性。</strong></p>\n<h3 id=\"DOM属性绑定\"><a href=\"#DOM属性绑定\" class=\"headerlink\" title=\"DOM属性绑定\"></a>DOM属性绑定</h3><p>插值表达式是DOM属性绑定。</p>\n<p>Html属性和DOM属性的区别：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input value&#x3D;&quot;Tom&quot; (change)&#x3D;&quot;inputChange($event)&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">inputChange(event:any)&#123;</span><br><span class=\"line\">  console.log(event.target.value);\t\t\t&#x2F;&#x2F;这是DOM属性，value会随着输入的值而变化。DOM属性表示当前的值，DOM属性的值可以改变</span><br><span class=\"line\">  console.log(event.target.getAttribute(&#39;value&#39;));\t&#x2F;&#x2F;这是Html属性，value不变。Html属性指定初始值，html属性的值不能改变</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"HTML属性绑定\"><a href=\"#HTML属性绑定\" class=\"headerlink\" title=\"HTML属性绑定\"></a>HTML属性绑定</h3><ol>\n<li><p>基本html属性绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td [attr.colspan]&#x3D;&quot;tableColspan&quot;&gt;Something&lt;&#x2F;td&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>css类绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; [class]绑定的样式会替换class的样式，[class]等号右边的表达式的值字符串，内容是要绑定的样式名称</span><br><span class=\"line\">&lt;div class&#x3D;&quot;aaa bbb&quot; [class]&#x3D;&quot;someExpression&quot;&gt;Something&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;[class.样式名称]不会覆盖已有的样式，等号右边是一个boolean值，为true则绑定样式</span><br><span class=\"line\">&lt;div class&#x3D;&quot;a b&quot; [class.special]&#x3D;&quot;isSpecial&quot;&gt;Something&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;[ngClass]管理多个样式，等号右边是一个对象，key是样式名，值是表达式，返回true则绑定</span><br><span class=\"line\">&lt;div [ngClass]&#x3D;&quot;&#123;aaa:isA, bbb:isB&#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>样式绑定</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button [style.color]&#x3D;&quot;isRed?&#39;red&#39;:&#39;blue&#39;&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;button [ngStyle]&#x3D;&quot;&#123;&#39;color&#39;:isRed?&#39;red&#39;:&#39;green&#39;&#125;&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"什么时候使用HTML属性绑定\"><a href=\"#什么时候使用HTML属性绑定\" class=\"headerlink\" title=\"什么时候使用HTML属性绑定\"></a>什么时候使用HTML属性绑定</h3><p>应当优先使用DOM属性绑定，没有DOM属性的时候，使用HTML属性绑定。</p>\n<p>例如：</p>\n<p>表格的colspan属性是HTML属性，DOM属性中没有这个属性，如果使用DOM属性绑定，也就是插值表达式绑定该属性的话，浏览器会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">\t&lt;tr&gt;&lt;td colspan&#x3D;&quot;&#123;&#123;2&#125;&#125;&quot;&gt;Hello world&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class=\"line\">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>\n\n<p>由于td的colspan属性不是DOM属性，使用DOM属性绑定当然就会报错。</p>\n<p>改成HTML属性绑定就正确了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;table&gt;</span><br><span class=\"line\">\t&lt;tr&gt;&lt;td [attr.colspan]&#x3D;&quot;2&quot;&gt;Hello world&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class=\"line\">&lt;&#x2F;table&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button (click)&#x3D;&quot;onButtonClick($event)&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>()</code>表示这是一个angular的事件绑定；</p>\n<p><code>(click)</code>括号中的内容是事件的名称，这里是一个click事件</p>\n<p><code>=</code>等号右侧是事件表达式，当绑定的事件触发时，右侧的事件表达式会被执行。表达式是组件控制器中的一个方法；</p>\n<p><code>$event</code>是一个浏览器事件对象。如果处理事件的方法需要拿到事件本身这个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button (click)&#x3D;&quot;save &#x3D; true&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<p><code>=</code>等号右侧的表达式不用必须是一个函数调用，也可以是一个赋值表达式。</p>\n<p>被绑定的事件不一定必须是标准的DOM事件，也可以是一个自定义事件。</p>\n<h2 id=\"双向绑定\"><a href=\"#双向绑定\" class=\"headerlink\" title=\"双向绑定\"></a>双向绑定</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input [(ngModel)]&#x3D;&quot;name&quot;&gt;&#123;&#123;name&#125;&#125;&lt;&#x2F;input&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h1><h2 id=\"观察者模式与RxJS\"><a href=\"#观察者模式与RxJS\" class=\"headerlink\" title=\"观察者模式与RxJS\"></a>观察者模式与RxJS</h2><p><a href=\"https://buctwbzs.gitbooks.io/rxjs/content/observer.html\">RxJS中文文档</a>。</p>\n<p>观察者模式由可观察对象和观察者对象两个对象组成。</p>\n<p>一般在初始化可观察对象时，会向可观察对象中注册一些观察者对象。</p>\n<p>当可观察对象发生变化时，会调用观察者对象中相应的方法，来处理这些变化。</p>\n<p>这种模式就叫观察者模式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var subscription &#x3D; Observable.from([1,2,3,4])&#x2F;&#x2F;Observable.from方法从数组[1,2,3,4]中创建一个流</span><br><span class=\"line\">\t\t\t\t\t.filter((e) &#x3D;&gt; e%2&#x3D;&#x3D;0) &#x2F;&#x2F;调用filter方法过滤这个流，把偶数选出来</span><br><span class=\"line\">\t\t\t\t\t.map((e) &#x3D;&gt; e*e)\t&#x2F;&#x2F;调用map方法映射这个流，求偶数的平方</span><br><span class=\"line\">\t\t\t\t\t.subscribe(\t&#x2F;&#x2F;经过上面操作，此时拿到了一个包含偶数平方的流，订阅这个流，打印出来</span><br><span class=\"line\">\t\t\t\t\t\te &#x3D;&gt; console.log(e),\t&#x2F;&#x2F; 4 16</span><br><span class=\"line\">\t\t\t\t\t\terror &#x3D;&gt; console.error(error),</span><br><span class=\"line\">\t\t\t\t\t\t() &#x3D;&gt; console.log(&quot;结束啦“)</span><br><span class=\"line\">\t\t\t\t\t);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>可观察对象Observable（流）：表示一组值或事件的集合。可观察对象也叫流，因为它会像水流一样不停的依次发送值。</p>\n<p>本例中1，2，3，4这四个值组成了一个可观察对象。也可以用事件生成一个可观察对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var button &#x3D; document.querySelector(&#39;button&#39;);</span><br><span class=\"line\">Observable.from(button,&#39;click&#39;)</span><br></pre></td></tr></table></figure></li>\n<li><p>观察者对象Observer：一个回调函数的集合，它知道怎样去监听被Observable发送的值。</p>\n<p>在本例中<code>.subscribe()</code>方法的参数是三个函数，这三个函数组成的回调函数集合就是可观察对象<code>[1,2,3,4]</code>的观察者。当可观察对象发射出<code>1</code>这个值的时候，这个值就会被交给观察者的第一个回调函数处理<code>console.log(1)</code>。</p>\n</li>\n<li><p>订阅Subscription：表示一个可观察对象，主要用于取消注册。</p>\n<p>当一个可观察对象调用<code>subscribe()</code>方法，也就是被订阅以后，会返回一个可观察对象，本例中就是<code>subscription</code>。这个可观察对象可以调用<code>unsubscribe()</code>方法取消订阅：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">subscription.unsubscribe();</span><br></pre></td></tr></table></figure>\n\n<p>观察者里有三个回调函数，分别表示<code>next</code>、<code>error</code>、<code>complete</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var observer &#x3D; &#123;</span><br><span class=\"line\">  next: x &#x3D;&gt; console.log(&#39;Observer got a next value: &#39; + x),</span><br><span class=\"line\">  error: err &#x3D;&gt; console.error(&#39;Observer got an error: &#39; + err),</span><br><span class=\"line\">  complete: () &#x3D;&gt; console.log(&#39;Observer got a complete notification&#39;),</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">observable.subscribe(observer);</span><br></pre></td></tr></table></figure>\n\n<p>后两个可以省略。</p>\n</li>\n<li><p>操作符 Operators：纯粹的函数，使开发者可以以函数编程的方式处理集合。</p>\n<p>在本例中，<code>filter()</code>、<code>map()</code>都是操作符，它们可以处理流中的数据。</p>\n</li>\n</ul>\n<p>Observable对象是Rxjs库提供的，在angular中使用Observable进行响应式编程时需要引入RxJS库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;Observable&#125; from &#39;rxjs&#39;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模版本地变量\"><a href=\"#模版本地变量\" class=\"headerlink\" title=\"模版本地变量\"></a>模版本地变量</h2><p>angular中提供了一个叫做<em>模版本地变量</em>的语法来方便获得Html元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;事件对象</span><br><span class=\"line\">&lt;input (keyup)&#x3D;&quot;onKey($event)&quot;&gt;</span><br><span class=\"line\">onKey(event:any)&#123;</span><br><span class=\"line\">  console.log(event.target.value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;模版本地变量</span><br><span class=\"line\">&lt;input #myFiled (keyup)&#x3D;&quot;myFiled.value&gt;</span><br><span class=\"line\">onKey(value:string)&#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>声明模版本地变量用<code>#</code>号，<code>#myFiled</code>。</p>\n<p>使用模版本地变量时不需要加<code>#</code>号，<code>myFiled</code>就是input标签。<code>myFiled.value</code>就能直接拿到input元素的值。</p>\n<h2 id=\"使用响应式编程处理DOM事件\"><a href=\"#使用响应式编程处理DOM事件\" class=\"headerlink\" title=\"使用响应式编程处理DOM事件\"></a>使用响应式编程处理DOM事件</h2><p>传统JS中，对DOM事件的处理是一次性的。例如click事件，每点击一次鼠标，所对应的方法被调用一次。</p>\n<p>在Angular中，将事件作为永不结束的流来处理。</p>\n<h3 id=\"1-引入ReactiveFormsModule模块\"><a href=\"#1-引入ReactiveFormsModule模块\" class=\"headerlink\" title=\"1.引入ReactiveFormsModule模块\"></a>1.引入ReactiveFormsModule模块</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">import &#123;ReactiveFormsModule&#125; from &#39;@angular&#x2F;forms&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[ReavtiveFormsModule]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这个模块是angular中用来做响应式编程的模块。</p>\n<h3 id=\"2-使用FormControl类绑定Html元素\"><a href=\"#2-使用FormControl类绑定Html元素\" class=\"headerlink\" title=\"2.使用FormControl类绑定Html元素\"></a>2.使用FormControl类绑定Html元素</h3><p>FormControl是angular进行表单处理时常用的类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; ex.html</span><br><span class=\"line\">&lt;input [formControl]&#x3D;&quot;searchInput&quot; (keyup)&#x3D;&quot;onKey()&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; ex.component.ts</span><br><span class=\"line\">export class ExComponent implements OnInit&#123;</span><br><span class=\"line\">  searchInput: FormControl &#x3D; new FormControl();</span><br><span class=\"line\">  constructor()&#123;</span><br><span class=\"line\">    this.searchInput.valueChanges.debounceTime(500).subscribe(</span><br><span class=\"line\">    \te &#x3D;&gt; console.log(e)</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>valueChanges是一个Observable可观察对象，每当被控制的元素的值发生变化，valueChanges就会发射一个流。</p>\n<p>debounceTime是Observable可观察对象的方法，作用是延迟。该方法不属于angular，来自RxJS库的Observable对象，因此使用该方法要引入RxJS库。</p>\n<h1 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; ts</span><br><span class=\"line\">birthday:Date &#x3D; new Date();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; html</span><br><span class=\"line\">&lt;div&gt;我的生日是：&#123;&#123;birthday&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 我的生日是：Thu Dec 21 2017 15:01:10 GMT+0800 (CST)</span><br></pre></td></tr></table></figure>\n\n<p>使用管道格式化数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; html</span><br><span class=\"line\">&lt;div&gt;我的生日是：&#123;&#123;birthday | date&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 我的生日是：Dec 21,2017</span><br></pre></td></tr></table></figure>\n\n<p>多个管道可以组合使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; html</span><br><span class=\"line\">&lt;div&gt;我的生日是：&#123;&#123;birthday | date | uppercase&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 我的生日是：DEC 21,2017</span><br></pre></td></tr></table></figure>\n\n<p>angular内置了一些管道，如date，uppercase，lowercase等。</p>\n<p>一些复杂的管道可以接受参数，比如date管道：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; html</span><br><span class=\"line\">&lt;div&gt;我的生日是：&#123;&#123;birthday | date:&#39;yyyy-MM-dd HH:mm:ss&#39;&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 我的生日是：2017-12-21 16:00:00</span><br></pre></td></tr></table></figure>\n\n<p>date管道接受一个参数，该参数指定当前的日期格式化的形式，yyyy表示年（2017），大写的MM表示月（12），dd表示日（21），大写的HH表示24小时制的时（16），相反小写的hh表示12小时制的时（04），小写的mm表示分（00），ss表示秒（00）。</p>\n<h2 id=\"自定义管道\"><a href=\"#自定义管道\" class=\"headerlink\" title=\"自定义管道\"></a>自定义管道</h2><p>一 生成管道文件</p>\n<p><code>ng g pipe XXXX</code></p>\n<p>管道需要声明在模块中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  declaration:[XXXXPipe]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; pipeName.pipe.ts</span><br><span class=\"line\">import &#123;Pipe,PipeTransform&#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">@Pipe(&#123;</span><br><span class=\"line\">  name: &#39;XXXX&#39;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class XXXXPipe implements PipeTransform&#123;</span><br><span class=\"line\">  transform(value: any, arg?: any): any&#123;</span><br><span class=\"line\">    return undefined</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>value参数是在模版中，传入管道的原始值。</p>\n<p>arg参数是管道可接受的参数，比如date管道接受的<code>&#39;yyyy-MM-dd HH:mm:ss&#39;</code>。</p>\n<p>管道可以接收多个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transform(value:any, arg?;any, arg2?:any...):any&#123;</span><br><span class=\"line\">  return undefined</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div&gt;&#123;&#123;value | pipe:arg:arg2:....&#125;&#125;&lt;&#x2F;div&gt; </span><br></pre></td></tr></table></figure>\n\n<p>例子：写一个乘法管道</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; multiply.pipe.ts</span><br><span class=\"line\">@Pipe(&#123;</span><br><span class=\"line\">  name:&#39;multiply&#39;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">export class MultiplyPipe implements PipeTransform&#123;</span><br><span class=\"line\">  transform(value:any, arg?:any):any&#123;</span><br><span class=\"line\">    if(!arg)&#123;</span><br><span class=\"line\">      arg &#x3D; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return value * arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; ex.component.html</span><br><span class=\"line\">&#x2F;&#x2F; 假设num的值为 5</span><br><span class=\"line\">&lt;div&gt;&#123;&#123;num | multiply&#125;&#125;&lt;&#x2F;div&gt;\t&#x2F;&#x2F; 5</span><br><span class=\"line\">&lt;div&gt;&#123;&#123;num | nultiply:&#39;2&#39;&#125;&#125;&lt;&#x2F;div&gt;\t&#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>"},{"title":"Angular4——8.与服务器通讯","date":"2018-01-10T09:15:25.000Z","description":"angular与服务器通讯，http，websocket","_content":"\n# 使用NodeJS创建一个简单的web服务器\n\n## 1.创建一个新的项目\n\n## 2.使用npm init初始化项目\n\n```\nnpm init -y\n```\n\n`-y`这个参数会生成一个包含默认配置的package.json文件。\n\n## 3.引入Node类型定义文件\n\n```\nnpm install @types/node --save\n```\n\n使用TypeScript开发node服务器，需要引入node的类型定义文件。\n\n类型定义文件的作用是让开发者在TypeScript中可以使用JavaScript写成的已有的库。\n\n## 4.配置编译TypeScript\n\nnode并不认识TypeScript语法，需要编译成JavaScript。\n\n### 1.编写tsconfig.json配置文件\n\n根目录下新建`tsconfig.json`文件，配置内容如下：\n\n```\n{\n  \"compilerOptions\": {\t\t// 编译器配置\n    \"target\": \"es5\",\t\t\t// 目标是编译成ES5\n    \"module\": \"commonjs\",\t\t// 现在使用的模块的规范是commonjs\n    \"emitDecoratorMetadata\": true, //和装饰器相关，编译时保留装饰器元数据\n    \"experimentalDecorators\": true,//和装饰器相关，编译时保留装饰器元数据\n    \"outDir\": \"build\",\t\t\t// 编译后的Js文件放在build目录下\n    \"lib\": [\"es6\"]\t\t\t\t// 开发时使用es6语法\n  },\n  \"exclude\": [\t\t\t\t// 编译时排除node_modules文件\n    \"node_modules\"\n  ]\n}\n```\n\n### 2.设置IDE\n\nwebstorm中，打开preference，找到TypeScript，勾选Enable TypeScript Compiler，use tsconfig.json。\n\n## 5.编写服务器代码\n\n新建一个文件，比如server.ts，编写服务器代码：\n\n```\nimport * as http from 'http';  // 引入Node的Http模块\n\nconst server = http.createServer((resquest,response) => {\n  response.end('Hello Node');\n});\n\nserver.listen(8000);\n```\n\n保存后会自动编译，编译后的js文件在build文件夹中。\n\n##6.启动服务器\n\n启动编译后的js文件。\n\n```\nnode build/server.js\n```\n\n\n\n# 使用express框架创建服务器\n\n## 1.安装express框架\n\nexpress框架可以简化node服务器的开发，减少手工编码量。\n\n```\nnpm install express --save\n```\n\n## 2.安装express类型定义文件\n\n和node一样，也需要安装express的类型定义文件，以便我们可以使用TypeScript文件来开发。\n\n```\nnpm install @types/express --save\n```\n\n## 3.编写服务器代码\n\n新建一个文件，来编写服务器代码：\n\n```\nimport * as express from \"express\";\n\nconst app = express();\n\napp.get('/', (req, res) => res.send('Hello Express'));\napp.get('/stock', (req, res) => res.send('Hello Stock'));\n\nconst server = app.listen(8080, 'localhost', () => {\n  console.log('服务启动');\n})\n```\n\n\n\n# Nodemon 热更新node服务器\n\n在node服务器启动以后，如果服务器的文件发生变化，node不会自动更新这些变化，需要重启服务器。\n\nNodemon组件可以实时监测代码，一旦代码发生变化，服务器就会自动重启，刷新浏览器就可看到变化。\n\n```\nnpm install nodemon --save\n```\n\n\n\n# 使用Angular提供的Http服务创建客户端\n\n异步的http请求，可以使用多种方式实现。比如callback回调函数，promise，响应式编程。\n\nangular的http服务默认使用响应式编程的方式来处理http请求。\n\n##http服务\n\nhttp类方法返回的是Observable可观察对象。\n\n```javascript\nclass Http {\n  constructor(_backend: ConnectionBackend, _defaultOptions: RequestOptions)\n  protected _backend: ConnectionBackend\n  protected _defaultOptions: RequestOptions\n  request(url: string|Request, options?: RequestOptionsArgs): Observable<Response>\n  get(url: string, options?: RequestOptionsArgs): Observable<Response>\n  post(url: string, body: any, options?: RequestOptionsArgs): Observable<Response>\n  put(url: string, body: any, options?: RequestOptionsArgs): Observable<Response>\n  delete(url: string, options?: RequestOptionsArgs): Observable<Response>\n  patch(url: string, body: any, options?: RequestOptionsArgs): Observable<Response>\n  head(url: string, options?: RequestOptionsArgs): Observable<Response>\n  options(url: string, options?: RequestOptionsArgs): Observable<Response>\n}\n```\n\n## 创建客户端\n\n```\n// app.module.ts\n@NgModule({\n  imports:[\n    HttpModule\n  ]\n})\n```\n\n```javascript\n// stock.component.ts\nimport { Component, OnInit } from '@angular/core';\nimport {Headers, Http} from \"@angular/http\";\nimport \"rxjs/Rx\";\nimport {Observable} from \"rxjs\";\n\n@Component({\n  selector: 'app-stock',\n  templateUrl: './stock.component.html',\n  styleUrls: ['./stock.component.css']\n})\nexport class StockComponent implements OnInit {\n\n  stocks:Observable<any>;\n\n  constructor(public http: Http) {\n\n    let myHeaders:Headers = new Headers();\n    myHeaders.append(\"Authorization\", \"Basic 123456\");\n\n    this.stocks = this.http.get('/api/stock', {headers: myHeaders}).map(response => response.json());\n  }\n\n  ngOnInit() {\n\n  }\n\n}\n\n```\n\n","source":"_posts/Angular4——8.与服务器通讯.md","raw":"---\ntitle: Angular4——8.与服务器通讯\ndate: 2018-01-10 17:15:25\ntags:\n- Angular\ncategories:\n- 学习笔记\ndescription: angular与服务器通讯，http，websocket\n---\n\n# 使用NodeJS创建一个简单的web服务器\n\n## 1.创建一个新的项目\n\n## 2.使用npm init初始化项目\n\n```\nnpm init -y\n```\n\n`-y`这个参数会生成一个包含默认配置的package.json文件。\n\n## 3.引入Node类型定义文件\n\n```\nnpm install @types/node --save\n```\n\n使用TypeScript开发node服务器，需要引入node的类型定义文件。\n\n类型定义文件的作用是让开发者在TypeScript中可以使用JavaScript写成的已有的库。\n\n## 4.配置编译TypeScript\n\nnode并不认识TypeScript语法，需要编译成JavaScript。\n\n### 1.编写tsconfig.json配置文件\n\n根目录下新建`tsconfig.json`文件，配置内容如下：\n\n```\n{\n  \"compilerOptions\": {\t\t// 编译器配置\n    \"target\": \"es5\",\t\t\t// 目标是编译成ES5\n    \"module\": \"commonjs\",\t\t// 现在使用的模块的规范是commonjs\n    \"emitDecoratorMetadata\": true, //和装饰器相关，编译时保留装饰器元数据\n    \"experimentalDecorators\": true,//和装饰器相关，编译时保留装饰器元数据\n    \"outDir\": \"build\",\t\t\t// 编译后的Js文件放在build目录下\n    \"lib\": [\"es6\"]\t\t\t\t// 开发时使用es6语法\n  },\n  \"exclude\": [\t\t\t\t// 编译时排除node_modules文件\n    \"node_modules\"\n  ]\n}\n```\n\n### 2.设置IDE\n\nwebstorm中，打开preference，找到TypeScript，勾选Enable TypeScript Compiler，use tsconfig.json。\n\n## 5.编写服务器代码\n\n新建一个文件，比如server.ts，编写服务器代码：\n\n```\nimport * as http from 'http';  // 引入Node的Http模块\n\nconst server = http.createServer((resquest,response) => {\n  response.end('Hello Node');\n});\n\nserver.listen(8000);\n```\n\n保存后会自动编译，编译后的js文件在build文件夹中。\n\n##6.启动服务器\n\n启动编译后的js文件。\n\n```\nnode build/server.js\n```\n\n\n\n# 使用express框架创建服务器\n\n## 1.安装express框架\n\nexpress框架可以简化node服务器的开发，减少手工编码量。\n\n```\nnpm install express --save\n```\n\n## 2.安装express类型定义文件\n\n和node一样，也需要安装express的类型定义文件，以便我们可以使用TypeScript文件来开发。\n\n```\nnpm install @types/express --save\n```\n\n## 3.编写服务器代码\n\n新建一个文件，来编写服务器代码：\n\n```\nimport * as express from \"express\";\n\nconst app = express();\n\napp.get('/', (req, res) => res.send('Hello Express'));\napp.get('/stock', (req, res) => res.send('Hello Stock'));\n\nconst server = app.listen(8080, 'localhost', () => {\n  console.log('服务启动');\n})\n```\n\n\n\n# Nodemon 热更新node服务器\n\n在node服务器启动以后，如果服务器的文件发生变化，node不会自动更新这些变化，需要重启服务器。\n\nNodemon组件可以实时监测代码，一旦代码发生变化，服务器就会自动重启，刷新浏览器就可看到变化。\n\n```\nnpm install nodemon --save\n```\n\n\n\n# 使用Angular提供的Http服务创建客户端\n\n异步的http请求，可以使用多种方式实现。比如callback回调函数，promise，响应式编程。\n\nangular的http服务默认使用响应式编程的方式来处理http请求。\n\n##http服务\n\nhttp类方法返回的是Observable可观察对象。\n\n```javascript\nclass Http {\n  constructor(_backend: ConnectionBackend, _defaultOptions: RequestOptions)\n  protected _backend: ConnectionBackend\n  protected _defaultOptions: RequestOptions\n  request(url: string|Request, options?: RequestOptionsArgs): Observable<Response>\n  get(url: string, options?: RequestOptionsArgs): Observable<Response>\n  post(url: string, body: any, options?: RequestOptionsArgs): Observable<Response>\n  put(url: string, body: any, options?: RequestOptionsArgs): Observable<Response>\n  delete(url: string, options?: RequestOptionsArgs): Observable<Response>\n  patch(url: string, body: any, options?: RequestOptionsArgs): Observable<Response>\n  head(url: string, options?: RequestOptionsArgs): Observable<Response>\n  options(url: string, options?: RequestOptionsArgs): Observable<Response>\n}\n```\n\n## 创建客户端\n\n```\n// app.module.ts\n@NgModule({\n  imports:[\n    HttpModule\n  ]\n})\n```\n\n```javascript\n// stock.component.ts\nimport { Component, OnInit } from '@angular/core';\nimport {Headers, Http} from \"@angular/http\";\nimport \"rxjs/Rx\";\nimport {Observable} from \"rxjs\";\n\n@Component({\n  selector: 'app-stock',\n  templateUrl: './stock.component.html',\n  styleUrls: ['./stock.component.css']\n})\nexport class StockComponent implements OnInit {\n\n  stocks:Observable<any>;\n\n  constructor(public http: Http) {\n\n    let myHeaders:Headers = new Headers();\n    myHeaders.append(\"Authorization\", \"Basic 123456\");\n\n    this.stocks = this.http.get('/api/stock', {headers: myHeaders}).map(response => response.json());\n  }\n\n  ngOnInit() {\n\n  }\n\n}\n\n```\n\n","slug":"Angular4——8.与服务器通讯","published":1,"updated":"2021-05-08T15:00:15.905Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbob000cwct49socgh05","content":"<h1 id=\"使用NodeJS创建一个简单的web服务器\"><a href=\"#使用NodeJS创建一个简单的web服务器\" class=\"headerlink\" title=\"使用NodeJS创建一个简单的web服务器\"></a>使用NodeJS创建一个简单的web服务器</h1><h2 id=\"1-创建一个新的项目\"><a href=\"#1-创建一个新的项目\" class=\"headerlink\" title=\"1.创建一个新的项目\"></a>1.创建一个新的项目</h2><h2 id=\"2-使用npm-init初始化项目\"><a href=\"#2-使用npm-init初始化项目\" class=\"headerlink\" title=\"2.使用npm init初始化项目\"></a>2.使用npm init初始化项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init -y</span><br></pre></td></tr></table></figure>\n\n<p><code>-y</code>这个参数会生成一个包含默认配置的package.json文件。</p>\n<h2 id=\"3-引入Node类型定义文件\"><a href=\"#3-引入Node类型定义文件\" class=\"headerlink\" title=\"3.引入Node类型定义文件\"></a>3.引入Node类型定义文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @types&#x2F;node --save</span><br></pre></td></tr></table></figure>\n\n<p>使用TypeScript开发node服务器，需要引入node的类型定义文件。</p>\n<p>类型定义文件的作用是让开发者在TypeScript中可以使用JavaScript写成的已有的库。</p>\n<h2 id=\"4-配置编译TypeScript\"><a href=\"#4-配置编译TypeScript\" class=\"headerlink\" title=\"4.配置编译TypeScript\"></a>4.配置编译TypeScript</h2><p>node并不认识TypeScript语法，需要编译成JavaScript。</p>\n<h3 id=\"1-编写tsconfig-json配置文件\"><a href=\"#1-编写tsconfig-json配置文件\" class=\"headerlink\" title=\"1.编写tsconfig.json配置文件\"></a>1.编写tsconfig.json配置文件</h3><p>根目录下新建<code>tsconfig.json</code>文件，配置内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;\t\t&#x2F;&#x2F; 编译器配置</span><br><span class=\"line\">    &quot;target&quot;: &quot;es5&quot;,\t\t\t&#x2F;&#x2F; 目标是编译成ES5</span><br><span class=\"line\">    &quot;module&quot;: &quot;commonjs&quot;,\t\t&#x2F;&#x2F; 现在使用的模块的规范是commonjs</span><br><span class=\"line\">    &quot;emitDecoratorMetadata&quot;: true, &#x2F;&#x2F;和装饰器相关，编译时保留装饰器元数据</span><br><span class=\"line\">    &quot;experimentalDecorators&quot;: true,&#x2F;&#x2F;和装饰器相关，编译时保留装饰器元数据</span><br><span class=\"line\">    &quot;outDir&quot;: &quot;build&quot;,\t\t\t&#x2F;&#x2F; 编译后的Js文件放在build目录下</span><br><span class=\"line\">    &quot;lib&quot;: [&quot;es6&quot;]\t\t\t\t&#x2F;&#x2F; 开发时使用es6语法</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;exclude&quot;: [\t\t\t\t&#x2F;&#x2F; 编译时排除node_modules文件</span><br><span class=\"line\">    &quot;node_modules&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-设置IDE\"><a href=\"#2-设置IDE\" class=\"headerlink\" title=\"2.设置IDE\"></a>2.设置IDE</h3><p>webstorm中，打开preference，找到TypeScript，勾选Enable TypeScript Compiler，use tsconfig.json。</p>\n<h2 id=\"5-编写服务器代码\"><a href=\"#5-编写服务器代码\" class=\"headerlink\" title=\"5.编写服务器代码\"></a>5.编写服务器代码</h2><p>新建一个文件，比如server.ts，编写服务器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as http from &#39;http&#39;;  &#x2F;&#x2F; 引入Node的Http模块</span><br><span class=\"line\"></span><br><span class=\"line\">const server &#x3D; http.createServer((resquest,response) &#x3D;&gt; &#123;</span><br><span class=\"line\">  response.end(&#39;Hello Node&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8000);</span><br></pre></td></tr></table></figure>\n\n<p>保存后会自动编译，编译后的js文件在build文件夹中。</p>\n<p>##6.启动服务器</p>\n<p>启动编译后的js文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node build&#x2F;server.js</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"使用express框架创建服务器\"><a href=\"#使用express框架创建服务器\" class=\"headerlink\" title=\"使用express框架创建服务器\"></a>使用express框架创建服务器</h1><h2 id=\"1-安装express框架\"><a href=\"#1-安装express框架\" class=\"headerlink\" title=\"1.安装express框架\"></a>1.安装express框架</h2><p>express框架可以简化node服务器的开发，减少手工编码量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装express类型定义文件\"><a href=\"#2-安装express类型定义文件\" class=\"headerlink\" title=\"2.安装express类型定义文件\"></a>2.安装express类型定义文件</h2><p>和node一样，也需要安装express的类型定义文件，以便我们可以使用TypeScript文件来开发。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @types&#x2F;express --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-编写服务器代码\"><a href=\"#3-编写服务器代码\" class=\"headerlink\" title=\"3.编写服务器代码\"></a>3.编写服务器代码</h2><p>新建一个文件，来编写服务器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as express from &quot;express&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">const app &#x3D; express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; res.send(&#39;Hello Express&#39;));</span><br><span class=\"line\">app.get(&#39;&#x2F;stock&#39;, (req, res) &#x3D;&gt; res.send(&#39;Hello Stock&#39;));</span><br><span class=\"line\"></span><br><span class=\"line\">const server &#x3D; app.listen(8080, &#39;localhost&#39;, () &#x3D;&gt; &#123;</span><br><span class=\"line\">  console.log(&#39;服务启动&#39;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Nodemon-热更新node服务器\"><a href=\"#Nodemon-热更新node服务器\" class=\"headerlink\" title=\"Nodemon 热更新node服务器\"></a>Nodemon 热更新node服务器</h1><p>在node服务器启动以后，如果服务器的文件发生变化，node不会自动更新这些变化，需要重启服务器。</p>\n<p>Nodemon组件可以实时监测代码，一旦代码发生变化，服务器就会自动重启，刷新浏览器就可看到变化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install nodemon --save</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"使用Angular提供的Http服务创建客户端\"><a href=\"#使用Angular提供的Http服务创建客户端\" class=\"headerlink\" title=\"使用Angular提供的Http服务创建客户端\"></a>使用Angular提供的Http服务创建客户端</h1><p>异步的http请求，可以使用多种方式实现。比如callback回调函数，promise，响应式编程。</p>\n<p>angular的http服务默认使用响应式编程的方式来处理http请求。</p>\n<p>##http服务</p>\n<p>http类方法返回的是Observable可观察对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Http</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"title\">constructor</span>(<span class=\"params\">_backend: ConnectionBackend, _defaultOptions: RequestOptions</span>)</span><br><span class=\"line\">  <span class=\"title\">protected</span> <span class=\"title\">_backend</span>: <span class=\"title\">ConnectionBackend</span></span><br><span class=\"line\">  <span class=\"title\">protected</span> <span class=\"title\">_defaultOptions</span>: <span class=\"title\">RequestOptions</span></span><br><span class=\"line\">  <span class=\"title\">request</span>(<span class=\"params\">url: string|Request, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">get</span>(<span class=\"params\">url: string, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">post</span>(<span class=\"params\">url: string, body: any, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">put</span>(<span class=\"params\">url: string, body: any, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">delete</span>(<span class=\"params\">url: string, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">patch</span>(<span class=\"params\">url: string, body: any, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">head</span>(<span class=\"params\">url: string, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">options</span>(<span class=\"params\">url: string, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建客户端\"><a href=\"#创建客户端\" class=\"headerlink\" title=\"创建客户端\"></a>创建客户端</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    HttpModule</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// stock.component.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component, OnInit &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Headers, Http&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@angular/http&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;rxjs/Rx&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;rxjs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">&#x27;app-stock&#x27;</span>,</span><br><span class=\"line\">  templateUrl: <span class=\"string\">&#x27;./stock.component.html&#x27;</span>,</span><br><span class=\"line\">  styleUrls: [<span class=\"string\">&#x27;./stock.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StockComponent</span> <span class=\"title\">implements</span> <span class=\"title\">OnInit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  stocks:Observable&lt;any&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">public http: Http</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> myHeaders:Headers = <span class=\"keyword\">new</span> Headers();</span><br><span class=\"line\">    myHeaders.append(<span class=\"string\">&quot;Authorization&quot;</span>, <span class=\"string\">&quot;Basic 123456&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.stocks = <span class=\"built_in\">this</span>.http.get(<span class=\"string\">&#x27;/api/stock&#x27;</span>, &#123;<span class=\"attr\">headers</span>: myHeaders&#125;).map(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">ngOnInit</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用NodeJS创建一个简单的web服务器\"><a href=\"#使用NodeJS创建一个简单的web服务器\" class=\"headerlink\" title=\"使用NodeJS创建一个简单的web服务器\"></a>使用NodeJS创建一个简单的web服务器</h1><h2 id=\"1-创建一个新的项目\"><a href=\"#1-创建一个新的项目\" class=\"headerlink\" title=\"1.创建一个新的项目\"></a>1.创建一个新的项目</h2><h2 id=\"2-使用npm-init初始化项目\"><a href=\"#2-使用npm-init初始化项目\" class=\"headerlink\" title=\"2.使用npm init初始化项目\"></a>2.使用npm init初始化项目</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm init -y</span><br></pre></td></tr></table></figure>\n\n<p><code>-y</code>这个参数会生成一个包含默认配置的package.json文件。</p>\n<h2 id=\"3-引入Node类型定义文件\"><a href=\"#3-引入Node类型定义文件\" class=\"headerlink\" title=\"3.引入Node类型定义文件\"></a>3.引入Node类型定义文件</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @types&#x2F;node --save</span><br></pre></td></tr></table></figure>\n\n<p>使用TypeScript开发node服务器，需要引入node的类型定义文件。</p>\n<p>类型定义文件的作用是让开发者在TypeScript中可以使用JavaScript写成的已有的库。</p>\n<h2 id=\"4-配置编译TypeScript\"><a href=\"#4-配置编译TypeScript\" class=\"headerlink\" title=\"4.配置编译TypeScript\"></a>4.配置编译TypeScript</h2><p>node并不认识TypeScript语法，需要编译成JavaScript。</p>\n<h3 id=\"1-编写tsconfig-json配置文件\"><a href=\"#1-编写tsconfig-json配置文件\" class=\"headerlink\" title=\"1.编写tsconfig.json配置文件\"></a>1.编写tsconfig.json配置文件</h3><p>根目录下新建<code>tsconfig.json</code>文件，配置内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;compilerOptions&quot;: &#123;\t\t&#x2F;&#x2F; 编译器配置</span><br><span class=\"line\">    &quot;target&quot;: &quot;es5&quot;,\t\t\t&#x2F;&#x2F; 目标是编译成ES5</span><br><span class=\"line\">    &quot;module&quot;: &quot;commonjs&quot;,\t\t&#x2F;&#x2F; 现在使用的模块的规范是commonjs</span><br><span class=\"line\">    &quot;emitDecoratorMetadata&quot;: true, &#x2F;&#x2F;和装饰器相关，编译时保留装饰器元数据</span><br><span class=\"line\">    &quot;experimentalDecorators&quot;: true,&#x2F;&#x2F;和装饰器相关，编译时保留装饰器元数据</span><br><span class=\"line\">    &quot;outDir&quot;: &quot;build&quot;,\t\t\t&#x2F;&#x2F; 编译后的Js文件放在build目录下</span><br><span class=\"line\">    &quot;lib&quot;: [&quot;es6&quot;]\t\t\t\t&#x2F;&#x2F; 开发时使用es6语法</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;exclude&quot;: [\t\t\t\t&#x2F;&#x2F; 编译时排除node_modules文件</span><br><span class=\"line\">    &quot;node_modules&quot;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-设置IDE\"><a href=\"#2-设置IDE\" class=\"headerlink\" title=\"2.设置IDE\"></a>2.设置IDE</h3><p>webstorm中，打开preference，找到TypeScript，勾选Enable TypeScript Compiler，use tsconfig.json。</p>\n<h2 id=\"5-编写服务器代码\"><a href=\"#5-编写服务器代码\" class=\"headerlink\" title=\"5.编写服务器代码\"></a>5.编写服务器代码</h2><p>新建一个文件，比如server.ts，编写服务器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as http from &#39;http&#39;;  &#x2F;&#x2F; 引入Node的Http模块</span><br><span class=\"line\"></span><br><span class=\"line\">const server &#x3D; http.createServer((resquest,response) &#x3D;&gt; &#123;</span><br><span class=\"line\">  response.end(&#39;Hello Node&#39;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(8000);</span><br></pre></td></tr></table></figure>\n\n<p>保存后会自动编译，编译后的js文件在build文件夹中。</p>\n<p>##6.启动服务器</p>\n<p>启动编译后的js文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node build&#x2F;server.js</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"使用express框架创建服务器\"><a href=\"#使用express框架创建服务器\" class=\"headerlink\" title=\"使用express框架创建服务器\"></a>使用express框架创建服务器</h1><h2 id=\"1-安装express框架\"><a href=\"#1-安装express框架\" class=\"headerlink\" title=\"1.安装express框架\"></a>1.安装express框架</h2><p>express框架可以简化node服务器的开发，减少手工编码量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install express --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-安装express类型定义文件\"><a href=\"#2-安装express类型定义文件\" class=\"headerlink\" title=\"2.安装express类型定义文件\"></a>2.安装express类型定义文件</h2><p>和node一样，也需要安装express的类型定义文件，以便我们可以使用TypeScript文件来开发。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @types&#x2F;express --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-编写服务器代码\"><a href=\"#3-编写服务器代码\" class=\"headerlink\" title=\"3.编写服务器代码\"></a>3.编写服务器代码</h2><p>新建一个文件，来编写服务器代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as express from &quot;express&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">const app &#x3D; express();</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; res.send(&#39;Hello Express&#39;));</span><br><span class=\"line\">app.get(&#39;&#x2F;stock&#39;, (req, res) &#x3D;&gt; res.send(&#39;Hello Stock&#39;));</span><br><span class=\"line\"></span><br><span class=\"line\">const server &#x3D; app.listen(8080, &#39;localhost&#39;, () &#x3D;&gt; &#123;</span><br><span class=\"line\">  console.log(&#39;服务启动&#39;);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Nodemon-热更新node服务器\"><a href=\"#Nodemon-热更新node服务器\" class=\"headerlink\" title=\"Nodemon 热更新node服务器\"></a>Nodemon 热更新node服务器</h1><p>在node服务器启动以后，如果服务器的文件发生变化，node不会自动更新这些变化，需要重启服务器。</p>\n<p>Nodemon组件可以实时监测代码，一旦代码发生变化，服务器就会自动重启，刷新浏览器就可看到变化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install nodemon --save</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"使用Angular提供的Http服务创建客户端\"><a href=\"#使用Angular提供的Http服务创建客户端\" class=\"headerlink\" title=\"使用Angular提供的Http服务创建客户端\"></a>使用Angular提供的Http服务创建客户端</h1><p>异步的http请求，可以使用多种方式实现。比如callback回调函数，promise，响应式编程。</p>\n<p>angular的http服务默认使用响应式编程的方式来处理http请求。</p>\n<p>##http服务</p>\n<p>http类方法返回的是Observable可观察对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Http</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"title\">constructor</span>(<span class=\"params\">_backend: ConnectionBackend, _defaultOptions: RequestOptions</span>)</span><br><span class=\"line\">  <span class=\"title\">protected</span> <span class=\"title\">_backend</span>: <span class=\"title\">ConnectionBackend</span></span><br><span class=\"line\">  <span class=\"title\">protected</span> <span class=\"title\">_defaultOptions</span>: <span class=\"title\">RequestOptions</span></span><br><span class=\"line\">  <span class=\"title\">request</span>(<span class=\"params\">url: string|Request, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">get</span>(<span class=\"params\">url: string, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">post</span>(<span class=\"params\">url: string, body: any, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">put</span>(<span class=\"params\">url: string, body: any, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">delete</span>(<span class=\"params\">url: string, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">patch</span>(<span class=\"params\">url: string, body: any, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">head</span>(<span class=\"params\">url: string, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">  <span class=\"title\">options</span>(<span class=\"params\">url: string, options?: RequestOptionsArgs</span>): <span class=\"title\">Observable</span>&lt;<span class=\"title\">Response</span>&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建客户端\"><a href=\"#创建客户端\" class=\"headerlink\" title=\"创建客户端\"></a>创建客户端</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; app.module.ts</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    HttpModule</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// stock.component.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component, OnInit &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/core&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Headers, Http&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@angular/http&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;rxjs/Rx&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;rxjs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">&#x27;app-stock&#x27;</span>,</span><br><span class=\"line\">  templateUrl: <span class=\"string\">&#x27;./stock.component.html&#x27;</span>,</span><br><span class=\"line\">  styleUrls: [<span class=\"string\">&#x27;./stock.component.css&#x27;</span>]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StockComponent</span> <span class=\"title\">implements</span> <span class=\"title\">OnInit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  stocks:Observable&lt;any&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">public http: Http</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> myHeaders:Headers = <span class=\"keyword\">new</span> Headers();</span><br><span class=\"line\">    myHeaders.append(<span class=\"string\">&quot;Authorization&quot;</span>, <span class=\"string\">&quot;Basic 123456&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.stocks = <span class=\"built_in\">this</span>.http.get(<span class=\"string\">&#x27;/api/stock&#x27;</span>, &#123;<span class=\"attr\">headers</span>: myHeaders&#125;).map(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">ngOnInit</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n"},{"title":"Angular4——6.组件间通讯","date":"2017-12-22T06:18:15.000Z","description":"Angular组件间通讯","_content":"\n# 输入属性\n\n**父组件**将数据传递给**子组件**。\n\n在子组件中，被`@Input()`装饰器注解的属性，可以接收父组件的数据。\n\n```\n// 父组件.ts\nexport class fatherComponent{\n  father:string = 'hello';\n}\n// 父组件.html\n<div>我是父组件</div>\n<app-child [son]=\"father\"></app-child>\n\n// 子组件.ts\nexport class ChildComponent{\n  @Input() son:string;\t\t// 'hello'\n}\n```\n\n通过输入、输出属性传递参数的方式只能用在父子组件中。\n\n# EventEmitter自定义事件\n\nEventEmitter是RxJS中`subject`类的子类。\n\n在响应式编程中，EventEmitter即可以作为观察者，也可以作为被观察者。\n\nEventEmitter即可以通过`emit()`方法发射自定义事件，也可以通过`subscribe()`方法订阅所发射的事件流。\n\nEvevtEmitter需要一个泛型，泛型是要发射的事件的类型。\n\n# 输出属性\n\n**子组件**传递数据给**父组件**。\n\n在子组件中，被`@Output()`装饰器注解的属性，可以被父组件接收。\n\n例：通过输出属性向外发射事件，并通过实践携带数据\n\n```\n// 子组件.ts\nexport class childComponent implements OnInit{\n  @Output()\n  sendData: EventEmitter<要发射的数据的类型> = new EventEmitter();\n  \n  ngOnInit(){\n  \tlet data = '123';\n    this.sendData.emit(data);\n  }\n}\n\n// 父组件.html\n<div>我是父组件</div>\n<app-child (sendData)=\"getData($event)\"></app-child>\t//这里的$event就是子组件中emit()方法发射的数据\n\n// 父组件.ts\nexport class fatherComponent{\n  getData(data:数据类型){\n    console.log(data)\n  }\n}\n\n```\n\nOutput装饰器函数可以为输出属性重命名：\n\n```\n// child\n@Output('newName')\nsendData:EventEmitter<要发射的数据的类型> = new EventEmitter();\n\n//father\n<div>我是父组件</div>\n<app-child (newName)=\"getData($event)></app-child>\n```\n\n\n\n# 中间人模式\n\n由于输入输出属性只能用于父子关系的组件间传递数据。如果一个父组件下的两个子组件间要传递数据，可以将父组件当作中间人，通过中间人进行传递\n\n```\n// 子组件A 发射事件\nexport class AChildComponent{\n  @Output()\n  sendData: EventEmitter<string> = new EventEmitter();\n  NgOnInit(){\n  \tlet data:string = '123';\n    this.sendData.emit(data)\n  }\n}\n\n// 父组件 中间人，捕获子组件A发射的事件，并把数据输出给子组件B\n<div>我是父组件 中间人</div>\n<app-achild (sendData)=\"getData($event)\">发送数据的组件A</app-achild>\n<app-bchild [bValue]=\"value>接收数据的组件B</app-bchild>\n\nexport class father{\n  value:string;\n  getData(data:string){\n    this.value = data\n  }\n}\n\n// 子组件B 接收数据\nexport class BChildComponent{\n  @Input()\n  bValue:string;\n}\n```\n\n当两个组件有共同的父组件时，可以使用父组件作为中间人进行通讯。\n\n如果两个组件没有共同的父组件，应该使用一个可注入的服务作为中间人进行通讯。\n\n\n\n# 组件生命周期\n\n组件初始化：constructor（只调用一次），ngOnChanges，ngOnInit（只调用一次），ngDoCheck，ngAfterContentInit（只调用一次），ngAfterContentChecked，ngAfterViewInit（只调用一次），ngAfterViewChecked\n\n变化检测：ngOnChanges，ngDoCheck，ngAfterContentChecked，ngAfterViewChecked\n\n组件销毁：ngOnDestroy（只调用一次）\n\n组件从创建到销毁依次调用以下生命周期钩子函数：\n\n1. constructor\n\n   当一个组件被创建时，首先调用构造函数方法。\n\n   构造函数一定会被调用，但其他钩子函数是根据需要来调用的。\n\n2. ngOnChanges\n\n   ngOnChanges(changes: SimpleChange){ }\n\n   这个钩子函数，是当一个父组件修改或初始化一个子组件的输入属性时才调用的。\n\n   如果一个组件没有输入属性，ngOnChanges方法永远不会被调用。\n\n   ngOnChanges首次调用一定发生在ngOnInit之前，而且这个方法可以被多次调用，每当输入属性变化时就会被调用。\n\n3. ngOnInit\n\n   如果组件存在输入属性，则ngOnInit方法在ngOnChanges首次调用之后被调用，用来初始化组件或指令。\n\n   不在构造函数里初始化的原因：\n\n   输入属性在构造函数里是空的，输入属性是在首次调用ngOnChanges时被初始化的。所以，如果组件的初始化逻辑依赖输入属性的值，那么初始化逻辑一定要卸载ngOnInit里。\n\n4. ngDoCheck\n\n   在每个angular变更检测周期中调用，用来检测\n\n5. ngAfterContentInit\n\n6. ngAfterContentChecked\n\n7. ngAfterViewInit\n\n8. ngAfterViewChecked\n\n9. ngOnDestroy\n\n## onChanges钩子\n\n这个钩子是在父组件初始化或者修改子组件的输入属性时被调用。\n\n**注意**：\n\n+ 首先，ngOnChanges钩子只有在输入属性变化时才会被调用，组件自身的属性通过`[(ngModel)]`双向绑定的方式改变，不会调用ngOnChanges。\n\n+ 其次，只有输入属性的值的类型是number、string这种不可变的原始类型时，输入属性改变时，ngOnChanges才会被调用；如果输入属性的值的类型是对象这种可变的复杂类型时，ngOnChanges不会被调用。\n\n  ```\n  //father\n  greeting:string = \"hello\";\n  <app-child [greeting]=\"greeting\"></app-child>\n\n  //child\n  @Input()\n  greeting:string;\n\n  ngOnChanges(changes: SimpleChanges){\n    console.log('OK')\t\t// 'ok'\t\tngOnChanges被调用，输入属性也被初始化\n  }\n  <div>{{greeting}}</div>\t\t// hello\n  ```\n\n+ 最后，虽然输入属性的值的类型为对象时，ngOnChanges不会被调用，但是输入属性依然能够正确初始化，这是因为angular的变更检测机制起了作用。\n\n  ```\n  //father\n  user:{name:string} = {name: \"tom\"}\n  <app-child [user]=\"user\"></app-child>\n\n  //child\n  @Input()\n  user:{name:string};\n  ngOnChanges(changes: SimpleChanges){\n    console.log('OK')\t\t//\t  ngOnChanges没有被调用，因为输入属性是一个对象，是一个可变类型\n  }\n  <div>{{user.name}}</div>\t\t// tom 但是输入属性依然能偶被初始化\n  ```\n\n\n\n# 变更检测机制和DoCheck\n\n## 变更检测机制\n\nangular中实现变更检测机制的包是`zone.js`，它的作用是使组件的属性和页面同步变化。\n\n浏览器的任何异步事件，如按钮点击，setTimeOut方法等，都会出发变更检测。\n\n在angular1中，原生的事件无法触发脏检查，比如按钮click事件。而在aunglar2以后，原声事件随便用。\n\n变更检测机制只是将属性的改变反映到模版上，变更检测机制本身永远不会改变属性的值。\n\n### 变更检测原理\n\nangular应用是一个以主组件为根的组件树，当angular应用运行时，每一个组件都会生成一个它自己的变更检测器。当任何一个变更检测器检测到变化时，`zone.js`就会根据组件的变更检测策略来检查组件，以判断组件是否需要更新模版。\n\n###变更检测策略\n\nangular实现了两个变更检测策略，一个是default，一个是OnPush。\n\n默认情况下所有组件都是default策略。\n\n如果所有的组件都是default策略，那么不管变更发生在哪个组件上，`zone.js`都会检查整个组件树。\n\n`zone.js`从跟组件开始向下检查，当遇到是OnPush策略的组件时，就不会检查该组件及其以下的组件。\n\n## DoCheck\n\n```\nngDoCheck(){\n  \n}\n```\n\n鼠标的点击，键盘按键，都会出发变更检测，所谓的触发变更检测就是调用DoCheck钩子，因此在调用ngDoCheck的时候要小心使用。\n\n# View钩子\n\n## 父组件调用子组件的方法\n\n父组件调用子组件的方法有两种，一种是在控制器中通过`@ViewChild()`装饰器来调用，另一种是在模版中通过模版本地变量调用。\n\n```\n// 子组件.ts\nexport class ChildComponent{\n  greeting(name:string){\n    console.log('hello'+name);\n  }\n}\n\n// 父组件\n<app-child #child1></app-child>\t\t// 'hello Tom'\n<app-child #child2></app-child>\n<button (click)=\"child2.greeting('Jerry')\">点我</button>\t\t// 'hello Jerry'\n\nexport class fatherComponent implements OnInit{\n  @ViewChild(\"child1\")\t\t\t//装饰器函数有一个参数，值就是模版中声明的模版本地变量\n  child1:ChildComponent;\n  \n  ngOnInit(){\n    this.child1.greeting(\"Tom\");\n  }\n}\n```\n\n## ngAfterViewInit、ngAfterViewChecked\n\n+ ngAfterViewInit的调用先于ngAfterViewChecked，这两个方法都是在组件的视图被组装完毕以后调用的。  \n\n+ 如果一个组件有子组件，那么父组件要在所有子组件的视图都组装完毕以后，才会调用自己的ngAfterViewInit和ngAfterViewChecked方法。\n\n+ ngAfterViewInit只会在视图初始化完毕后调用一次，之后永远不会再调用。\n\n+ 在ngAfterViewInit、ngAfterViewChecked方法里面改变去改变组件属性的值，angular会抛出异常：\n\n  ```\n  <div>{{message}}</div>\n\n  message:string;\n  ngAfterViewInit(){\n    this.message = 'hello';\n  }\n\n  // Error!!\n  ```\n\n  这是因为，在变更检测周期中，angular禁止在一个视图已经组装好之后，再去更新视图。而ngAfterViewInit是在视图已经组装好之后触发的。\n\n  同样，ngAfterViewChecked方法也是在视图组装好之后触发的，所以在ngAfterViewChecked方法中去更新视图也会抛出异常。\n\n  ```\n  <div>{{message}}</div>\n\n  message:string;\n  ngAfterViewChecked(){\n    this.message = 'hello';\n  }\n\n  // Error!!\n  ```\n\n  如果需要在ngAfterViewInit或者ngAfterViewChecked中改变视图，放在一个setTimeOut中就可以：\n\n  ```html\n  <div>{{message}}</div>\n\n  message:string;\n  ngAfterViewChecked(){\n  \tsetTimeOut(() => {\n        this.message = 'hello';\n  \t},0)\n  }\n\n  // hello\n  ```\n\n# ng-content指令\n\nng-content指令：父组件的内容投影到子组件中。\n\n```html\n// 父组件\n<app-child>\n\t<div class=\"content1\">内容1</div>\n\t<div class=\"content2\">内容2</div>\n</app-child>\n\n//子组件\n<div>\n\t<ng-content select=\".content1\"></ng-content>\n\t<div>\n    \t<ng-content select=\".content2\"></ng-content>  \n  \t</div>\n</div>\n\n```\n\n# ngContent钩子\n\nngContent钩子和ngView钩子类似，不同的是ngContent钩子针对的是父组件投影到子组件的部分。\n\n`ngAfterContentInit`是在投影进来的内容初始化完毕后调用的。\n\n`ngAfterContentChecked`是针对投影进来的内通进行变更检测的。\n\n+ 先完成投影内容的初始化和检测，再完成整个视图的初始化和检测。\n+ 在`ngAfterContentInit`和`ngAfterContentChecked`中改变视图内容是不会报错的，因为在调用这两个钩子被调用的时候整个视图还没有被组装完。\n\n# 组件生命周期\n\n+ 组件初始化阶段：\n\n  + 属性初始化阶段：\n\n    1. constructor（只调用一次）：构造函数实例化对象\n    2. ngOnChanges：初始化输入属性\n    3. ngOnInit（只调用一次） ：初始化除了输入属性以外的所有其他属性。\n    4. ngDoCheck：做一次变更检查\n\n  + 这时整个组件的属性都应该被赋予了需要被赋予的值，这时开始渲染视图\n\n  + 视图初始化阶段：\n\n    ​\t先渲染投影部分的内容，投影部分渲染完毕后调用下面两个钩子。\n\n    5. ngAfterContentInit（只调用一次）：\n\n    6. ngAfterContentChecked：\n\n       这时如果组件有子组件，那么进入子组件的生命周期。\n\n       如果没有子组件，或者所有子组件的生命周期执行完毕，这时如果组件的全部视图渲染完了，会调用下面两个方法：\n\n    7. ngAfterViewInit（只调用一次）：\n\n    8. ngAfterViewChecked：\n\n当7，8方法调用完毕后，整个组件的初始化过程就完毕了这时候，组件就会呈现出来，给到用户做一些交互。\n\n而用户做的任何一个交互，比如鼠标点击，键盘输入，都会出发angular的变更检测机制。\n\n而一旦检测到发生了变更，那么在当前组件树上，所有活动 组件上被实现的带有`check`关键字的方法，都会被调用，用来检查当前组件的变化。\n\n如果某个组件的变化导致输入属性也改变了，那么这个组件的ngOnChanges方法也会被调用。\n\n+ 变更检测阶段：\n\n  ngOnChanges\n\n  ngDoCheck\n\n  ngAfterContentChecked\n\n  ngAfterViewChecked\n\n+ 组件销毁\n\n  最终当组件被销毁的时候，会调用ngOnDestroy。\n\n  组件会在路由的时候被销毁。","source":"_posts/Angular4——6-组件间通讯.md","raw":"---\ntitle: Angular4——6.组件间通讯\ndate: 2017-12-22 14:18:15\ntags:\n- Angular\ncategories:\n- 学习笔记\ndescription: Angular组件间通讯\n---\n\n# 输入属性\n\n**父组件**将数据传递给**子组件**。\n\n在子组件中，被`@Input()`装饰器注解的属性，可以接收父组件的数据。\n\n```\n// 父组件.ts\nexport class fatherComponent{\n  father:string = 'hello';\n}\n// 父组件.html\n<div>我是父组件</div>\n<app-child [son]=\"father\"></app-child>\n\n// 子组件.ts\nexport class ChildComponent{\n  @Input() son:string;\t\t// 'hello'\n}\n```\n\n通过输入、输出属性传递参数的方式只能用在父子组件中。\n\n# EventEmitter自定义事件\n\nEventEmitter是RxJS中`subject`类的子类。\n\n在响应式编程中，EventEmitter即可以作为观察者，也可以作为被观察者。\n\nEventEmitter即可以通过`emit()`方法发射自定义事件，也可以通过`subscribe()`方法订阅所发射的事件流。\n\nEvevtEmitter需要一个泛型，泛型是要发射的事件的类型。\n\n# 输出属性\n\n**子组件**传递数据给**父组件**。\n\n在子组件中，被`@Output()`装饰器注解的属性，可以被父组件接收。\n\n例：通过输出属性向外发射事件，并通过实践携带数据\n\n```\n// 子组件.ts\nexport class childComponent implements OnInit{\n  @Output()\n  sendData: EventEmitter<要发射的数据的类型> = new EventEmitter();\n  \n  ngOnInit(){\n  \tlet data = '123';\n    this.sendData.emit(data);\n  }\n}\n\n// 父组件.html\n<div>我是父组件</div>\n<app-child (sendData)=\"getData($event)\"></app-child>\t//这里的$event就是子组件中emit()方法发射的数据\n\n// 父组件.ts\nexport class fatherComponent{\n  getData(data:数据类型){\n    console.log(data)\n  }\n}\n\n```\n\nOutput装饰器函数可以为输出属性重命名：\n\n```\n// child\n@Output('newName')\nsendData:EventEmitter<要发射的数据的类型> = new EventEmitter();\n\n//father\n<div>我是父组件</div>\n<app-child (newName)=\"getData($event)></app-child>\n```\n\n\n\n# 中间人模式\n\n由于输入输出属性只能用于父子关系的组件间传递数据。如果一个父组件下的两个子组件间要传递数据，可以将父组件当作中间人，通过中间人进行传递\n\n```\n// 子组件A 发射事件\nexport class AChildComponent{\n  @Output()\n  sendData: EventEmitter<string> = new EventEmitter();\n  NgOnInit(){\n  \tlet data:string = '123';\n    this.sendData.emit(data)\n  }\n}\n\n// 父组件 中间人，捕获子组件A发射的事件，并把数据输出给子组件B\n<div>我是父组件 中间人</div>\n<app-achild (sendData)=\"getData($event)\">发送数据的组件A</app-achild>\n<app-bchild [bValue]=\"value>接收数据的组件B</app-bchild>\n\nexport class father{\n  value:string;\n  getData(data:string){\n    this.value = data\n  }\n}\n\n// 子组件B 接收数据\nexport class BChildComponent{\n  @Input()\n  bValue:string;\n}\n```\n\n当两个组件有共同的父组件时，可以使用父组件作为中间人进行通讯。\n\n如果两个组件没有共同的父组件，应该使用一个可注入的服务作为中间人进行通讯。\n\n\n\n# 组件生命周期\n\n组件初始化：constructor（只调用一次），ngOnChanges，ngOnInit（只调用一次），ngDoCheck，ngAfterContentInit（只调用一次），ngAfterContentChecked，ngAfterViewInit（只调用一次），ngAfterViewChecked\n\n变化检测：ngOnChanges，ngDoCheck，ngAfterContentChecked，ngAfterViewChecked\n\n组件销毁：ngOnDestroy（只调用一次）\n\n组件从创建到销毁依次调用以下生命周期钩子函数：\n\n1. constructor\n\n   当一个组件被创建时，首先调用构造函数方法。\n\n   构造函数一定会被调用，但其他钩子函数是根据需要来调用的。\n\n2. ngOnChanges\n\n   ngOnChanges(changes: SimpleChange){ }\n\n   这个钩子函数，是当一个父组件修改或初始化一个子组件的输入属性时才调用的。\n\n   如果一个组件没有输入属性，ngOnChanges方法永远不会被调用。\n\n   ngOnChanges首次调用一定发生在ngOnInit之前，而且这个方法可以被多次调用，每当输入属性变化时就会被调用。\n\n3. ngOnInit\n\n   如果组件存在输入属性，则ngOnInit方法在ngOnChanges首次调用之后被调用，用来初始化组件或指令。\n\n   不在构造函数里初始化的原因：\n\n   输入属性在构造函数里是空的，输入属性是在首次调用ngOnChanges时被初始化的。所以，如果组件的初始化逻辑依赖输入属性的值，那么初始化逻辑一定要卸载ngOnInit里。\n\n4. ngDoCheck\n\n   在每个angular变更检测周期中调用，用来检测\n\n5. ngAfterContentInit\n\n6. ngAfterContentChecked\n\n7. ngAfterViewInit\n\n8. ngAfterViewChecked\n\n9. ngOnDestroy\n\n## onChanges钩子\n\n这个钩子是在父组件初始化或者修改子组件的输入属性时被调用。\n\n**注意**：\n\n+ 首先，ngOnChanges钩子只有在输入属性变化时才会被调用，组件自身的属性通过`[(ngModel)]`双向绑定的方式改变，不会调用ngOnChanges。\n\n+ 其次，只有输入属性的值的类型是number、string这种不可变的原始类型时，输入属性改变时，ngOnChanges才会被调用；如果输入属性的值的类型是对象这种可变的复杂类型时，ngOnChanges不会被调用。\n\n  ```\n  //father\n  greeting:string = \"hello\";\n  <app-child [greeting]=\"greeting\"></app-child>\n\n  //child\n  @Input()\n  greeting:string;\n\n  ngOnChanges(changes: SimpleChanges){\n    console.log('OK')\t\t// 'ok'\t\tngOnChanges被调用，输入属性也被初始化\n  }\n  <div>{{greeting}}</div>\t\t// hello\n  ```\n\n+ 最后，虽然输入属性的值的类型为对象时，ngOnChanges不会被调用，但是输入属性依然能够正确初始化，这是因为angular的变更检测机制起了作用。\n\n  ```\n  //father\n  user:{name:string} = {name: \"tom\"}\n  <app-child [user]=\"user\"></app-child>\n\n  //child\n  @Input()\n  user:{name:string};\n  ngOnChanges(changes: SimpleChanges){\n    console.log('OK')\t\t//\t  ngOnChanges没有被调用，因为输入属性是一个对象，是一个可变类型\n  }\n  <div>{{user.name}}</div>\t\t// tom 但是输入属性依然能偶被初始化\n  ```\n\n\n\n# 变更检测机制和DoCheck\n\n## 变更检测机制\n\nangular中实现变更检测机制的包是`zone.js`，它的作用是使组件的属性和页面同步变化。\n\n浏览器的任何异步事件，如按钮点击，setTimeOut方法等，都会出发变更检测。\n\n在angular1中，原生的事件无法触发脏检查，比如按钮click事件。而在aunglar2以后，原声事件随便用。\n\n变更检测机制只是将属性的改变反映到模版上，变更检测机制本身永远不会改变属性的值。\n\n### 变更检测原理\n\nangular应用是一个以主组件为根的组件树，当angular应用运行时，每一个组件都会生成一个它自己的变更检测器。当任何一个变更检测器检测到变化时，`zone.js`就会根据组件的变更检测策略来检查组件，以判断组件是否需要更新模版。\n\n###变更检测策略\n\nangular实现了两个变更检测策略，一个是default，一个是OnPush。\n\n默认情况下所有组件都是default策略。\n\n如果所有的组件都是default策略，那么不管变更发生在哪个组件上，`zone.js`都会检查整个组件树。\n\n`zone.js`从跟组件开始向下检查，当遇到是OnPush策略的组件时，就不会检查该组件及其以下的组件。\n\n## DoCheck\n\n```\nngDoCheck(){\n  \n}\n```\n\n鼠标的点击，键盘按键，都会出发变更检测，所谓的触发变更检测就是调用DoCheck钩子，因此在调用ngDoCheck的时候要小心使用。\n\n# View钩子\n\n## 父组件调用子组件的方法\n\n父组件调用子组件的方法有两种，一种是在控制器中通过`@ViewChild()`装饰器来调用，另一种是在模版中通过模版本地变量调用。\n\n```\n// 子组件.ts\nexport class ChildComponent{\n  greeting(name:string){\n    console.log('hello'+name);\n  }\n}\n\n// 父组件\n<app-child #child1></app-child>\t\t// 'hello Tom'\n<app-child #child2></app-child>\n<button (click)=\"child2.greeting('Jerry')\">点我</button>\t\t// 'hello Jerry'\n\nexport class fatherComponent implements OnInit{\n  @ViewChild(\"child1\")\t\t\t//装饰器函数有一个参数，值就是模版中声明的模版本地变量\n  child1:ChildComponent;\n  \n  ngOnInit(){\n    this.child1.greeting(\"Tom\");\n  }\n}\n```\n\n## ngAfterViewInit、ngAfterViewChecked\n\n+ ngAfterViewInit的调用先于ngAfterViewChecked，这两个方法都是在组件的视图被组装完毕以后调用的。  \n\n+ 如果一个组件有子组件，那么父组件要在所有子组件的视图都组装完毕以后，才会调用自己的ngAfterViewInit和ngAfterViewChecked方法。\n\n+ ngAfterViewInit只会在视图初始化完毕后调用一次，之后永远不会再调用。\n\n+ 在ngAfterViewInit、ngAfterViewChecked方法里面改变去改变组件属性的值，angular会抛出异常：\n\n  ```\n  <div>{{message}}</div>\n\n  message:string;\n  ngAfterViewInit(){\n    this.message = 'hello';\n  }\n\n  // Error!!\n  ```\n\n  这是因为，在变更检测周期中，angular禁止在一个视图已经组装好之后，再去更新视图。而ngAfterViewInit是在视图已经组装好之后触发的。\n\n  同样，ngAfterViewChecked方法也是在视图组装好之后触发的，所以在ngAfterViewChecked方法中去更新视图也会抛出异常。\n\n  ```\n  <div>{{message}}</div>\n\n  message:string;\n  ngAfterViewChecked(){\n    this.message = 'hello';\n  }\n\n  // Error!!\n  ```\n\n  如果需要在ngAfterViewInit或者ngAfterViewChecked中改变视图，放在一个setTimeOut中就可以：\n\n  ```html\n  <div>{{message}}</div>\n\n  message:string;\n  ngAfterViewChecked(){\n  \tsetTimeOut(() => {\n        this.message = 'hello';\n  \t},0)\n  }\n\n  // hello\n  ```\n\n# ng-content指令\n\nng-content指令：父组件的内容投影到子组件中。\n\n```html\n// 父组件\n<app-child>\n\t<div class=\"content1\">内容1</div>\n\t<div class=\"content2\">内容2</div>\n</app-child>\n\n//子组件\n<div>\n\t<ng-content select=\".content1\"></ng-content>\n\t<div>\n    \t<ng-content select=\".content2\"></ng-content>  \n  \t</div>\n</div>\n\n```\n\n# ngContent钩子\n\nngContent钩子和ngView钩子类似，不同的是ngContent钩子针对的是父组件投影到子组件的部分。\n\n`ngAfterContentInit`是在投影进来的内容初始化完毕后调用的。\n\n`ngAfterContentChecked`是针对投影进来的内通进行变更检测的。\n\n+ 先完成投影内容的初始化和检测，再完成整个视图的初始化和检测。\n+ 在`ngAfterContentInit`和`ngAfterContentChecked`中改变视图内容是不会报错的，因为在调用这两个钩子被调用的时候整个视图还没有被组装完。\n\n# 组件生命周期\n\n+ 组件初始化阶段：\n\n  + 属性初始化阶段：\n\n    1. constructor（只调用一次）：构造函数实例化对象\n    2. ngOnChanges：初始化输入属性\n    3. ngOnInit（只调用一次） ：初始化除了输入属性以外的所有其他属性。\n    4. ngDoCheck：做一次变更检查\n\n  + 这时整个组件的属性都应该被赋予了需要被赋予的值，这时开始渲染视图\n\n  + 视图初始化阶段：\n\n    ​\t先渲染投影部分的内容，投影部分渲染完毕后调用下面两个钩子。\n\n    5. ngAfterContentInit（只调用一次）：\n\n    6. ngAfterContentChecked：\n\n       这时如果组件有子组件，那么进入子组件的生命周期。\n\n       如果没有子组件，或者所有子组件的生命周期执行完毕，这时如果组件的全部视图渲染完了，会调用下面两个方法：\n\n    7. ngAfterViewInit（只调用一次）：\n\n    8. ngAfterViewChecked：\n\n当7，8方法调用完毕后，整个组件的初始化过程就完毕了这时候，组件就会呈现出来，给到用户做一些交互。\n\n而用户做的任何一个交互，比如鼠标点击，键盘输入，都会出发angular的变更检测机制。\n\n而一旦检测到发生了变更，那么在当前组件树上，所有活动 组件上被实现的带有`check`关键字的方法，都会被调用，用来检查当前组件的变化。\n\n如果某个组件的变化导致输入属性也改变了，那么这个组件的ngOnChanges方法也会被调用。\n\n+ 变更检测阶段：\n\n  ngOnChanges\n\n  ngDoCheck\n\n  ngAfterContentChecked\n\n  ngAfterViewChecked\n\n+ 组件销毁\n\n  最终当组件被销毁的时候，会调用ngOnDestroy。\n\n  组件会在路由的时候被销毁。","slug":"Angular4——6-组件间通讯","published":1,"updated":"2021-05-08T15:00:37.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbod000ewct4fochg6as","content":"<h1 id=\"输入属性\"><a href=\"#输入属性\" class=\"headerlink\" title=\"输入属性\"></a>输入属性</h1><p><strong>父组件</strong>将数据传递给<strong>子组件</strong>。</p>\n<p>在子组件中，被<code>@Input()</code>装饰器注解的属性，可以接收父组件的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 父组件.ts</span><br><span class=\"line\">export class fatherComponent&#123;</span><br><span class=\"line\">  father:string &#x3D; &#39;hello&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 父组件.html</span><br><span class=\"line\">&lt;div&gt;我是父组件&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;app-child [son]&#x3D;&quot;father&quot;&gt;&lt;&#x2F;app-child&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 子组件.ts</span><br><span class=\"line\">export class ChildComponent&#123;</span><br><span class=\"line\">  @Input() son:string;\t\t&#x2F;&#x2F; &#39;hello&#39;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过输入、输出属性传递参数的方式只能用在父子组件中。</p>\n<h1 id=\"EventEmitter自定义事件\"><a href=\"#EventEmitter自定义事件\" class=\"headerlink\" title=\"EventEmitter自定义事件\"></a>EventEmitter自定义事件</h1><p>EventEmitter是RxJS中<code>subject</code>类的子类。</p>\n<p>在响应式编程中，EventEmitter即可以作为观察者，也可以作为被观察者。</p>\n<p>EventEmitter即可以通过<code>emit()</code>方法发射自定义事件，也可以通过<code>subscribe()</code>方法订阅所发射的事件流。</p>\n<p>EvevtEmitter需要一个泛型，泛型是要发射的事件的类型。</p>\n<h1 id=\"输出属性\"><a href=\"#输出属性\" class=\"headerlink\" title=\"输出属性\"></a>输出属性</h1><p><strong>子组件</strong>传递数据给<strong>父组件</strong>。</p>\n<p>在子组件中，被<code>@Output()</code>装饰器注解的属性，可以被父组件接收。</p>\n<p>例：通过输出属性向外发射事件，并通过实践携带数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 子组件.ts</span><br><span class=\"line\">export class childComponent implements OnInit&#123;</span><br><span class=\"line\">  @Output()</span><br><span class=\"line\">  sendData: EventEmitter&lt;要发射的数据的类型&gt; &#x3D; new EventEmitter();</span><br><span class=\"line\">  </span><br><span class=\"line\">  ngOnInit()&#123;</span><br><span class=\"line\">  \tlet data &#x3D; &#39;123&#39;;</span><br><span class=\"line\">    this.sendData.emit(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 父组件.html</span><br><span class=\"line\">&lt;div&gt;我是父组件&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;app-child (sendData)&#x3D;&quot;getData($event)&quot;&gt;&lt;&#x2F;app-child&gt;\t&#x2F;&#x2F;这里的$event就是子组件中emit()方法发射的数据</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 父组件.ts</span><br><span class=\"line\">export class fatherComponent&#123;</span><br><span class=\"line\">  getData(data:数据类型)&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Output装饰器函数可以为输出属性重命名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; child</span><br><span class=\"line\">@Output(&#39;newName&#39;)</span><br><span class=\"line\">sendData:EventEmitter&lt;要发射的数据的类型&gt; &#x3D; new EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;father</span><br><span class=\"line\">&lt;div&gt;我是父组件&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;app-child (newName)&#x3D;&quot;getData($event)&gt;&lt;&#x2F;app-child&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"中间人模式\"><a href=\"#中间人模式\" class=\"headerlink\" title=\"中间人模式\"></a>中间人模式</h1><p>由于输入输出属性只能用于父子关系的组件间传递数据。如果一个父组件下的两个子组件间要传递数据，可以将父组件当作中间人，通过中间人进行传递</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 子组件A 发射事件</span><br><span class=\"line\">export class AChildComponent&#123;</span><br><span class=\"line\">  @Output()</span><br><span class=\"line\">  sendData: EventEmitter&lt;string&gt; &#x3D; new EventEmitter();</span><br><span class=\"line\">  NgOnInit()&#123;</span><br><span class=\"line\">  \tlet data:string &#x3D; &#39;123&#39;;</span><br><span class=\"line\">    this.sendData.emit(data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 父组件 中间人，捕获子组件A发射的事件，并把数据输出给子组件B</span><br><span class=\"line\">&lt;div&gt;我是父组件 中间人&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;app-achild (sendData)&#x3D;&quot;getData($event)&quot;&gt;发送数据的组件A&lt;&#x2F;app-achild&gt;</span><br><span class=\"line\">&lt;app-bchild [bValue]&#x3D;&quot;value&gt;接收数据的组件B&lt;&#x2F;app-bchild&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export class father&#123;</span><br><span class=\"line\">  value:string;</span><br><span class=\"line\">  getData(data:string)&#123;</span><br><span class=\"line\">    this.value &#x3D; data</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 子组件B 接收数据</span><br><span class=\"line\">export class BChildComponent&#123;</span><br><span class=\"line\">  @Input()</span><br><span class=\"line\">  bValue:string;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当两个组件有共同的父组件时，可以使用父组件作为中间人进行通讯。</p>\n<p>如果两个组件没有共同的父组件，应该使用一个可注入的服务作为中间人进行通讯。</p>\n<h1 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h1><p>组件初始化：constructor（只调用一次），ngOnChanges，ngOnInit（只调用一次），ngDoCheck，ngAfterContentInit（只调用一次），ngAfterContentChecked，ngAfterViewInit（只调用一次），ngAfterViewChecked</p>\n<p>变化检测：ngOnChanges，ngDoCheck，ngAfterContentChecked，ngAfterViewChecked</p>\n<p>组件销毁：ngOnDestroy（只调用一次）</p>\n<p>组件从创建到销毁依次调用以下生命周期钩子函数：</p>\n<ol>\n<li><p>constructor</p>\n<p>当一个组件被创建时，首先调用构造函数方法。</p>\n<p>构造函数一定会被调用，但其他钩子函数是根据需要来调用的。</p>\n</li>\n<li><p>ngOnChanges</p>\n<p>ngOnChanges(changes: SimpleChange){ }</p>\n<p>这个钩子函数，是当一个父组件修改或初始化一个子组件的输入属性时才调用的。</p>\n<p>如果一个组件没有输入属性，ngOnChanges方法永远不会被调用。</p>\n<p>ngOnChanges首次调用一定发生在ngOnInit之前，而且这个方法可以被多次调用，每当输入属性变化时就会被调用。</p>\n</li>\n<li><p>ngOnInit</p>\n<p>如果组件存在输入属性，则ngOnInit方法在ngOnChanges首次调用之后被调用，用来初始化组件或指令。</p>\n<p>不在构造函数里初始化的原因：</p>\n<p>输入属性在构造函数里是空的，输入属性是在首次调用ngOnChanges时被初始化的。所以，如果组件的初始化逻辑依赖输入属性的值，那么初始化逻辑一定要卸载ngOnInit里。</p>\n</li>\n<li><p>ngDoCheck</p>\n<p>在每个angular变更检测周期中调用，用来检测</p>\n</li>\n<li><p>ngAfterContentInit</p>\n</li>\n<li><p>ngAfterContentChecked</p>\n</li>\n<li><p>ngAfterViewInit</p>\n</li>\n<li><p>ngAfterViewChecked</p>\n</li>\n<li><p>ngOnDestroy</p>\n</li>\n</ol>\n<h2 id=\"onChanges钩子\"><a href=\"#onChanges钩子\" class=\"headerlink\" title=\"onChanges钩子\"></a>onChanges钩子</h2><p>这个钩子是在父组件初始化或者修改子组件的输入属性时被调用。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>首先，ngOnChanges钩子只有在输入属性变化时才会被调用，组件自身的属性通过<code>[(ngModel)]</code>双向绑定的方式改变，不会调用ngOnChanges。</p>\n</li>\n<li><p>其次，只有输入属性的值的类型是number、string这种不可变的原始类型时，输入属性改变时，ngOnChanges才会被调用；如果输入属性的值的类型是对象这种可变的复杂类型时，ngOnChanges不会被调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;father</span><br><span class=\"line\">greeting:string &#x3D; &quot;hello&quot;;</span><br><span class=\"line\">&lt;app-child [greeting]&#x3D;&quot;greeting&quot;&gt;&lt;&#x2F;app-child&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;child</span><br><span class=\"line\">@Input()</span><br><span class=\"line\">greeting:string;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnChanges(changes: SimpleChanges)&#123;</span><br><span class=\"line\">  console.log(&#39;OK&#39;)\t\t&#x2F;&#x2F; &#39;ok&#39;\t\tngOnChanges被调用，输入属性也被初始化</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div&gt;&#123;&#123;greeting&#125;&#125;&lt;&#x2F;div&gt;\t\t&#x2F;&#x2F; hello</span><br></pre></td></tr></table></figure></li>\n<li><p>最后，虽然输入属性的值的类型为对象时，ngOnChanges不会被调用，但是输入属性依然能够正确初始化，这是因为angular的变更检测机制起了作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;father</span><br><span class=\"line\">user:&#123;name:string&#125; &#x3D; &#123;name: &quot;tom&quot;&#125;</span><br><span class=\"line\">&lt;app-child [user]&#x3D;&quot;user&quot;&gt;&lt;&#x2F;app-child&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;child</span><br><span class=\"line\">@Input()</span><br><span class=\"line\">user:&#123;name:string&#125;;</span><br><span class=\"line\">ngOnChanges(changes: SimpleChanges)&#123;</span><br><span class=\"line\">  console.log(&#39;OK&#39;)\t\t&#x2F;&#x2F;\t  ngOnChanges没有被调用，因为输入属性是一个对象，是一个可变类型</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div&gt;&#123;&#123;user.name&#125;&#125;&lt;&#x2F;div&gt;\t\t&#x2F;&#x2F; tom 但是输入属性依然能偶被初始化</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"变更检测机制和DoCheck\"><a href=\"#变更检测机制和DoCheck\" class=\"headerlink\" title=\"变更检测机制和DoCheck\"></a>变更检测机制和DoCheck</h1><h2 id=\"变更检测机制\"><a href=\"#变更检测机制\" class=\"headerlink\" title=\"变更检测机制\"></a>变更检测机制</h2><p>angular中实现变更检测机制的包是<code>zone.js</code>，它的作用是使组件的属性和页面同步变化。</p>\n<p>浏览器的任何异步事件，如按钮点击，setTimeOut方法等，都会出发变更检测。</p>\n<p>在angular1中，原生的事件无法触发脏检查，比如按钮click事件。而在aunglar2以后，原声事件随便用。</p>\n<p>变更检测机制只是将属性的改变反映到模版上，变更检测机制本身永远不会改变属性的值。</p>\n<h3 id=\"变更检测原理\"><a href=\"#变更检测原理\" class=\"headerlink\" title=\"变更检测原理\"></a>变更检测原理</h3><p>angular应用是一个以主组件为根的组件树，当angular应用运行时，每一个组件都会生成一个它自己的变更检测器。当任何一个变更检测器检测到变化时，<code>zone.js</code>就会根据组件的变更检测策略来检查组件，以判断组件是否需要更新模版。</p>\n<p>###变更检测策略</p>\n<p>angular实现了两个变更检测策略，一个是default，一个是OnPush。</p>\n<p>默认情况下所有组件都是default策略。</p>\n<p>如果所有的组件都是default策略，那么不管变更发生在哪个组件上，<code>zone.js</code>都会检查整个组件树。</p>\n<p><code>zone.js</code>从跟组件开始向下检查，当遇到是OnPush策略的组件时，就不会检查该组件及其以下的组件。</p>\n<h2 id=\"DoCheck\"><a href=\"#DoCheck\" class=\"headerlink\" title=\"DoCheck\"></a>DoCheck</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngDoCheck()&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>鼠标的点击，键盘按键，都会出发变更检测，所谓的触发变更检测就是调用DoCheck钩子，因此在调用ngDoCheck的时候要小心使用。</p>\n<h1 id=\"View钩子\"><a href=\"#View钩子\" class=\"headerlink\" title=\"View钩子\"></a>View钩子</h1><h2 id=\"父组件调用子组件的方法\"><a href=\"#父组件调用子组件的方法\" class=\"headerlink\" title=\"父组件调用子组件的方法\"></a>父组件调用子组件的方法</h2><p>父组件调用子组件的方法有两种，一种是在控制器中通过<code>@ViewChild()</code>装饰器来调用，另一种是在模版中通过模版本地变量调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 子组件.ts</span><br><span class=\"line\">export class ChildComponent&#123;</span><br><span class=\"line\">  greeting(name:string)&#123;</span><br><span class=\"line\">    console.log(&#39;hello&#39;+name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 父组件</span><br><span class=\"line\">&lt;app-child #child1&gt;&lt;&#x2F;app-child&gt;\t\t&#x2F;&#x2F; &#39;hello Tom&#39;</span><br><span class=\"line\">&lt;app-child #child2&gt;&lt;&#x2F;app-child&gt;</span><br><span class=\"line\">&lt;button (click)&#x3D;&quot;child2.greeting(&#39;Jerry&#39;)&quot;&gt;点我&lt;&#x2F;button&gt;\t\t&#x2F;&#x2F; &#39;hello Jerry&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">export class fatherComponent implements OnInit&#123;</span><br><span class=\"line\">  @ViewChild(&quot;child1&quot;)\t\t\t&#x2F;&#x2F;装饰器函数有一个参数，值就是模版中声明的模版本地变量</span><br><span class=\"line\">  child1:ChildComponent;</span><br><span class=\"line\">  </span><br><span class=\"line\">  ngOnInit()&#123;</span><br><span class=\"line\">    this.child1.greeting(&quot;Tom&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ngAfterViewInit、ngAfterViewChecked\"><a href=\"#ngAfterViewInit、ngAfterViewChecked\" class=\"headerlink\" title=\"ngAfterViewInit、ngAfterViewChecked\"></a>ngAfterViewInit、ngAfterViewChecked</h2><ul>\n<li><p>ngAfterViewInit的调用先于ngAfterViewChecked，这两个方法都是在组件的视图被组装完毕以后调用的。  </p>\n</li>\n<li><p>如果一个组件有子组件，那么父组件要在所有子组件的视图都组装完毕以后，才会调用自己的ngAfterViewInit和ngAfterViewChecked方法。</p>\n</li>\n<li><p>ngAfterViewInit只会在视图初始化完毕后调用一次，之后永远不会再调用。</p>\n</li>\n<li><p>在ngAfterViewInit、ngAfterViewChecked方法里面改变去改变组件属性的值，angular会抛出异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">message:string;</span><br><span class=\"line\">ngAfterViewInit()&#123;</span><br><span class=\"line\">  this.message &#x3D; &#39;hello&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Error!!</span><br></pre></td></tr></table></figure>\n\n<p>这是因为，在变更检测周期中，angular禁止在一个视图已经组装好之后，再去更新视图。而ngAfterViewInit是在视图已经组装好之后触发的。</p>\n<p>同样，ngAfterViewChecked方法也是在视图组装好之后触发的，所以在ngAfterViewChecked方法中去更新视图也会抛出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">message:string;</span><br><span class=\"line\">ngAfterViewChecked()&#123;</span><br><span class=\"line\">  this.message &#x3D; &#39;hello&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Error!!</span><br></pre></td></tr></table></figure>\n\n<p>如果需要在ngAfterViewInit或者ngAfterViewChecked中改变视图，放在一个setTimeOut中就可以：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">message:string;</span><br><span class=\"line\">ngAfterViewChecked()&#123;</span><br><span class=\"line\">\tsetTimeOut(() =&gt; &#123;</span><br><span class=\"line\">      this.message = &#x27;hello&#x27;;</span><br><span class=\"line\">\t&#125;,0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// hello</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"ng-content指令\"><a href=\"#ng-content指令\" class=\"headerlink\" title=\"ng-content指令\"></a>ng-content指令</h1><p>ng-content指令：父组件的内容投影到子组件中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content1&quot;</span>&gt;</span>内容1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content2&quot;</span>&gt;</span>内容2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-child</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//子组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">ng-content</span> <span class=\"attr\">select</span>=<span class=\"string\">&quot;.content1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">ng-content</span> <span class=\"attr\">select</span>=<span class=\"string\">&quot;.content2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span>  </span><br><span class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ngContent钩子\"><a href=\"#ngContent钩子\" class=\"headerlink\" title=\"ngContent钩子\"></a>ngContent钩子</h1><p>ngContent钩子和ngView钩子类似，不同的是ngContent钩子针对的是父组件投影到子组件的部分。</p>\n<p><code>ngAfterContentInit</code>是在投影进来的内容初始化完毕后调用的。</p>\n<p><code>ngAfterContentChecked</code>是针对投影进来的内通进行变更检测的。</p>\n<ul>\n<li>先完成投影内容的初始化和检测，再完成整个视图的初始化和检测。</li>\n<li>在<code>ngAfterContentInit</code>和<code>ngAfterContentChecked</code>中改变视图内容是不会报错的，因为在调用这两个钩子被调用的时候整个视图还没有被组装完。</li>\n</ul>\n<h1 id=\"组件生命周期-1\"><a href=\"#组件生命周期-1\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h1><ul>\n<li><p>组件初始化阶段：</p>\n<ul>\n<li><p>属性初始化阶段：</p>\n<ol>\n<li>constructor（只调用一次）：构造函数实例化对象</li>\n<li>ngOnChanges：初始化输入属性</li>\n<li>ngOnInit（只调用一次） ：初始化除了输入属性以外的所有其他属性。</li>\n<li>ngDoCheck：做一次变更检查</li>\n</ol>\n</li>\n<li><p>这时整个组件的属性都应该被赋予了需要被赋予的值，这时开始渲染视图</p>\n</li>\n<li><p>视图初始化阶段：</p>\n<p>​    先渲染投影部分的内容，投影部分渲染完毕后调用下面两个钩子。</p>\n<ol start=\"5\">\n<li><p>ngAfterContentInit（只调用一次）：</p>\n</li>\n<li><p>ngAfterContentChecked：</p>\n<p>这时如果组件有子组件，那么进入子组件的生命周期。</p>\n<p>如果没有子组件，或者所有子组件的生命周期执行完毕，这时如果组件的全部视图渲染完了，会调用下面两个方法：</p>\n</li>\n<li><p>ngAfterViewInit（只调用一次）：</p>\n</li>\n<li><p>ngAfterViewChecked：</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p>当7，8方法调用完毕后，整个组件的初始化过程就完毕了这时候，组件就会呈现出来，给到用户做一些交互。</p>\n<p>而用户做的任何一个交互，比如鼠标点击，键盘输入，都会出发angular的变更检测机制。</p>\n<p>而一旦检测到发生了变更，那么在当前组件树上，所有活动 组件上被实现的带有<code>check</code>关键字的方法，都会被调用，用来检查当前组件的变化。</p>\n<p>如果某个组件的变化导致输入属性也改变了，那么这个组件的ngOnChanges方法也会被调用。</p>\n<ul>\n<li><p>变更检测阶段：</p>\n<p>ngOnChanges</p>\n<p>ngDoCheck</p>\n<p>ngAfterContentChecked</p>\n<p>ngAfterViewChecked</p>\n</li>\n<li><p>组件销毁</p>\n<p>最终当组件被销毁的时候，会调用ngOnDestroy。</p>\n<p>组件会在路由的时候被销毁。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"输入属性\"><a href=\"#输入属性\" class=\"headerlink\" title=\"输入属性\"></a>输入属性</h1><p><strong>父组件</strong>将数据传递给<strong>子组件</strong>。</p>\n<p>在子组件中，被<code>@Input()</code>装饰器注解的属性，可以接收父组件的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 父组件.ts</span><br><span class=\"line\">export class fatherComponent&#123;</span><br><span class=\"line\">  father:string &#x3D; &#39;hello&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; 父组件.html</span><br><span class=\"line\">&lt;div&gt;我是父组件&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;app-child [son]&#x3D;&quot;father&quot;&gt;&lt;&#x2F;app-child&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 子组件.ts</span><br><span class=\"line\">export class ChildComponent&#123;</span><br><span class=\"line\">  @Input() son:string;\t\t&#x2F;&#x2F; &#39;hello&#39;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过输入、输出属性传递参数的方式只能用在父子组件中。</p>\n<h1 id=\"EventEmitter自定义事件\"><a href=\"#EventEmitter自定义事件\" class=\"headerlink\" title=\"EventEmitter自定义事件\"></a>EventEmitter自定义事件</h1><p>EventEmitter是RxJS中<code>subject</code>类的子类。</p>\n<p>在响应式编程中，EventEmitter即可以作为观察者，也可以作为被观察者。</p>\n<p>EventEmitter即可以通过<code>emit()</code>方法发射自定义事件，也可以通过<code>subscribe()</code>方法订阅所发射的事件流。</p>\n<p>EvevtEmitter需要一个泛型，泛型是要发射的事件的类型。</p>\n<h1 id=\"输出属性\"><a href=\"#输出属性\" class=\"headerlink\" title=\"输出属性\"></a>输出属性</h1><p><strong>子组件</strong>传递数据给<strong>父组件</strong>。</p>\n<p>在子组件中，被<code>@Output()</code>装饰器注解的属性，可以被父组件接收。</p>\n<p>例：通过输出属性向外发射事件，并通过实践携带数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 子组件.ts</span><br><span class=\"line\">export class childComponent implements OnInit&#123;</span><br><span class=\"line\">  @Output()</span><br><span class=\"line\">  sendData: EventEmitter&lt;要发射的数据的类型&gt; &#x3D; new EventEmitter();</span><br><span class=\"line\">  </span><br><span class=\"line\">  ngOnInit()&#123;</span><br><span class=\"line\">  \tlet data &#x3D; &#39;123&#39;;</span><br><span class=\"line\">    this.sendData.emit(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 父组件.html</span><br><span class=\"line\">&lt;div&gt;我是父组件&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;app-child (sendData)&#x3D;&quot;getData($event)&quot;&gt;&lt;&#x2F;app-child&gt;\t&#x2F;&#x2F;这里的$event就是子组件中emit()方法发射的数据</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 父组件.ts</span><br><span class=\"line\">export class fatherComponent&#123;</span><br><span class=\"line\">  getData(data:数据类型)&#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Output装饰器函数可以为输出属性重命名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; child</span><br><span class=\"line\">@Output(&#39;newName&#39;)</span><br><span class=\"line\">sendData:EventEmitter&lt;要发射的数据的类型&gt; &#x3D; new EventEmitter();</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;father</span><br><span class=\"line\">&lt;div&gt;我是父组件&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;app-child (newName)&#x3D;&quot;getData($event)&gt;&lt;&#x2F;app-child&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"中间人模式\"><a href=\"#中间人模式\" class=\"headerlink\" title=\"中间人模式\"></a>中间人模式</h1><p>由于输入输出属性只能用于父子关系的组件间传递数据。如果一个父组件下的两个子组件间要传递数据，可以将父组件当作中间人，通过中间人进行传递</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 子组件A 发射事件</span><br><span class=\"line\">export class AChildComponent&#123;</span><br><span class=\"line\">  @Output()</span><br><span class=\"line\">  sendData: EventEmitter&lt;string&gt; &#x3D; new EventEmitter();</span><br><span class=\"line\">  NgOnInit()&#123;</span><br><span class=\"line\">  \tlet data:string &#x3D; &#39;123&#39;;</span><br><span class=\"line\">    this.sendData.emit(data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 父组件 中间人，捕获子组件A发射的事件，并把数据输出给子组件B</span><br><span class=\"line\">&lt;div&gt;我是父组件 中间人&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;app-achild (sendData)&#x3D;&quot;getData($event)&quot;&gt;发送数据的组件A&lt;&#x2F;app-achild&gt;</span><br><span class=\"line\">&lt;app-bchild [bValue]&#x3D;&quot;value&gt;接收数据的组件B&lt;&#x2F;app-bchild&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">export class father&#123;</span><br><span class=\"line\">  value:string;</span><br><span class=\"line\">  getData(data:string)&#123;</span><br><span class=\"line\">    this.value &#x3D; data</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 子组件B 接收数据</span><br><span class=\"line\">export class BChildComponent&#123;</span><br><span class=\"line\">  @Input()</span><br><span class=\"line\">  bValue:string;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当两个组件有共同的父组件时，可以使用父组件作为中间人进行通讯。</p>\n<p>如果两个组件没有共同的父组件，应该使用一个可注入的服务作为中间人进行通讯。</p>\n<h1 id=\"组件生命周期\"><a href=\"#组件生命周期\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h1><p>组件初始化：constructor（只调用一次），ngOnChanges，ngOnInit（只调用一次），ngDoCheck，ngAfterContentInit（只调用一次），ngAfterContentChecked，ngAfterViewInit（只调用一次），ngAfterViewChecked</p>\n<p>变化检测：ngOnChanges，ngDoCheck，ngAfterContentChecked，ngAfterViewChecked</p>\n<p>组件销毁：ngOnDestroy（只调用一次）</p>\n<p>组件从创建到销毁依次调用以下生命周期钩子函数：</p>\n<ol>\n<li><p>constructor</p>\n<p>当一个组件被创建时，首先调用构造函数方法。</p>\n<p>构造函数一定会被调用，但其他钩子函数是根据需要来调用的。</p>\n</li>\n<li><p>ngOnChanges</p>\n<p>ngOnChanges(changes: SimpleChange){ }</p>\n<p>这个钩子函数，是当一个父组件修改或初始化一个子组件的输入属性时才调用的。</p>\n<p>如果一个组件没有输入属性，ngOnChanges方法永远不会被调用。</p>\n<p>ngOnChanges首次调用一定发生在ngOnInit之前，而且这个方法可以被多次调用，每当输入属性变化时就会被调用。</p>\n</li>\n<li><p>ngOnInit</p>\n<p>如果组件存在输入属性，则ngOnInit方法在ngOnChanges首次调用之后被调用，用来初始化组件或指令。</p>\n<p>不在构造函数里初始化的原因：</p>\n<p>输入属性在构造函数里是空的，输入属性是在首次调用ngOnChanges时被初始化的。所以，如果组件的初始化逻辑依赖输入属性的值，那么初始化逻辑一定要卸载ngOnInit里。</p>\n</li>\n<li><p>ngDoCheck</p>\n<p>在每个angular变更检测周期中调用，用来检测</p>\n</li>\n<li><p>ngAfterContentInit</p>\n</li>\n<li><p>ngAfterContentChecked</p>\n</li>\n<li><p>ngAfterViewInit</p>\n</li>\n<li><p>ngAfterViewChecked</p>\n</li>\n<li><p>ngOnDestroy</p>\n</li>\n</ol>\n<h2 id=\"onChanges钩子\"><a href=\"#onChanges钩子\" class=\"headerlink\" title=\"onChanges钩子\"></a>onChanges钩子</h2><p>这个钩子是在父组件初始化或者修改子组件的输入属性时被调用。</p>\n<p><strong>注意</strong>：</p>\n<ul>\n<li><p>首先，ngOnChanges钩子只有在输入属性变化时才会被调用，组件自身的属性通过<code>[(ngModel)]</code>双向绑定的方式改变，不会调用ngOnChanges。</p>\n</li>\n<li><p>其次，只有输入属性的值的类型是number、string这种不可变的原始类型时，输入属性改变时，ngOnChanges才会被调用；如果输入属性的值的类型是对象这种可变的复杂类型时，ngOnChanges不会被调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;father</span><br><span class=\"line\">greeting:string &#x3D; &quot;hello&quot;;</span><br><span class=\"line\">&lt;app-child [greeting]&#x3D;&quot;greeting&quot;&gt;&lt;&#x2F;app-child&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;child</span><br><span class=\"line\">@Input()</span><br><span class=\"line\">greeting:string;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnChanges(changes: SimpleChanges)&#123;</span><br><span class=\"line\">  console.log(&#39;OK&#39;)\t\t&#x2F;&#x2F; &#39;ok&#39;\t\tngOnChanges被调用，输入属性也被初始化</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div&gt;&#123;&#123;greeting&#125;&#125;&lt;&#x2F;div&gt;\t\t&#x2F;&#x2F; hello</span><br></pre></td></tr></table></figure></li>\n<li><p>最后，虽然输入属性的值的类型为对象时，ngOnChanges不会被调用，但是输入属性依然能够正确初始化，这是因为angular的变更检测机制起了作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;father</span><br><span class=\"line\">user:&#123;name:string&#125; &#x3D; &#123;name: &quot;tom&quot;&#125;</span><br><span class=\"line\">&lt;app-child [user]&#x3D;&quot;user&quot;&gt;&lt;&#x2F;app-child&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;child</span><br><span class=\"line\">@Input()</span><br><span class=\"line\">user:&#123;name:string&#125;;</span><br><span class=\"line\">ngOnChanges(changes: SimpleChanges)&#123;</span><br><span class=\"line\">  console.log(&#39;OK&#39;)\t\t&#x2F;&#x2F;\t  ngOnChanges没有被调用，因为输入属性是一个对象，是一个可变类型</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div&gt;&#123;&#123;user.name&#125;&#125;&lt;&#x2F;div&gt;\t\t&#x2F;&#x2F; tom 但是输入属性依然能偶被初始化</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"变更检测机制和DoCheck\"><a href=\"#变更检测机制和DoCheck\" class=\"headerlink\" title=\"变更检测机制和DoCheck\"></a>变更检测机制和DoCheck</h1><h2 id=\"变更检测机制\"><a href=\"#变更检测机制\" class=\"headerlink\" title=\"变更检测机制\"></a>变更检测机制</h2><p>angular中实现变更检测机制的包是<code>zone.js</code>，它的作用是使组件的属性和页面同步变化。</p>\n<p>浏览器的任何异步事件，如按钮点击，setTimeOut方法等，都会出发变更检测。</p>\n<p>在angular1中，原生的事件无法触发脏检查，比如按钮click事件。而在aunglar2以后，原声事件随便用。</p>\n<p>变更检测机制只是将属性的改变反映到模版上，变更检测机制本身永远不会改变属性的值。</p>\n<h3 id=\"变更检测原理\"><a href=\"#变更检测原理\" class=\"headerlink\" title=\"变更检测原理\"></a>变更检测原理</h3><p>angular应用是一个以主组件为根的组件树，当angular应用运行时，每一个组件都会生成一个它自己的变更检测器。当任何一个变更检测器检测到变化时，<code>zone.js</code>就会根据组件的变更检测策略来检查组件，以判断组件是否需要更新模版。</p>\n<p>###变更检测策略</p>\n<p>angular实现了两个变更检测策略，一个是default，一个是OnPush。</p>\n<p>默认情况下所有组件都是default策略。</p>\n<p>如果所有的组件都是default策略，那么不管变更发生在哪个组件上，<code>zone.js</code>都会检查整个组件树。</p>\n<p><code>zone.js</code>从跟组件开始向下检查，当遇到是OnPush策略的组件时，就不会检查该组件及其以下的组件。</p>\n<h2 id=\"DoCheck\"><a href=\"#DoCheck\" class=\"headerlink\" title=\"DoCheck\"></a>DoCheck</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngDoCheck()&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>鼠标的点击，键盘按键，都会出发变更检测，所谓的触发变更检测就是调用DoCheck钩子，因此在调用ngDoCheck的时候要小心使用。</p>\n<h1 id=\"View钩子\"><a href=\"#View钩子\" class=\"headerlink\" title=\"View钩子\"></a>View钩子</h1><h2 id=\"父组件调用子组件的方法\"><a href=\"#父组件调用子组件的方法\" class=\"headerlink\" title=\"父组件调用子组件的方法\"></a>父组件调用子组件的方法</h2><p>父组件调用子组件的方法有两种，一种是在控制器中通过<code>@ViewChild()</code>装饰器来调用，另一种是在模版中通过模版本地变量调用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 子组件.ts</span><br><span class=\"line\">export class ChildComponent&#123;</span><br><span class=\"line\">  greeting(name:string)&#123;</span><br><span class=\"line\">    console.log(&#39;hello&#39;+name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 父组件</span><br><span class=\"line\">&lt;app-child #child1&gt;&lt;&#x2F;app-child&gt;\t\t&#x2F;&#x2F; &#39;hello Tom&#39;</span><br><span class=\"line\">&lt;app-child #child2&gt;&lt;&#x2F;app-child&gt;</span><br><span class=\"line\">&lt;button (click)&#x3D;&quot;child2.greeting(&#39;Jerry&#39;)&quot;&gt;点我&lt;&#x2F;button&gt;\t\t&#x2F;&#x2F; &#39;hello Jerry&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">export class fatherComponent implements OnInit&#123;</span><br><span class=\"line\">  @ViewChild(&quot;child1&quot;)\t\t\t&#x2F;&#x2F;装饰器函数有一个参数，值就是模版中声明的模版本地变量</span><br><span class=\"line\">  child1:ChildComponent;</span><br><span class=\"line\">  </span><br><span class=\"line\">  ngOnInit()&#123;</span><br><span class=\"line\">    this.child1.greeting(&quot;Tom&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ngAfterViewInit、ngAfterViewChecked\"><a href=\"#ngAfterViewInit、ngAfterViewChecked\" class=\"headerlink\" title=\"ngAfterViewInit、ngAfterViewChecked\"></a>ngAfterViewInit、ngAfterViewChecked</h2><ul>\n<li><p>ngAfterViewInit的调用先于ngAfterViewChecked，这两个方法都是在组件的视图被组装完毕以后调用的。  </p>\n</li>\n<li><p>如果一个组件有子组件，那么父组件要在所有子组件的视图都组装完毕以后，才会调用自己的ngAfterViewInit和ngAfterViewChecked方法。</p>\n</li>\n<li><p>ngAfterViewInit只会在视图初始化完毕后调用一次，之后永远不会再调用。</p>\n</li>\n<li><p>在ngAfterViewInit、ngAfterViewChecked方法里面改变去改变组件属性的值，angular会抛出异常：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">message:string;</span><br><span class=\"line\">ngAfterViewInit()&#123;</span><br><span class=\"line\">  this.message &#x3D; &#39;hello&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Error!!</span><br></pre></td></tr></table></figure>\n\n<p>这是因为，在变更检测周期中，angular禁止在一个视图已经组装好之后，再去更新视图。而ngAfterViewInit是在视图已经组装好之后触发的。</p>\n<p>同样，ngAfterViewChecked方法也是在视图组装好之后触发的，所以在ngAfterViewChecked方法中去更新视图也会抛出异常。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">message:string;</span><br><span class=\"line\">ngAfterViewChecked()&#123;</span><br><span class=\"line\">  this.message &#x3D; &#39;hello&#39;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; Error!!</span><br></pre></td></tr></table></figure>\n\n<p>如果需要在ngAfterViewInit或者ngAfterViewChecked中改变视图，放在一个setTimeOut中就可以：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">message:string;</span><br><span class=\"line\">ngAfterViewChecked()&#123;</span><br><span class=\"line\">\tsetTimeOut(() =&gt; &#123;</span><br><span class=\"line\">      this.message = &#x27;hello&#x27;;</span><br><span class=\"line\">\t&#125;,0)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// hello</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"ng-content指令\"><a href=\"#ng-content指令\" class=\"headerlink\" title=\"ng-content指令\"></a>ng-content指令</h1><p>ng-content指令：父组件的内容投影到子组件中。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">app-child</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content1&quot;</span>&gt;</span>内容1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content2&quot;</span>&gt;</span>内容2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">app-child</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//子组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">ng-content</span> <span class=\"attr\">select</span>=<span class=\"string\">&quot;.content1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">ng-content</span> <span class=\"attr\">select</span>=<span class=\"string\">&quot;.content2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">ng-content</span>&gt;</span>  </span><br><span class=\"line\">  \t<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"ngContent钩子\"><a href=\"#ngContent钩子\" class=\"headerlink\" title=\"ngContent钩子\"></a>ngContent钩子</h1><p>ngContent钩子和ngView钩子类似，不同的是ngContent钩子针对的是父组件投影到子组件的部分。</p>\n<p><code>ngAfterContentInit</code>是在投影进来的内容初始化完毕后调用的。</p>\n<p><code>ngAfterContentChecked</code>是针对投影进来的内通进行变更检测的。</p>\n<ul>\n<li>先完成投影内容的初始化和检测，再完成整个视图的初始化和检测。</li>\n<li>在<code>ngAfterContentInit</code>和<code>ngAfterContentChecked</code>中改变视图内容是不会报错的，因为在调用这两个钩子被调用的时候整个视图还没有被组装完。</li>\n</ul>\n<h1 id=\"组件生命周期-1\"><a href=\"#组件生命周期-1\" class=\"headerlink\" title=\"组件生命周期\"></a>组件生命周期</h1><ul>\n<li><p>组件初始化阶段：</p>\n<ul>\n<li><p>属性初始化阶段：</p>\n<ol>\n<li>constructor（只调用一次）：构造函数实例化对象</li>\n<li>ngOnChanges：初始化输入属性</li>\n<li>ngOnInit（只调用一次） ：初始化除了输入属性以外的所有其他属性。</li>\n<li>ngDoCheck：做一次变更检查</li>\n</ol>\n</li>\n<li><p>这时整个组件的属性都应该被赋予了需要被赋予的值，这时开始渲染视图</p>\n</li>\n<li><p>视图初始化阶段：</p>\n<p>​    先渲染投影部分的内容，投影部分渲染完毕后调用下面两个钩子。</p>\n<ol start=\"5\">\n<li><p>ngAfterContentInit（只调用一次）：</p>\n</li>\n<li><p>ngAfterContentChecked：</p>\n<p>这时如果组件有子组件，那么进入子组件的生命周期。</p>\n<p>如果没有子组件，或者所有子组件的生命周期执行完毕，这时如果组件的全部视图渲染完了，会调用下面两个方法：</p>\n</li>\n<li><p>ngAfterViewInit（只调用一次）：</p>\n</li>\n<li><p>ngAfterViewChecked：</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<p>当7，8方法调用完毕后，整个组件的初始化过程就完毕了这时候，组件就会呈现出来，给到用户做一些交互。</p>\n<p>而用户做的任何一个交互，比如鼠标点击，键盘输入，都会出发angular的变更检测机制。</p>\n<p>而一旦检测到发生了变更，那么在当前组件树上，所有活动 组件上被实现的带有<code>check</code>关键字的方法，都会被调用，用来检查当前组件的变化。</p>\n<p>如果某个组件的变化导致输入属性也改变了，那么这个组件的ngOnChanges方法也会被调用。</p>\n<ul>\n<li><p>变更检测阶段：</p>\n<p>ngOnChanges</p>\n<p>ngDoCheck</p>\n<p>ngAfterContentChecked</p>\n<p>ngAfterViewChecked</p>\n</li>\n<li><p>组件销毁</p>\n<p>最终当组件被销毁的时候，会调用ngOnDestroy。</p>\n<p>组件会在路由的时候被销毁。</p>\n</li>\n</ul>\n"},{"title":"Hexo+GitPages搭建个人博客","date":"2017-06-02T09:02:53.000Z","description":"GitHub + Hexo + Next 搭建个人博客","_content":"> Git命令、Hexo框架、Markdown语句\n\n# 环境\n\n* Node\n* Npm\n* Git\n\n# 搭建\n\n　　hexo生成博客的静态页面+上传到gitpages+通过固定域名访问\n　　传送门：[手把手教你使用Hexo + Github Pages搭建个人独立博客](https://segmentfault.com/a/1190000004947261)\n　　　　　　[如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2)\n　　　　　　[Markdown——入门指南](http://www.jianshu.com/p/1e402922ee32/)\n　　　　　　[多个github帐号的SSH key切换](http://blog.csdn.net/itmyhome1990/article/details/42643233)","source":"_posts/Hexo+GitPages搭建博客.md","raw":"---\ntitle: Hexo+GitPages搭建个人博客\ndate: 2017-06-02 17:02:53\ntags:\n- hexo\ncategories:\n- 环境搭建\ndescription: GitHub + Hexo + Next 搭建个人博客\n---\n> Git命令、Hexo框架、Markdown语句\n\n# 环境\n\n* Node\n* Npm\n* Git\n\n# 搭建\n\n　　hexo生成博客的静态页面+上传到gitpages+通过固定域名访问\n　　传送门：[手把手教你使用Hexo + Github Pages搭建个人独立博客](https://segmentfault.com/a/1190000004947261)\n　　　　　　[如何搭建一个独立博客——简明Github Pages与Hexo教程](http://www.jianshu.com/p/05289a4bc8b2)\n　　　　　　[Markdown——入门指南](http://www.jianshu.com/p/1e402922ee32/)\n　　　　　　[多个github帐号的SSH key切换](http://blog.csdn.net/itmyhome1990/article/details/42643233)","slug":"Hexo+GitPages搭建博客","published":1,"updated":"2021-05-08T14:59:14.558Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbof000jwct4able14mu","content":"<blockquote>\n<p>Git命令、Hexo框架、Markdown语句</p>\n</blockquote>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><ul>\n<li>Node</li>\n<li>Npm</li>\n<li>Git</li>\n</ul>\n<h1 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h1><p>　　hexo生成博客的静态页面+上传到gitpages+通过固定域名访问<br>　　传送门：<a href=\"https://segmentfault.com/a/1190000004947261\">手把手教你使用Hexo + Github Pages搭建个人独立博客</a><br>　　　　　　<a href=\"http://www.jianshu.com/p/05289a4bc8b2\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br>　　　　　　<a href=\"http://www.jianshu.com/p/1e402922ee32/\">Markdown——入门指南</a><br>　　　　　　<a href=\"http://blog.csdn.net/itmyhome1990/article/details/42643233\">多个github帐号的SSH key切换</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Git命令、Hexo框架、Markdown语句</p>\n</blockquote>\n<h1 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h1><ul>\n<li>Node</li>\n<li>Npm</li>\n<li>Git</li>\n</ul>\n<h1 id=\"搭建\"><a href=\"#搭建\" class=\"headerlink\" title=\"搭建\"></a>搭建</h1><p>　　hexo生成博客的静态页面+上传到gitpages+通过固定域名访问<br>　　传送门：<a href=\"https://segmentfault.com/a/1190000004947261\">手把手教你使用Hexo + Github Pages搭建个人独立博客</a><br>　　　　　　<a href=\"http://www.jianshu.com/p/05289a4bc8b2\">如何搭建一个独立博客——简明Github Pages与Hexo教程</a><br>　　　　　　<a href=\"http://www.jianshu.com/p/1e402922ee32/\">Markdown——入门指南</a><br>　　　　　　<a href=\"http://blog.csdn.net/itmyhome1990/article/details/42643233\">多个github帐号的SSH key切换</a></p>\n"},{"title":"RxJS","date":"2018-01-20T05:15:23.000Z","description":"RxJS，响应式编程","_content":"\n# 什么是RxJS？\n\n**RxJS是ReactiveX的JavaScript实现**。\n\n**ReactiveX**是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。\n\nReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。\n\n**RxJS** 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 [Observable](http://cn.rx.js.org/manual/overview.html#observable)，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。\n\n## 基本概念\n\n在 RxJS 中用来解决异步事件管理的的基本概念是：\n\n- **Observable (可观察对象):** 表示一个概念，这个概念是一个可调用的未来值或事件的集合。\n- **Observer (观察者):** 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。\n- **Subscription (订阅):** 表示 Observable 的执行，主要用于取消 Observable 的执行。\n- **Operators (操作符):** 采用函数式编程风格的纯函数 (pure function)，使用像 `map`、`filter`、`concat`、`flatMap` 等这样的操作符来处理集合。\n- **Subject (主体):** 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。\n- **Schedulers (调度器):** 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 `setTimeout` 或 `requestAnimationFrame` 或其他。\n\n# Observable可观察对象\n\n","source":"_posts/RxJS.md","raw":"---\ntitle: RxJS\ndate: 2018-01-20 13:15:23\ntags:\n- Rxjs\ncategories:\n- 学习笔记\ndescription: RxJS，响应式编程\n---\n\n# 什么是RxJS？\n\n**RxJS是ReactiveX的JavaScript实现**。\n\n**ReactiveX**是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。\n\nReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。\n\n**RxJS** 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 [Observable](http://cn.rx.js.org/manual/overview.html#observable)，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。\n\n## 基本概念\n\n在 RxJS 中用来解决异步事件管理的的基本概念是：\n\n- **Observable (可观察对象):** 表示一个概念，这个概念是一个可调用的未来值或事件的集合。\n- **Observer (观察者):** 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。\n- **Subscription (订阅):** 表示 Observable 的执行，主要用于取消 Observable 的执行。\n- **Operators (操作符):** 采用函数式编程风格的纯函数 (pure function)，使用像 `map`、`filter`、`concat`、`flatMap` 等这样的操作符来处理集合。\n- **Subject (主体):** 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。\n- **Schedulers (调度器):** 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 `setTimeout` 或 `requestAnimationFrame` 或其他。\n\n# Observable可观察对象\n\n","slug":"RxJS","published":1,"updated":"2021-05-08T14:57:37.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbon000mwct447984lhe","content":"<h1 id=\"什么是RxJS？\"><a href=\"#什么是RxJS？\" class=\"headerlink\" title=\"什么是RxJS？\"></a>什么是RxJS？</h1><p><strong>RxJS是ReactiveX的JavaScript实现</strong>。</p>\n<p><strong>ReactiveX</strong>是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。</p>\n<p>ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。</p>\n<p><strong>RxJS</strong> 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 <a href=\"http://cn.rx.js.org/manual/overview.html#observable\">Observable</a>，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>在 RxJS 中用来解决异步事件管理的的基本概念是：</p>\n<ul>\n<li><strong>Observable (可观察对象):</strong> 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li>\n<li><strong>Observer (观察者):</strong> 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li>\n<li><strong>Subscription (订阅):</strong> 表示 Observable 的执行，主要用于取消 Observable 的执行。</li>\n<li><strong>Operators (操作符):</strong> 采用函数式编程风格的纯函数 (pure function)，使用像 <code>map</code>、<code>filter</code>、<code>concat</code>、<code>flatMap</code> 等这样的操作符来处理集合。</li>\n<li><strong>Subject (主体):</strong> 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li>\n<li><strong>Schedulers (调度器):</strong> 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 或其他。</li>\n</ul>\n<h1 id=\"Observable可观察对象\"><a href=\"#Observable可观察对象\" class=\"headerlink\" title=\"Observable可观察对象\"></a>Observable可观察对象</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是RxJS？\"><a href=\"#什么是RxJS？\" class=\"headerlink\" title=\"什么是RxJS？\"></a>什么是RxJS？</h1><p><strong>RxJS是ReactiveX的JavaScript实现</strong>。</p>\n<p><strong>ReactiveX</strong>是Reactive Extensions的缩写，一般简写为Rx，最初是LINQ的一个扩展，由微软的架构师Erik Meijer领导的团队开发，在2012年11月开源，Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流。</p>\n<p>ReactiveX.io给的定义是，Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华。</p>\n<p><strong>RxJS</strong> 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 <a href=\"http://cn.rx.js.org/manual/overview.html#observable\">Observable</a>，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>在 RxJS 中用来解决异步事件管理的的基本概念是：</p>\n<ul>\n<li><strong>Observable (可观察对象):</strong> 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li>\n<li><strong>Observer (观察者):</strong> 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li>\n<li><strong>Subscription (订阅):</strong> 表示 Observable 的执行，主要用于取消 Observable 的执行。</li>\n<li><strong>Operators (操作符):</strong> 采用函数式编程风格的纯函数 (pure function)，使用像 <code>map</code>、<code>filter</code>、<code>concat</code>、<code>flatMap</code> 等这样的操作符来处理集合。</li>\n<li><strong>Subject (主体):</strong> 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li>\n<li><strong>Schedulers (调度器):</strong> 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 或其他。</li>\n</ul>\n<h1 id=\"Observable可观察对象\"><a href=\"#Observable可观察对象\" class=\"headerlink\" title=\"Observable可观察对象\"></a>Observable可观察对象</h1>"},{"title":"TypeScript学习笔记","date":"2017-10-03T08:26:54.000Z","description":"typescript语法简介","_content":"\n# TypeScript介绍\n\n微软开发的脚本语言\n\njavascript的超集\n\n遵循ES6规范\n\n2016年9月发布的Angular2框架就是由TypeScript编写的\n\n# TypeScript的开发环境\n\n搭建typescript的开发环境，就是安装typescript的编译器（compiler）。\n\n编译器的作用是把typescript的代码转换成javascript代码\n\n为什么\n\n因为ES6规范是2015年发布的，目前大多主流的浏览器并没有完全支持ES6规范。因此用ES6写的代码不能直接放到浏览器里跑，需要转换成ES5\n\n**两种编译器**\n\n在线compiler：[typescript在线编译器](http://www.typescriptlang.org/play/index.html)\n\n本地compiler：`sudo npm install -g typescript`\n\n# TypeScript语法\n\n## 字符串新特性\n\n### 多行字符串\n\nES5:\n\n```\n//传统javascript中字符串换行必须用+号拼接起来\nvar content = \"aaa\"+\n\"bbb\"+\n\"ccc\";\n```\n\nTS:\n\n```\n//TS多行字符串可以随意换行，用``双撇号声明\nvar content = 'aaa\nbbb\nccc`;\n```\n\n### 字符串模版\n\n在一个**多行字符串里**，用一个变量插入表达式、调用方法 \n\n ```\n`...${}...`\n ```\n\nts：\n\n```\nvar name = \"Ethan\"\nvar getName = function () {\n    return \"Ethan\";\n}\n\nconsole.log(`<div>\n<span>${name}</span>\n<soan>${getName()}</span>\n</div>`)\n```\n\n编译后：\n\n```\nvar name = \"Ethan\";\nvar getName = function () {\n    return \"Ethan\";\n};\nconsole.log(\"<div>\\n<span>\" + name + \"</span>\\n<soan>\" + getName() + \"</span>\\n</div>\");\n```\n\n**注意**：表达式的语法只在多行字符串里起作用，如果这个字符串是双引号\"\"声明的普通字符串，表达式不会被解析，双引号之间的所有内容都会被作为字符串打印出来，就像这样：\n\n```\n//ts\nconsole.log(\"hellow ${name}\")\n\n//js\nconsole.log(\"hellow ${name}\");\n```\n\n### 自动拆分字符串\n\n当用一个字符串模版调用一个方法的时候，这个字符串模版里面表达式的值，会自动赋给被调用方法的参数。\n\nts:\n\n```\nvar test = function (template, name, age) {\n    console.log(template);\n    console.log(name);\n    console.log(age);\n}\n\nvar myName = \"Ethan\";\nvar getAge = function () {\n    return 25;\n}\n\ntest`hello, my name is ${myName},i'm ${getAge()}`;\n```\n\n如果要使用自动拆分的特性，在调方法的时候不要写圆括号`test()`，而是直接写字符串模版``test`hello, my name is ${myName},i'm ${getAge()}`;``\n\n编译后：\n\n```\nvar test = function (template, name, age) {\n    console.log(template);\n    console.log(name);\n    console.log(age);\n};\nvar myName = \"Ethan\";\nvar getAge = function () {\n    return 25;\n};\n(_a = [\"hello, my name is \", \",i'm \", \"\"], _a.raw = [\"hello, my name is \", \",i'm \", \"\"], test(_a, myName, getAge()));\nvar _a;\n```\n\n结果：\n\n```\nVM2163:2 Array(3)\n0: \"hello, my name is \"\n1: \",i'm \"\n2: \"\"\nraw: (3) [\"hello, my name is \", \",i'm \", \"\"]\nlength: 3__proto__: Array(0)\nVM2163:3 Ethan\nVM2163:4 25\n```\n\n用一个字符串模版去调用test方法，字符串模版里表达式的值会赋给相应的参数。\n\n第一个参数template就是字符串模版的值，第二个参数name就是第一个表达式的值，第三个参数age就是第二个表达式的值\n\n## 参数新特性\n\n### 参数类型\n\n 在参数名称后面，可以使用冒号：来指定参数的类型；\n\n变量指定类型、函数返回值指定类型、函数参数指定类型、自定义类型\n\n#### 变量指定类型\n\n```\n//ts\nvar myName: string = \"Ethan\";\nvar age: number = 12;\nvar man: boolean = true;\nvar a: any = \"123\";\n\n//js\nvar myName = \"Ethan\";\nvar age = 12;\nvar man = true;\nvar a = \"123\";\n```\n\n声明了指定类型变量的作用，是在以后再次给变量赋值时，编译器会根据指定类型做检查，如果类型不一致编译器会报错，以此来降低开发人员出错的几率。但是编译后的js不会报错，因为ES5中变量为弱类型，就想这样：\n\n```\n//ts\nvar myName: string = \"ethan\";  //声明了一个字符串类型的指定类型变量\n\nmyName = 13; //再次赋值number，ts中会报错，但仍可以编译\n\n//js\nvar myName = \"ethan\";\nmyName = 13; //js中正常，不会报错\n\n```\n\n如果我想声明一个可以是任意类型的变量，就用any：\n\n```\n//ts\nvar a: any = \"ethan\"\na = 13; //不会报错\n```\n\n如果在ts中，不指定任何类型生命变量\n\n```\n//ts\nvar myName = \"Ethan\";\n```\n\n再次给这个变量赋值，赋一个数字，就会报错。这是因为ts中存在类型推断机制，这个机制会在第一次给变量赋值的时候推断变量类型 ：\n\n```\n//ts\nmyName = 13  //报错\n```\n\n#### 函数返回值指定类型\n\n在方法后声明指定类型，指定这个方法的返回值的类型，比如指定一个方法返回string类型的值：\n\n```\n//ts\nfunction test(): string{\n  return \"Ethan\"\t//return返回的值必须是string类型，否则报错\n}\n```\n\n用void声明一个方法，表明这个方法不需要任何返回值，指定返回值会报错\n\n```\n//ts\nfunction test(): void {\n    return \"323\"  //报错\n }\n```\n\n#### 函数参数指定类型\n\n给方法的参数指定类型：\n\n```\n//ts\nfunction test(name: string):string{\n  return \"\"\n}\n\ntest(\"Ethan\")\n```\n\n在调用方法的时候，参数只能是string类型，如果用其他类型就会报错\n\n#### 自定义类型\n\n 通过**class**关键字 或 接口自定义一个类型，比如自定义一个Person类型：\n\n```\n//ts\nclass Person{\n    name: string;\n    age: number;\n}\n//编译后\nvar Person = /** @class */ (function () {\n    function Person() {\n    }\n    return Person;\n}());\n```\n\n下面我就可以声明一个自定义的Person类型：\n\n```\n//ts\nclass Person{\n    name: string;\n    age:number;\n}\n\nvar ethan: Person = new Person();\nethan.name = \"Ethan\";\nethan.age = \"18\";\n```\n\n### 默认参数\n\n在参数声明后面用等号声明参数的默认值。\n\n```\nvar myName: string = \"Ethan\"\n```\n\n**给方法的变量指定默认值**\n\n```\nfunction test(a: string,b: string,c: string = \"Ethan\"){\n  console.log(a);\n  console.log(b);\n  console.log(c);\n}\n\ntest(\"xxx\",\"yyy\")\n\n//console.log\nxxx\nyyy\nEthan\n```\n\n**注意**\n\n带默认值的参数一定是声明在最后面，如果声明在前面，像这样：\n\n```\nfunction test(a: string = \"Ethan\",b: string,c: string){\n  console.log(a);\n  console.log(b);\n  console.log(c);\n}\ntest(\"xxx\",\"yyy\")\n```\n\n调用test方法就会报错，因为xxx是参数a，yyy是参数b，c参数没有传。TS中调用方法时不传参数会报错。\n\n### 可选参数\n\n在方法的参数声明后面用?来标明此参数为可选参数\n\n```\nfunction test(a: string,b?: string,c: string = \"Ethan\"){\n  console.log(a);\n  console.log(b);\n  console.log(c);\n}\n\ntest(\"xxx\")\n\n//console.log\nxxx\t\t\t\t//a参数传了\"xxx\"\nundefined\t\t//b参数是可选参数，没传\nEthan\t\t\t//c参数有默认值\n```\n\n**注意**\n\n1.需要处理可选参数没传时候的情况，可选参数没传,这个参数就是undefined，如果方法里调用这个参数(undefined)就会报错\n\n2.比传参数不能在可选参数后面：\n\n```\nfunction test(a?: string,b: string,c: string = \"Ethan\"){\n  console.log(a);\n  console.log(b);\n  console.log(c);\n}\n```\n\nb是必选参数，在可选参数a的后面，这样写会报错\n\n## 函数新特性\n\n### Rest and Spread操作符\n\n…就是Rest and Spread操作符\n\n**用法一**：用来声明任意数量参数的方法\n\n```\n//ts\nfunction fun1(...args) {\n    args.forEach(function (arg) {\n        console.log(arg)\n    })\n}\n\nfun1(1, 2, 3);\t\t\t//输出1，2，3\nfun1(7, 8, 9, 10, 11);\t//输出7，8，9，10，11\n\n//编译后\nfunction fun1() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    args.forEach(function (arg) {\n        console.log(arg);\n    });\n}\nfun1(1, 2, 3);\nfun1(7, 8, 9, 10, 11);\n```\n\n**用法二**：方法参数数量固定，调用方法的时候传入任意数量参数\n\n该语法是ES6的，目前版本的TypeScript还不支持，但是编译后的js是可以正常运行的\n\n```\n//ts\nfunction fun1(a,b,c) {\n    console.log(a);\n    console.log(b);\n    console.log(c);\n}\n\nvar arg1 = [1, 2];\nvar arg2 = [7, 8, 9];\n\nfun1(...arg1);\t\t//输出1，2，undefined\nfun1(...arg2);\t\t//输出7，8，9\n\n//编译后\nfunction fun1(a, b, c) {\n    console.log(a);\n    console.log(b);\n    console.log(c);\n}\nvar arg1 = [1, 2];\nvar arg2 = [7, 8, 9];\nfun1.apply(void 0, arg1);\nfun1.apply(void 0, arg2);\n```\n\n### Generator函数\n\n控制函数的执行过程，手动暂停和恢复代码执行\n\n在ES5中，调用一个方法，没有办法让这个方法执行到一半停住。但是在ES6里，新添加了一个关键字yield，这个关键字可以实现这个特性\n\n这个特性目前版本TypeScript还不支持，他是ES6的语法\n\n声明一个generator函数非常简单，就是在function后面加*号，像这样\n\n```\n//ts\nfunction* doSomething(){\n  console.log(\"start\");\n  yield;\t\t//相当于一个断点\n  console.log(\"finish\");\n}\n```\n\n在调用generator函数时，如果像往常一样调用函数是不会起任何作用的：\n\n`doSomething()`\n\n控制台不会有任何输出\n\n调用generator函数，必须把它声明成一个变量，然后调用这个变量的next()方法：\n\n```\nvar func = doSomething();\nfunc.next();\n```\n\n每调一次next方法，generator函数就会执行到yield关键字停住，然后接着调用next方法，函数继续执行到下一个yield，如此继续直到函数执行结束。\n\n### 析构表达式\n\n析构表达式的作用是通过表达式将对象或数组拆解成任意数量的变量\n\n析构表达式的好处就是，当你需要用一个对象的属性或者一个数组的元素来初始化一些本地的变量时，可以写更少的代码\n\n#### 用析构表达式从对象里取值\n\n```\n//ts\nfunction getStock(){\n  return{\n    code:\"IBM\",\n    price:{\n      price1:200,\n      price2:400\n    },\n    aaa:\"xixi\",\n    bbb:\"haha\"\n  }\n}\nvar {code: codex, price:{price2}} = getStock();\t\t//对象的属性转化成本地的两个变量\n\nconsole.log(codex);\t\t//IBM\nconsole.log(price2);\t//400\n```\n\n+ 针对对象的析构表达式，用花括号{ }声明\n\n+ { }里面的变量名要和被析构的对象的属性名一致\n\n+ 如果想让表达式中的变量梦和被解构对象的属性名不一致，要这么写\n\n  `var {code: codex} = getStock();`\n\n  表示本地声明一个codex变量，并把getStock对象的code属性值赋给他\n\n+ 如果被析构对象的属性值也是对象，想解构嵌套对象的属性这么写：\n\n  `var {price: {price2}} = getStock();`\n\n  表示声明一个price2变量，获取getStock对象中price对象的price2属性\n\n+ 对象里的其他属性不会影响析构表达式的执行\n\n#### 用析构表达式从数组里取值\n\n```\nvar array = [1, 2, 3, 4, 5];\n\nvar [a, b] = array;\t\t//1,2\n\nvar [a, , , b] = array;\t//1,4\n\nvar [a, b, ...c] = array;//1,2,Array[3,4,5]\n\nfunction doSomething([a, b, ...c]){\n  \tconsole.log(a);\n\tconsole.log(b);\n\tconsole.log(c);\n}\ndoSomething(array);\n```\n\n+ 针对数组的析构表达式用方括号[ ]声明\n+ 表达式中用,,跳过不需要析构的数组元素\n+ 用Rset操作符取出剩余的是一个数组，包含所有剩余的元素\n+ 方法的形参也可以是一个针对数组的析构表达式，调用方法的传参会按照形参的析高表达式被析构\n\n## 表达式和循环\n\n### 箭头表达式\n\n用来声明匿名函数，消除传统匿名函数的this指针问题\n\n```\n//ts\nvar sum1 = (arg1, arg2) => arg1 + arg2;\t\t//函数体只有一行，不用写{} return\nvar sum2 = (arg1, arg2) => {\t\t\t\t//函数体多行，要写{} return\n    return arg1 + arg2;\n}\nvar sum3 = () => { };\t\t\t//函数没有参数，不用写\nvar sum4 = arg => {\t\t\t\t//函数只有一个参数，不用写()\n    return arg\n}\n\n//js\nvar sum1 = function (arg1, arg2) { return arg1 + arg2; };\nvar sum2 = function (arg1, arg2) {\n    return arg1 + arg2;\n};\nvar sum3 = function () { };\nvar sum4 = function (arg) {\n    return arg;\n};\n```\n\n**关于this指针的例子**\n\n```\n//es5\nfunction getStock(name: string) {\n    this.name = name;\n\n    setInterval(function () {\t\t//es5写法\n        console.log(this.name)\t\t//es5中，匿名函数的调用者是window对象，this指向函数的调用者。\n        \t\t\t\t\t\t\t因此，this.name为空\n    })\n}\n\nvar stock =new  getStock(\"IBM\");\t//空\n\n//es6\nfunction getStock2(name: string) {\n    this.name = name;\n\n    setInterval(() => {\t\t\t\t//es6写法\n        console.log(this.name)\n    })\n}\n\nvar stock =new  getStock2(\"IBM\");\t//IBM\n```\n\n### for of循环\n\n#### 循环数组\n\n```\nvar array = ['a', 'b', 'c', 'd']\narray.desc = \"number array\";\n\n//es5\narray.forEach(function (value) {\n    console.log(value);\t\t\t//a,b,c,d\n})\nfor (var index in array) {\n    console.log(index)\t\t\t//0,1,2,3,desc\n}\n\n//es6\nfor (var el of array) {\n\tif(el=='c') break;\t\t\t//a,b\n    console.log(el)\t\t\t\t//a,b,c,d\n}\n```\n\n+ forEach方法只循环数组的元素，不循环数组的属性，不能跳出循环\n+ for in方法循环数组的所有元素下标以及属性键名，不能跳出循环\n+ for of方法只循环数组的元素，可以用break跳出循环\n\n#### 还可以循环字符串\n\n```\nfor (var n of array.desc) {\n    console.log(n)\t\t\t//n,u,m,b,e,r, ,a,r,r,a,y\n}\n```\n\n## 面向对象新特性\n\n","source":"_posts/TypeScript学习笔记.md","raw":"---\ntitle: TypeScript学习笔记\ndate: 2017-10-03 16:26:54\ntags:\n- typeScript\ncategories:\n- 学习笔记\ndescription: typescript语法简介\n---\n\n# TypeScript介绍\n\n微软开发的脚本语言\n\njavascript的超集\n\n遵循ES6规范\n\n2016年9月发布的Angular2框架就是由TypeScript编写的\n\n# TypeScript的开发环境\n\n搭建typescript的开发环境，就是安装typescript的编译器（compiler）。\n\n编译器的作用是把typescript的代码转换成javascript代码\n\n为什么\n\n因为ES6规范是2015年发布的，目前大多主流的浏览器并没有完全支持ES6规范。因此用ES6写的代码不能直接放到浏览器里跑，需要转换成ES5\n\n**两种编译器**\n\n在线compiler：[typescript在线编译器](http://www.typescriptlang.org/play/index.html)\n\n本地compiler：`sudo npm install -g typescript`\n\n# TypeScript语法\n\n## 字符串新特性\n\n### 多行字符串\n\nES5:\n\n```\n//传统javascript中字符串换行必须用+号拼接起来\nvar content = \"aaa\"+\n\"bbb\"+\n\"ccc\";\n```\n\nTS:\n\n```\n//TS多行字符串可以随意换行，用``双撇号声明\nvar content = 'aaa\nbbb\nccc`;\n```\n\n### 字符串模版\n\n在一个**多行字符串里**，用一个变量插入表达式、调用方法 \n\n ```\n`...${}...`\n ```\n\nts：\n\n```\nvar name = \"Ethan\"\nvar getName = function () {\n    return \"Ethan\";\n}\n\nconsole.log(`<div>\n<span>${name}</span>\n<soan>${getName()}</span>\n</div>`)\n```\n\n编译后：\n\n```\nvar name = \"Ethan\";\nvar getName = function () {\n    return \"Ethan\";\n};\nconsole.log(\"<div>\\n<span>\" + name + \"</span>\\n<soan>\" + getName() + \"</span>\\n</div>\");\n```\n\n**注意**：表达式的语法只在多行字符串里起作用，如果这个字符串是双引号\"\"声明的普通字符串，表达式不会被解析，双引号之间的所有内容都会被作为字符串打印出来，就像这样：\n\n```\n//ts\nconsole.log(\"hellow ${name}\")\n\n//js\nconsole.log(\"hellow ${name}\");\n```\n\n### 自动拆分字符串\n\n当用一个字符串模版调用一个方法的时候，这个字符串模版里面表达式的值，会自动赋给被调用方法的参数。\n\nts:\n\n```\nvar test = function (template, name, age) {\n    console.log(template);\n    console.log(name);\n    console.log(age);\n}\n\nvar myName = \"Ethan\";\nvar getAge = function () {\n    return 25;\n}\n\ntest`hello, my name is ${myName},i'm ${getAge()}`;\n```\n\n如果要使用自动拆分的特性，在调方法的时候不要写圆括号`test()`，而是直接写字符串模版``test`hello, my name is ${myName},i'm ${getAge()}`;``\n\n编译后：\n\n```\nvar test = function (template, name, age) {\n    console.log(template);\n    console.log(name);\n    console.log(age);\n};\nvar myName = \"Ethan\";\nvar getAge = function () {\n    return 25;\n};\n(_a = [\"hello, my name is \", \",i'm \", \"\"], _a.raw = [\"hello, my name is \", \",i'm \", \"\"], test(_a, myName, getAge()));\nvar _a;\n```\n\n结果：\n\n```\nVM2163:2 Array(3)\n0: \"hello, my name is \"\n1: \",i'm \"\n2: \"\"\nraw: (3) [\"hello, my name is \", \",i'm \", \"\"]\nlength: 3__proto__: Array(0)\nVM2163:3 Ethan\nVM2163:4 25\n```\n\n用一个字符串模版去调用test方法，字符串模版里表达式的值会赋给相应的参数。\n\n第一个参数template就是字符串模版的值，第二个参数name就是第一个表达式的值，第三个参数age就是第二个表达式的值\n\n## 参数新特性\n\n### 参数类型\n\n 在参数名称后面，可以使用冒号：来指定参数的类型；\n\n变量指定类型、函数返回值指定类型、函数参数指定类型、自定义类型\n\n#### 变量指定类型\n\n```\n//ts\nvar myName: string = \"Ethan\";\nvar age: number = 12;\nvar man: boolean = true;\nvar a: any = \"123\";\n\n//js\nvar myName = \"Ethan\";\nvar age = 12;\nvar man = true;\nvar a = \"123\";\n```\n\n声明了指定类型变量的作用，是在以后再次给变量赋值时，编译器会根据指定类型做检查，如果类型不一致编译器会报错，以此来降低开发人员出错的几率。但是编译后的js不会报错，因为ES5中变量为弱类型，就想这样：\n\n```\n//ts\nvar myName: string = \"ethan\";  //声明了一个字符串类型的指定类型变量\n\nmyName = 13; //再次赋值number，ts中会报错，但仍可以编译\n\n//js\nvar myName = \"ethan\";\nmyName = 13; //js中正常，不会报错\n\n```\n\n如果我想声明一个可以是任意类型的变量，就用any：\n\n```\n//ts\nvar a: any = \"ethan\"\na = 13; //不会报错\n```\n\n如果在ts中，不指定任何类型生命变量\n\n```\n//ts\nvar myName = \"Ethan\";\n```\n\n再次给这个变量赋值，赋一个数字，就会报错。这是因为ts中存在类型推断机制，这个机制会在第一次给变量赋值的时候推断变量类型 ：\n\n```\n//ts\nmyName = 13  //报错\n```\n\n#### 函数返回值指定类型\n\n在方法后声明指定类型，指定这个方法的返回值的类型，比如指定一个方法返回string类型的值：\n\n```\n//ts\nfunction test(): string{\n  return \"Ethan\"\t//return返回的值必须是string类型，否则报错\n}\n```\n\n用void声明一个方法，表明这个方法不需要任何返回值，指定返回值会报错\n\n```\n//ts\nfunction test(): void {\n    return \"323\"  //报错\n }\n```\n\n#### 函数参数指定类型\n\n给方法的参数指定类型：\n\n```\n//ts\nfunction test(name: string):string{\n  return \"\"\n}\n\ntest(\"Ethan\")\n```\n\n在调用方法的时候，参数只能是string类型，如果用其他类型就会报错\n\n#### 自定义类型\n\n 通过**class**关键字 或 接口自定义一个类型，比如自定义一个Person类型：\n\n```\n//ts\nclass Person{\n    name: string;\n    age: number;\n}\n//编译后\nvar Person = /** @class */ (function () {\n    function Person() {\n    }\n    return Person;\n}());\n```\n\n下面我就可以声明一个自定义的Person类型：\n\n```\n//ts\nclass Person{\n    name: string;\n    age:number;\n}\n\nvar ethan: Person = new Person();\nethan.name = \"Ethan\";\nethan.age = \"18\";\n```\n\n### 默认参数\n\n在参数声明后面用等号声明参数的默认值。\n\n```\nvar myName: string = \"Ethan\"\n```\n\n**给方法的变量指定默认值**\n\n```\nfunction test(a: string,b: string,c: string = \"Ethan\"){\n  console.log(a);\n  console.log(b);\n  console.log(c);\n}\n\ntest(\"xxx\",\"yyy\")\n\n//console.log\nxxx\nyyy\nEthan\n```\n\n**注意**\n\n带默认值的参数一定是声明在最后面，如果声明在前面，像这样：\n\n```\nfunction test(a: string = \"Ethan\",b: string,c: string){\n  console.log(a);\n  console.log(b);\n  console.log(c);\n}\ntest(\"xxx\",\"yyy\")\n```\n\n调用test方法就会报错，因为xxx是参数a，yyy是参数b，c参数没有传。TS中调用方法时不传参数会报错。\n\n### 可选参数\n\n在方法的参数声明后面用?来标明此参数为可选参数\n\n```\nfunction test(a: string,b?: string,c: string = \"Ethan\"){\n  console.log(a);\n  console.log(b);\n  console.log(c);\n}\n\ntest(\"xxx\")\n\n//console.log\nxxx\t\t\t\t//a参数传了\"xxx\"\nundefined\t\t//b参数是可选参数，没传\nEthan\t\t\t//c参数有默认值\n```\n\n**注意**\n\n1.需要处理可选参数没传时候的情况，可选参数没传,这个参数就是undefined，如果方法里调用这个参数(undefined)就会报错\n\n2.比传参数不能在可选参数后面：\n\n```\nfunction test(a?: string,b: string,c: string = \"Ethan\"){\n  console.log(a);\n  console.log(b);\n  console.log(c);\n}\n```\n\nb是必选参数，在可选参数a的后面，这样写会报错\n\n## 函数新特性\n\n### Rest and Spread操作符\n\n…就是Rest and Spread操作符\n\n**用法一**：用来声明任意数量参数的方法\n\n```\n//ts\nfunction fun1(...args) {\n    args.forEach(function (arg) {\n        console.log(arg)\n    })\n}\n\nfun1(1, 2, 3);\t\t\t//输出1，2，3\nfun1(7, 8, 9, 10, 11);\t//输出7，8，9，10，11\n\n//编译后\nfunction fun1() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    args.forEach(function (arg) {\n        console.log(arg);\n    });\n}\nfun1(1, 2, 3);\nfun1(7, 8, 9, 10, 11);\n```\n\n**用法二**：方法参数数量固定，调用方法的时候传入任意数量参数\n\n该语法是ES6的，目前版本的TypeScript还不支持，但是编译后的js是可以正常运行的\n\n```\n//ts\nfunction fun1(a,b,c) {\n    console.log(a);\n    console.log(b);\n    console.log(c);\n}\n\nvar arg1 = [1, 2];\nvar arg2 = [7, 8, 9];\n\nfun1(...arg1);\t\t//输出1，2，undefined\nfun1(...arg2);\t\t//输出7，8，9\n\n//编译后\nfunction fun1(a, b, c) {\n    console.log(a);\n    console.log(b);\n    console.log(c);\n}\nvar arg1 = [1, 2];\nvar arg2 = [7, 8, 9];\nfun1.apply(void 0, arg1);\nfun1.apply(void 0, arg2);\n```\n\n### Generator函数\n\n控制函数的执行过程，手动暂停和恢复代码执行\n\n在ES5中，调用一个方法，没有办法让这个方法执行到一半停住。但是在ES6里，新添加了一个关键字yield，这个关键字可以实现这个特性\n\n这个特性目前版本TypeScript还不支持，他是ES6的语法\n\n声明一个generator函数非常简单，就是在function后面加*号，像这样\n\n```\n//ts\nfunction* doSomething(){\n  console.log(\"start\");\n  yield;\t\t//相当于一个断点\n  console.log(\"finish\");\n}\n```\n\n在调用generator函数时，如果像往常一样调用函数是不会起任何作用的：\n\n`doSomething()`\n\n控制台不会有任何输出\n\n调用generator函数，必须把它声明成一个变量，然后调用这个变量的next()方法：\n\n```\nvar func = doSomething();\nfunc.next();\n```\n\n每调一次next方法，generator函数就会执行到yield关键字停住，然后接着调用next方法，函数继续执行到下一个yield，如此继续直到函数执行结束。\n\n### 析构表达式\n\n析构表达式的作用是通过表达式将对象或数组拆解成任意数量的变量\n\n析构表达式的好处就是，当你需要用一个对象的属性或者一个数组的元素来初始化一些本地的变量时，可以写更少的代码\n\n#### 用析构表达式从对象里取值\n\n```\n//ts\nfunction getStock(){\n  return{\n    code:\"IBM\",\n    price:{\n      price1:200,\n      price2:400\n    },\n    aaa:\"xixi\",\n    bbb:\"haha\"\n  }\n}\nvar {code: codex, price:{price2}} = getStock();\t\t//对象的属性转化成本地的两个变量\n\nconsole.log(codex);\t\t//IBM\nconsole.log(price2);\t//400\n```\n\n+ 针对对象的析构表达式，用花括号{ }声明\n\n+ { }里面的变量名要和被析构的对象的属性名一致\n\n+ 如果想让表达式中的变量梦和被解构对象的属性名不一致，要这么写\n\n  `var {code: codex} = getStock();`\n\n  表示本地声明一个codex变量，并把getStock对象的code属性值赋给他\n\n+ 如果被析构对象的属性值也是对象，想解构嵌套对象的属性这么写：\n\n  `var {price: {price2}} = getStock();`\n\n  表示声明一个price2变量，获取getStock对象中price对象的price2属性\n\n+ 对象里的其他属性不会影响析构表达式的执行\n\n#### 用析构表达式从数组里取值\n\n```\nvar array = [1, 2, 3, 4, 5];\n\nvar [a, b] = array;\t\t//1,2\n\nvar [a, , , b] = array;\t//1,4\n\nvar [a, b, ...c] = array;//1,2,Array[3,4,5]\n\nfunction doSomething([a, b, ...c]){\n  \tconsole.log(a);\n\tconsole.log(b);\n\tconsole.log(c);\n}\ndoSomething(array);\n```\n\n+ 针对数组的析构表达式用方括号[ ]声明\n+ 表达式中用,,跳过不需要析构的数组元素\n+ 用Rset操作符取出剩余的是一个数组，包含所有剩余的元素\n+ 方法的形参也可以是一个针对数组的析构表达式，调用方法的传参会按照形参的析高表达式被析构\n\n## 表达式和循环\n\n### 箭头表达式\n\n用来声明匿名函数，消除传统匿名函数的this指针问题\n\n```\n//ts\nvar sum1 = (arg1, arg2) => arg1 + arg2;\t\t//函数体只有一行，不用写{} return\nvar sum2 = (arg1, arg2) => {\t\t\t\t//函数体多行，要写{} return\n    return arg1 + arg2;\n}\nvar sum3 = () => { };\t\t\t//函数没有参数，不用写\nvar sum4 = arg => {\t\t\t\t//函数只有一个参数，不用写()\n    return arg\n}\n\n//js\nvar sum1 = function (arg1, arg2) { return arg1 + arg2; };\nvar sum2 = function (arg1, arg2) {\n    return arg1 + arg2;\n};\nvar sum3 = function () { };\nvar sum4 = function (arg) {\n    return arg;\n};\n```\n\n**关于this指针的例子**\n\n```\n//es5\nfunction getStock(name: string) {\n    this.name = name;\n\n    setInterval(function () {\t\t//es5写法\n        console.log(this.name)\t\t//es5中，匿名函数的调用者是window对象，this指向函数的调用者。\n        \t\t\t\t\t\t\t因此，this.name为空\n    })\n}\n\nvar stock =new  getStock(\"IBM\");\t//空\n\n//es6\nfunction getStock2(name: string) {\n    this.name = name;\n\n    setInterval(() => {\t\t\t\t//es6写法\n        console.log(this.name)\n    })\n}\n\nvar stock =new  getStock2(\"IBM\");\t//IBM\n```\n\n### for of循环\n\n#### 循环数组\n\n```\nvar array = ['a', 'b', 'c', 'd']\narray.desc = \"number array\";\n\n//es5\narray.forEach(function (value) {\n    console.log(value);\t\t\t//a,b,c,d\n})\nfor (var index in array) {\n    console.log(index)\t\t\t//0,1,2,3,desc\n}\n\n//es6\nfor (var el of array) {\n\tif(el=='c') break;\t\t\t//a,b\n    console.log(el)\t\t\t\t//a,b,c,d\n}\n```\n\n+ forEach方法只循环数组的元素，不循环数组的属性，不能跳出循环\n+ for in方法循环数组的所有元素下标以及属性键名，不能跳出循环\n+ for of方法只循环数组的元素，可以用break跳出循环\n\n#### 还可以循环字符串\n\n```\nfor (var n of array.desc) {\n    console.log(n)\t\t\t//n,u,m,b,e,r, ,a,r,r,a,y\n}\n```\n\n## 面向对象新特性\n\n","slug":"TypeScript学习笔记","published":1,"updated":"2021-05-08T14:57:28.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbop000rwct4bypn30jr","content":"<h1 id=\"TypeScript介绍\"><a href=\"#TypeScript介绍\" class=\"headerlink\" title=\"TypeScript介绍\"></a>TypeScript介绍</h1><p>微软开发的脚本语言</p>\n<p>javascript的超集</p>\n<p>遵循ES6规范</p>\n<p>2016年9月发布的Angular2框架就是由TypeScript编写的</p>\n<h1 id=\"TypeScript的开发环境\"><a href=\"#TypeScript的开发环境\" class=\"headerlink\" title=\"TypeScript的开发环境\"></a>TypeScript的开发环境</h1><p>搭建typescript的开发环境，就是安装typescript的编译器（compiler）。</p>\n<p>编译器的作用是把typescript的代码转换成javascript代码</p>\n<p>为什么</p>\n<p>因为ES6规范是2015年发布的，目前大多主流的浏览器并没有完全支持ES6规范。因此用ES6写的代码不能直接放到浏览器里跑，需要转换成ES5</p>\n<p><strong>两种编译器</strong></p>\n<p>在线compiler：<a href=\"http://www.typescriptlang.org/play/index.html\">typescript在线编译器</a></p>\n<p>本地compiler：<code>sudo npm install -g typescript</code></p>\n<h1 id=\"TypeScript语法\"><a href=\"#TypeScript语法\" class=\"headerlink\" title=\"TypeScript语法\"></a>TypeScript语法</h1><h2 id=\"字符串新特性\"><a href=\"#字符串新特性\" class=\"headerlink\" title=\"字符串新特性\"></a>字符串新特性</h2><h3 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h3><p>ES5:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;传统javascript中字符串换行必须用+号拼接起来</span><br><span class=\"line\">var content &#x3D; &quot;aaa&quot;+</span><br><span class=\"line\">&quot;bbb&quot;+</span><br><span class=\"line\">&quot;ccc&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>TS:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;TS多行字符串可以随意换行，用&#96;&#96;双撇号声明</span><br><span class=\"line\">var content &#x3D; &#39;aaa</span><br><span class=\"line\">bbb</span><br><span class=\"line\">ccc&#96;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串模版\"><a href=\"#字符串模版\" class=\"headerlink\" title=\"字符串模版\"></a>字符串模版</h3><p>在一个<strong>多行字符串里</strong>，用一个变量插入表达式、调用方法 </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#96;...$&#123;&#125;...&#96;</span><br></pre></td></tr></table></figure>\n\n<p>ts：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name &#x3D; &quot;Ethan&quot;</span><br><span class=\"line\">var getName &#x3D; function () &#123;</span><br><span class=\"line\">    return &quot;Ethan&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#96;&lt;div&gt;</span><br><span class=\"line\">&lt;span&gt;$&#123;name&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;soan&gt;$&#123;getName()&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;&#96;)</span><br></pre></td></tr></table></figure>\n\n<p>编译后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var getName &#x3D; function () &#123;</span><br><span class=\"line\">    return &quot;Ethan&quot;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(&quot;&lt;div&gt;\\n&lt;span&gt;&quot; + name + &quot;&lt;&#x2F;span&gt;\\n&lt;soan&gt;&quot; + getName() + &quot;&lt;&#x2F;span&gt;\\n&lt;&#x2F;div&gt;&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：表达式的语法只在多行字符串里起作用，如果这个字符串是双引号””声明的普通字符串，表达式不会被解析，双引号之间的所有内容都会被作为字符串打印出来，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">console.log(&quot;hellow $&#123;name&#125;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;js</span><br><span class=\"line\">console.log(&quot;hellow $&#123;name&#125;&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动拆分字符串\"><a href=\"#自动拆分字符串\" class=\"headerlink\" title=\"自动拆分字符串\"></a>自动拆分字符串</h3><p>当用一个字符串模版调用一个方法的时候，这个字符串模版里面表达式的值，会自动赋给被调用方法的参数。</p>\n<p>ts:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test &#x3D; function (template, name, age) &#123;</span><br><span class=\"line\">    console.log(template);</span><br><span class=\"line\">    console.log(name);</span><br><span class=\"line\">    console.log(age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myName &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var getAge &#x3D; function () &#123;</span><br><span class=\"line\">    return 25;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test&#96;hello, my name is $&#123;myName&#125;,i&#39;m $&#123;getAge()&#125;&#96;;</span><br></pre></td></tr></table></figure>\n\n<p>如果要使用自动拆分的特性，在调方法的时候不要写圆括号<code>test()</code>，而是直接写字符串模版<code>test`hello, my name is $&#123;myName&#125;,i&#39;m $&#123;getAge()&#125;`;</code></p>\n<p>编译后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test &#x3D; function (template, name, age) &#123;</span><br><span class=\"line\">    console.log(template);</span><br><span class=\"line\">    console.log(name);</span><br><span class=\"line\">    console.log(age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var myName &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var getAge &#x3D; function () &#123;</span><br><span class=\"line\">    return 25;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">(_a &#x3D; [&quot;hello, my name is &quot;, &quot;,i&#39;m &quot;, &quot;&quot;], _a.raw &#x3D; [&quot;hello, my name is &quot;, &quot;,i&#39;m &quot;, &quot;&quot;], test(_a, myName, getAge()));</span><br><span class=\"line\">var _a;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VM2163:2 Array(3)</span><br><span class=\"line\">0: &quot;hello, my name is &quot;</span><br><span class=\"line\">1: &quot;,i&#39;m &quot;</span><br><span class=\"line\">2: &quot;&quot;</span><br><span class=\"line\">raw: (3) [&quot;hello, my name is &quot;, &quot;,i&#39;m &quot;, &quot;&quot;]</span><br><span class=\"line\">length: 3__proto__: Array(0)</span><br><span class=\"line\">VM2163:3 Ethan</span><br><span class=\"line\">VM2163:4 25</span><br></pre></td></tr></table></figure>\n\n<p>用一个字符串模版去调用test方法，字符串模版里表达式的值会赋给相应的参数。</p>\n<p>第一个参数template就是字符串模版的值，第二个参数name就是第一个表达式的值，第三个参数age就是第二个表达式的值</p>\n<h2 id=\"参数新特性\"><a href=\"#参数新特性\" class=\"headerlink\" title=\"参数新特性\"></a>参数新特性</h2><h3 id=\"参数类型\"><a href=\"#参数类型\" class=\"headerlink\" title=\"参数类型\"></a>参数类型</h3><p> 在参数名称后面，可以使用冒号：来指定参数的类型；</p>\n<p>变量指定类型、函数返回值指定类型、函数参数指定类型、自定义类型</p>\n<h4 id=\"变量指定类型\"><a href=\"#变量指定类型\" class=\"headerlink\" title=\"变量指定类型\"></a>变量指定类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var myName: string &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var age: number &#x3D; 12;</span><br><span class=\"line\">var man: boolean &#x3D; true;</span><br><span class=\"line\">var a: any &#x3D; &quot;123&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;js</span><br><span class=\"line\">var myName &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var age &#x3D; 12;</span><br><span class=\"line\">var man &#x3D; true;</span><br><span class=\"line\">var a &#x3D; &quot;123&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>声明了指定类型变量的作用，是在以后再次给变量赋值时，编译器会根据指定类型做检查，如果类型不一致编译器会报错，以此来降低开发人员出错的几率。但是编译后的js不会报错，因为ES5中变量为弱类型，就想这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var myName: string &#x3D; &quot;ethan&quot;;  &#x2F;&#x2F;声明了一个字符串类型的指定类型变量</span><br><span class=\"line\"></span><br><span class=\"line\">myName &#x3D; 13; &#x2F;&#x2F;再次赋值number，ts中会报错，但仍可以编译</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;js</span><br><span class=\"line\">var myName &#x3D; &quot;ethan&quot;;</span><br><span class=\"line\">myName &#x3D; 13; &#x2F;&#x2F;js中正常，不会报错</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果我想声明一个可以是任意类型的变量，就用any：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var a: any &#x3D; &quot;ethan&quot;</span><br><span class=\"line\">a &#x3D; 13; &#x2F;&#x2F;不会报错</span><br></pre></td></tr></table></figure>\n\n<p>如果在ts中，不指定任何类型生命变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var myName &#x3D; &quot;Ethan&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>再次给这个变量赋值，赋一个数字，就会报错。这是因为ts中存在类型推断机制，这个机制会在第一次给变量赋值的时候推断变量类型 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">myName &#x3D; 13  &#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数返回值指定类型\"><a href=\"#函数返回值指定类型\" class=\"headerlink\" title=\"函数返回值指定类型\"></a>函数返回值指定类型</h4><p>在方法后声明指定类型，指定这个方法的返回值的类型，比如指定一个方法返回string类型的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function test(): string&#123;</span><br><span class=\"line\">  return &quot;Ethan&quot;\t&#x2F;&#x2F;return返回的值必须是string类型，否则报错</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用void声明一个方法，表明这个方法不需要任何返回值，指定返回值会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function test(): void &#123;</span><br><span class=\"line\">    return &quot;323&quot;  &#x2F;&#x2F;报错</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数参数指定类型\"><a href=\"#函数参数指定类型\" class=\"headerlink\" title=\"函数参数指定类型\"></a>函数参数指定类型</h4><p>给方法的参数指定类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function test(name: string):string&#123;</span><br><span class=\"line\">  return &quot;&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test(&quot;Ethan&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>在调用方法的时候，参数只能是string类型，如果用其他类型就会报错</p>\n<h4 id=\"自定义类型\"><a href=\"#自定义类型\" class=\"headerlink\" title=\"自定义类型\"></a>自定义类型</h4><p> 通过<strong>class</strong>关键字 或 接口自定义一个类型，比如自定义一个Person类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;编译后</span><br><span class=\"line\">var Person &#x3D; &#x2F;** @class *&#x2F; (function () &#123;</span><br><span class=\"line\">    function Person() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n\n<p>下面我就可以声明一个自定义的Person类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age:number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var ethan: Person &#x3D; new Person();</span><br><span class=\"line\">ethan.name &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">ethan.age &#x3D; &quot;18&quot;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>在参数声明后面用等号声明参数的默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myName: string &#x3D; &quot;Ethan&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>给方法的变量指定默认值</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a: string,b: string,c: string &#x3D; &quot;Ethan&quot;)&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  console.log(b);</span><br><span class=\"line\">  console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test(&quot;xxx&quot;,&quot;yyy&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;console.log</span><br><span class=\"line\">xxx</span><br><span class=\"line\">yyy</span><br><span class=\"line\">Ethan</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong></p>\n<p>带默认值的参数一定是声明在最后面，如果声明在前面，像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a: string &#x3D; &quot;Ethan&quot;,b: string,c: string)&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  console.log(b);</span><br><span class=\"line\">  console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(&quot;xxx&quot;,&quot;yyy&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>调用test方法就会报错，因为xxx是参数a，yyy是参数b，c参数没有传。TS中调用方法时不传参数会报错。</p>\n<h3 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h3><p>在方法的参数声明后面用?来标明此参数为可选参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a: string,b?: string,c: string &#x3D; &quot;Ethan&quot;)&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  console.log(b);</span><br><span class=\"line\">  console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test(&quot;xxx&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;console.log</span><br><span class=\"line\">xxx\t\t\t\t&#x2F;&#x2F;a参数传了&quot;xxx&quot;</span><br><span class=\"line\">undefined\t\t&#x2F;&#x2F;b参数是可选参数，没传</span><br><span class=\"line\">Ethan\t\t\t&#x2F;&#x2F;c参数有默认值</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong></p>\n<p>1.需要处理可选参数没传时候的情况，可选参数没传,这个参数就是undefined，如果方法里调用这个参数(undefined)就会报错</p>\n<p>2.比传参数不能在可选参数后面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a?: string,b: string,c: string &#x3D; &quot;Ethan&quot;)&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  console.log(b);</span><br><span class=\"line\">  console.log(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>b是必选参数，在可选参数a的后面，这样写会报错</p>\n<h2 id=\"函数新特性\"><a href=\"#函数新特性\" class=\"headerlink\" title=\"函数新特性\"></a>函数新特性</h2><h3 id=\"Rest-and-Spread操作符\"><a href=\"#Rest-and-Spread操作符\" class=\"headerlink\" title=\"Rest and Spread操作符\"></a>Rest and Spread操作符</h3><p>…就是Rest and Spread操作符</p>\n<p><strong>用法一</strong>：用来声明任意数量参数的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function fun1(...args) &#123;</span><br><span class=\"line\">    args.forEach(function (arg) &#123;</span><br><span class=\"line\">        console.log(arg)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fun1(1, 2, 3);\t\t\t&#x2F;&#x2F;输出1，2，3</span><br><span class=\"line\">fun1(7, 8, 9, 10, 11);\t&#x2F;&#x2F;输出7，8，9，10，11</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;编译后</span><br><span class=\"line\">function fun1() &#123;</span><br><span class=\"line\">    var args &#x3D; [];</span><br><span class=\"line\">    for (var _i &#x3D; 0; _i &lt; arguments.length; _i++) &#123;</span><br><span class=\"line\">        args[_i] &#x3D; arguments[_i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    args.forEach(function (arg) &#123;</span><br><span class=\"line\">        console.log(arg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun1(1, 2, 3);</span><br><span class=\"line\">fun1(7, 8, 9, 10, 11);</span><br></pre></td></tr></table></figure>\n\n<p><strong>用法二</strong>：方法参数数量固定，调用方法的时候传入任意数量参数</p>\n<p>该语法是ES6的，目前版本的TypeScript还不支持，但是编译后的js是可以正常运行的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function fun1(a,b,c) &#123;</span><br><span class=\"line\">    console.log(a);</span><br><span class=\"line\">    console.log(b);</span><br><span class=\"line\">    console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arg1 &#x3D; [1, 2];</span><br><span class=\"line\">var arg2 &#x3D; [7, 8, 9];</span><br><span class=\"line\"></span><br><span class=\"line\">fun1(...arg1);\t\t&#x2F;&#x2F;输出1，2，undefined</span><br><span class=\"line\">fun1(...arg2);\t\t&#x2F;&#x2F;输出7，8，9</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;编译后</span><br><span class=\"line\">function fun1(a, b, c) &#123;</span><br><span class=\"line\">    console.log(a);</span><br><span class=\"line\">    console.log(b);</span><br><span class=\"line\">    console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arg1 &#x3D; [1, 2];</span><br><span class=\"line\">var arg2 &#x3D; [7, 8, 9];</span><br><span class=\"line\">fun1.apply(void 0, arg1);</span><br><span class=\"line\">fun1.apply(void 0, arg2);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Generator函数\"><a href=\"#Generator函数\" class=\"headerlink\" title=\"Generator函数\"></a>Generator函数</h3><p>控制函数的执行过程，手动暂停和恢复代码执行</p>\n<p>在ES5中，调用一个方法，没有办法让这个方法执行到一半停住。但是在ES6里，新添加了一个关键字yield，这个关键字可以实现这个特性</p>\n<p>这个特性目前版本TypeScript还不支持，他是ES6的语法</p>\n<p>声明一个generator函数非常简单，就是在function后面加*号，像这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function* doSomething()&#123;</span><br><span class=\"line\">  console.log(&quot;start&quot;);</span><br><span class=\"line\">  yield;\t\t&#x2F;&#x2F;相当于一个断点</span><br><span class=\"line\">  console.log(&quot;finish&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在调用generator函数时，如果像往常一样调用函数是不会起任何作用的：</p>\n<p><code>doSomething()</code></p>\n<p>控制台不会有任何输出</p>\n<p>调用generator函数，必须把它声明成一个变量，然后调用这个变量的next()方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func &#x3D; doSomething();</span><br><span class=\"line\">func.next();</span><br></pre></td></tr></table></figure>\n\n<p>每调一次next方法，generator函数就会执行到yield关键字停住，然后接着调用next方法，函数继续执行到下一个yield，如此继续直到函数执行结束。</p>\n<h3 id=\"析构表达式\"><a href=\"#析构表达式\" class=\"headerlink\" title=\"析构表达式\"></a>析构表达式</h3><p>析构表达式的作用是通过表达式将对象或数组拆解成任意数量的变量</p>\n<p>析构表达式的好处就是，当你需要用一个对象的属性或者一个数组的元素来初始化一些本地的变量时，可以写更少的代码</p>\n<h4 id=\"用析构表达式从对象里取值\"><a href=\"#用析构表达式从对象里取值\" class=\"headerlink\" title=\"用析构表达式从对象里取值\"></a>用析构表达式从对象里取值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function getStock()&#123;</span><br><span class=\"line\">  return&#123;</span><br><span class=\"line\">    code:&quot;IBM&quot;,</span><br><span class=\"line\">    price:&#123;</span><br><span class=\"line\">      price1:200,</span><br><span class=\"line\">      price2:400</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    aaa:&quot;xixi&quot;,</span><br><span class=\"line\">    bbb:&quot;haha&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var &#123;code: codex, price:&#123;price2&#125;&#125; &#x3D; getStock();\t\t&#x2F;&#x2F;对象的属性转化成本地的两个变量</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(codex);\t\t&#x2F;&#x2F;IBM</span><br><span class=\"line\">console.log(price2);\t&#x2F;&#x2F;400</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>针对对象的析构表达式，用花括号{ }声明</p>\n</li>\n<li><p>{ }里面的变量名要和被析构的对象的属性名一致</p>\n</li>\n<li><p>如果想让表达式中的变量梦和被解构对象的属性名不一致，要这么写</p>\n<p><code>var &#123;code: codex&#125; = getStock();</code></p>\n<p>表示本地声明一个codex变量，并把getStock对象的code属性值赋给他</p>\n</li>\n<li><p>如果被析构对象的属性值也是对象，想解构嵌套对象的属性这么写：</p>\n<p><code>var &#123;price: &#123;price2&#125;&#125; = getStock();</code></p>\n<p>表示声明一个price2变量，获取getStock对象中price对象的price2属性</p>\n</li>\n<li><p>对象里的其他属性不会影响析构表达式的执行</p>\n</li>\n</ul>\n<h4 id=\"用析构表达式从数组里取值\"><a href=\"#用析构表达式从数组里取值\" class=\"headerlink\" title=\"用析构表达式从数组里取值\"></a>用析构表达式从数组里取值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array &#x3D; [1, 2, 3, 4, 5];</span><br><span class=\"line\"></span><br><span class=\"line\">var [a, b] &#x3D; array;\t\t&#x2F;&#x2F;1,2</span><br><span class=\"line\"></span><br><span class=\"line\">var [a, , , b] &#x3D; array;\t&#x2F;&#x2F;1,4</span><br><span class=\"line\"></span><br><span class=\"line\">var [a, b, ...c] &#x3D; array;&#x2F;&#x2F;1,2,Array[3,4,5]</span><br><span class=\"line\"></span><br><span class=\"line\">function doSomething([a, b, ...c])&#123;</span><br><span class=\"line\">  \tconsole.log(a);</span><br><span class=\"line\">\tconsole.log(b);</span><br><span class=\"line\">\tconsole.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomething(array);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>针对数组的析构表达式用方括号[ ]声明</li>\n<li>表达式中用,,跳过不需要析构的数组元素</li>\n<li>用Rset操作符取出剩余的是一个数组，包含所有剩余的元素</li>\n<li>方法的形参也可以是一个针对数组的析构表达式，调用方法的传参会按照形参的析高表达式被析构</li>\n</ul>\n<h2 id=\"表达式和循环\"><a href=\"#表达式和循环\" class=\"headerlink\" title=\"表达式和循环\"></a>表达式和循环</h2><h3 id=\"箭头表达式\"><a href=\"#箭头表达式\" class=\"headerlink\" title=\"箭头表达式\"></a>箭头表达式</h3><p>用来声明匿名函数，消除传统匿名函数的this指针问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var sum1 &#x3D; (arg1, arg2) &#x3D;&gt; arg1 + arg2;\t\t&#x2F;&#x2F;函数体只有一行，不用写&#123;&#125; return</span><br><span class=\"line\">var sum2 &#x3D; (arg1, arg2) &#x3D;&gt; &#123;\t\t\t\t&#x2F;&#x2F;函数体多行，要写&#123;&#125; return</span><br><span class=\"line\">    return arg1 + arg2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sum3 &#x3D; () &#x3D;&gt; &#123; &#125;;\t\t\t&#x2F;&#x2F;函数没有参数，不用写</span><br><span class=\"line\">var sum4 &#x3D; arg &#x3D;&gt; &#123;\t\t\t\t&#x2F;&#x2F;函数只有一个参数，不用写()</span><br><span class=\"line\">    return arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;js</span><br><span class=\"line\">var sum1 &#x3D; function (arg1, arg2) &#123; return arg1 + arg2; &#125;;</span><br><span class=\"line\">var sum2 &#x3D; function (arg1, arg2) &#123;</span><br><span class=\"line\">    return arg1 + arg2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var sum3 &#x3D; function () &#123; &#125;;</span><br><span class=\"line\">var sum4 &#x3D; function (arg) &#123;</span><br><span class=\"line\">    return arg;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于this指针的例子</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;es5</span><br><span class=\"line\">function getStock(name: string) &#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\"></span><br><span class=\"line\">    setInterval(function () &#123;\t\t&#x2F;&#x2F;es5写法</span><br><span class=\"line\">        console.log(this.name)\t\t&#x2F;&#x2F;es5中，匿名函数的调用者是window对象，this指向函数的调用者。</span><br><span class=\"line\">        \t\t\t\t\t\t\t因此，this.name为空</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var stock &#x3D;new  getStock(&quot;IBM&quot;);\t&#x2F;&#x2F;空</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;es6</span><br><span class=\"line\">function getStock2(name: string) &#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\"></span><br><span class=\"line\">    setInterval(() &#x3D;&gt; &#123;\t\t\t\t&#x2F;&#x2F;es6写法</span><br><span class=\"line\">        console.log(this.name)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var stock &#x3D;new  getStock2(&quot;IBM&quot;);\t&#x2F;&#x2F;IBM</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"for-of循环\"><a href=\"#for-of循环\" class=\"headerlink\" title=\"for of循环\"></a>for of循环</h3><h4 id=\"循环数组\"><a href=\"#循环数组\" class=\"headerlink\" title=\"循环数组\"></a>循环数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br><span class=\"line\">array.desc &#x3D; &quot;number array&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;es5</span><br><span class=\"line\">array.forEach(function (value) &#123;</span><br><span class=\"line\">    console.log(value);\t\t\t&#x2F;&#x2F;a,b,c,d</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">for (var index in array) &#123;</span><br><span class=\"line\">    console.log(index)\t\t\t&#x2F;&#x2F;0,1,2,3,desc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;es6</span><br><span class=\"line\">for (var el of array) &#123;</span><br><span class=\"line\">\tif(el&#x3D;&#x3D;&#39;c&#39;) break;\t\t\t&#x2F;&#x2F;a,b</span><br><span class=\"line\">    console.log(el)\t\t\t\t&#x2F;&#x2F;a,b,c,d</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>forEach方法只循环数组的元素，不循环数组的属性，不能跳出循环</li>\n<li>for in方法循环数组的所有元素下标以及属性键名，不能跳出循环</li>\n<li>for of方法只循环数组的元素，可以用break跳出循环</li>\n</ul>\n<h4 id=\"还可以循环字符串\"><a href=\"#还可以循环字符串\" class=\"headerlink\" title=\"还可以循环字符串\"></a>还可以循环字符串</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var n of array.desc) &#123;</span><br><span class=\"line\">    console.log(n)\t\t\t&#x2F;&#x2F;n,u,m,b,e,r, ,a,r,r,a,y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"面向对象新特性\"><a href=\"#面向对象新特性\" class=\"headerlink\" title=\"面向对象新特性\"></a>面向对象新特性</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TypeScript介绍\"><a href=\"#TypeScript介绍\" class=\"headerlink\" title=\"TypeScript介绍\"></a>TypeScript介绍</h1><p>微软开发的脚本语言</p>\n<p>javascript的超集</p>\n<p>遵循ES6规范</p>\n<p>2016年9月发布的Angular2框架就是由TypeScript编写的</p>\n<h1 id=\"TypeScript的开发环境\"><a href=\"#TypeScript的开发环境\" class=\"headerlink\" title=\"TypeScript的开发环境\"></a>TypeScript的开发环境</h1><p>搭建typescript的开发环境，就是安装typescript的编译器（compiler）。</p>\n<p>编译器的作用是把typescript的代码转换成javascript代码</p>\n<p>为什么</p>\n<p>因为ES6规范是2015年发布的，目前大多主流的浏览器并没有完全支持ES6规范。因此用ES6写的代码不能直接放到浏览器里跑，需要转换成ES5</p>\n<p><strong>两种编译器</strong></p>\n<p>在线compiler：<a href=\"http://www.typescriptlang.org/play/index.html\">typescript在线编译器</a></p>\n<p>本地compiler：<code>sudo npm install -g typescript</code></p>\n<h1 id=\"TypeScript语法\"><a href=\"#TypeScript语法\" class=\"headerlink\" title=\"TypeScript语法\"></a>TypeScript语法</h1><h2 id=\"字符串新特性\"><a href=\"#字符串新特性\" class=\"headerlink\" title=\"字符串新特性\"></a>字符串新特性</h2><h3 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h3><p>ES5:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;传统javascript中字符串换行必须用+号拼接起来</span><br><span class=\"line\">var content &#x3D; &quot;aaa&quot;+</span><br><span class=\"line\">&quot;bbb&quot;+</span><br><span class=\"line\">&quot;ccc&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>TS:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;TS多行字符串可以随意换行，用&#96;&#96;双撇号声明</span><br><span class=\"line\">var content &#x3D; &#39;aaa</span><br><span class=\"line\">bbb</span><br><span class=\"line\">ccc&#96;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串模版\"><a href=\"#字符串模版\" class=\"headerlink\" title=\"字符串模版\"></a>字符串模版</h3><p>在一个<strong>多行字符串里</strong>，用一个变量插入表达式、调用方法 </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#96;...$&#123;&#125;...&#96;</span><br></pre></td></tr></table></figure>\n\n<p>ts：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name &#x3D; &quot;Ethan&quot;</span><br><span class=\"line\">var getName &#x3D; function () &#123;</span><br><span class=\"line\">    return &quot;Ethan&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#96;&lt;div&gt;</span><br><span class=\"line\">&lt;span&gt;$&#123;name&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;soan&gt;$&#123;getName()&#125;&lt;&#x2F;span&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;&#96;)</span><br></pre></td></tr></table></figure>\n\n<p>编译后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var getName &#x3D; function () &#123;</span><br><span class=\"line\">    return &quot;Ethan&quot;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">console.log(&quot;&lt;div&gt;\\n&lt;span&gt;&quot; + name + &quot;&lt;&#x2F;span&gt;\\n&lt;soan&gt;&quot; + getName() + &quot;&lt;&#x2F;span&gt;\\n&lt;&#x2F;div&gt;&quot;);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：表达式的语法只在多行字符串里起作用，如果这个字符串是双引号””声明的普通字符串，表达式不会被解析，双引号之间的所有内容都会被作为字符串打印出来，就像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">console.log(&quot;hellow $&#123;name&#125;&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;js</span><br><span class=\"line\">console.log(&quot;hellow $&#123;name&#125;&quot;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自动拆分字符串\"><a href=\"#自动拆分字符串\" class=\"headerlink\" title=\"自动拆分字符串\"></a>自动拆分字符串</h3><p>当用一个字符串模版调用一个方法的时候，这个字符串模版里面表达式的值，会自动赋给被调用方法的参数。</p>\n<p>ts:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test &#x3D; function (template, name, age) &#123;</span><br><span class=\"line\">    console.log(template);</span><br><span class=\"line\">    console.log(name);</span><br><span class=\"line\">    console.log(age);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var myName &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var getAge &#x3D; function () &#123;</span><br><span class=\"line\">    return 25;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test&#96;hello, my name is $&#123;myName&#125;,i&#39;m $&#123;getAge()&#125;&#96;;</span><br></pre></td></tr></table></figure>\n\n<p>如果要使用自动拆分的特性，在调方法的时候不要写圆括号<code>test()</code>，而是直接写字符串模版<code>test`hello, my name is $&#123;myName&#125;,i&#39;m $&#123;getAge()&#125;`;</code></p>\n<p>编译后：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var test &#x3D; function (template, name, age) &#123;</span><br><span class=\"line\">    console.log(template);</span><br><span class=\"line\">    console.log(name);</span><br><span class=\"line\">    console.log(age);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var myName &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var getAge &#x3D; function () &#123;</span><br><span class=\"line\">    return 25;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">(_a &#x3D; [&quot;hello, my name is &quot;, &quot;,i&#39;m &quot;, &quot;&quot;], _a.raw &#x3D; [&quot;hello, my name is &quot;, &quot;,i&#39;m &quot;, &quot;&quot;], test(_a, myName, getAge()));</span><br><span class=\"line\">var _a;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VM2163:2 Array(3)</span><br><span class=\"line\">0: &quot;hello, my name is &quot;</span><br><span class=\"line\">1: &quot;,i&#39;m &quot;</span><br><span class=\"line\">2: &quot;&quot;</span><br><span class=\"line\">raw: (3) [&quot;hello, my name is &quot;, &quot;,i&#39;m &quot;, &quot;&quot;]</span><br><span class=\"line\">length: 3__proto__: Array(0)</span><br><span class=\"line\">VM2163:3 Ethan</span><br><span class=\"line\">VM2163:4 25</span><br></pre></td></tr></table></figure>\n\n<p>用一个字符串模版去调用test方法，字符串模版里表达式的值会赋给相应的参数。</p>\n<p>第一个参数template就是字符串模版的值，第二个参数name就是第一个表达式的值，第三个参数age就是第二个表达式的值</p>\n<h2 id=\"参数新特性\"><a href=\"#参数新特性\" class=\"headerlink\" title=\"参数新特性\"></a>参数新特性</h2><h3 id=\"参数类型\"><a href=\"#参数类型\" class=\"headerlink\" title=\"参数类型\"></a>参数类型</h3><p> 在参数名称后面，可以使用冒号：来指定参数的类型；</p>\n<p>变量指定类型、函数返回值指定类型、函数参数指定类型、自定义类型</p>\n<h4 id=\"变量指定类型\"><a href=\"#变量指定类型\" class=\"headerlink\" title=\"变量指定类型\"></a>变量指定类型</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var myName: string &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var age: number &#x3D; 12;</span><br><span class=\"line\">var man: boolean &#x3D; true;</span><br><span class=\"line\">var a: any &#x3D; &quot;123&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;js</span><br><span class=\"line\">var myName &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">var age &#x3D; 12;</span><br><span class=\"line\">var man &#x3D; true;</span><br><span class=\"line\">var a &#x3D; &quot;123&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>声明了指定类型变量的作用，是在以后再次给变量赋值时，编译器会根据指定类型做检查，如果类型不一致编译器会报错，以此来降低开发人员出错的几率。但是编译后的js不会报错，因为ES5中变量为弱类型，就想这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var myName: string &#x3D; &quot;ethan&quot;;  &#x2F;&#x2F;声明了一个字符串类型的指定类型变量</span><br><span class=\"line\"></span><br><span class=\"line\">myName &#x3D; 13; &#x2F;&#x2F;再次赋值number，ts中会报错，但仍可以编译</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;js</span><br><span class=\"line\">var myName &#x3D; &quot;ethan&quot;;</span><br><span class=\"line\">myName &#x3D; 13; &#x2F;&#x2F;js中正常，不会报错</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>如果我想声明一个可以是任意类型的变量，就用any：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var a: any &#x3D; &quot;ethan&quot;</span><br><span class=\"line\">a &#x3D; 13; &#x2F;&#x2F;不会报错</span><br></pre></td></tr></table></figure>\n\n<p>如果在ts中，不指定任何类型生命变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var myName &#x3D; &quot;Ethan&quot;;</span><br></pre></td></tr></table></figure>\n\n<p>再次给这个变量赋值，赋一个数字，就会报错。这是因为ts中存在类型推断机制，这个机制会在第一次给变量赋值的时候推断变量类型 ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">myName &#x3D; 13  &#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数返回值指定类型\"><a href=\"#函数返回值指定类型\" class=\"headerlink\" title=\"函数返回值指定类型\"></a>函数返回值指定类型</h4><p>在方法后声明指定类型，指定这个方法的返回值的类型，比如指定一个方法返回string类型的值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function test(): string&#123;</span><br><span class=\"line\">  return &quot;Ethan&quot;\t&#x2F;&#x2F;return返回的值必须是string类型，否则报错</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用void声明一个方法，表明这个方法不需要任何返回值，指定返回值会报错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function test(): void &#123;</span><br><span class=\"line\">    return &quot;323&quot;  &#x2F;&#x2F;报错</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"函数参数指定类型\"><a href=\"#函数参数指定类型\" class=\"headerlink\" title=\"函数参数指定类型\"></a>函数参数指定类型</h4><p>给方法的参数指定类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function test(name: string):string&#123;</span><br><span class=\"line\">  return &quot;&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test(&quot;Ethan&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>在调用方法的时候，参数只能是string类型，如果用其他类型就会报错</p>\n<h4 id=\"自定义类型\"><a href=\"#自定义类型\" class=\"headerlink\" title=\"自定义类型\"></a>自定义类型</h4><p> 通过<strong>class</strong>关键字 或 接口自定义一个类型，比如自定义一个Person类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;编译后</span><br><span class=\"line\">var Person &#x3D; &#x2F;** @class *&#x2F; (function () &#123;</span><br><span class=\"line\">    function Person() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person;</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n\n<p>下面我就可以声明一个自定义的Person类型：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age:number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var ethan: Person &#x3D; new Person();</span><br><span class=\"line\">ethan.name &#x3D; &quot;Ethan&quot;;</span><br><span class=\"line\">ethan.age &#x3D; &quot;18&quot;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>在参数声明后面用等号声明参数的默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myName: string &#x3D; &quot;Ethan&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>给方法的变量指定默认值</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a: string,b: string,c: string &#x3D; &quot;Ethan&quot;)&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  console.log(b);</span><br><span class=\"line\">  console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test(&quot;xxx&quot;,&quot;yyy&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;console.log</span><br><span class=\"line\">xxx</span><br><span class=\"line\">yyy</span><br><span class=\"line\">Ethan</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong></p>\n<p>带默认值的参数一定是声明在最后面，如果声明在前面，像这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a: string &#x3D; &quot;Ethan&quot;,b: string,c: string)&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  console.log(b);</span><br><span class=\"line\">  console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(&quot;xxx&quot;,&quot;yyy&quot;)</span><br></pre></td></tr></table></figure>\n\n<p>调用test方法就会报错，因为xxx是参数a，yyy是参数b，c参数没有传。TS中调用方法时不传参数会报错。</p>\n<h3 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h3><p>在方法的参数声明后面用?来标明此参数为可选参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a: string,b?: string,c: string &#x3D; &quot;Ethan&quot;)&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  console.log(b);</span><br><span class=\"line\">  console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test(&quot;xxx&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;console.log</span><br><span class=\"line\">xxx\t\t\t\t&#x2F;&#x2F;a参数传了&quot;xxx&quot;</span><br><span class=\"line\">undefined\t\t&#x2F;&#x2F;b参数是可选参数，没传</span><br><span class=\"line\">Ethan\t\t\t&#x2F;&#x2F;c参数有默认值</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong></p>\n<p>1.需要处理可选参数没传时候的情况，可选参数没传,这个参数就是undefined，如果方法里调用这个参数(undefined)就会报错</p>\n<p>2.比传参数不能在可选参数后面：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test(a?: string,b: string,c: string &#x3D; &quot;Ethan&quot;)&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">  console.log(b);</span><br><span class=\"line\">  console.log(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>b是必选参数，在可选参数a的后面，这样写会报错</p>\n<h2 id=\"函数新特性\"><a href=\"#函数新特性\" class=\"headerlink\" title=\"函数新特性\"></a>函数新特性</h2><h3 id=\"Rest-and-Spread操作符\"><a href=\"#Rest-and-Spread操作符\" class=\"headerlink\" title=\"Rest and Spread操作符\"></a>Rest and Spread操作符</h3><p>…就是Rest and Spread操作符</p>\n<p><strong>用法一</strong>：用来声明任意数量参数的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function fun1(...args) &#123;</span><br><span class=\"line\">    args.forEach(function (arg) &#123;</span><br><span class=\"line\">        console.log(arg)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fun1(1, 2, 3);\t\t\t&#x2F;&#x2F;输出1，2，3</span><br><span class=\"line\">fun1(7, 8, 9, 10, 11);\t&#x2F;&#x2F;输出7，8，9，10，11</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;编译后</span><br><span class=\"line\">function fun1() &#123;</span><br><span class=\"line\">    var args &#x3D; [];</span><br><span class=\"line\">    for (var _i &#x3D; 0; _i &lt; arguments.length; _i++) &#123;</span><br><span class=\"line\">        args[_i] &#x3D; arguments[_i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    args.forEach(function (arg) &#123;</span><br><span class=\"line\">        console.log(arg);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun1(1, 2, 3);</span><br><span class=\"line\">fun1(7, 8, 9, 10, 11);</span><br></pre></td></tr></table></figure>\n\n<p><strong>用法二</strong>：方法参数数量固定，调用方法的时候传入任意数量参数</p>\n<p>该语法是ES6的，目前版本的TypeScript还不支持，但是编译后的js是可以正常运行的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function fun1(a,b,c) &#123;</span><br><span class=\"line\">    console.log(a);</span><br><span class=\"line\">    console.log(b);</span><br><span class=\"line\">    console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arg1 &#x3D; [1, 2];</span><br><span class=\"line\">var arg2 &#x3D; [7, 8, 9];</span><br><span class=\"line\"></span><br><span class=\"line\">fun1(...arg1);\t\t&#x2F;&#x2F;输出1，2，undefined</span><br><span class=\"line\">fun1(...arg2);\t\t&#x2F;&#x2F;输出7，8，9</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;编译后</span><br><span class=\"line\">function fun1(a, b, c) &#123;</span><br><span class=\"line\">    console.log(a);</span><br><span class=\"line\">    console.log(b);</span><br><span class=\"line\">    console.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var arg1 &#x3D; [1, 2];</span><br><span class=\"line\">var arg2 &#x3D; [7, 8, 9];</span><br><span class=\"line\">fun1.apply(void 0, arg1);</span><br><span class=\"line\">fun1.apply(void 0, arg2);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Generator函数\"><a href=\"#Generator函数\" class=\"headerlink\" title=\"Generator函数\"></a>Generator函数</h3><p>控制函数的执行过程，手动暂停和恢复代码执行</p>\n<p>在ES5中，调用一个方法，没有办法让这个方法执行到一半停住。但是在ES6里，新添加了一个关键字yield，这个关键字可以实现这个特性</p>\n<p>这个特性目前版本TypeScript还不支持，他是ES6的语法</p>\n<p>声明一个generator函数非常简单，就是在function后面加*号，像这样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function* doSomething()&#123;</span><br><span class=\"line\">  console.log(&quot;start&quot;);</span><br><span class=\"line\">  yield;\t\t&#x2F;&#x2F;相当于一个断点</span><br><span class=\"line\">  console.log(&quot;finish&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在调用generator函数时，如果像往常一样调用函数是不会起任何作用的：</p>\n<p><code>doSomething()</code></p>\n<p>控制台不会有任何输出</p>\n<p>调用generator函数，必须把它声明成一个变量，然后调用这个变量的next()方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var func &#x3D; doSomething();</span><br><span class=\"line\">func.next();</span><br></pre></td></tr></table></figure>\n\n<p>每调一次next方法，generator函数就会执行到yield关键字停住，然后接着调用next方法，函数继续执行到下一个yield，如此继续直到函数执行结束。</p>\n<h3 id=\"析构表达式\"><a href=\"#析构表达式\" class=\"headerlink\" title=\"析构表达式\"></a>析构表达式</h3><p>析构表达式的作用是通过表达式将对象或数组拆解成任意数量的变量</p>\n<p>析构表达式的好处就是，当你需要用一个对象的属性或者一个数组的元素来初始化一些本地的变量时，可以写更少的代码</p>\n<h4 id=\"用析构表达式从对象里取值\"><a href=\"#用析构表达式从对象里取值\" class=\"headerlink\" title=\"用析构表达式从对象里取值\"></a>用析构表达式从对象里取值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">function getStock()&#123;</span><br><span class=\"line\">  return&#123;</span><br><span class=\"line\">    code:&quot;IBM&quot;,</span><br><span class=\"line\">    price:&#123;</span><br><span class=\"line\">      price1:200,</span><br><span class=\"line\">      price2:400</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    aaa:&quot;xixi&quot;,</span><br><span class=\"line\">    bbb:&quot;haha&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var &#123;code: codex, price:&#123;price2&#125;&#125; &#x3D; getStock();\t\t&#x2F;&#x2F;对象的属性转化成本地的两个变量</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(codex);\t\t&#x2F;&#x2F;IBM</span><br><span class=\"line\">console.log(price2);\t&#x2F;&#x2F;400</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>针对对象的析构表达式，用花括号{ }声明</p>\n</li>\n<li><p>{ }里面的变量名要和被析构的对象的属性名一致</p>\n</li>\n<li><p>如果想让表达式中的变量梦和被解构对象的属性名不一致，要这么写</p>\n<p><code>var &#123;code: codex&#125; = getStock();</code></p>\n<p>表示本地声明一个codex变量，并把getStock对象的code属性值赋给他</p>\n</li>\n<li><p>如果被析构对象的属性值也是对象，想解构嵌套对象的属性这么写：</p>\n<p><code>var &#123;price: &#123;price2&#125;&#125; = getStock();</code></p>\n<p>表示声明一个price2变量，获取getStock对象中price对象的price2属性</p>\n</li>\n<li><p>对象里的其他属性不会影响析构表达式的执行</p>\n</li>\n</ul>\n<h4 id=\"用析构表达式从数组里取值\"><a href=\"#用析构表达式从数组里取值\" class=\"headerlink\" title=\"用析构表达式从数组里取值\"></a>用析构表达式从数组里取值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array &#x3D; [1, 2, 3, 4, 5];</span><br><span class=\"line\"></span><br><span class=\"line\">var [a, b] &#x3D; array;\t\t&#x2F;&#x2F;1,2</span><br><span class=\"line\"></span><br><span class=\"line\">var [a, , , b] &#x3D; array;\t&#x2F;&#x2F;1,4</span><br><span class=\"line\"></span><br><span class=\"line\">var [a, b, ...c] &#x3D; array;&#x2F;&#x2F;1,2,Array[3,4,5]</span><br><span class=\"line\"></span><br><span class=\"line\">function doSomething([a, b, ...c])&#123;</span><br><span class=\"line\">  \tconsole.log(a);</span><br><span class=\"line\">\tconsole.log(b);</span><br><span class=\"line\">\tconsole.log(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomething(array);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>针对数组的析构表达式用方括号[ ]声明</li>\n<li>表达式中用,,跳过不需要析构的数组元素</li>\n<li>用Rset操作符取出剩余的是一个数组，包含所有剩余的元素</li>\n<li>方法的形参也可以是一个针对数组的析构表达式，调用方法的传参会按照形参的析高表达式被析构</li>\n</ul>\n<h2 id=\"表达式和循环\"><a href=\"#表达式和循环\" class=\"headerlink\" title=\"表达式和循环\"></a>表达式和循环</h2><h3 id=\"箭头表达式\"><a href=\"#箭头表达式\" class=\"headerlink\" title=\"箭头表达式\"></a>箭头表达式</h3><p>用来声明匿名函数，消除传统匿名函数的this指针问题</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ts</span><br><span class=\"line\">var sum1 &#x3D; (arg1, arg2) &#x3D;&gt; arg1 + arg2;\t\t&#x2F;&#x2F;函数体只有一行，不用写&#123;&#125; return</span><br><span class=\"line\">var sum2 &#x3D; (arg1, arg2) &#x3D;&gt; &#123;\t\t\t\t&#x2F;&#x2F;函数体多行，要写&#123;&#125; return</span><br><span class=\"line\">    return arg1 + arg2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var sum3 &#x3D; () &#x3D;&gt; &#123; &#125;;\t\t\t&#x2F;&#x2F;函数没有参数，不用写</span><br><span class=\"line\">var sum4 &#x3D; arg &#x3D;&gt; &#123;\t\t\t\t&#x2F;&#x2F;函数只有一个参数，不用写()</span><br><span class=\"line\">    return arg</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;js</span><br><span class=\"line\">var sum1 &#x3D; function (arg1, arg2) &#123; return arg1 + arg2; &#125;;</span><br><span class=\"line\">var sum2 &#x3D; function (arg1, arg2) &#123;</span><br><span class=\"line\">    return arg1 + arg2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var sum3 &#x3D; function () &#123; &#125;;</span><br><span class=\"line\">var sum4 &#x3D; function (arg) &#123;</span><br><span class=\"line\">    return arg;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><strong>关于this指针的例子</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;es5</span><br><span class=\"line\">function getStock(name: string) &#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\"></span><br><span class=\"line\">    setInterval(function () &#123;\t\t&#x2F;&#x2F;es5写法</span><br><span class=\"line\">        console.log(this.name)\t\t&#x2F;&#x2F;es5中，匿名函数的调用者是window对象，this指向函数的调用者。</span><br><span class=\"line\">        \t\t\t\t\t\t\t因此，this.name为空</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var stock &#x3D;new  getStock(&quot;IBM&quot;);\t&#x2F;&#x2F;空</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;es6</span><br><span class=\"line\">function getStock2(name: string) &#123;</span><br><span class=\"line\">    this.name &#x3D; name;</span><br><span class=\"line\"></span><br><span class=\"line\">    setInterval(() &#x3D;&gt; &#123;\t\t\t\t&#x2F;&#x2F;es6写法</span><br><span class=\"line\">        console.log(this.name)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var stock &#x3D;new  getStock2(&quot;IBM&quot;);\t&#x2F;&#x2F;IBM</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"for-of循环\"><a href=\"#for-of循环\" class=\"headerlink\" title=\"for of循环\"></a>for of循环</h3><h4 id=\"循环数组\"><a href=\"#循环数组\" class=\"headerlink\" title=\"循环数组\"></a>循环数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span><br><span class=\"line\">array.desc &#x3D; &quot;number array&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;es5</span><br><span class=\"line\">array.forEach(function (value) &#123;</span><br><span class=\"line\">    console.log(value);\t\t\t&#x2F;&#x2F;a,b,c,d</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">for (var index in array) &#123;</span><br><span class=\"line\">    console.log(index)\t\t\t&#x2F;&#x2F;0,1,2,3,desc</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;es6</span><br><span class=\"line\">for (var el of array) &#123;</span><br><span class=\"line\">\tif(el&#x3D;&#x3D;&#39;c&#39;) break;\t\t\t&#x2F;&#x2F;a,b</span><br><span class=\"line\">    console.log(el)\t\t\t\t&#x2F;&#x2F;a,b,c,d</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>forEach方法只循环数组的元素，不循环数组的属性，不能跳出循环</li>\n<li>for in方法循环数组的所有元素下标以及属性键名，不能跳出循环</li>\n<li>for of方法只循环数组的元素，可以用break跳出循环</li>\n</ul>\n<h4 id=\"还可以循环字符串\"><a href=\"#还可以循环字符串\" class=\"headerlink\" title=\"还可以循环字符串\"></a>还可以循环字符串</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var n of array.desc) &#123;</span><br><span class=\"line\">    console.log(n)\t\t\t&#x2F;&#x2F;n,u,m,b,e,r, ,a,r,r,a,y</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"面向对象新特性\"><a href=\"#面向对象新特性\" class=\"headerlink\" title=\"面向对象新特性\"></a>面向对象新特性</h2>"},{"title":"node安装开发环境搭建","date":"2017-10-04T09:24:57.000Z","description":"介绍安装、卸载node的几种方法","_content":"\n> 操作系统：macOS Sierra\n\n# 一 官网下载\n\n**安装**：官网下载安装node\n\n**卸载**：\n\n首先运行脚本\n\n```\nlsbom -f -l -s -pf /var/db/receipts/org.nodejs.pkg.bom | while read f; do sudo rm /usr/local/${f}; done\n```\n\n接着\n\n```\nsudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*\n```\n\n```\ncd /usr/local/lib\nsudo rm -rf node*\n```\n\n进入 `/usr/local/include` 删除含有 `node` 和 `node_modules` 的目录\n\n```\ncd /usr/local/include\nsudo rm -rf node*\n```\n\n如果是用 brew 安装的node，用下面的命令卸载\n\n```\nbrew uninstall node\n```\n\n进入个人主文件夹，检查各种 local、lib、include 文件夹，删除名字含有`node`和`node_modules`的文件\n\n进入 `/usr/local/bin` 删除 node 执行文件\n\n```\ncd /usr/local/bin\nsudo rm -rf /usr/local/bin/npm\nsudo rm -rf /usr/local/bin/node\nls -las 仔细查看，全局安装的npm包一般会在这个目录下创建软连接，发现就删除\n```\n\n其他清理工作\n\n```\nsudo rm -rf /usr/local/share/man/man1/node.1\nsudo rm -rf /usr/local/lib/dtrace/node.d\nsudo rm -rf ~/.npm\n```\n\n# 二 通过brew安装\n\n**安装brew**:\n\n官网安装命令\n\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n**卸载brew**：\n\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n```\n\n# 三 通过nvm安装\n\n**安装NVM**：\n\n官网安装命令\n\n```\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.5/install.sh | bash\n```\n\n[安装教程](http://www.cnblogs.com/greenteaone/p/5065981.html)\n\n**卸载NVM**：\n\n```\nrm -rf ~/.nvm \n```\n\n[教程](http://blog.csdn.net/q617610589/article/details/51456152)\n\n","source":"_posts/node安装开发环境搭建.md","raw":"---\ntitle: node安装开发环境搭建\ndate: 2017-10-04 17:24:57\ntags:\n- Node\ncategories:\n- 环境搭建\ndescription: 介绍安装、卸载node的几种方法\n---\n\n> 操作系统：macOS Sierra\n\n# 一 官网下载\n\n**安装**：官网下载安装node\n\n**卸载**：\n\n首先运行脚本\n\n```\nlsbom -f -l -s -pf /var/db/receipts/org.nodejs.pkg.bom | while read f; do sudo rm /usr/local/${f}; done\n```\n\n接着\n\n```\nsudo rm -rf /usr/local/lib/node /usr/local/lib/node_modules /var/db/receipts/org.nodejs.*\n```\n\n```\ncd /usr/local/lib\nsudo rm -rf node*\n```\n\n进入 `/usr/local/include` 删除含有 `node` 和 `node_modules` 的目录\n\n```\ncd /usr/local/include\nsudo rm -rf node*\n```\n\n如果是用 brew 安装的node，用下面的命令卸载\n\n```\nbrew uninstall node\n```\n\n进入个人主文件夹，检查各种 local、lib、include 文件夹，删除名字含有`node`和`node_modules`的文件\n\n进入 `/usr/local/bin` 删除 node 执行文件\n\n```\ncd /usr/local/bin\nsudo rm -rf /usr/local/bin/npm\nsudo rm -rf /usr/local/bin/node\nls -las 仔细查看，全局安装的npm包一般会在这个目录下创建软连接，发现就删除\n```\n\n其他清理工作\n\n```\nsudo rm -rf /usr/local/share/man/man1/node.1\nsudo rm -rf /usr/local/lib/dtrace/node.d\nsudo rm -rf ~/.npm\n```\n\n# 二 通过brew安装\n\n**安装brew**:\n\n官网安装命令\n\n```\n/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"\n```\n\n**卸载brew**：\n\n```\nruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\"\n```\n\n# 三 通过nvm安装\n\n**安装NVM**：\n\n官网安装命令\n\n```\ncurl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.5/install.sh | bash\n```\n\n[安装教程](http://www.cnblogs.com/greenteaone/p/5065981.html)\n\n**卸载NVM**：\n\n```\nrm -rf ~/.nvm \n```\n\n[教程](http://blog.csdn.net/q617610589/article/details/51456152)\n\n","slug":"node安装开发环境搭建","published":1,"updated":"2021-05-08T14:58:52.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbor000uwct4e5bbe8r5","content":"<blockquote>\n<p>操作系统：macOS Sierra</p>\n</blockquote>\n<h1 id=\"一-官网下载\"><a href=\"#一-官网下载\" class=\"headerlink\" title=\"一 官网下载\"></a>一 官网下载</h1><p><strong>安装</strong>：官网下载安装node</p>\n<p><strong>卸载</strong>：</p>\n<p>首先运行脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsbom -f -l -s -pf &#x2F;var&#x2F;db&#x2F;receipts&#x2F;org.nodejs.pkg.bom | while read f; do sudo rm &#x2F;usr&#x2F;local&#x2F;$&#123;f&#125;; done</span><br></pre></td></tr></table></figure>\n\n<p>接着</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules &#x2F;var&#x2F;db&#x2F;receipts&#x2F;org.nodejs.*</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;lib</span><br><span class=\"line\">sudo rm -rf node*</span><br></pre></td></tr></table></figure>\n\n<p>进入 <code>/usr/local/include</code> 删除含有 <code>node</code> 和 <code>node_modules</code> 的目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;include</span><br><span class=\"line\">sudo rm -rf node*</span><br></pre></td></tr></table></figure>\n\n<p>如果是用 brew 安装的node，用下面的命令卸载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew uninstall node</span><br></pre></td></tr></table></figure>\n\n<p>进入个人主文件夹，检查各种 local、lib、include 文件夹，删除名字含有<code>node</code>和<code>node_modules</code>的文件</p>\n<p>进入 <code>/usr/local/bin</code> 删除 node 执行文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm</span><br><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node</span><br><span class=\"line\">ls -las 仔细查看，全局安装的npm包一般会在这个目录下创建软连接，发现就删除</span><br></pre></td></tr></table></figure>\n\n<p>其他清理工作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1&#x2F;node.1</span><br><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;lib&#x2F;dtrace&#x2F;node.d</span><br><span class=\"line\">sudo rm -rf ~&#x2F;.npm</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二-通过brew安装\"><a href=\"#二-通过brew安装\" class=\"headerlink\" title=\"二 通过brew安装\"></a>二 通过brew安装</h1><p><strong>安装brew</strong>:</p>\n<p>官网安装命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>卸载brew</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三-通过nvm安装\"><a href=\"#三-通过nvm安装\" class=\"headerlink\" title=\"三 通过nvm安装\"></a>三 通过nvm安装</h1><p><strong>安装NVM</strong>：</p>\n<p>官网安装命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.5&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://www.cnblogs.com/greenteaone/p/5065981.html\">安装教程</a></p>\n<p><strong>卸载NVM</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf ~&#x2F;.nvm </span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://blog.csdn.net/q617610589/article/details/51456152\">教程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>操作系统：macOS Sierra</p>\n</blockquote>\n<h1 id=\"一-官网下载\"><a href=\"#一-官网下载\" class=\"headerlink\" title=\"一 官网下载\"></a>一 官网下载</h1><p><strong>安装</strong>：官网下载安装node</p>\n<p><strong>卸载</strong>：</p>\n<p>首先运行脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsbom -f -l -s -pf &#x2F;var&#x2F;db&#x2F;receipts&#x2F;org.nodejs.pkg.bom | while read f; do sudo rm &#x2F;usr&#x2F;local&#x2F;$&#123;f&#125;; done</span><br></pre></td></tr></table></figure>\n\n<p>接着</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node &#x2F;usr&#x2F;local&#x2F;lib&#x2F;node_modules &#x2F;var&#x2F;db&#x2F;receipts&#x2F;org.nodejs.*</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;lib</span><br><span class=\"line\">sudo rm -rf node*</span><br></pre></td></tr></table></figure>\n\n<p>进入 <code>/usr/local/include</code> 删除含有 <code>node</code> 和 <code>node_modules</code> 的目录</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;include</span><br><span class=\"line\">sudo rm -rf node*</span><br></pre></td></tr></table></figure>\n\n<p>如果是用 brew 安装的node，用下面的命令卸载</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew uninstall node</span><br></pre></td></tr></table></figure>\n\n<p>进入个人主文件夹，检查各种 local、lib、include 文件夹，删除名字含有<code>node</code>和<code>node_modules</code>的文件</p>\n<p>进入 <code>/usr/local/bin</code> 删除 node 执行文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm</span><br><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node</span><br><span class=\"line\">ls -las 仔细查看，全局安装的npm包一般会在这个目录下创建软连接，发现就删除</span><br></pre></td></tr></table></figure>\n\n<p>其他清理工作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;share&#x2F;man&#x2F;man1&#x2F;node.1</span><br><span class=\"line\">sudo rm -rf &#x2F;usr&#x2F;local&#x2F;lib&#x2F;dtrace&#x2F;node.d</span><br><span class=\"line\">sudo rm -rf ~&#x2F;.npm</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二-通过brew安装\"><a href=\"#二-通过brew安装\" class=\"headerlink\" title=\"二 通过brew安装\"></a>二 通过brew安装</h1><p><strong>安装brew</strong>:</p>\n<p>官网安装命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;usr&#x2F;bin&#x2F;ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;install)&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>卸载brew</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ruby -e &quot;$(curl -fsSL https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Homebrew&#x2F;install&#x2F;master&#x2F;uninstall)&quot;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"三-通过nvm安装\"><a href=\"#三-通过nvm安装\" class=\"headerlink\" title=\"三 通过nvm安装\"></a>三 通过nvm安装</h1><p><strong>安装NVM</strong>：</p>\n<p>官网安装命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;creationix&#x2F;nvm&#x2F;v0.33.5&#x2F;install.sh | bash</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://www.cnblogs.com/greenteaone/p/5065981.html\">安装教程</a></p>\n<p><strong>卸载NVM</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rm -rf ~&#x2F;.nvm </span><br></pre></td></tr></table></figure>\n\n<p><a href=\"http://blog.csdn.net/q617610589/article/details/51456152\">教程</a></p>\n"},{"title":"return Promise.resolve(res.data)和return res.data的区别","date":"2018-03-11T04:05:53.000Z","description":"promise.then()的回调函数返回Promise.resolve(res.data)和直接返回res.data有何区别","_content":"\n# 问题\n\n一个axios异步请求函数：\n\n```javascript\nexport function getDiscList() {\n  const url = '/api/getDiscList'\n\n  const data = Object.assign({}, commonParams, {\n    platform: 'yqq',\n    hostUin: 0,\n    sin: 0,\n    ein: 29,\n    sortId: 5,\n    needNewCode: 0,\n    categoryId: 10000000,\n    rnd: Math.random(),\n    format: 'json'\n  })\n\n  return axios.get(url, {\n    params: data\n  }).then((res) => {\n    return Promise.resolve(res.data)\n  })\n}\n```\n\n组件里调用这个异步请求获取数据：\n\n```javascript\ngetDiscList().then((res) => {\n          if (res.code === ERR_OK) {\n            this.discList = res.data.list\n          }\n        })\n```\n\n**为何在请求函数中，最后的then方法里return的是Promise.resolve(res.data)，而不是直接return res.data?**\n\n**两种return对请求的调用有什么影响吗？**\n\n\n\n# 思考\n\nok，一步一步分析：\n\n1. 先搞清楚这个请求的返回是什么：\n\n   ```javascript\n   return axios.get(url, {\n       params: data\n     }).then((res) => {\n       return Promise.resolve(res.data)\n     })\n   ```\n\n   这一坨就是getDiscList这个函数返回的东西，axios是一个ajax请求第三方库，根据官方ReadMe可知道，axios.get()方法返回一个promise，并且这个promise的resolve回调函数的参数就是请求返回的数据res\n\n2. 那么这个return相当于这样：\n\n   ```javascript\n   return new Promise((resolve) => {\n     /*异步请求*／\n     。。。\n       if(/*请求成功*/){\n            resolve(res)\n          }\n   }).then((res) => {\n       return Promise.resolve(res.data)\n   })\n   ```\n\n   现在return的就是new Promise().then()，为什么在请求函数里就then而不是在调用请求的时候再then？我猜是由于axios.get()这个promise返回的res不是作者需要的数据，res.data才是。因此作者在这里就先then一次，相当于对请求结果做个预处理，把真正需要的res.data传出去。这样在调用请求的时候直接拿到的就是res.data。起到简化代码的目的。\n\n   那么问题来了，既然出于这样的目的，为什么作者不直接return res.data呢？return Promise.resolve(res.data)有什么别的用意吗？\n\n3. 接着分析，现在知道return的是一个promise调用then()方法。那这个then()方法的返回结果又是什么？\n\n   >then方法返回一个[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)，而它的行为与then中的回调函数的返回值有关：\n   >\n   >- 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。\n   >- 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。\n\n   根据官方文档，then()方法返回的也是一个promise，并且这个promise的状态，resolve函数的参数和then()方法中的回调函数的返回值有关。\n\n4. return res.data就是文档中所说的`如果then中的回调函数返回一个值`这种情况，return Promise.resolve(res.data)就是文档中所说的`如果then中的回调函数返回一个已经是接受状态的Promise`这种情况。\n\n   因为Promise.resolve(res.data)返回的就是一个已经是接受状态的Promise\n\n   > `Promise.resolve(value)`方法返回一个以给定值解析后的Promise对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；否则以该值为成功状态返回promise对象。\n\n5. 既然两个return方式最终都是使then()返回接受状态的Promise，并且这个Promise的接受状态回调函数的参数都是res.data，那为何一定要采用return Promise.resolve(res.data)这种方式呢？\n\n# 答案\n\n`.then((res) => {return res.data})`和`.then((res) => {return Promise.resolve(res.data)})`返回的都是一个接受状态的promise`new Promise((resolve) => {resolve(res.data)})`，那我猜测作者之所以那么写，可能是他觉得这样看起来更严谨。","source":"_posts/return-Promise-resolve-res-data-和return-res-data的区别研究.md","raw":"---\ntitle: return Promise.resolve(res.data)和return res.data的区别\ndate: 2018-03-11 12:05:53\ntags:\n- javaScript\ncategories:\n- 问题记录\ndescription: promise.then()的回调函数返回Promise.resolve(res.data)和直接返回res.data有何区别\n---\n\n# 问题\n\n一个axios异步请求函数：\n\n```javascript\nexport function getDiscList() {\n  const url = '/api/getDiscList'\n\n  const data = Object.assign({}, commonParams, {\n    platform: 'yqq',\n    hostUin: 0,\n    sin: 0,\n    ein: 29,\n    sortId: 5,\n    needNewCode: 0,\n    categoryId: 10000000,\n    rnd: Math.random(),\n    format: 'json'\n  })\n\n  return axios.get(url, {\n    params: data\n  }).then((res) => {\n    return Promise.resolve(res.data)\n  })\n}\n```\n\n组件里调用这个异步请求获取数据：\n\n```javascript\ngetDiscList().then((res) => {\n          if (res.code === ERR_OK) {\n            this.discList = res.data.list\n          }\n        })\n```\n\n**为何在请求函数中，最后的then方法里return的是Promise.resolve(res.data)，而不是直接return res.data?**\n\n**两种return对请求的调用有什么影响吗？**\n\n\n\n# 思考\n\nok，一步一步分析：\n\n1. 先搞清楚这个请求的返回是什么：\n\n   ```javascript\n   return axios.get(url, {\n       params: data\n     }).then((res) => {\n       return Promise.resolve(res.data)\n     })\n   ```\n\n   这一坨就是getDiscList这个函数返回的东西，axios是一个ajax请求第三方库，根据官方ReadMe可知道，axios.get()方法返回一个promise，并且这个promise的resolve回调函数的参数就是请求返回的数据res\n\n2. 那么这个return相当于这样：\n\n   ```javascript\n   return new Promise((resolve) => {\n     /*异步请求*／\n     。。。\n       if(/*请求成功*/){\n            resolve(res)\n          }\n   }).then((res) => {\n       return Promise.resolve(res.data)\n   })\n   ```\n\n   现在return的就是new Promise().then()，为什么在请求函数里就then而不是在调用请求的时候再then？我猜是由于axios.get()这个promise返回的res不是作者需要的数据，res.data才是。因此作者在这里就先then一次，相当于对请求结果做个预处理，把真正需要的res.data传出去。这样在调用请求的时候直接拿到的就是res.data。起到简化代码的目的。\n\n   那么问题来了，既然出于这样的目的，为什么作者不直接return res.data呢？return Promise.resolve(res.data)有什么别的用意吗？\n\n3. 接着分析，现在知道return的是一个promise调用then()方法。那这个then()方法的返回结果又是什么？\n\n   >then方法返回一个[`Promise`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise)，而它的行为与then中的回调函数的返回值有关：\n   >\n   >- 如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。\n   >- 如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。\n\n   根据官方文档，then()方法返回的也是一个promise，并且这个promise的状态，resolve函数的参数和then()方法中的回调函数的返回值有关。\n\n4. return res.data就是文档中所说的`如果then中的回调函数返回一个值`这种情况，return Promise.resolve(res.data)就是文档中所说的`如果then中的回调函数返回一个已经是接受状态的Promise`这种情况。\n\n   因为Promise.resolve(res.data)返回的就是一个已经是接受状态的Promise\n\n   > `Promise.resolve(value)`方法返回一个以给定值解析后的Promise对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；否则以该值为成功状态返回promise对象。\n\n5. 既然两个return方式最终都是使then()返回接受状态的Promise，并且这个Promise的接受状态回调函数的参数都是res.data，那为何一定要采用return Promise.resolve(res.data)这种方式呢？\n\n# 答案\n\n`.then((res) => {return res.data})`和`.then((res) => {return Promise.resolve(res.data)})`返回的都是一个接受状态的promise`new Promise((resolve) => {resolve(res.data)})`，那我猜测作者之所以那么写，可能是他觉得这样看起来更严谨。","slug":"return-Promise-resolve-res-data-和return-res-data的区别研究","published":1,"updated":"2021-05-08T14:58:26.415Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbos000xwct4bzjza46l","content":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>一个axios异步请求函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDiscList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = <span class=\"string\">&#x27;/api/getDiscList&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, commonParams, &#123;</span><br><span class=\"line\">    platform: <span class=\"string\">&#x27;yqq&#x27;</span>,</span><br><span class=\"line\">    hostUin: <span class=\"number\">0</span>,</span><br><span class=\"line\">    sin: <span class=\"number\">0</span>,</span><br><span class=\"line\">    ein: <span class=\"number\">29</span>,</span><br><span class=\"line\">    sortId: <span class=\"number\">5</span>,</span><br><span class=\"line\">    needNewCode: <span class=\"number\">0</span>,</span><br><span class=\"line\">    categoryId: <span class=\"number\">10000000</span>,</span><br><span class=\"line\">    rnd: <span class=\"built_in\">Math</span>.random(),</span><br><span class=\"line\">    format: <span class=\"string\">&#x27;json&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(url, &#123;</span><br><span class=\"line\">    params: data</span><br><span class=\"line\">  &#125;).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(res.data)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>组件里调用这个异步请求获取数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getDiscList().then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (res.code === ERR_OK) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.discList = res.data.list</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>为何在请求函数中，最后的then方法里return的是Promise.resolve(res.data)，而不是直接return res.data?</strong></p>\n<p><strong>两种return对请求的调用有什么影响吗？</strong></p>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><p>ok，一步一步分析：</p>\n<ol>\n<li><p>先搞清楚这个请求的返回是什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> axios.get(url, &#123;</span><br><span class=\"line\">    params: data</span><br><span class=\"line\">  &#125;).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(res.data)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这一坨就是getDiscList这个函数返回的东西，axios是一个ajax请求第三方库，根据官方ReadMe可知道，axios.get()方法返回一个promise，并且这个promise的resolve回调函数的参数就是请求返回的数据res</p>\n</li>\n<li><p>那么这个return相当于这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/*异步请求*／</span></span><br><span class=\"line\"><span class=\"comment\">  。。。</span></span><br><span class=\"line\"><span class=\"comment\">    if(/*请求成功*/</span>)&#123;</span><br><span class=\"line\">         resolve(res)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(res.data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>现在return的就是new Promise().then()，为什么在请求函数里就then而不是在调用请求的时候再then？我猜是由于axios.get()这个promise返回的res不是作者需要的数据，res.data才是。因此作者在这里就先then一次，相当于对请求结果做个预处理，把真正需要的res.data传出去。这样在调用请求的时候直接拿到的就是res.data。起到简化代码的目的。</p>\n<p>那么问题来了，既然出于这样的目的，为什么作者不直接return res.data呢？return Promise.resolve(res.data)有什么别的用意吗？</p>\n</li>\n<li><p>接着分析，现在知道return的是一个promise调用then()方法。那这个then()方法的返回结果又是什么？</p>\n<blockquote>\n<p>then方法返回一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a>，而它的行为与then中的回调函数的返回值有关：</p>\n<ul>\n<li>如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。</li>\n<li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li>\n</ul>\n</blockquote>\n<p>根据官方文档，then()方法返回的也是一个promise，并且这个promise的状态，resolve函数的参数和then()方法中的回调函数的返回值有关。</p>\n</li>\n<li><p>return res.data就是文档中所说的<code>如果then中的回调函数返回一个值</code>这种情况，return Promise.resolve(res.data)就是文档中所说的<code>如果then中的回调函数返回一个已经是接受状态的Promise</code>这种情况。</p>\n<p>因为Promise.resolve(res.data)返回的就是一个已经是接受状态的Promise</p>\n<blockquote>\n<p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的Promise对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；否则以该值为成功状态返回promise对象。</p>\n</blockquote>\n</li>\n<li><p>既然两个return方式最终都是使then()返回接受状态的Promise，并且这个Promise的接受状态回调函数的参数都是res.data，那为何一定要采用return Promise.resolve(res.data)这种方式呢？</p>\n</li>\n</ol>\n<h1 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h1><p><code>.then((res) =&gt; &#123;return res.data&#125;)</code>和<code>.then((res) =&gt; &#123;return Promise.resolve(res.data)&#125;)</code>返回的都是一个接受状态的promise<code>new Promise((resolve) =&gt; &#123;resolve(res.data)&#125;)</code>，那我猜测作者之所以那么写，可能是他觉得这样看起来更严谨。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p>一个axios异步请求函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDiscList</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = <span class=\"string\">&#x27;/api/getDiscList&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, commonParams, &#123;</span><br><span class=\"line\">    platform: <span class=\"string\">&#x27;yqq&#x27;</span>,</span><br><span class=\"line\">    hostUin: <span class=\"number\">0</span>,</span><br><span class=\"line\">    sin: <span class=\"number\">0</span>,</span><br><span class=\"line\">    ein: <span class=\"number\">29</span>,</span><br><span class=\"line\">    sortId: <span class=\"number\">5</span>,</span><br><span class=\"line\">    needNewCode: <span class=\"number\">0</span>,</span><br><span class=\"line\">    categoryId: <span class=\"number\">10000000</span>,</span><br><span class=\"line\">    rnd: <span class=\"built_in\">Math</span>.random(),</span><br><span class=\"line\">    format: <span class=\"string\">&#x27;json&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> axios.get(url, &#123;</span><br><span class=\"line\">    params: data</span><br><span class=\"line\">  &#125;).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(res.data)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>组件里调用这个异步请求获取数据：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getDiscList().then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (res.code === ERR_OK) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.discList = res.data.list</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>为何在请求函数中，最后的then方法里return的是Promise.resolve(res.data)，而不是直接return res.data?</strong></p>\n<p><strong>两种return对请求的调用有什么影响吗？</strong></p>\n<h1 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h1><p>ok，一步一步分析：</p>\n<ol>\n<li><p>先搞清楚这个请求的返回是什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> axios.get(url, &#123;</span><br><span class=\"line\">    params: data</span><br><span class=\"line\">  &#125;).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(res.data)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这一坨就是getDiscList这个函数返回的东西，axios是一个ajax请求第三方库，根据官方ReadMe可知道，axios.get()方法返回一个promise，并且这个promise的resolve回调函数的参数就是请求返回的数据res</p>\n</li>\n<li><p>那么这个return相当于这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">/*异步请求*／</span></span><br><span class=\"line\"><span class=\"comment\">  。。。</span></span><br><span class=\"line\"><span class=\"comment\">    if(/*请求成功*/</span>)&#123;</span><br><span class=\"line\">         resolve(res)</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;).then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(res.data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>现在return的就是new Promise().then()，为什么在请求函数里就then而不是在调用请求的时候再then？我猜是由于axios.get()这个promise返回的res不是作者需要的数据，res.data才是。因此作者在这里就先then一次，相当于对请求结果做个预处理，把真正需要的res.data传出去。这样在调用请求的时候直接拿到的就是res.data。起到简化代码的目的。</p>\n<p>那么问题来了，既然出于这样的目的，为什么作者不直接return res.data呢？return Promise.resolve(res.data)有什么别的用意吗？</p>\n</li>\n<li><p>接着分析，现在知道return的是一个promise调用then()方法。那这个then()方法的返回结果又是什么？</p>\n<blockquote>\n<p>then方法返回一个<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\"><code>Promise</code></a>，而它的行为与then中的回调函数的返回值有关：</p>\n<ul>\n<li>如果then中的回调函数返回一个值，那么then返回的Promise将会成为接受状态，并且将返回的值作为接受状态的回调函数的参数值。</li>\n<li>如果then中的回调函数返回一个已经是接受状态的Promise，那么then返回的Promise也会成为接受状态，并且将那个Promise的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</li>\n</ul>\n</blockquote>\n<p>根据官方文档，then()方法返回的也是一个promise，并且这个promise的状态，resolve函数的参数和then()方法中的回调函数的返回值有关。</p>\n</li>\n<li><p>return res.data就是文档中所说的<code>如果then中的回调函数返回一个值</code>这种情况，return Promise.resolve(res.data)就是文档中所说的<code>如果then中的回调函数返回一个已经是接受状态的Promise</code>这种情况。</p>\n<p>因为Promise.resolve(res.data)返回的就是一个已经是接受状态的Promise</p>\n<blockquote>\n<p><code>Promise.resolve(value)</code>方法返回一个以给定值解析后的Promise对象。但如果这个值是个thenable（即带有then方法），返回的promise会“跟随”这个thenable的对象，采用它的最终状态（指resolved/rejected/pending/settled）；否则以该值为成功状态返回promise对象。</p>\n</blockquote>\n</li>\n<li><p>既然两个return方式最终都是使then()返回接受状态的Promise，并且这个Promise的接受状态回调函数的参数都是res.data，那为何一定要采用return Promise.resolve(res.data)这种方式呢？</p>\n</li>\n</ol>\n<h1 id=\"答案\"><a href=\"#答案\" class=\"headerlink\" title=\"答案\"></a>答案</h1><p><code>.then((res) =&gt; &#123;return res.data&#125;)</code>和<code>.then((res) =&gt; &#123;return Promise.resolve(res.data)&#125;)</code>返回的都是一个接受状态的promise<code>new Promise((resolve) =&gt; &#123;resolve(res.data)&#125;)</code>，那我猜测作者之所以那么写，可能是他觉得这样看起来更严谨。</p>\n"},{"title":"【数据分析】Excel基础知识","date":"2021-04-28T09:55:35.000Z","description":"Excel基础操作、数据透视表、图标","_content":"\n# 单元格的引用\n\n```\n//相对引用\nA1\n//绝对引用\n$A$1\n//混合引用\n$A1//绝对列引用\nA$1//绝对行引用\n```\n当引用的单元格行和列需要变化时，使用相对引用\n当引用的单元格行和列不需要变化时，使用绝对引用\n当引用的单元格行或列的某一个需要变化时，使用混合引用\n\n练习：制作一个9x9乘法表\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-36-59.jpg)\n\n1. 先写一个公式\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-39-20.jpg)\n\n   这时如果直接填充复制的话，会发现是错误的。每一个单元格所引用的单元格位置都相对最开始做了平移。\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-42-02.jpg)\n\n   这是因为写公式时用的是相对引用，当把公式复制到其他单元格时，公式里所引用的单元格位置按照现在的位置和最开始的位置平行移动。如果不想移动，就需要用绝对引用锁定引用的位置。\n\n2. 使用绝对引用\n\n   通过观察发现，两两相乘的时候，第一个乘数都在F列里，第二个乘数都在26行里，这两个位置是固定不变的。只要该位置需要固定不变，我们就给他加锁。\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-52-22.jpg)\n\n   拖动填充\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-53-46.jpg)\n\n   这样就正确了。乘数一的列和乘数二的行都固定，但乘数一的行和乘数二的列都随着公式的位置而变动。\n\n3. 优化一下\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-56-42.jpg)\n\n# 数据透视表\n\n数据透视表要求：\n\n- 不能有空字段（空的列名）。\n- 不要有相同的字段名（虽然会自动给相同的列加编号）。\n- 字段名不能有合并单元格（表头不能有合并单元格）。\n\n","source":"_posts/【数据分析】Excel基础知识.md","raw":"---\ntitle: 【数据分析】Excel基础知识\ndate: 2021-04-28 17:55:35\ntags:\n- 数据分析\ncategories:\n- 学习笔记\ndescription: Excel基础操作、数据透视表、图标\n---\n\n# 单元格的引用\n\n```\n//相对引用\nA1\n//绝对引用\n$A$1\n//混合引用\n$A1//绝对列引用\nA$1//绝对行引用\n```\n当引用的单元格行和列需要变化时，使用相对引用\n当引用的单元格行和列不需要变化时，使用绝对引用\n当引用的单元格行或列的某一个需要变化时，使用混合引用\n\n练习：制作一个9x9乘法表\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-36-59.jpg)\n\n1. 先写一个公式\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-39-20.jpg)\n\n   这时如果直接填充复制的话，会发现是错误的。每一个单元格所引用的单元格位置都相对最开始做了平移。\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-42-02.jpg)\n\n   这是因为写公式时用的是相对引用，当把公式复制到其他单元格时，公式里所引用的单元格位置按照现在的位置和最开始的位置平行移动。如果不想移动，就需要用绝对引用锁定引用的位置。\n\n2. 使用绝对引用\n\n   通过观察发现，两两相乘的时候，第一个乘数都在F列里，第二个乘数都在26行里，这两个位置是固定不变的。只要该位置需要固定不变，我们就给他加锁。\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-52-22.jpg)\n\n   拖动填充\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-53-46.jpg)\n\n   这样就正确了。乘数一的列和乘数二的行都固定，但乘数一的行和乘数二的列都随着公式的位置而变动。\n\n3. 优化一下\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-56-42.jpg)\n\n# 数据透视表\n\n数据透视表要求：\n\n- 不能有空字段（空的列名）。\n- 不要有相同的字段名（虽然会自动给相同的列加编号）。\n- 字段名不能有合并单元格（表头不能有合并单元格）。\n\n","slug":"【数据分析】Excel基础知识","published":1,"updated":"2021-05-08T15:02:49.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbot0011wct4a1eph1zw","content":"<h1 id=\"单元格的引用\"><a href=\"#单元格的引用\" class=\"headerlink\" title=\"单元格的引用\"></a>单元格的引用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;相对引用</span><br><span class=\"line\">A1</span><br><span class=\"line\">&#x2F;&#x2F;绝对引用</span><br><span class=\"line\">$A$1</span><br><span class=\"line\">&#x2F;&#x2F;混合引用</span><br><span class=\"line\">$A1&#x2F;&#x2F;绝对列引用</span><br><span class=\"line\">A$1&#x2F;&#x2F;绝对行引用</span><br></pre></td></tr></table></figure>\n<p>当引用的单元格行和列需要变化时，使用相对引用<br>当引用的单元格行和列不需要变化时，使用绝对引用<br>当引用的单元格行或列的某一个需要变化时，使用混合引用</p>\n<p>练习：制作一个9x9乘法表</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-36-59.jpg\"></p>\n<ol>\n<li><p>先写一个公式</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-39-20.jpg\"></p>\n<p>这时如果直接填充复制的话，会发现是错误的。每一个单元格所引用的单元格位置都相对最开始做了平移。</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-42-02.jpg\"></p>\n<p>这是因为写公式时用的是相对引用，当把公式复制到其他单元格时，公式里所引用的单元格位置按照现在的位置和最开始的位置平行移动。如果不想移动，就需要用绝对引用锁定引用的位置。</p>\n</li>\n<li><p>使用绝对引用</p>\n<p>通过观察发现，两两相乘的时候，第一个乘数都在F列里，第二个乘数都在26行里，这两个位置是固定不变的。只要该位置需要固定不变，我们就给他加锁。</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-52-22.jpg\"></p>\n<p>拖动填充</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-53-46.jpg\"></p>\n<p>这样就正确了。乘数一的列和乘数二的行都固定，但乘数一的行和乘数二的列都随着公式的位置而变动。</p>\n</li>\n<li><p>优化一下</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-56-42.jpg\"></p>\n</li>\n</ol>\n<h1 id=\"数据透视表\"><a href=\"#数据透视表\" class=\"headerlink\" title=\"数据透视表\"></a>数据透视表</h1><p>数据透视表要求：</p>\n<ul>\n<li>不能有空字段（空的列名）。</li>\n<li>不要有相同的字段名（虽然会自动给相同的列加编号）。</li>\n<li>字段名不能有合并单元格（表头不能有合并单元格）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"单元格的引用\"><a href=\"#单元格的引用\" class=\"headerlink\" title=\"单元格的引用\"></a>单元格的引用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;相对引用</span><br><span class=\"line\">A1</span><br><span class=\"line\">&#x2F;&#x2F;绝对引用</span><br><span class=\"line\">$A$1</span><br><span class=\"line\">&#x2F;&#x2F;混合引用</span><br><span class=\"line\">$A1&#x2F;&#x2F;绝对列引用</span><br><span class=\"line\">A$1&#x2F;&#x2F;绝对行引用</span><br></pre></td></tr></table></figure>\n<p>当引用的单元格行和列需要变化时，使用相对引用<br>当引用的单元格行和列不需要变化时，使用绝对引用<br>当引用的单元格行或列的某一个需要变化时，使用混合引用</p>\n<p>练习：制作一个9x9乘法表</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-36-59.jpg\"></p>\n<ol>\n<li><p>先写一个公式</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-39-20.jpg\"></p>\n<p>这时如果直接填充复制的话，会发现是错误的。每一个单元格所引用的单元格位置都相对最开始做了平移。</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-42-02.jpg\"></p>\n<p>这是因为写公式时用的是相对引用，当把公式复制到其他单元格时，公式里所引用的单元格位置按照现在的位置和最开始的位置平行移动。如果不想移动，就需要用绝对引用锁定引用的位置。</p>\n</li>\n<li><p>使用绝对引用</p>\n<p>通过观察发现，两两相乘的时候，第一个乘数都在F列里，第二个乘数都在26行里，这两个位置是固定不变的。只要该位置需要固定不变，我们就给他加锁。</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-52-22.jpg\"></p>\n<p>拖动填充</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-53-46.jpg\"></p>\n<p>这样就正确了。乘数一的列和乘数二的行都固定，但乘数一的行和乘数二的列都随着公式的位置而变动。</p>\n</li>\n<li><p>优化一下</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-08_20-56-42.jpg\"></p>\n</li>\n</ol>\n<h1 id=\"数据透视表\"><a href=\"#数据透视表\" class=\"headerlink\" title=\"数据透视表\"></a>数据透视表</h1><p>数据透视表要求：</p>\n<ul>\n<li>不能有空字段（空的列名）。</li>\n<li>不要有相同的字段名（虽然会自动给相同的列加编号）。</li>\n<li>字段名不能有合并单元格（表头不能有合并单元格）。</li>\n</ul>\n"},{"title":"【数据分析】第一阶段：数据分析思维与业务流程","date":"2021-04-29T09:12:01.000Z","description":"数据分析学习笔记","_content":"\n# 概述\n\n数据分析能做什么\n\n+ 预测未来\n+ 优化现状\n+ 总结规律\n\n数据分析的基本流程\n\n+ 确定：了解和确定业务出现什么问题（明确问题）\n+ 分解：分解问题和数据为可管理、可量化的指标数据（拆解问题，量化指标）\n+ 评估：对前两部了解到的情况作出各种结论（目标评估，实验，分析实验效果）\n+ 决策：把结论重新组合在一起，作出一个结论或决策（结案报告）\n\n数据分析技能树：统计学，SQL，python，excel，Hive，BI，可视化。\n\n3年本职工作，5年考虑团队，8年考虑公司，10年考虑行业。\n\n# 一些术语\n\nSKU：物理上不可分割的最小存货单元。比如某水果店只卖苹果、香蕉、葡萄，那它的SKU就是3。某淘宝服装店只卖一种衣服，该衣服只有L号，但是有红、黑两个颜色，那这家淘宝服装店的SKU是2（L号黑色、L号红色）而不是1。\n\n净利润：精细计算得出的利润。\n\n毛利润：粗略计算得出的利润。\n\n同比：与历史同期比较。比如今天和上周的今天比较。\n\n环比：与前一个相邻的时期作比较。比如今天和昨天比较。\n\n方法论：解决方案，套路。\n\n流量：指在一定时间内打开网站地址的人气访问量。流浪不可跟踪。\n\n线索：留下个人信息、联系方式的访客。线索可跟踪。\n\n私域流量\n\n落地\n\nKOL：关键意见领袖（Key Opinion Leader,简称KOL）\n\nROI：投资回报率（利润/投入）\n\nRFM模型：3项指标来描述该客户的价值状况。\n\n+ 最近一次消费 (Recency)\n\n+ 消费频率 (Frequency)\n\n+ 消费金额 (Monetary)\n\n\n\n# 案例一 某线下连锁水果店销售数据分析\n\n+ 明确问题\n\n  今年1、2季度利润同比下跌，按照1、2季度销售利润来看，今年总体利润相比去年是下降的，老板希望今年利润能比去年增长5%。\n\n  通过历史销售数据和今年1、2季度销售数据可计算出，按目前1、2季度情况预计今年利润为7600万。今年目标是比去年利润7800万增长5%，即今年利润目标为8200万，也就是说剩下的3、4季度要多完成8200-7600=600万的利润。\n\n  > 现在的问题就是今年利润下跌，老板希望能把利润搞上去。\n  >\n  > 那么我是否想过通过数据估算出还需要完成多少万的业绩能达到老板的目标？\n  >\n  > 是否考虑过结合行业的特性和历史数据，来分配每个季度需要完成的目标？\n\n+ 拆解问题\n\n  如果要实现目标，通过现有销售数据可计算出，3、4季度需要增加600w利润。再通过历史数据中每年3、4季度利润的占比情况，把问题拆分为今年3季度增加400w利润，4季度要增加200w利润。\n\n  利润=收入-成本，所以提高利润完成目标就可以从两方面入手——增加收入，降低成本。\n\n  增加收入：\n\n  1. 提升高利润水果的销量。\n\n  降低成本：\n\n  1. 提升未盈利门店的利润。\n  2. 对依然无法提升利润的未盈利门店，选择关停来降低成本。\n\n  眼下先实现3季度任务。\n\n  现在的问题就比较明朗：目标——3季度增加400w利润，方法——提升高利润水果销量、提高未盈利门店利润。\n\n  > 增加收入我一般只能想到增加销量，我是否想到过把高利润的水果作为突破口？什么样的水果算高利润水果？\n  >\n  > 是否考虑过门店业绩有好有坏？是否想到提升未盈利门店的利润也是一种变相的降低成本？\n\n+ 量化指标\n\n  将3季度增加400w利润继续细分：\n\n  1. 通过数据计算出目前1/4门店不盈利，3/4盈利（粗略计算出一家门店每日成本大约4000元，日毛利低于4000就是不盈利门店）。\n\n     因此将增加400w利润目标按照比例分配给这两种门店——3季度未盈利门店增加400万x1/4=100w利润，全部门店增加400万x3/4=300w利润（利用高利润水果）。\n\n  2. 再次将目标拆解到每一个门店——3季度未盈利门店单店日均毛利额增加100万/90天/23家门店=500元，全部门店单店日均毛利额增加300万/90天/92家门店=360元。\n\n  > 是否想到将400w任务按照门店盈利情况分配？\n  >\n  > 计算门店每日成本时，是否考虑到各个方面？\n  >\n  > 按照门店盈利与否的比例分配400w利润任务时，300w应该是盈利门店还是全部门店承担？\n\n+ 制定方案\n\n  1. 分组分析：以日均毛利额4000元为标准把所有店铺分成两个组——不盈利、盈利，通过数据找出不盈利的店铺和盈利店铺。\n  2. 对比分析：通过销量这一个维度，对比找出销量好的水果。\n  3. 矩阵分析：在销量高的水果中，关联利润这个维度，找出销量高、利润高的水果，以及销量低、利润低的水果。\n  4. 趋势分析：用趋势分析预测上一步找到的两种水果的未来销量走势。\n\n  通过以上分析制定方案：对未盈利店铺进行营销推广，提升毛利；对盈利店铺增加高销量高利润水果供货量，减少低利润低销量水果供货量，提升毛利。\n\n+ 实验评估\n\n  在两组类型门店中，分别随机选取几家，按照制定方案进行阶段实验。\n\n  实验结束后，比较方案前和方案后的销售数据，计算这几家店铺日均毛利额是否增长，增长额度是否达到目标。\n\n  根据效果来看是否需要重新调整方案或是进行下一步结案报告，并推广到全部门店。\n\n  >完全平方和/差：(a±b)²=a²±2ab+b²\n  >\n  >完全立方和/差：(a±b)³=a³±3a²b+3ab²±b³。\n\n+ 结案报告\n\n# 案例二 某在线教育机构经营分析\n\n- 思路\n\n  ![流程图](https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_1.jpg)\n\n- 明确问题\n\n  某在线教育机构需要在今年剩下的9至12月完成320万左右的毛利润目标。\n\n  由于9/10月是换工作旺季，考虑这段时间培训需求更高，因此9/10月承担任务的70%，也就是224万，平均到一个月112万毛利润任务。\n\n  而近期公司发现，8月份课程销量在上升，毛利额却在下降。\n\n  因此明确出两个需要解决的问题：1. 找出8月份销量上升毛利润下降的原因。2. 9-12月完成224万毛利润。\n\n  > 问题可能是一个，也可能像本案例是多个。\n  >\n  > 多个问题需要考虑优先级，哪个问题是需要先解决的。\n\n- 拆解问题\n\n  通过逻辑树拆解法，将两个大问题拆解为若干小问题。\n\n  问题一逻辑树拆解\n\n  ![逻辑树1](https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_2.jpg)\n\n  拆解出四个子问题。\n\n  首先分析数据源是否有问题，8月是否存在销量上升毛利下降的情况。\n\n  在确认数据源没问题之后，我们认为渠道问题是主要原因。假设渠道中存在一些销量高但是毛利很低的渠道是造成问题一的主要原因，通过矩阵分析找出销量高、毛利低的渠道。\n\n  问题二逻辑树拆解\n\n  ![逻辑树2](https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_3.jpg)\n\n  拆解出三个子问题。\n\n  我们认为最应该去实现的是提升销量。\n\n  提升销量中优先考虑的是营销优化。\n\n  其中核心是增加优质渠道投放，通过综合排名分析找到转化高、成本低、流量大的优质渠道增加投放。\n\n  其次是精细化运用，通过RFM模型对用户进行分类，实现用户精准运营，提高转化。\n\n  然后考虑产品优化，通过漏斗分析，找到需要提升转化率的环节，优化该环节，提升转化率。\n\n  > 利润 = 总收入-总成本 = 销量\\*单价-销量\\*单品成本 = 销量\\*(单价-单品成本)\n  >\n  > 销量上升、利润却在下降，那么(单价-单品成本)就一定是大幅减少的。\n  >\n  > 因此找到两个方向，单价大幅减低，或者单品成本大幅升高。\n  >\n  > 除了产品本身的成本之外，作为互联网公司营销成本是最主要的，比如渠道成本，广告成本等。\n  >\n  > 一个公司可能有多个产品，每个产品的定位都是不同的。一些低端产品可能单价低，单品成本也低。一些高端产品就可能单价高，单品成本越高。所以按照统一的单价和单品成本来计算是不对的。\n\n  # 拆解问题\n  \n  拆解问题：\n  \n  1. 按照指标的组成来拆解\n  2. 通过业务流程来拆解\n  \n  拆解后的问题，需要重点分析哪一个，是根据需求背景、业务背景来判断的。\n  \n  搭建指标\n  \n  指标背后一定是有业务意义的，指标不能是空的。\n  \n  拆解问题是数据分析的核心能力。\n  \n  费米问题。\n  \n  \n  \n  \n\n\n\n\n\n","source":"_posts/【数据分析】第一阶段：数据分析思维与业务流程.md","raw":"---\ntitle: 【数据分析】第一阶段：数据分析思维与业务流程\ndate: 2021-04-29 17:12:01\ntags:\n- 数据分析\ncategories:\n- 学习笔记\ndescription: 数据分析学习笔记\n---\n\n# 概述\n\n数据分析能做什么\n\n+ 预测未来\n+ 优化现状\n+ 总结规律\n\n数据分析的基本流程\n\n+ 确定：了解和确定业务出现什么问题（明确问题）\n+ 分解：分解问题和数据为可管理、可量化的指标数据（拆解问题，量化指标）\n+ 评估：对前两部了解到的情况作出各种结论（目标评估，实验，分析实验效果）\n+ 决策：把结论重新组合在一起，作出一个结论或决策（结案报告）\n\n数据分析技能树：统计学，SQL，python，excel，Hive，BI，可视化。\n\n3年本职工作，5年考虑团队，8年考虑公司，10年考虑行业。\n\n# 一些术语\n\nSKU：物理上不可分割的最小存货单元。比如某水果店只卖苹果、香蕉、葡萄，那它的SKU就是3。某淘宝服装店只卖一种衣服，该衣服只有L号，但是有红、黑两个颜色，那这家淘宝服装店的SKU是2（L号黑色、L号红色）而不是1。\n\n净利润：精细计算得出的利润。\n\n毛利润：粗略计算得出的利润。\n\n同比：与历史同期比较。比如今天和上周的今天比较。\n\n环比：与前一个相邻的时期作比较。比如今天和昨天比较。\n\n方法论：解决方案，套路。\n\n流量：指在一定时间内打开网站地址的人气访问量。流浪不可跟踪。\n\n线索：留下个人信息、联系方式的访客。线索可跟踪。\n\n私域流量\n\n落地\n\nKOL：关键意见领袖（Key Opinion Leader,简称KOL）\n\nROI：投资回报率（利润/投入）\n\nRFM模型：3项指标来描述该客户的价值状况。\n\n+ 最近一次消费 (Recency)\n\n+ 消费频率 (Frequency)\n\n+ 消费金额 (Monetary)\n\n\n\n# 案例一 某线下连锁水果店销售数据分析\n\n+ 明确问题\n\n  今年1、2季度利润同比下跌，按照1、2季度销售利润来看，今年总体利润相比去年是下降的，老板希望今年利润能比去年增长5%。\n\n  通过历史销售数据和今年1、2季度销售数据可计算出，按目前1、2季度情况预计今年利润为7600万。今年目标是比去年利润7800万增长5%，即今年利润目标为8200万，也就是说剩下的3、4季度要多完成8200-7600=600万的利润。\n\n  > 现在的问题就是今年利润下跌，老板希望能把利润搞上去。\n  >\n  > 那么我是否想过通过数据估算出还需要完成多少万的业绩能达到老板的目标？\n  >\n  > 是否考虑过结合行业的特性和历史数据，来分配每个季度需要完成的目标？\n\n+ 拆解问题\n\n  如果要实现目标，通过现有销售数据可计算出，3、4季度需要增加600w利润。再通过历史数据中每年3、4季度利润的占比情况，把问题拆分为今年3季度增加400w利润，4季度要增加200w利润。\n\n  利润=收入-成本，所以提高利润完成目标就可以从两方面入手——增加收入，降低成本。\n\n  增加收入：\n\n  1. 提升高利润水果的销量。\n\n  降低成本：\n\n  1. 提升未盈利门店的利润。\n  2. 对依然无法提升利润的未盈利门店，选择关停来降低成本。\n\n  眼下先实现3季度任务。\n\n  现在的问题就比较明朗：目标——3季度增加400w利润，方法——提升高利润水果销量、提高未盈利门店利润。\n\n  > 增加收入我一般只能想到增加销量，我是否想到过把高利润的水果作为突破口？什么样的水果算高利润水果？\n  >\n  > 是否考虑过门店业绩有好有坏？是否想到提升未盈利门店的利润也是一种变相的降低成本？\n\n+ 量化指标\n\n  将3季度增加400w利润继续细分：\n\n  1. 通过数据计算出目前1/4门店不盈利，3/4盈利（粗略计算出一家门店每日成本大约4000元，日毛利低于4000就是不盈利门店）。\n\n     因此将增加400w利润目标按照比例分配给这两种门店——3季度未盈利门店增加400万x1/4=100w利润，全部门店增加400万x3/4=300w利润（利用高利润水果）。\n\n  2. 再次将目标拆解到每一个门店——3季度未盈利门店单店日均毛利额增加100万/90天/23家门店=500元，全部门店单店日均毛利额增加300万/90天/92家门店=360元。\n\n  > 是否想到将400w任务按照门店盈利情况分配？\n  >\n  > 计算门店每日成本时，是否考虑到各个方面？\n  >\n  > 按照门店盈利与否的比例分配400w利润任务时，300w应该是盈利门店还是全部门店承担？\n\n+ 制定方案\n\n  1. 分组分析：以日均毛利额4000元为标准把所有店铺分成两个组——不盈利、盈利，通过数据找出不盈利的店铺和盈利店铺。\n  2. 对比分析：通过销量这一个维度，对比找出销量好的水果。\n  3. 矩阵分析：在销量高的水果中，关联利润这个维度，找出销量高、利润高的水果，以及销量低、利润低的水果。\n  4. 趋势分析：用趋势分析预测上一步找到的两种水果的未来销量走势。\n\n  通过以上分析制定方案：对未盈利店铺进行营销推广，提升毛利；对盈利店铺增加高销量高利润水果供货量，减少低利润低销量水果供货量，提升毛利。\n\n+ 实验评估\n\n  在两组类型门店中，分别随机选取几家，按照制定方案进行阶段实验。\n\n  实验结束后，比较方案前和方案后的销售数据，计算这几家店铺日均毛利额是否增长，增长额度是否达到目标。\n\n  根据效果来看是否需要重新调整方案或是进行下一步结案报告，并推广到全部门店。\n\n  >完全平方和/差：(a±b)²=a²±2ab+b²\n  >\n  >完全立方和/差：(a±b)³=a³±3a²b+3ab²±b³。\n\n+ 结案报告\n\n# 案例二 某在线教育机构经营分析\n\n- 思路\n\n  ![流程图](https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_1.jpg)\n\n- 明确问题\n\n  某在线教育机构需要在今年剩下的9至12月完成320万左右的毛利润目标。\n\n  由于9/10月是换工作旺季，考虑这段时间培训需求更高，因此9/10月承担任务的70%，也就是224万，平均到一个月112万毛利润任务。\n\n  而近期公司发现，8月份课程销量在上升，毛利额却在下降。\n\n  因此明确出两个需要解决的问题：1. 找出8月份销量上升毛利润下降的原因。2. 9-12月完成224万毛利润。\n\n  > 问题可能是一个，也可能像本案例是多个。\n  >\n  > 多个问题需要考虑优先级，哪个问题是需要先解决的。\n\n- 拆解问题\n\n  通过逻辑树拆解法，将两个大问题拆解为若干小问题。\n\n  问题一逻辑树拆解\n\n  ![逻辑树1](https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_2.jpg)\n\n  拆解出四个子问题。\n\n  首先分析数据源是否有问题，8月是否存在销量上升毛利下降的情况。\n\n  在确认数据源没问题之后，我们认为渠道问题是主要原因。假设渠道中存在一些销量高但是毛利很低的渠道是造成问题一的主要原因，通过矩阵分析找出销量高、毛利低的渠道。\n\n  问题二逻辑树拆解\n\n  ![逻辑树2](https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_3.jpg)\n\n  拆解出三个子问题。\n\n  我们认为最应该去实现的是提升销量。\n\n  提升销量中优先考虑的是营销优化。\n\n  其中核心是增加优质渠道投放，通过综合排名分析找到转化高、成本低、流量大的优质渠道增加投放。\n\n  其次是精细化运用，通过RFM模型对用户进行分类，实现用户精准运营，提高转化。\n\n  然后考虑产品优化，通过漏斗分析，找到需要提升转化率的环节，优化该环节，提升转化率。\n\n  > 利润 = 总收入-总成本 = 销量\\*单价-销量\\*单品成本 = 销量\\*(单价-单品成本)\n  >\n  > 销量上升、利润却在下降，那么(单价-单品成本)就一定是大幅减少的。\n  >\n  > 因此找到两个方向，单价大幅减低，或者单品成本大幅升高。\n  >\n  > 除了产品本身的成本之外，作为互联网公司营销成本是最主要的，比如渠道成本，广告成本等。\n  >\n  > 一个公司可能有多个产品，每个产品的定位都是不同的。一些低端产品可能单价低，单品成本也低。一些高端产品就可能单价高，单品成本越高。所以按照统一的单价和单品成本来计算是不对的。\n\n  # 拆解问题\n  \n  拆解问题：\n  \n  1. 按照指标的组成来拆解\n  2. 通过业务流程来拆解\n  \n  拆解后的问题，需要重点分析哪一个，是根据需求背景、业务背景来判断的。\n  \n  搭建指标\n  \n  指标背后一定是有业务意义的，指标不能是空的。\n  \n  拆解问题是数据分析的核心能力。\n  \n  费米问题。\n  \n  \n  \n  \n\n\n\n\n\n","slug":"【数据分析】第一阶段：数据分析思维与业务流程","published":1,"updated":"2021-05-11T09:46:03.537Z","_id":"ckohezbou0014wct47z5chj0v","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>数据分析能做什么</p>\n<ul>\n<li>预测未来</li>\n<li>优化现状</li>\n<li>总结规律</li>\n</ul>\n<p>数据分析的基本流程</p>\n<ul>\n<li>确定：了解和确定业务出现什么问题（明确问题）</li>\n<li>分解：分解问题和数据为可管理、可量化的指标数据（拆解问题，量化指标）</li>\n<li>评估：对前两部了解到的情况作出各种结论（目标评估，实验，分析实验效果）</li>\n<li>决策：把结论重新组合在一起，作出一个结论或决策（结案报告）</li>\n</ul>\n<p>数据分析技能树：统计学，SQL，python，excel，Hive，BI，可视化。</p>\n<p>3年本职工作，5年考虑团队，8年考虑公司，10年考虑行业。</p>\n<h1 id=\"一些术语\"><a href=\"#一些术语\" class=\"headerlink\" title=\"一些术语\"></a>一些术语</h1><p>SKU：物理上不可分割的最小存货单元。比如某水果店只卖苹果、香蕉、葡萄，那它的SKU就是3。某淘宝服装店只卖一种衣服，该衣服只有L号，但是有红、黑两个颜色，那这家淘宝服装店的SKU是2（L号黑色、L号红色）而不是1。</p>\n<p>净利润：精细计算得出的利润。</p>\n<p>毛利润：粗略计算得出的利润。</p>\n<p>同比：与历史同期比较。比如今天和上周的今天比较。</p>\n<p>环比：与前一个相邻的时期作比较。比如今天和昨天比较。</p>\n<p>方法论：解决方案，套路。</p>\n<p>流量：指在一定时间内打开网站地址的人气访问量。流浪不可跟踪。</p>\n<p>线索：留下个人信息、联系方式的访客。线索可跟踪。</p>\n<p>私域流量</p>\n<p>落地</p>\n<p>KOL：关键意见领袖（Key Opinion Leader,简称KOL）</p>\n<p>ROI：投资回报率（利润/投入）</p>\n<p>RFM模型：3项指标来描述该客户的价值状况。</p>\n<ul>\n<li><p>最近一次消费 (Recency)</p>\n</li>\n<li><p>消费频率 (Frequency)</p>\n</li>\n<li><p>消费金额 (Monetary)</p>\n</li>\n</ul>\n<h1 id=\"案例一-某线下连锁水果店销售数据分析\"><a href=\"#案例一-某线下连锁水果店销售数据分析\" class=\"headerlink\" title=\"案例一 某线下连锁水果店销售数据分析\"></a>案例一 某线下连锁水果店销售数据分析</h1><ul>\n<li><p>明确问题</p>\n<p>今年1、2季度利润同比下跌，按照1、2季度销售利润来看，今年总体利润相比去年是下降的，老板希望今年利润能比去年增长5%。</p>\n<p>通过历史销售数据和今年1、2季度销售数据可计算出，按目前1、2季度情况预计今年利润为7600万。今年目标是比去年利润7800万增长5%，即今年利润目标为8200万，也就是说剩下的3、4季度要多完成8200-7600=600万的利润。</p>\n<blockquote>\n<p>现在的问题就是今年利润下跌，老板希望能把利润搞上去。</p>\n<p>那么我是否想过通过数据估算出还需要完成多少万的业绩能达到老板的目标？</p>\n<p>是否考虑过结合行业的特性和历史数据，来分配每个季度需要完成的目标？</p>\n</blockquote>\n</li>\n<li><p>拆解问题</p>\n<p>如果要实现目标，通过现有销售数据可计算出，3、4季度需要增加600w利润。再通过历史数据中每年3、4季度利润的占比情况，把问题拆分为今年3季度增加400w利润，4季度要增加200w利润。</p>\n<p>利润=收入-成本，所以提高利润完成目标就可以从两方面入手——增加收入，降低成本。</p>\n<p>增加收入：</p>\n<ol>\n<li>提升高利润水果的销量。</li>\n</ol>\n<p>降低成本：</p>\n<ol>\n<li>提升未盈利门店的利润。</li>\n<li>对依然无法提升利润的未盈利门店，选择关停来降低成本。</li>\n</ol>\n<p>眼下先实现3季度任务。</p>\n<p>现在的问题就比较明朗：目标——3季度增加400w利润，方法——提升高利润水果销量、提高未盈利门店利润。</p>\n<blockquote>\n<p>增加收入我一般只能想到增加销量，我是否想到过把高利润的水果作为突破口？什么样的水果算高利润水果？</p>\n<p>是否考虑过门店业绩有好有坏？是否想到提升未盈利门店的利润也是一种变相的降低成本？</p>\n</blockquote>\n</li>\n<li><p>量化指标</p>\n<p>将3季度增加400w利润继续细分：</p>\n<ol>\n<li><p>通过数据计算出目前1/4门店不盈利，3/4盈利（粗略计算出一家门店每日成本大约4000元，日毛利低于4000就是不盈利门店）。</p>\n<p>因此将增加400w利润目标按照比例分配给这两种门店——3季度未盈利门店增加400万x1/4=100w利润，全部门店增加400万x3/4=300w利润（利用高利润水果）。</p>\n</li>\n<li><p>再次将目标拆解到每一个门店——3季度未盈利门店单店日均毛利额增加100万/90天/23家门店=500元，全部门店单店日均毛利额增加300万/90天/92家门店=360元。</p>\n</li>\n</ol>\n<blockquote>\n<p>是否想到将400w任务按照门店盈利情况分配？</p>\n<p>计算门店每日成本时，是否考虑到各个方面？</p>\n<p>按照门店盈利与否的比例分配400w利润任务时，300w应该是盈利门店还是全部门店承担？</p>\n</blockquote>\n</li>\n<li><p>制定方案</p>\n<ol>\n<li>分组分析：以日均毛利额4000元为标准把所有店铺分成两个组——不盈利、盈利，通过数据找出不盈利的店铺和盈利店铺。</li>\n<li>对比分析：通过销量这一个维度，对比找出销量好的水果。</li>\n<li>矩阵分析：在销量高的水果中，关联利润这个维度，找出销量高、利润高的水果，以及销量低、利润低的水果。</li>\n<li>趋势分析：用趋势分析预测上一步找到的两种水果的未来销量走势。</li>\n</ol>\n<p>通过以上分析制定方案：对未盈利店铺进行营销推广，提升毛利；对盈利店铺增加高销量高利润水果供货量，减少低利润低销量水果供货量，提升毛利。</p>\n</li>\n<li><p>实验评估</p>\n<p>在两组类型门店中，分别随机选取几家，按照制定方案进行阶段实验。</p>\n<p>实验结束后，比较方案前和方案后的销售数据，计算这几家店铺日均毛利额是否增长，增长额度是否达到目标。</p>\n<p>根据效果来看是否需要重新调整方案或是进行下一步结案报告，并推广到全部门店。</p>\n<blockquote>\n<p>完全平方和/差：(a±b)²=a²±2ab+b²</p>\n<p>完全立方和/差：(a±b)³=a³±3a²b+3ab²±b³。</p>\n</blockquote>\n</li>\n<li><p>结案报告</p>\n</li>\n</ul>\n<h1 id=\"案例二-某在线教育机构经营分析\"><a href=\"#案例二-某在线教育机构经营分析\" class=\"headerlink\" title=\"案例二 某在线教育机构经营分析\"></a>案例二 某在线教育机构经营分析</h1><ul>\n<li><p>思路</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_1.jpg\" alt=\"流程图\"></p>\n</li>\n<li><p>明确问题</p>\n<p>某在线教育机构需要在今年剩下的9至12月完成320万左右的毛利润目标。</p>\n<p>由于9/10月是换工作旺季，考虑这段时间培训需求更高，因此9/10月承担任务的70%，也就是224万，平均到一个月112万毛利润任务。</p>\n<p>而近期公司发现，8月份课程销量在上升，毛利额却在下降。</p>\n<p>因此明确出两个需要解决的问题：1. 找出8月份销量上升毛利润下降的原因。2. 9-12月完成224万毛利润。</p>\n<blockquote>\n<p>问题可能是一个，也可能像本案例是多个。</p>\n<p>多个问题需要考虑优先级，哪个问题是需要先解决的。</p>\n</blockquote>\n</li>\n<li><p>拆解问题</p>\n<p>通过逻辑树拆解法，将两个大问题拆解为若干小问题。</p>\n<p>问题一逻辑树拆解</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_2.jpg\" alt=\"逻辑树1\"></p>\n<p>拆解出四个子问题。</p>\n<p>首先分析数据源是否有问题，8月是否存在销量上升毛利下降的情况。</p>\n<p>在确认数据源没问题之后，我们认为渠道问题是主要原因。假设渠道中存在一些销量高但是毛利很低的渠道是造成问题一的主要原因，通过矩阵分析找出销量高、毛利低的渠道。</p>\n<p>问题二逻辑树拆解</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_3.jpg\" alt=\"逻辑树2\"></p>\n<p>拆解出三个子问题。</p>\n<p>我们认为最应该去实现的是提升销量。</p>\n<p>提升销量中优先考虑的是营销优化。</p>\n<p>其中核心是增加优质渠道投放，通过综合排名分析找到转化高、成本低、流量大的优质渠道增加投放。</p>\n<p>其次是精细化运用，通过RFM模型对用户进行分类，实现用户精准运营，提高转化。</p>\n<p>然后考虑产品优化，通过漏斗分析，找到需要提升转化率的环节，优化该环节，提升转化率。</p>\n<blockquote>\n<p>利润 = 总收入-总成本 = 销量*单价-销量*单品成本 = 销量*(单价-单品成本)</p>\n<p>销量上升、利润却在下降，那么(单价-单品成本)就一定是大幅减少的。</p>\n<p>因此找到两个方向，单价大幅减低，或者单品成本大幅升高。</p>\n<p>除了产品本身的成本之外，作为互联网公司营销成本是最主要的，比如渠道成本，广告成本等。</p>\n<p>一个公司可能有多个产品，每个产品的定位都是不同的。一些低端产品可能单价低，单品成本也低。一些高端产品就可能单价高，单品成本越高。所以按照统一的单价和单品成本来计算是不对的。</p>\n</blockquote>\n<h1 id=\"拆解问题\"><a href=\"#拆解问题\" class=\"headerlink\" title=\"拆解问题\"></a>拆解问题</h1><p>拆解问题：</p>\n<ol>\n<li>按照指标的组成来拆解</li>\n<li>通过业务流程来拆解</li>\n</ol>\n<p>拆解后的问题，需要重点分析哪一个，是根据需求背景、业务背景来判断的。</p>\n<p>搭建指标</p>\n<p>指标背后一定是有业务意义的，指标不能是空的。</p>\n<p>拆解问题是数据分析的核心能力。</p>\n<p>费米问题。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>数据分析能做什么</p>\n<ul>\n<li>预测未来</li>\n<li>优化现状</li>\n<li>总结规律</li>\n</ul>\n<p>数据分析的基本流程</p>\n<ul>\n<li>确定：了解和确定业务出现什么问题（明确问题）</li>\n<li>分解：分解问题和数据为可管理、可量化的指标数据（拆解问题，量化指标）</li>\n<li>评估：对前两部了解到的情况作出各种结论（目标评估，实验，分析实验效果）</li>\n<li>决策：把结论重新组合在一起，作出一个结论或决策（结案报告）</li>\n</ul>\n<p>数据分析技能树：统计学，SQL，python，excel，Hive，BI，可视化。</p>\n<p>3年本职工作，5年考虑团队，8年考虑公司，10年考虑行业。</p>\n<h1 id=\"一些术语\"><a href=\"#一些术语\" class=\"headerlink\" title=\"一些术语\"></a>一些术语</h1><p>SKU：物理上不可分割的最小存货单元。比如某水果店只卖苹果、香蕉、葡萄，那它的SKU就是3。某淘宝服装店只卖一种衣服，该衣服只有L号，但是有红、黑两个颜色，那这家淘宝服装店的SKU是2（L号黑色、L号红色）而不是1。</p>\n<p>净利润：精细计算得出的利润。</p>\n<p>毛利润：粗略计算得出的利润。</p>\n<p>同比：与历史同期比较。比如今天和上周的今天比较。</p>\n<p>环比：与前一个相邻的时期作比较。比如今天和昨天比较。</p>\n<p>方法论：解决方案，套路。</p>\n<p>流量：指在一定时间内打开网站地址的人气访问量。流浪不可跟踪。</p>\n<p>线索：留下个人信息、联系方式的访客。线索可跟踪。</p>\n<p>私域流量</p>\n<p>落地</p>\n<p>KOL：关键意见领袖（Key Opinion Leader,简称KOL）</p>\n<p>ROI：投资回报率（利润/投入）</p>\n<p>RFM模型：3项指标来描述该客户的价值状况。</p>\n<ul>\n<li><p>最近一次消费 (Recency)</p>\n</li>\n<li><p>消费频率 (Frequency)</p>\n</li>\n<li><p>消费金额 (Monetary)</p>\n</li>\n</ul>\n<h1 id=\"案例一-某线下连锁水果店销售数据分析\"><a href=\"#案例一-某线下连锁水果店销售数据分析\" class=\"headerlink\" title=\"案例一 某线下连锁水果店销售数据分析\"></a>案例一 某线下连锁水果店销售数据分析</h1><ul>\n<li><p>明确问题</p>\n<p>今年1、2季度利润同比下跌，按照1、2季度销售利润来看，今年总体利润相比去年是下降的，老板希望今年利润能比去年增长5%。</p>\n<p>通过历史销售数据和今年1、2季度销售数据可计算出，按目前1、2季度情况预计今年利润为7600万。今年目标是比去年利润7800万增长5%，即今年利润目标为8200万，也就是说剩下的3、4季度要多完成8200-7600=600万的利润。</p>\n<blockquote>\n<p>现在的问题就是今年利润下跌，老板希望能把利润搞上去。</p>\n<p>那么我是否想过通过数据估算出还需要完成多少万的业绩能达到老板的目标？</p>\n<p>是否考虑过结合行业的特性和历史数据，来分配每个季度需要完成的目标？</p>\n</blockquote>\n</li>\n<li><p>拆解问题</p>\n<p>如果要实现目标，通过现有销售数据可计算出，3、4季度需要增加600w利润。再通过历史数据中每年3、4季度利润的占比情况，把问题拆分为今年3季度增加400w利润，4季度要增加200w利润。</p>\n<p>利润=收入-成本，所以提高利润完成目标就可以从两方面入手——增加收入，降低成本。</p>\n<p>增加收入：</p>\n<ol>\n<li>提升高利润水果的销量。</li>\n</ol>\n<p>降低成本：</p>\n<ol>\n<li>提升未盈利门店的利润。</li>\n<li>对依然无法提升利润的未盈利门店，选择关停来降低成本。</li>\n</ol>\n<p>眼下先实现3季度任务。</p>\n<p>现在的问题就比较明朗：目标——3季度增加400w利润，方法——提升高利润水果销量、提高未盈利门店利润。</p>\n<blockquote>\n<p>增加收入我一般只能想到增加销量，我是否想到过把高利润的水果作为突破口？什么样的水果算高利润水果？</p>\n<p>是否考虑过门店业绩有好有坏？是否想到提升未盈利门店的利润也是一种变相的降低成本？</p>\n</blockquote>\n</li>\n<li><p>量化指标</p>\n<p>将3季度增加400w利润继续细分：</p>\n<ol>\n<li><p>通过数据计算出目前1/4门店不盈利，3/4盈利（粗略计算出一家门店每日成本大约4000元，日毛利低于4000就是不盈利门店）。</p>\n<p>因此将增加400w利润目标按照比例分配给这两种门店——3季度未盈利门店增加400万x1/4=100w利润，全部门店增加400万x3/4=300w利润（利用高利润水果）。</p>\n</li>\n<li><p>再次将目标拆解到每一个门店——3季度未盈利门店单店日均毛利额增加100万/90天/23家门店=500元，全部门店单店日均毛利额增加300万/90天/92家门店=360元。</p>\n</li>\n</ol>\n<blockquote>\n<p>是否想到将400w任务按照门店盈利情况分配？</p>\n<p>计算门店每日成本时，是否考虑到各个方面？</p>\n<p>按照门店盈利与否的比例分配400w利润任务时，300w应该是盈利门店还是全部门店承担？</p>\n</blockquote>\n</li>\n<li><p>制定方案</p>\n<ol>\n<li>分组分析：以日均毛利额4000元为标准把所有店铺分成两个组——不盈利、盈利，通过数据找出不盈利的店铺和盈利店铺。</li>\n<li>对比分析：通过销量这一个维度，对比找出销量好的水果。</li>\n<li>矩阵分析：在销量高的水果中，关联利润这个维度，找出销量高、利润高的水果，以及销量低、利润低的水果。</li>\n<li>趋势分析：用趋势分析预测上一步找到的两种水果的未来销量走势。</li>\n</ol>\n<p>通过以上分析制定方案：对未盈利店铺进行营销推广，提升毛利；对盈利店铺增加高销量高利润水果供货量，减少低利润低销量水果供货量，提升毛利。</p>\n</li>\n<li><p>实验评估</p>\n<p>在两组类型门店中，分别随机选取几家，按照制定方案进行阶段实验。</p>\n<p>实验结束后，比较方案前和方案后的销售数据，计算这几家店铺日均毛利额是否增长，增长额度是否达到目标。</p>\n<p>根据效果来看是否需要重新调整方案或是进行下一步结案报告，并推广到全部门店。</p>\n<blockquote>\n<p>完全平方和/差：(a±b)²=a²±2ab+b²</p>\n<p>完全立方和/差：(a±b)³=a³±3a²b+3ab²±b³。</p>\n</blockquote>\n</li>\n<li><p>结案报告</p>\n</li>\n</ul>\n<h1 id=\"案例二-某在线教育机构经营分析\"><a href=\"#案例二-某在线教育机构经营分析\" class=\"headerlink\" title=\"案例二 某在线教育机构经营分析\"></a>案例二 某在线教育机构经营分析</h1><ul>\n<li><p>思路</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_1.jpg\" alt=\"流程图\"></p>\n</li>\n<li><p>明确问题</p>\n<p>某在线教育机构需要在今年剩下的9至12月完成320万左右的毛利润目标。</p>\n<p>由于9/10月是换工作旺季，考虑这段时间培训需求更高，因此9/10月承担任务的70%，也就是224万，平均到一个月112万毛利润任务。</p>\n<p>而近期公司发现，8月份课程销量在上升，毛利额却在下降。</p>\n<p>因此明确出两个需要解决的问题：1. 找出8月份销量上升毛利润下降的原因。2. 9-12月完成224万毛利润。</p>\n<blockquote>\n<p>问题可能是一个，也可能像本案例是多个。</p>\n<p>多个问题需要考虑优先级，哪个问题是需要先解决的。</p>\n</blockquote>\n</li>\n<li><p>拆解问题</p>\n<p>通过逻辑树拆解法，将两个大问题拆解为若干小问题。</p>\n<p>问题一逻辑树拆解</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_2.jpg\" alt=\"逻辑树1\"></p>\n<p>拆解出四个子问题。</p>\n<p>首先分析数据源是否有问题，8月是否存在销量上升毛利下降的情况。</p>\n<p>在确认数据源没问题之后，我们认为渠道问题是主要原因。假设渠道中存在一些销量高但是毛利很低的渠道是造成问题一的主要原因，通过矩阵分析找出销量高、毛利低的渠道。</p>\n<p>问题二逻辑树拆解</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/20210429171201_3.jpg\" alt=\"逻辑树2\"></p>\n<p>拆解出三个子问题。</p>\n<p>我们认为最应该去实现的是提升销量。</p>\n<p>提升销量中优先考虑的是营销优化。</p>\n<p>其中核心是增加优质渠道投放，通过综合排名分析找到转化高、成本低、流量大的优质渠道增加投放。</p>\n<p>其次是精细化运用，通过RFM模型对用户进行分类，实现用户精准运营，提高转化。</p>\n<p>然后考虑产品优化，通过漏斗分析，找到需要提升转化率的环节，优化该环节，提升转化率。</p>\n<blockquote>\n<p>利润 = 总收入-总成本 = 销量*单价-销量*单品成本 = 销量*(单价-单品成本)</p>\n<p>销量上升、利润却在下降，那么(单价-单品成本)就一定是大幅减少的。</p>\n<p>因此找到两个方向，单价大幅减低，或者单品成本大幅升高。</p>\n<p>除了产品本身的成本之外，作为互联网公司营销成本是最主要的，比如渠道成本，广告成本等。</p>\n<p>一个公司可能有多个产品，每个产品的定位都是不同的。一些低端产品可能单价低，单品成本也低。一些高端产品就可能单价高，单品成本越高。所以按照统一的单价和单品成本来计算是不对的。</p>\n</blockquote>\n<h1 id=\"拆解问题\"><a href=\"#拆解问题\" class=\"headerlink\" title=\"拆解问题\"></a>拆解问题</h1><p>拆解问题：</p>\n<ol>\n<li>按照指标的组成来拆解</li>\n<li>通过业务流程来拆解</li>\n</ol>\n<p>拆解后的问题，需要重点分析哪一个，是根据需求背景、业务背景来判断的。</p>\n<p>搭建指标</p>\n<p>指标背后一定是有业务意义的，指标不能是空的。</p>\n<p>拆解问题是数据分析的核心能力。</p>\n<p>费米问题。</p>\n</li>\n</ul>\n"},{"title":"数组去重","date":"2017-06-16T08:24:58.000Z","description":"数组去重的巧妙方法","_content":"> 数组去重的巧妙应用\n\n　　[JavaScript正则进阶之路——活学妙用奇淫正则表达式](https://github.com/jawil/blog/issues/20)","source":"_posts/检测数组重复元素.md","raw":"---\ntitle: 数组去重\ndate: 2017-06-16 16:24:58\ntags:\n- javaScript\ncategories:\n- 问题记录\ndescription: 数组去重的巧妙方法\n---\n> 数组去重的巧妙应用\n\n　　[JavaScript正则进阶之路——活学妙用奇淫正则表达式](https://github.com/jawil/blog/issues/20)","slug":"检测数组重复元素","published":1,"updated":"2021-05-08T15:02:38.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbow0017wct45v1k9lr0","content":"<blockquote>\n<p>数组去重的巧妙应用</p>\n</blockquote>\n<p>　　<a href=\"https://github.com/jawil/blog/issues/20\">JavaScript正则进阶之路——活学妙用奇淫正则表达式</a></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>数组去重的巧妙应用</p>\n</blockquote>\n<p>　　<a href=\"https://github.com/jawil/blog/issues/20\">JavaScript正则进阶之路——活学妙用奇淫正则表达式</a></p>\n"},{"title":"统计学笔记","date":"2021-05-07T14:57:31.000Z","description":"统计学笔记","_content":"\n# 1. 均值，中位数，众数\n\n均值\n\n- 就是平均数\n- 所有数字之和/数字的个数\n- 测量集中趋势\n\n中位数\n\n- 选取中间的数\n- 要找中位数，需要先从小到大排序\n- 偶数个数中间会有两个数，取其平均值，虽然平均值不在这些数字中，但这就是中位数\n- 测量集中趋势的另一种方式\n\n众数\n\n- 数字集中出现频率最多的数字\n\n# 2. 极差，中呈数\n\n极差\n\n- 极差指的是这些数字分开的有多远\n- 用其中最大的数 - 最小的数\n- 极差越大，表示分的越开；越小，表示数字之间越紧密\n\n中呈数\n\n- 考虑集中趋势的又一种方式\n- 取最大数和最小数的平均值\n\n# 3. 象形统计图\n\n象形统计图\n\n- 是用一些象形图像表示数据的一种方式\n\n# 4. 条形图\n\n适用于将事物归类，看每一类分别是怎样的情况\n\n# 5. 线形图\n\n线形图可以用于显示随时间的趋势变化。\n\n# 6. 饼图\n\n适用于各部分的占比。\n\n# 8. 茎叶图\n\n了解分布情况。\n\n# 9. 箱形图（盒须图）\n\n盒须图和中位数有关。","source":"_posts/统计学笔记.md","raw":"---\ntitle: 统计学笔记\ndate: 2021-05-07 22:57:31\ntags:\n- 数据分析\ncategories:\n- 学习笔记\ndescription: 统计学笔记\n---\n\n# 1. 均值，中位数，众数\n\n均值\n\n- 就是平均数\n- 所有数字之和/数字的个数\n- 测量集中趋势\n\n中位数\n\n- 选取中间的数\n- 要找中位数，需要先从小到大排序\n- 偶数个数中间会有两个数，取其平均值，虽然平均值不在这些数字中，但这就是中位数\n- 测量集中趋势的另一种方式\n\n众数\n\n- 数字集中出现频率最多的数字\n\n# 2. 极差，中呈数\n\n极差\n\n- 极差指的是这些数字分开的有多远\n- 用其中最大的数 - 最小的数\n- 极差越大，表示分的越开；越小，表示数字之间越紧密\n\n中呈数\n\n- 考虑集中趋势的又一种方式\n- 取最大数和最小数的平均值\n\n# 3. 象形统计图\n\n象形统计图\n\n- 是用一些象形图像表示数据的一种方式\n\n# 4. 条形图\n\n适用于将事物归类，看每一类分别是怎样的情况\n\n# 5. 线形图\n\n线形图可以用于显示随时间的趋势变化。\n\n# 6. 饼图\n\n适用于各部分的占比。\n\n# 8. 茎叶图\n\n了解分布情况。\n\n# 9. 箱形图（盒须图）\n\n盒须图和中位数有关。","slug":"统计学笔记","published":1,"updated":"2021-05-08T15:02:16.318Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbox001awct4dpft9lb1","content":"<h1 id=\"1-均值，中位数，众数\"><a href=\"#1-均值，中位数，众数\" class=\"headerlink\" title=\"1. 均值，中位数，众数\"></a>1. 均值，中位数，众数</h1><p>均值</p>\n<ul>\n<li>就是平均数</li>\n<li>所有数字之和/数字的个数</li>\n<li>测量集中趋势</li>\n</ul>\n<p>中位数</p>\n<ul>\n<li>选取中间的数</li>\n<li>要找中位数，需要先从小到大排序</li>\n<li>偶数个数中间会有两个数，取其平均值，虽然平均值不在这些数字中，但这就是中位数</li>\n<li>测量集中趋势的另一种方式</li>\n</ul>\n<p>众数</p>\n<ul>\n<li>数字集中出现频率最多的数字</li>\n</ul>\n<h1 id=\"2-极差，中呈数\"><a href=\"#2-极差，中呈数\" class=\"headerlink\" title=\"2. 极差，中呈数\"></a>2. 极差，中呈数</h1><p>极差</p>\n<ul>\n<li>极差指的是这些数字分开的有多远</li>\n<li>用其中最大的数 - 最小的数</li>\n<li>极差越大，表示分的越开；越小，表示数字之间越紧密</li>\n</ul>\n<p>中呈数</p>\n<ul>\n<li>考虑集中趋势的又一种方式</li>\n<li>取最大数和最小数的平均值</li>\n</ul>\n<h1 id=\"3-象形统计图\"><a href=\"#3-象形统计图\" class=\"headerlink\" title=\"3. 象形统计图\"></a>3. 象形统计图</h1><p>象形统计图</p>\n<ul>\n<li>是用一些象形图像表示数据的一种方式</li>\n</ul>\n<h1 id=\"4-条形图\"><a href=\"#4-条形图\" class=\"headerlink\" title=\"4. 条形图\"></a>4. 条形图</h1><p>适用于将事物归类，看每一类分别是怎样的情况</p>\n<h1 id=\"5-线形图\"><a href=\"#5-线形图\" class=\"headerlink\" title=\"5. 线形图\"></a>5. 线形图</h1><p>线形图可以用于显示随时间的趋势变化。</p>\n<h1 id=\"6-饼图\"><a href=\"#6-饼图\" class=\"headerlink\" title=\"6. 饼图\"></a>6. 饼图</h1><p>适用于各部分的占比。</p>\n<h1 id=\"8-茎叶图\"><a href=\"#8-茎叶图\" class=\"headerlink\" title=\"8. 茎叶图\"></a>8. 茎叶图</h1><p>了解分布情况。</p>\n<h1 id=\"9-箱形图（盒须图）\"><a href=\"#9-箱形图（盒须图）\" class=\"headerlink\" title=\"9. 箱形图（盒须图）\"></a>9. 箱形图（盒须图）</h1><p>盒须图和中位数有关。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-均值，中位数，众数\"><a href=\"#1-均值，中位数，众数\" class=\"headerlink\" title=\"1. 均值，中位数，众数\"></a>1. 均值，中位数，众数</h1><p>均值</p>\n<ul>\n<li>就是平均数</li>\n<li>所有数字之和/数字的个数</li>\n<li>测量集中趋势</li>\n</ul>\n<p>中位数</p>\n<ul>\n<li>选取中间的数</li>\n<li>要找中位数，需要先从小到大排序</li>\n<li>偶数个数中间会有两个数，取其平均值，虽然平均值不在这些数字中，但这就是中位数</li>\n<li>测量集中趋势的另一种方式</li>\n</ul>\n<p>众数</p>\n<ul>\n<li>数字集中出现频率最多的数字</li>\n</ul>\n<h1 id=\"2-极差，中呈数\"><a href=\"#2-极差，中呈数\" class=\"headerlink\" title=\"2. 极差，中呈数\"></a>2. 极差，中呈数</h1><p>极差</p>\n<ul>\n<li>极差指的是这些数字分开的有多远</li>\n<li>用其中最大的数 - 最小的数</li>\n<li>极差越大，表示分的越开；越小，表示数字之间越紧密</li>\n</ul>\n<p>中呈数</p>\n<ul>\n<li>考虑集中趋势的又一种方式</li>\n<li>取最大数和最小数的平均值</li>\n</ul>\n<h1 id=\"3-象形统计图\"><a href=\"#3-象形统计图\" class=\"headerlink\" title=\"3. 象形统计图\"></a>3. 象形统计图</h1><p>象形统计图</p>\n<ul>\n<li>是用一些象形图像表示数据的一种方式</li>\n</ul>\n<h1 id=\"4-条形图\"><a href=\"#4-条形图\" class=\"headerlink\" title=\"4. 条形图\"></a>4. 条形图</h1><p>适用于将事物归类，看每一类分别是怎样的情况</p>\n<h1 id=\"5-线形图\"><a href=\"#5-线形图\" class=\"headerlink\" title=\"5. 线形图\"></a>5. 线形图</h1><p>线形图可以用于显示随时间的趋势变化。</p>\n<h1 id=\"6-饼图\"><a href=\"#6-饼图\" class=\"headerlink\" title=\"6. 饼图\"></a>6. 饼图</h1><p>适用于各部分的占比。</p>\n<h1 id=\"8-茎叶图\"><a href=\"#8-茎叶图\" class=\"headerlink\" title=\"8. 茎叶图\"></a>8. 茎叶图</h1><p>了解分布情况。</p>\n<h1 id=\"9-箱形图（盒须图）\"><a href=\"#9-箱形图（盒须图）\" class=\"headerlink\" title=\"9. 箱形图（盒须图）\"></a>9. 箱形图（盒须图）</h1><p>盒须图和中位数有关。</p>\n"},{"title":"【数据分析】第二阶段：MySQL数据分析实战（二）","date":"2021-05-08T14:46:42.000Z","description":"窗口函数、索引、视图","_content":"\n# 窗口函数\n\n窗口函数（也叫分析函数），从MySQL8.0开始支持。\n\n窗口在数据中限定出一个范围，函数对这个范围内的集合进行统计。\n\n```\n函数名() over(子句)\n```\n\nover就是窗口，通过子句限定窗口的范围，函数在该范围内执行。\n\nover中的子句具体如下：\n\n```\n函数名() over(partition by 分组字段1,分组字段2... order by <排序字段> rows between <范围起始行数> and <范围结束行数>)\n```\n\n**⚠️注意：**\n\n- **子句间*没有*逗号，间隔**\n- **over子句中多个字段用逗号，分割，不是用and**\n\n具体示例：\n\n```\n# 选出D1行至D2行的记录集合，在该集合内，按照B分组，按照C排序，最后每一组对A求和\nsum(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...) \navg(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...)\n\nA: 需要被加工的字段名称 \nB: 分组的字段名称\nC: 排序的字段名称\nD: 计算的行数范围\n```\n\n```\nrows between 2 preceding(在..之前) and current row # 范围：当前查询位置的前2行——当前行，共3行\nrows between unbounded(无限) preceding(在..之前) and current row # 范围：当前查询位置的前所有行——当前行\nrows between current row and unbounded(无限) following(在...之后) # 范围：当前查询位置的当前行——之后的所有行\nrows between 3 preceding and current row # 范围：当前查询位置的前3行——当前行，共4行\nrows between 3 preceding and 1 following # 范围：当前查询位置的前3行——后1行，共5行\n```\n\n- 当不指定rows between时，窗口规范默认是：该partition分组中rows between unbounded preceding and current row\n- 当不指定order by 和 rows between时, 窗口规范默认是：该partition分组中rows between unbounded preceding and unbounded following\n- 当不指定partition时，order by的作用范围是整个数据表；指定partition时，order by的作用范围是当前分组\n- 当over子句中什么都不写时，窗口规范默认是整张表全部数据\n\n**⚠️注意：where优先级>over，where是对源数据进行过滤，过滤后的结果集再执行over或group by等操作。**\n\n## 聚合类窗口函数\n\n- sum()\n- count()\n- avg()\n- Max()\n- min()\n\n窗口函数下的聚合函数 和 普通场景下的聚合函数区别：\n\n普通场景下的聚合函数是将多条记录聚合为一条**(多到一)**；窗口函数下是每条记录都会执 行，有几条记录执行完还是几条**(多到多)**。\n\n### 累计计算\n\n```sql\n# 需求1：查询出2019年每月的支付总额和当年累积支付总额\nselect a._month, a._pay_mount_sum, sum(a._pay_mount_sum) over(order by a._month)\nfrom\n(\n\tselect month(pay_time) as _month, sum(pay_amount) as _pay_mount_sum\n\tfrom user_trade\n\twhere year(pay_time) = 2019\n\tgroup by month(pay_time)\n)a\n\n# ❌错误写法\nselect month(pay_time), sum(pay_amount)，sum(sum(pay_amount)) over(month(pay_time))\nfrom user_trade\nwhere year(pay_time) = 2019\ngroup by month(pay_time)\n# 这么写的想法：group by分组已经取得了月份、每个月支付总额，那么再直接用窗口函数就能取得每个月的累计支付总额\n# 错误原因：group by只是完成了按月分组，必须还要完成select month(pay_time), sum(pay_amount)才能获取最终的数据集，如果在 select中加入窗口函数，此时并没有取得数据集，窗口函数也就无法执行。所以需要子查询的方式，先让group by完成select取得数据集，再将数 据集作为表通过子查询执行窗口函数\n\n# 需求2：查询出2018-2019年每月的支付总额和当年累积支付总额\nselect a._year,a._month,sum(a.pay_amount_sum) over(partition by a._year order by a._month)\nfrom\n(\n\tselect year(pay_time) _year, month(pay_time) _month, sum(pay_amount) pay_amount_sum\n\tfrom user_trade\n\tgroup by year(pay_time), month(pay_time)\n\thaving _year in (2018,2019)\n\torder by _year, _month\n)a\n\n# 需求3: 查询出2019年每个月的近三月移动平均支付金额\nselect a._month, a._pay_amount, avg(a._pay_amount) over(rows between 2 preceding and current row)\nfrom (\n\tselect month(pay_time) _month, sum(pay_amount) _pay_amount\n\tfrom user_trade\n\twhere year(pay_time) = 2019\n\tgroup by _month\n\torder by _month\n)a\n```\n\n## 排序窗口函数\n\n### rank、dense_rank、row_number\n\n- rank() over(partition by <分组字段> order by <排序字段>)，返回排序后的排名（并列排名占用名次）\n- Dense_rank() over(partition by <分组字段> order by <排序字段>)，返回排序后的排名（并列排名不占用名次）\n- Row_number() over(partition by <分组字段> order by <排序字段>)，返回排序后的行号（从1开始）\n\n⚠️这三种排序函数不需要参数。\n\n```\n# 语法\nrow_number(无参数) over(......) \nrank(无参数) over(......) \ndense_rank(无参数) over(......)\n\n在rank()函数，如果有并列情况，会占用下一个名次的位置，比如，成绩为100的学生有三个并列第一，那么99分的学生是第二名，通过rank()函数，名次是：1,1,1,4；\n\n在dense()函数中，如果有并列的情况，不会占用下一个名词，同用上个例子，名次是：1,1,1,2；\n\n在row_number()函数中，会忽略并列的情况，同用上述例子，名次是：1,2,3,4;\n```\n\n```sql\n# 需求5: 2020年1月，购买商品品类数的用户排名\n# 本案例中 不需要先子查询再对子查询结果使用排序函数。要考虑两个问题，一是所使用的函数是在生成数据集的同时就能使用，还是要生成完毕才可以使用；二是在使用函数的时，是否已经生成了数据集。\nSELECT\n\tuser_name,\n\t-- 这里使用distinct去重，因为一个用户可能在不同的时间购买了同一个品类的商品\n\tcount( DISTINCT goods_category ) goods_c_count,\n\trow_number() over ( ORDER BY count( DISTINCT goods_category ) ) _row_number,\n\trank() over ( ORDER BY count( DISTINCT goods_category ) ) _rank,\n\tdense_rank() over ( ORDER BY count( DISTINCT goods_category ) ) _dense_rank \nFROM\n\tuser_trade \nWHERE\n\tYEAR ( pay_time ) = 2020 \n\tAND MONTH ( pay_time ) = 1 \nGROUP BY\n\tuser_name\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_18-26-26.jpg)\n\n### ntile\n\n- ntile(n) over(partition by <分组字段A> order by <排序字段B>)\n\n**n**:切分的片数\n**A**:分组的字段名称\n**B**:排序的字段名称\n\nntile(**n**)，用于将分组数据按照顺序切分成n片，返回当前切片值。\n\nNtile(n) over(partition by <分组字段A> order by <排序字段B>)函数简单的说，就是对将个分组（没有分组就是整张表）的数据，先按照order by字段排序，然后分成n组，然后按照排序给每个组排名。\n\n```sql\n# 需求6: 查询出将2020年2月的支付用户，按照支付金额分成5组后的结果\nselect user_name, sum(pay_amount) pay_amount, ntile(5) over(order by sum(pay_amount) desc)level\nfrom user_trade\nwhere year(pay_time) = 2020\nand month(pay_time) = 2\ngroup by user_name\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_21-42-58.jpg)\n\n```sql\n# 需求7：查询出2020年支付金额排名前30%的所有用户\nselect a.user_name, a.pay_amount, a.level\nfrom (\n\tselect user_name, sum(pay_amount)pay_amount, ntile(10) over(order by sum(pay_amount) desc) level\n\tfrom user_trade\n\twhere year(pay_time) = 2020\n\tgroup by user_name\n)a\nwhere a.level < 4\n```\n\n## 偏移分析函数\n\n### lag、lead\n\nlag() 函数，允许您向上偏移多行并从当前行访问偏移行的数据\n\nlead() 函数，允许您向下看多行并从当前行访问偏移行的数据。\n\n```\n# 向上偏移\nlag(<expression>[,offset[, default_value]]) over (partition by expr,... order by expr [asc|desc],...) \n# 向下偏移\nlead(<expression>[,offset[, default_value]]) over (partition by expr,... order by expr [asc|desc],...) \n```\n\n执行到当前分组的某一行时，返回偏移offset行的行的expression字段的值，如果偏移量超过了分组或窗口范围，返回default_value。\n\n如果不写offset参数，默认偏移1行。\n\n如果不写default_value参数，默认值为null。\n\n```sql\nSELECT user_name,pay_time,\n       lag(pay_time,1,pay_time) over(partition by user_name order by pay_time) lag1,\n\t\t\t-- 没有传入偏移量，那么默认就是1，找不到的话，此处也没有给默认值，为 null\n\t\t\t lag(pay_time) over(partition by user_name order by pay_time)lag1_s,\n       lag(pay_time,2,pay_time) over(partition by user_name order by pay_time) lag2,\n       lag(pay_time,2) over(partition by user_name order by pay_time)lag2_s\nFROM user_trade\nWHERE user_name in ('King','West');\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_22-54-39.jpg)\n\n**在实际应用当中，若要用到取今天和昨天的某字段差值时，Lag和Lead函数的应用就显得尤为重要。**\n\n```sql\n# 需求10: 查询出支付时间间隔超过100天的用户数\nselect count(distinct a.user_name)\nfrom (\n\tselect \n  \tuser_name,pay_time, \n  \tlead(pay_time,1) over(partition by user_name order by pay_time) lead_time \n\tfrom user_trade\n)a\nwhere a.lead_time is not null\nand datediff(a.lead_time,a.pay_time) > 100\n```\n\n```sql\n# 需求11: 查询出每年支付时间间隔最长的用户\n# ✅\nselect b.user_name, year(b.pay_time), b.diff_time\nfrom (\n\t\tselect \n\t\t\ta.user_name, a.pay_time, \n\t\t\ta.lead_time, datediff(a.lead_time,a.pay_time) diff_time, \n\t\t\trank() over(partition by year(a.pay_time) order by datediff(a.lead_time,a.pay_time) desc) _rank\n\t\tfrom (\n\t\t\tselect user_name, pay_time, lead(pay_time,1) over(partition by user_name, year(pay_time) order by pay_time) lead_time\n\t\t\tfrom user_trade\n\t\t)a\n\t\twhere a.lead_time is not null\n\t)b\n\twhere b._rank = 1\n\n# ❌，错误原因：\n/*\n在第2层子查询计算出了每年每个用户的支付间隔后，外套一层查询，并按年分组，然后用max（）选出每组，也就是每年间隔时间最长的人，\n这时发现，在select中只有max(b.diff_time)时不会报错，但加上b.user_name就会报错。\n这时因为，一年中存在多个用户的支付时间间隔并列最长，这时max(b.diff_time)会默认返回第一个(还是随机一个），但是user_name有多个，系统不知道该返回哪个，就会报错了。\n所以这里不能用max，应该用rank()函数，这样就考虑到了并列最大的情况。\n*/\nselect b.user_name, max(b.diff_time)\nfrom (\n\tselect a.user_name, a.pay_time, a.lead_time, datediff(a.lead_time,a.pay_time) diff_time\n\tfrom (\n\t\tselect user_name, pay_time, lead(pay_time,1) over(partition by user_name, year(pay_time) order by pay_time) lead_time\n\t\tfrom user_trade\n\t)a\n\twhere a.lead_time is not null\n)b\ngroup by year(b.pay_time)\n```\n\n**max()并列最大错误测试：**\n\n测试表数据\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-07-31.jpg)\n\n只select max()不报错\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-08-38.jpg)\n\nselect user_id报错\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-09-15.jpg)\n\n## 小结\n\n- 聚合窗口函数 不能 在第一次select时同时执行，必须先select完毕，结果集再作为新表通过子查询使用聚合窗口函数。\n\n```sql\n# 报错❌\nselect \n\tmonth(pay_time) as _month, \n\tsum(pay_amount) over(order by month(pay_time))\nfrom user_trade\nwhere year(pay_time) = 2019\ngroup by month(pay_time)\n\n# 正确✅\nselect a._month, a._pay_mount_sum, sum(a._pay_amount_sum) over(order by a._month)\nfrom (\n\tselect month(pay_time) as _month, sum(pay_amount) as _pay_amount_sum\n\tfrom user_trade\n\twhere year(pay_time) = 2019\n\tgroup by month(pay_time)\n)a\n```\n\n- 排序窗口函数、偏移分析函数 可以 在第一次select时同时执行。\n\n```sql\n# ✅\nSELECT\n\tuser_name,\n\tcount( DISTINCT goods_category ) goods_c_count,\n\trow_number() over ( ORDER BY count( DISTINCT goods_category ) ) _row_number,\n\trank() over ( ORDER BY count( DISTINCT goods_category ) ) _rank,\n\tdense_rank() over ( ORDER BY count( DISTINCT goods_category ) ) _dense_rank \nFROM\n\tuser_trade \nWHERE\n\tYEAR ( pay_time ) = 2020 \n\tAND MONTH ( pay_time ) = 1 \nGROUP BY\n\tuser_name\n\t\n# ✅\nselect \n \tuser_name,pay_time, \n \tlead(pay_time,1) over(partition by user_name order by pay_time) lead_time \nfrom user_trade\n```\n\n# 索引\n\n字典的目录就是一种索引机制，提高检索的效率。\n\n- 索引可以提升查询速度，会影响where和order by。\n- 索引是针对字段的，需要添加到字段上。给某一列添加索引的时候，数据库会将这一列的数据进行提取、转换、再存储。存储下来的数据就是索引。当查询的时候，会先查询索引数据，能够更快速的找到相关信息。\n- 索引在大量数据场景下效果明显。\n\n## 常见索引分类\n\n- 从索引的存储结构划分:B Tree索引、Hash索引、fulltext全文索引、R Tree索引(了解) \n\n- **从应用层次划分:主键索引、唯一索引、普通索引、复合索引** \n\n- 从索引的键值(字段)类型划分:主键索引、辅助索引(二级索引) \n\n- 从索引数据和内容数据逻辑关系划分:聚集索引(聚簇索引)、非聚集索引(非聚簇索 引)\n\n## 主键索引(primary key)\n\n- 数据表添加主键的时候，会自动穿件逐渐索引，主键索引也是一种唯一索引。\n- 一个表可以没有主见，但最多只能有一个主键，且主键是唯一的、不能为Null。\n- 根据主键进行where条件查询，效率高。\n\n## 唯一索引(unique)\n\n特点：索引列的值只能出现一次，不能重复，保证唯一。\n\n在许多场合，人们创建唯一索引不是为了提高查询速度，而是为了避免数据重复。（使用唯一约束效果相同）\n\n```sql\n# 创建表的时候直接添加唯一索引\nCREATE TABLE 表名( \n  列名 类型(长度),\n\tUNIQUE [索引名称] (列名)\n);\n\n# 在已有的表上创建索引\ncreate unique index 索引名 on 表名(列名[长度])\ncreate unique index index_dname on test_index(dname);\n\n# 修改表结构添加索引\nALTER TABLE 表名 ADD UNIQUE 索引名( 列名 )\n```\n\n## 普通索引(normal index)\n\n普通索引的唯一任务是加快检索的速度。一般为需要where条件查询或order by排序的列添加普通索引。\n\n普通索引不要求数据唯一、非空。\n\n```sql\n# 在已有的表上创建索引\ncreate index 索引名 on 表名(列名[长度])\n\n# 修改表结构添加索引\nalter table 表名 add index 索引名 (列名)\n```\n\n## 复合索引\n\n创建普通索引时，同时写入多个字段。\n\n复合索引一般用在，需要对多个字段进行where条件查询或order by排序。\n\n```sql\n# 在已有的表上创建索引\ncreate index 索引名 on 表名(列名1, 列名2,...)\n\n# 修改表结构添加索引\nalter table 表名 add index 索引名 (列名1， 列名2,...)\n```\n\n⚠️注意：创建复合索引时要注意字段顺序，创建索引时字段的顺序，要和查询条件中字段的顺序保持一致。\n\n```sql\nwhere 字段1=‘’ and 字段2=‘’\t-- 字段1，字段2\n\ncreate index 索引名 on 表名(字段1, 字段2) -- 字段1，字段2；不能写成 字段2，字段1\n```\n\n⚠️注意：区别复合索引和多个单列索引。\n\n```sql\n# 复合索引\ncreate index 索引名 on 表名(列名1, 列名2) -- 字段顺序要和查询条件中保持一致\n\n# 多个单列索引\ncreate index 索引名 on 表名(列名1) -- 不需要考虑字段顺序\ncreate index 索引名 on 表名(列名2)\n```\n\n## 删除索引\n\n```sql\nalter table 表名 drop index 索引名;\n```\n\n# 视图\n\n概念：\n\n- 视图是一种虚拟表。（与之对应的是实体表，比如通过create语句创建的表）\n- 视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。\n-  向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句。\n- 视图向用户提供基表（实体表或者其他视图）数据的另一种表现形式。\n\n```sql\ncreate view 视图名 [column_list] as select语句;\nview: 表示视图\ncolumn_list: 可选参数，表示属性清单，指定视图中各个属性的名称，默认情况下，与 SELECT语句中查询的属性相同\nas : 表示视图要执行的操作\nselect语句: 向视图提供数据内容\n```\n\n作用：\n\n- 权限控制时可以使用\n- 简化复杂的多表查询\n\nsql中视图的概念类似于编程中封装函数的概念，将一段复杂的sql语句封装成一个视图，之后只需通过引用视图名进行查询就能得到结果。并且可以决定从视图中只查询某几个字段的数据，做到权限控制，就像函数可以指定返回的值一样。\n\n```sql\n# 需求1: 查询各个分类下的商品平均价格\ncreate view cp_view as\nselect *\nfrom category c\njoin products p\non c.cid = p.category_id; -- 注意这里必须有分号;结束\n\nselect cname, avg(price)\nfrom cp_view\ngroup by cname\n\n# 普通写法\nselect cname, avg(price)\nfrom products p left join category c\non p.category_id = c.cid\ngroup by c.cname\n```\n\n```sql\n# 需求2: 查询鞋服分类下最贵的商品的全部信息\ncreate view cp_view2 as \nselect c.cid, c.cname, p.pid,p.pname, p.price, p.flag, rank() over(partition by c.cname order by p.price desc) _rank\nfrom products p left join category c \non p.category_id = c.cid;\n\nselect * from cp_view2 where cname = '鞋服' and _rank = 1\n\n# 普通写法\nselect *\nfrom (\nselect c.cid, c.cname, p.pid,p.pname, p.price, p.flag, rank() over(partition by c.cname order by p.price desc) _rank\nfrom products p left join category c \non p.category_id = c.cid \n)a\nwhere a.cname = '鞋服' and a._rank = 1\n```\n\n视图和表的区别：\n\n- 视图是建立在表的基础上，表存储数据库中的数据，而视图只是做一个数据的展示 。\n- 通过视图不能改变表中数据(一般情况下视图中的数据都是表中的列 经过计算得到的结果, 不允许更新)。\n-  删除视图，表不受影响，而删除表，视图不再起作用。\n\n# 作业——知识点\n\n## 留存\n\n留存：指基准日到APP的用户在之后的n日当天返回APP的人数。\n\n留存率 = 基准日之后的n天当日返回的用户数 / 基准日的用户数 * 100%。\n\n\n\n留存代表一个用户愿意再次使用你的产品;而一个产品能够被用户再次使用，意味着这个产品是能够满\n\n足用户长期需求的，能够让用户产生一定粘性的产品。\n\n\n\n活跃用户 = 新增用户 + 留存用户\n\n\n\n如今互联网产品大多为免费产品，依靠持续的广告转化、用户持续的购买转化、用户持续的会员付费来维持收益。\n\n持续的广告转化、购买、会员付费，我们就 需要每天都有一定量的用户来完成以上过程，也就是说我们需要我们的产品每天都是有活跃用户的。\n\n从活跃用户的构成，我们就知道怎么维持我们的活跃用户规模：一方面持续有新用户流入，另一方 面持续有留存用户留存。\n\n\n\n为什么留存用户重要?部分有过从业经验的同学应该知道，产品的自然新增用户是比较少的，如果 我们仅靠产品自然用户增长，那么必然我们的活跃用户量级会非常小，虽然能够获得收益，但是这部分 收益很可能养不起我们的公司;但是如果我们想要用购买新用户的方式获得持续的较大规模的用户池， 又会产生比较大的成本，这样做容易亏本。所以我们需要新增留存两手抓;想方设法留住我们新增的用 户，让其长期地在我们的产品内产生价值，这样做，比起单做新增，在成本和效果上都是要好的。\n\n\n\n**留存的主要应用场景有两个：**\n\n- 一个是产品整体视角的持续留存情况;也就是我们需要定期分析用户在产品的留存是否维持在一个正常 的范围，有没有突然地涨跌情况，如果有的话问题出在哪里，为什么会出现这样的问题，如何解决留存 异常的问题。遇到这类问题首先需要确定的是整体用户的留存异常还是个别群体用户的留存异常，如果 是整体用户的留存异常，我们需要分析我们的产品是否发生异常，可以通过用户的行为路径确定异常产 品位置;如果是个别用户的留存异常，需要通过用户拆解的方法来定位有异常的用户群体，然后通过这 类用户的特征来分析问题原因。\n\n- 一个是新增用户视角的每批新增用户留存情况。一般出现在计算投放ROI的场景，也就是我们投放一批 用户，能够给我们带来多少收益。我们会用这些用户的“整个生命周期能够带来的收入”(LTV)去除以 “投放时的支出”来计算我们的ROI。“整个生命周期能够带来的收入”计算的是引入一批新用户，当用户完 全流失时，这部分用户所带来的所有收入。但是有时我们需要提前预估新用户在整个生命周期能够带来 的收入，我们就需要首先用留存来估计用户的生命周期，然后用估计出的生命周期再去计算用户的整个 生命周期能够带来的收入。\n\n**什么企业不关心留存：** \n\n需要用户产生持续活跃，持续转化，持续消费的企业都关心用户的留存。那么，什么样的企业不关心用户留存?\n\n- 部分线下企业存在数据难以获取的问题，所以对留存关注比较少，比如线下的商场，除非用户产生购买 行为，否则很难探知用户在什么情况下有回流。\n\n- 部分存在一锤子买卖的企业也不太关心留存，比如说用户在一次买断商品后再也不会产生后续购买或价 值转化行为，这类企业也不怎么关注留存。比如PC单机游戏;比如一次付费的工具类产品(线上线下类 工具都存在这个情况)。\n\n## 周同比\n\n周同比：周同比适用于以周为周期变动的数据，用于观察每天的数据较上周同一天的数据变化。\n\n现有互联网数据多以周为周期变动，一周内每一天的数据都有其特点:\n\n- 如工作类APP，周一会是每一周的高峰，然后向周五逐渐递减，周五到周六又会有一个锐减的过 程，周日与周六趋于平缓;\n\n- 如娱乐类APP，周一会较周末锐减，然后向周四逐渐递减，周五会有一个跃升的过程，周六会再次 跃升，周日会较周六下降;\n\n一般遇到这样的变动趋势，如果单纯的分析每一天较上一天的变动情况，就容易分析出错误结论。所 以，在我们分析带有周期类数据时，一定要先将周期提炼出来，使用周期的同比数据做分析，会得出更 有价值，更加准确的结论。\n\n## 平台模式\n\n如今的大多数内容APP都是以平台模式运营的。\n\n什么叫做平台模式?\n\n比如我们现在能接触到的大多数内容产品“抖音”、“Bilibili”、“微博”、“今日头条”等等。我们使用到的这个 APP，是由APP的制作公司提供的，也就是这个APP会有几个主要的页面，每个页面怎么引导用户进入内 容页面，播放内容的方式有哪些、内容间切换会用什么方式等等，都是我们的APP制作公司决定的;而 我们在这个APP里看到的大多数内容，都是由内容作者提供的。\n\n\n\n","source":"_posts/【数据分析】第二阶段：MySQL数据分析实战（二）.md","raw":"---\ntitle: 【数据分析】第二阶段：MySQL数据分析实战（二）\ndate: 2021-05-08 22:46:42\ntags:\n- 数据分析\ncategories:\n- 学习笔记\ndescription: 窗口函数、索引、视图\n---\n\n# 窗口函数\n\n窗口函数（也叫分析函数），从MySQL8.0开始支持。\n\n窗口在数据中限定出一个范围，函数对这个范围内的集合进行统计。\n\n```\n函数名() over(子句)\n```\n\nover就是窗口，通过子句限定窗口的范围，函数在该范围内执行。\n\nover中的子句具体如下：\n\n```\n函数名() over(partition by 分组字段1,分组字段2... order by <排序字段> rows between <范围起始行数> and <范围结束行数>)\n```\n\n**⚠️注意：**\n\n- **子句间*没有*逗号，间隔**\n- **over子句中多个字段用逗号，分割，不是用and**\n\n具体示例：\n\n```\n# 选出D1行至D2行的记录集合，在该集合内，按照B分组，按照C排序，最后每一组对A求和\nsum(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...) \navg(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...)\n\nA: 需要被加工的字段名称 \nB: 分组的字段名称\nC: 排序的字段名称\nD: 计算的行数范围\n```\n\n```\nrows between 2 preceding(在..之前) and current row # 范围：当前查询位置的前2行——当前行，共3行\nrows between unbounded(无限) preceding(在..之前) and current row # 范围：当前查询位置的前所有行——当前行\nrows between current row and unbounded(无限) following(在...之后) # 范围：当前查询位置的当前行——之后的所有行\nrows between 3 preceding and current row # 范围：当前查询位置的前3行——当前行，共4行\nrows between 3 preceding and 1 following # 范围：当前查询位置的前3行——后1行，共5行\n```\n\n- 当不指定rows between时，窗口规范默认是：该partition分组中rows between unbounded preceding and current row\n- 当不指定order by 和 rows between时, 窗口规范默认是：该partition分组中rows between unbounded preceding and unbounded following\n- 当不指定partition时，order by的作用范围是整个数据表；指定partition时，order by的作用范围是当前分组\n- 当over子句中什么都不写时，窗口规范默认是整张表全部数据\n\n**⚠️注意：where优先级>over，where是对源数据进行过滤，过滤后的结果集再执行over或group by等操作。**\n\n## 聚合类窗口函数\n\n- sum()\n- count()\n- avg()\n- Max()\n- min()\n\n窗口函数下的聚合函数 和 普通场景下的聚合函数区别：\n\n普通场景下的聚合函数是将多条记录聚合为一条**(多到一)**；窗口函数下是每条记录都会执 行，有几条记录执行完还是几条**(多到多)**。\n\n### 累计计算\n\n```sql\n# 需求1：查询出2019年每月的支付总额和当年累积支付总额\nselect a._month, a._pay_mount_sum, sum(a._pay_mount_sum) over(order by a._month)\nfrom\n(\n\tselect month(pay_time) as _month, sum(pay_amount) as _pay_mount_sum\n\tfrom user_trade\n\twhere year(pay_time) = 2019\n\tgroup by month(pay_time)\n)a\n\n# ❌错误写法\nselect month(pay_time), sum(pay_amount)，sum(sum(pay_amount)) over(month(pay_time))\nfrom user_trade\nwhere year(pay_time) = 2019\ngroup by month(pay_time)\n# 这么写的想法：group by分组已经取得了月份、每个月支付总额，那么再直接用窗口函数就能取得每个月的累计支付总额\n# 错误原因：group by只是完成了按月分组，必须还要完成select month(pay_time), sum(pay_amount)才能获取最终的数据集，如果在 select中加入窗口函数，此时并没有取得数据集，窗口函数也就无法执行。所以需要子查询的方式，先让group by完成select取得数据集，再将数 据集作为表通过子查询执行窗口函数\n\n# 需求2：查询出2018-2019年每月的支付总额和当年累积支付总额\nselect a._year,a._month,sum(a.pay_amount_sum) over(partition by a._year order by a._month)\nfrom\n(\n\tselect year(pay_time) _year, month(pay_time) _month, sum(pay_amount) pay_amount_sum\n\tfrom user_trade\n\tgroup by year(pay_time), month(pay_time)\n\thaving _year in (2018,2019)\n\torder by _year, _month\n)a\n\n# 需求3: 查询出2019年每个月的近三月移动平均支付金额\nselect a._month, a._pay_amount, avg(a._pay_amount) over(rows between 2 preceding and current row)\nfrom (\n\tselect month(pay_time) _month, sum(pay_amount) _pay_amount\n\tfrom user_trade\n\twhere year(pay_time) = 2019\n\tgroup by _month\n\torder by _month\n)a\n```\n\n## 排序窗口函数\n\n### rank、dense_rank、row_number\n\n- rank() over(partition by <分组字段> order by <排序字段>)，返回排序后的排名（并列排名占用名次）\n- Dense_rank() over(partition by <分组字段> order by <排序字段>)，返回排序后的排名（并列排名不占用名次）\n- Row_number() over(partition by <分组字段> order by <排序字段>)，返回排序后的行号（从1开始）\n\n⚠️这三种排序函数不需要参数。\n\n```\n# 语法\nrow_number(无参数) over(......) \nrank(无参数) over(......) \ndense_rank(无参数) over(......)\n\n在rank()函数，如果有并列情况，会占用下一个名次的位置，比如，成绩为100的学生有三个并列第一，那么99分的学生是第二名，通过rank()函数，名次是：1,1,1,4；\n\n在dense()函数中，如果有并列的情况，不会占用下一个名词，同用上个例子，名次是：1,1,1,2；\n\n在row_number()函数中，会忽略并列的情况，同用上述例子，名次是：1,2,3,4;\n```\n\n```sql\n# 需求5: 2020年1月，购买商品品类数的用户排名\n# 本案例中 不需要先子查询再对子查询结果使用排序函数。要考虑两个问题，一是所使用的函数是在生成数据集的同时就能使用，还是要生成完毕才可以使用；二是在使用函数的时，是否已经生成了数据集。\nSELECT\n\tuser_name,\n\t-- 这里使用distinct去重，因为一个用户可能在不同的时间购买了同一个品类的商品\n\tcount( DISTINCT goods_category ) goods_c_count,\n\trow_number() over ( ORDER BY count( DISTINCT goods_category ) ) _row_number,\n\trank() over ( ORDER BY count( DISTINCT goods_category ) ) _rank,\n\tdense_rank() over ( ORDER BY count( DISTINCT goods_category ) ) _dense_rank \nFROM\n\tuser_trade \nWHERE\n\tYEAR ( pay_time ) = 2020 \n\tAND MONTH ( pay_time ) = 1 \nGROUP BY\n\tuser_name\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_18-26-26.jpg)\n\n### ntile\n\n- ntile(n) over(partition by <分组字段A> order by <排序字段B>)\n\n**n**:切分的片数\n**A**:分组的字段名称\n**B**:排序的字段名称\n\nntile(**n**)，用于将分组数据按照顺序切分成n片，返回当前切片值。\n\nNtile(n) over(partition by <分组字段A> order by <排序字段B>)函数简单的说，就是对将个分组（没有分组就是整张表）的数据，先按照order by字段排序，然后分成n组，然后按照排序给每个组排名。\n\n```sql\n# 需求6: 查询出将2020年2月的支付用户，按照支付金额分成5组后的结果\nselect user_name, sum(pay_amount) pay_amount, ntile(5) over(order by sum(pay_amount) desc)level\nfrom user_trade\nwhere year(pay_time) = 2020\nand month(pay_time) = 2\ngroup by user_name\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_21-42-58.jpg)\n\n```sql\n# 需求7：查询出2020年支付金额排名前30%的所有用户\nselect a.user_name, a.pay_amount, a.level\nfrom (\n\tselect user_name, sum(pay_amount)pay_amount, ntile(10) over(order by sum(pay_amount) desc) level\n\tfrom user_trade\n\twhere year(pay_time) = 2020\n\tgroup by user_name\n)a\nwhere a.level < 4\n```\n\n## 偏移分析函数\n\n### lag、lead\n\nlag() 函数，允许您向上偏移多行并从当前行访问偏移行的数据\n\nlead() 函数，允许您向下看多行并从当前行访问偏移行的数据。\n\n```\n# 向上偏移\nlag(<expression>[,offset[, default_value]]) over (partition by expr,... order by expr [asc|desc],...) \n# 向下偏移\nlead(<expression>[,offset[, default_value]]) over (partition by expr,... order by expr [asc|desc],...) \n```\n\n执行到当前分组的某一行时，返回偏移offset行的行的expression字段的值，如果偏移量超过了分组或窗口范围，返回default_value。\n\n如果不写offset参数，默认偏移1行。\n\n如果不写default_value参数，默认值为null。\n\n```sql\nSELECT user_name,pay_time,\n       lag(pay_time,1,pay_time) over(partition by user_name order by pay_time) lag1,\n\t\t\t-- 没有传入偏移量，那么默认就是1，找不到的话，此处也没有给默认值，为 null\n\t\t\t lag(pay_time) over(partition by user_name order by pay_time)lag1_s,\n       lag(pay_time,2,pay_time) over(partition by user_name order by pay_time) lag2,\n       lag(pay_time,2) over(partition by user_name order by pay_time)lag2_s\nFROM user_trade\nWHERE user_name in ('King','West');\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_22-54-39.jpg)\n\n**在实际应用当中，若要用到取今天和昨天的某字段差值时，Lag和Lead函数的应用就显得尤为重要。**\n\n```sql\n# 需求10: 查询出支付时间间隔超过100天的用户数\nselect count(distinct a.user_name)\nfrom (\n\tselect \n  \tuser_name,pay_time, \n  \tlead(pay_time,1) over(partition by user_name order by pay_time) lead_time \n\tfrom user_trade\n)a\nwhere a.lead_time is not null\nand datediff(a.lead_time,a.pay_time) > 100\n```\n\n```sql\n# 需求11: 查询出每年支付时间间隔最长的用户\n# ✅\nselect b.user_name, year(b.pay_time), b.diff_time\nfrom (\n\t\tselect \n\t\t\ta.user_name, a.pay_time, \n\t\t\ta.lead_time, datediff(a.lead_time,a.pay_time) diff_time, \n\t\t\trank() over(partition by year(a.pay_time) order by datediff(a.lead_time,a.pay_time) desc) _rank\n\t\tfrom (\n\t\t\tselect user_name, pay_time, lead(pay_time,1) over(partition by user_name, year(pay_time) order by pay_time) lead_time\n\t\t\tfrom user_trade\n\t\t)a\n\t\twhere a.lead_time is not null\n\t)b\n\twhere b._rank = 1\n\n# ❌，错误原因：\n/*\n在第2层子查询计算出了每年每个用户的支付间隔后，外套一层查询，并按年分组，然后用max（）选出每组，也就是每年间隔时间最长的人，\n这时发现，在select中只有max(b.diff_time)时不会报错，但加上b.user_name就会报错。\n这时因为，一年中存在多个用户的支付时间间隔并列最长，这时max(b.diff_time)会默认返回第一个(还是随机一个），但是user_name有多个，系统不知道该返回哪个，就会报错了。\n所以这里不能用max，应该用rank()函数，这样就考虑到了并列最大的情况。\n*/\nselect b.user_name, max(b.diff_time)\nfrom (\n\tselect a.user_name, a.pay_time, a.lead_time, datediff(a.lead_time,a.pay_time) diff_time\n\tfrom (\n\t\tselect user_name, pay_time, lead(pay_time,1) over(partition by user_name, year(pay_time) order by pay_time) lead_time\n\t\tfrom user_trade\n\t)a\n\twhere a.lead_time is not null\n)b\ngroup by year(b.pay_time)\n```\n\n**max()并列最大错误测试：**\n\n测试表数据\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-07-31.jpg)\n\n只select max()不报错\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-08-38.jpg)\n\nselect user_id报错\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-09-15.jpg)\n\n## 小结\n\n- 聚合窗口函数 不能 在第一次select时同时执行，必须先select完毕，结果集再作为新表通过子查询使用聚合窗口函数。\n\n```sql\n# 报错❌\nselect \n\tmonth(pay_time) as _month, \n\tsum(pay_amount) over(order by month(pay_time))\nfrom user_trade\nwhere year(pay_time) = 2019\ngroup by month(pay_time)\n\n# 正确✅\nselect a._month, a._pay_mount_sum, sum(a._pay_amount_sum) over(order by a._month)\nfrom (\n\tselect month(pay_time) as _month, sum(pay_amount) as _pay_amount_sum\n\tfrom user_trade\n\twhere year(pay_time) = 2019\n\tgroup by month(pay_time)\n)a\n```\n\n- 排序窗口函数、偏移分析函数 可以 在第一次select时同时执行。\n\n```sql\n# ✅\nSELECT\n\tuser_name,\n\tcount( DISTINCT goods_category ) goods_c_count,\n\trow_number() over ( ORDER BY count( DISTINCT goods_category ) ) _row_number,\n\trank() over ( ORDER BY count( DISTINCT goods_category ) ) _rank,\n\tdense_rank() over ( ORDER BY count( DISTINCT goods_category ) ) _dense_rank \nFROM\n\tuser_trade \nWHERE\n\tYEAR ( pay_time ) = 2020 \n\tAND MONTH ( pay_time ) = 1 \nGROUP BY\n\tuser_name\n\t\n# ✅\nselect \n \tuser_name,pay_time, \n \tlead(pay_time,1) over(partition by user_name order by pay_time) lead_time \nfrom user_trade\n```\n\n# 索引\n\n字典的目录就是一种索引机制，提高检索的效率。\n\n- 索引可以提升查询速度，会影响where和order by。\n- 索引是针对字段的，需要添加到字段上。给某一列添加索引的时候，数据库会将这一列的数据进行提取、转换、再存储。存储下来的数据就是索引。当查询的时候，会先查询索引数据，能够更快速的找到相关信息。\n- 索引在大量数据场景下效果明显。\n\n## 常见索引分类\n\n- 从索引的存储结构划分:B Tree索引、Hash索引、fulltext全文索引、R Tree索引(了解) \n\n- **从应用层次划分:主键索引、唯一索引、普通索引、复合索引** \n\n- 从索引的键值(字段)类型划分:主键索引、辅助索引(二级索引) \n\n- 从索引数据和内容数据逻辑关系划分:聚集索引(聚簇索引)、非聚集索引(非聚簇索 引)\n\n## 主键索引(primary key)\n\n- 数据表添加主键的时候，会自动穿件逐渐索引，主键索引也是一种唯一索引。\n- 一个表可以没有主见，但最多只能有一个主键，且主键是唯一的、不能为Null。\n- 根据主键进行where条件查询，效率高。\n\n## 唯一索引(unique)\n\n特点：索引列的值只能出现一次，不能重复，保证唯一。\n\n在许多场合，人们创建唯一索引不是为了提高查询速度，而是为了避免数据重复。（使用唯一约束效果相同）\n\n```sql\n# 创建表的时候直接添加唯一索引\nCREATE TABLE 表名( \n  列名 类型(长度),\n\tUNIQUE [索引名称] (列名)\n);\n\n# 在已有的表上创建索引\ncreate unique index 索引名 on 表名(列名[长度])\ncreate unique index index_dname on test_index(dname);\n\n# 修改表结构添加索引\nALTER TABLE 表名 ADD UNIQUE 索引名( 列名 )\n```\n\n## 普通索引(normal index)\n\n普通索引的唯一任务是加快检索的速度。一般为需要where条件查询或order by排序的列添加普通索引。\n\n普通索引不要求数据唯一、非空。\n\n```sql\n# 在已有的表上创建索引\ncreate index 索引名 on 表名(列名[长度])\n\n# 修改表结构添加索引\nalter table 表名 add index 索引名 (列名)\n```\n\n## 复合索引\n\n创建普通索引时，同时写入多个字段。\n\n复合索引一般用在，需要对多个字段进行where条件查询或order by排序。\n\n```sql\n# 在已有的表上创建索引\ncreate index 索引名 on 表名(列名1, 列名2,...)\n\n# 修改表结构添加索引\nalter table 表名 add index 索引名 (列名1， 列名2,...)\n```\n\n⚠️注意：创建复合索引时要注意字段顺序，创建索引时字段的顺序，要和查询条件中字段的顺序保持一致。\n\n```sql\nwhere 字段1=‘’ and 字段2=‘’\t-- 字段1，字段2\n\ncreate index 索引名 on 表名(字段1, 字段2) -- 字段1，字段2；不能写成 字段2，字段1\n```\n\n⚠️注意：区别复合索引和多个单列索引。\n\n```sql\n# 复合索引\ncreate index 索引名 on 表名(列名1, 列名2) -- 字段顺序要和查询条件中保持一致\n\n# 多个单列索引\ncreate index 索引名 on 表名(列名1) -- 不需要考虑字段顺序\ncreate index 索引名 on 表名(列名2)\n```\n\n## 删除索引\n\n```sql\nalter table 表名 drop index 索引名;\n```\n\n# 视图\n\n概念：\n\n- 视图是一种虚拟表。（与之对应的是实体表，比如通过create语句创建的表）\n- 视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。\n-  向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句。\n- 视图向用户提供基表（实体表或者其他视图）数据的另一种表现形式。\n\n```sql\ncreate view 视图名 [column_list] as select语句;\nview: 表示视图\ncolumn_list: 可选参数，表示属性清单，指定视图中各个属性的名称，默认情况下，与 SELECT语句中查询的属性相同\nas : 表示视图要执行的操作\nselect语句: 向视图提供数据内容\n```\n\n作用：\n\n- 权限控制时可以使用\n- 简化复杂的多表查询\n\nsql中视图的概念类似于编程中封装函数的概念，将一段复杂的sql语句封装成一个视图，之后只需通过引用视图名进行查询就能得到结果。并且可以决定从视图中只查询某几个字段的数据，做到权限控制，就像函数可以指定返回的值一样。\n\n```sql\n# 需求1: 查询各个分类下的商品平均价格\ncreate view cp_view as\nselect *\nfrom category c\njoin products p\non c.cid = p.category_id; -- 注意这里必须有分号;结束\n\nselect cname, avg(price)\nfrom cp_view\ngroup by cname\n\n# 普通写法\nselect cname, avg(price)\nfrom products p left join category c\non p.category_id = c.cid\ngroup by c.cname\n```\n\n```sql\n# 需求2: 查询鞋服分类下最贵的商品的全部信息\ncreate view cp_view2 as \nselect c.cid, c.cname, p.pid,p.pname, p.price, p.flag, rank() over(partition by c.cname order by p.price desc) _rank\nfrom products p left join category c \non p.category_id = c.cid;\n\nselect * from cp_view2 where cname = '鞋服' and _rank = 1\n\n# 普通写法\nselect *\nfrom (\nselect c.cid, c.cname, p.pid,p.pname, p.price, p.flag, rank() over(partition by c.cname order by p.price desc) _rank\nfrom products p left join category c \non p.category_id = c.cid \n)a\nwhere a.cname = '鞋服' and a._rank = 1\n```\n\n视图和表的区别：\n\n- 视图是建立在表的基础上，表存储数据库中的数据，而视图只是做一个数据的展示 。\n- 通过视图不能改变表中数据(一般情况下视图中的数据都是表中的列 经过计算得到的结果, 不允许更新)。\n-  删除视图，表不受影响，而删除表，视图不再起作用。\n\n# 作业——知识点\n\n## 留存\n\n留存：指基准日到APP的用户在之后的n日当天返回APP的人数。\n\n留存率 = 基准日之后的n天当日返回的用户数 / 基准日的用户数 * 100%。\n\n\n\n留存代表一个用户愿意再次使用你的产品;而一个产品能够被用户再次使用，意味着这个产品是能够满\n\n足用户长期需求的，能够让用户产生一定粘性的产品。\n\n\n\n活跃用户 = 新增用户 + 留存用户\n\n\n\n如今互联网产品大多为免费产品，依靠持续的广告转化、用户持续的购买转化、用户持续的会员付费来维持收益。\n\n持续的广告转化、购买、会员付费，我们就 需要每天都有一定量的用户来完成以上过程，也就是说我们需要我们的产品每天都是有活跃用户的。\n\n从活跃用户的构成，我们就知道怎么维持我们的活跃用户规模：一方面持续有新用户流入，另一方 面持续有留存用户留存。\n\n\n\n为什么留存用户重要?部分有过从业经验的同学应该知道，产品的自然新增用户是比较少的，如果 我们仅靠产品自然用户增长，那么必然我们的活跃用户量级会非常小，虽然能够获得收益，但是这部分 收益很可能养不起我们的公司;但是如果我们想要用购买新用户的方式获得持续的较大规模的用户池， 又会产生比较大的成本，这样做容易亏本。所以我们需要新增留存两手抓;想方设法留住我们新增的用 户，让其长期地在我们的产品内产生价值，这样做，比起单做新增，在成本和效果上都是要好的。\n\n\n\n**留存的主要应用场景有两个：**\n\n- 一个是产品整体视角的持续留存情况;也就是我们需要定期分析用户在产品的留存是否维持在一个正常 的范围，有没有突然地涨跌情况，如果有的话问题出在哪里，为什么会出现这样的问题，如何解决留存 异常的问题。遇到这类问题首先需要确定的是整体用户的留存异常还是个别群体用户的留存异常，如果 是整体用户的留存异常，我们需要分析我们的产品是否发生异常，可以通过用户的行为路径确定异常产 品位置;如果是个别用户的留存异常，需要通过用户拆解的方法来定位有异常的用户群体，然后通过这 类用户的特征来分析问题原因。\n\n- 一个是新增用户视角的每批新增用户留存情况。一般出现在计算投放ROI的场景，也就是我们投放一批 用户，能够给我们带来多少收益。我们会用这些用户的“整个生命周期能够带来的收入”(LTV)去除以 “投放时的支出”来计算我们的ROI。“整个生命周期能够带来的收入”计算的是引入一批新用户，当用户完 全流失时，这部分用户所带来的所有收入。但是有时我们需要提前预估新用户在整个生命周期能够带来 的收入，我们就需要首先用留存来估计用户的生命周期，然后用估计出的生命周期再去计算用户的整个 生命周期能够带来的收入。\n\n**什么企业不关心留存：** \n\n需要用户产生持续活跃，持续转化，持续消费的企业都关心用户的留存。那么，什么样的企业不关心用户留存?\n\n- 部分线下企业存在数据难以获取的问题，所以对留存关注比较少，比如线下的商场，除非用户产生购买 行为，否则很难探知用户在什么情况下有回流。\n\n- 部分存在一锤子买卖的企业也不太关心留存，比如说用户在一次买断商品后再也不会产生后续购买或价 值转化行为，这类企业也不怎么关注留存。比如PC单机游戏;比如一次付费的工具类产品(线上线下类 工具都存在这个情况)。\n\n## 周同比\n\n周同比：周同比适用于以周为周期变动的数据，用于观察每天的数据较上周同一天的数据变化。\n\n现有互联网数据多以周为周期变动，一周内每一天的数据都有其特点:\n\n- 如工作类APP，周一会是每一周的高峰，然后向周五逐渐递减，周五到周六又会有一个锐减的过 程，周日与周六趋于平缓;\n\n- 如娱乐类APP，周一会较周末锐减，然后向周四逐渐递减，周五会有一个跃升的过程，周六会再次 跃升，周日会较周六下降;\n\n一般遇到这样的变动趋势，如果单纯的分析每一天较上一天的变动情况，就容易分析出错误结论。所 以，在我们分析带有周期类数据时，一定要先将周期提炼出来，使用周期的同比数据做分析，会得出更 有价值，更加准确的结论。\n\n## 平台模式\n\n如今的大多数内容APP都是以平台模式运营的。\n\n什么叫做平台模式?\n\n比如我们现在能接触到的大多数内容产品“抖音”、“Bilibili”、“微博”、“今日头条”等等。我们使用到的这个 APP，是由APP的制作公司提供的，也就是这个APP会有几个主要的页面，每个页面怎么引导用户进入内 容页面，播放内容的方式有哪些、内容间切换会用什么方式等等，都是我们的APP制作公司决定的;而 我们在这个APP里看到的大多数内容，都是由内容作者提供的。\n\n\n\n","slug":"【数据分析】第二阶段：MySQL数据分析实战（二）","published":1,"updated":"2021-05-11T02:43:21.735Z","_id":"ckohezboz001dwct4evecg8t2","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"窗口函数\"><a href=\"#窗口函数\" class=\"headerlink\" title=\"窗口函数\"></a>窗口函数</h1><p>窗口函数（也叫分析函数），从MySQL8.0开始支持。</p>\n<p>窗口在数据中限定出一个范围，函数对这个范围内的集合进行统计。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名() over(子句)</span><br></pre></td></tr></table></figure>\n\n<p>over就是窗口，通过子句限定窗口的范围，函数在该范围内执行。</p>\n<p>over中的子句具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名() over(partition by 分组字段1,分组字段2... order by &lt;排序字段&gt; rows between &lt;范围起始行数&gt; and &lt;范围结束行数&gt;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>⚠️注意：</strong></p>\n<ul>\n<li><strong>子句间<em>没有</em>逗号，间隔</strong></li>\n<li><strong>over子句中多个字段用逗号，分割，不是用and</strong></li>\n</ul>\n<p>具体示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 选出D1行至D2行的记录集合，在该集合内，按照B分组，按照C排序，最后每一组对A求和</span><br><span class=\"line\">sum(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...) </span><br><span class=\"line\">avg(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...)</span><br><span class=\"line\"></span><br><span class=\"line\">A: 需要被加工的字段名称 </span><br><span class=\"line\">B: 分组的字段名称</span><br><span class=\"line\">C: 排序的字段名称</span><br><span class=\"line\">D: 计算的行数范围</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rows between 2 preceding(在..之前) and current row # 范围：当前查询位置的前2行——当前行，共3行</span><br><span class=\"line\">rows between unbounded(无限) preceding(在..之前) and current row # 范围：当前查询位置的前所有行——当前行</span><br><span class=\"line\">rows between current row and unbounded(无限) following(在...之后) # 范围：当前查询位置的当前行——之后的所有行</span><br><span class=\"line\">rows between 3 preceding and current row # 范围：当前查询位置的前3行——当前行，共4行</span><br><span class=\"line\">rows between 3 preceding and 1 following # 范围：当前查询位置的前3行——后1行，共5行</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当不指定rows between时，窗口规范默认是：该partition分组中rows between unbounded preceding and current row</li>\n<li>当不指定order by 和 rows between时, 窗口规范默认是：该partition分组中rows between unbounded preceding and unbounded following</li>\n<li>当不指定partition时，order by的作用范围是整个数据表；指定partition时，order by的作用范围是当前分组</li>\n<li>当over子句中什么都不写时，窗口规范默认是整张表全部数据</li>\n</ul>\n<p><strong>⚠️注意：where优先级&gt;over，where是对源数据进行过滤，过滤后的结果集再执行over或group by等操作。</strong></p>\n<h2 id=\"聚合类窗口函数\"><a href=\"#聚合类窗口函数\" class=\"headerlink\" title=\"聚合类窗口函数\"></a>聚合类窗口函数</h2><ul>\n<li>sum()</li>\n<li>count()</li>\n<li>avg()</li>\n<li>Max()</li>\n<li>min()</li>\n</ul>\n<p>窗口函数下的聚合函数 和 普通场景下的聚合函数区别：</p>\n<p>普通场景下的聚合函数是将多条记录聚合为一条**(多到一)<strong>；窗口函数下是每条记录都会执 行，有几条记录执行完还是几条</strong>(多到多)**。</p>\n<h3 id=\"累计计算\"><a href=\"#累计计算\" class=\"headerlink\" title=\"累计计算\"></a>累计计算</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">1</span>：查询出<span class=\"number\">2019</span>年每月的支付总额和当年累积支付总额</span><br><span class=\"line\"><span class=\"keyword\">select</span> a._month, a._pay_mount_sum, <span class=\"built_in\">sum</span>(a._pay_mount_sum) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> a._month)</span><br><span class=\"line\"><span class=\"keyword\">from</span></span><br><span class=\"line\">(</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time) <span class=\"keyword\">as</span> _month, <span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">as</span> _pay_mount_sum</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\">)a</span><br><span class=\"line\"></span><br><span class=\"line\"># ❌错误写法</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time), <span class=\"built_in\">sum</span>(pay_amount)，<span class=\"built_in\">sum</span>(<span class=\"built_in\">sum</span>(pay_amount)) <span class=\"keyword\">over</span>(<span class=\"keyword\">month</span>(pay_time))</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\"><span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\"># 这么写的想法：<span class=\"keyword\">group</span> <span class=\"keyword\">by</span>分组已经取得了月份、每个月支付总额，那么再直接用窗口函数就能取得每个月的累计支付总额</span><br><span class=\"line\"># 错误原因：<span class=\"keyword\">group</span> <span class=\"keyword\">by</span>只是完成了按月分组，必须还要完成<span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time), <span class=\"built_in\">sum</span>(pay_amount)才能获取最终的数据集，如果在 <span class=\"keyword\">select</span>中加入窗口函数，此时并没有取得数据集，窗口函数也就无法执行。所以需要子查询的方式，先让<span class=\"keyword\">group</span> <span class=\"keyword\">by</span>完成<span class=\"keyword\">select</span>取得数据集，再将数 据集作为表通过子查询执行窗口函数</span><br><span class=\"line\"></span><br><span class=\"line\"># 需求<span class=\"number\">2</span>：查询出<span class=\"number\">2018</span><span class=\"number\">-2019</span>年每月的支付总额和当年累积支付总额</span><br><span class=\"line\"><span class=\"keyword\">select</span> a._year,a._month,<span class=\"built_in\">sum</span>(a.pay_amount_sum) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> a._year <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> a._month)</span><br><span class=\"line\"><span class=\"keyword\">from</span></span><br><span class=\"line\">(</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"keyword\">year</span>(pay_time) _year, <span class=\"keyword\">month</span>(pay_time) _month, <span class=\"built_in\">sum</span>(pay_amount) pay_amount_sum</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">year</span>(pay_time), <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\">\t<span class=\"keyword\">having</span> _year <span class=\"keyword\">in</span> (<span class=\"number\">2018</span>,<span class=\"number\">2019</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> _year, _month</span><br><span class=\"line\">)a</span><br><span class=\"line\"></span><br><span class=\"line\"># 需求<span class=\"number\">3</span>: 查询出<span class=\"number\">2019</span>年每个月的近三月移动平均支付金额</span><br><span class=\"line\"><span class=\"keyword\">select</span> a._month, a._pay_amount, <span class=\"built_in\">avg</span>(a._pay_amount) <span class=\"keyword\">over</span>(<span class=\"keyword\">rows</span> <span class=\"keyword\">between</span> <span class=\"number\">2</span> preceding <span class=\"keyword\">and</span> <span class=\"keyword\">current</span> <span class=\"type\">row</span>)</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time) _month, <span class=\"built_in\">sum</span>(pay_amount) _pay_amount</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> _month</span><br><span class=\"line\">\t<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> _month</span><br><span class=\"line\">)a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"排序窗口函数\"><a href=\"#排序窗口函数\" class=\"headerlink\" title=\"排序窗口函数\"></a>排序窗口函数</h2><h3 id=\"rank、dense-rank、row-number\"><a href=\"#rank、dense-rank、row-number\" class=\"headerlink\" title=\"rank、dense_rank、row_number\"></a>rank、dense_rank、row_number</h3><ul>\n<li>rank() over(partition by &lt;分组字段&gt; order by &lt;排序字段&gt;)，返回排序后的排名（并列排名占用名次）</li>\n<li>Dense_rank() over(partition by &lt;分组字段&gt; order by &lt;排序字段&gt;)，返回排序后的排名（并列排名不占用名次）</li>\n<li>Row_number() over(partition by &lt;分组字段&gt; order by &lt;排序字段&gt;)，返回排序后的行号（从1开始）</li>\n</ul>\n<p>⚠️这三种排序函数不需要参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 语法</span><br><span class=\"line\">row_number(无参数) over(......) </span><br><span class=\"line\">rank(无参数) over(......) </span><br><span class=\"line\">dense_rank(无参数) over(......)</span><br><span class=\"line\"></span><br><span class=\"line\">在rank()函数，如果有并列情况，会占用下一个名次的位置，比如，成绩为100的学生有三个并列第一，那么99分的学生是第二名，通过rank()函数，名次是：1,1,1,4；</span><br><span class=\"line\"></span><br><span class=\"line\">在dense()函数中，如果有并列的情况，不会占用下一个名词，同用上个例子，名次是：1,1,1,2；</span><br><span class=\"line\"></span><br><span class=\"line\">在row_number()函数中，会忽略并列的情况，同用上述例子，名次是：1,2,3,4;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">5</span>: <span class=\"number\">2020</span>年<span class=\"number\">1</span>月，购买商品品类数的用户排名</span><br><span class=\"line\"># 本案例中 不需要先子查询再对子查询结果使用排序函数。要考虑两个问题，一是所使用的函数是在生成数据集的同时就能使用，还是要生成完毕才可以使用；二是在使用函数的时，是否已经生成了数据集。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\tuser_name,</span><br><span class=\"line\">\t<span class=\"comment\">-- 这里使用distinct去重，因为一个用户可能在不同的时间购买了同一个品类的商品</span></span><br><span class=\"line\">\t<span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) goods_c_count,</span><br><span class=\"line\">\t<span class=\"built_in\">row_number</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _row_number,</span><br><span class=\"line\">\t<span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _rank,</span><br><span class=\"line\">\t<span class=\"built_in\">dense_rank</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _dense_rank </span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\tuser_trade </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">\t<span class=\"keyword\">YEAR</span> ( pay_time ) <span class=\"operator\">=</span> <span class=\"number\">2020</span> </span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> <span class=\"keyword\">MONTH</span> ( pay_time ) <span class=\"operator\">=</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\tuser_name</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_18-26-26.jpg\"></p>\n<h3 id=\"ntile\"><a href=\"#ntile\" class=\"headerlink\" title=\"ntile\"></a>ntile</h3><ul>\n<li>ntile(n) over(partition by &lt;分组字段A&gt; order by &lt;排序字段B&gt;)</li>\n</ul>\n<p><strong>n</strong>:切分的片数<br><strong>A</strong>:分组的字段名称<br><strong>B</strong>:排序的字段名称</p>\n<p>ntile(<strong>n</strong>)，用于将分组数据按照顺序切分成n片，返回当前切片值。</p>\n<p>Ntile(n) over(partition by &lt;分组字段A&gt; order by &lt;排序字段B&gt;)函数简单的说，就是对将个分组（没有分组就是整张表）的数据，先按照order by字段排序，然后分成n组，然后按照排序给每个组排名。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">6</span>: 查询出将<span class=\"number\">2020</span>年<span class=\"number\">2</span>月的支付用户，按照支付金额分成<span class=\"number\">5</span>组后的结果</span><br><span class=\"line\"><span class=\"keyword\">select</span> user_name, <span class=\"built_in\">sum</span>(pay_amount) pay_amount, <span class=\"built_in\">ntile</span>(<span class=\"number\">5</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">desc</span>)level</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\"><span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2020</span></span><br><span class=\"line\"><span class=\"keyword\">and</span> <span class=\"keyword\">month</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> user_name</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_21-42-58.jpg\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">7</span>：查询出<span class=\"number\">2020</span>年支付金额排名前<span class=\"number\">30</span><span class=\"operator\">%</span>的所有用户</span><br><span class=\"line\"><span class=\"keyword\">select</span> a.user_name, a.pay_amount, a.level</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> user_name, <span class=\"built_in\">sum</span>(pay_amount)pay_amount, <span class=\"built_in\">ntile</span>(<span class=\"number\">10</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">desc</span>) level</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2020</span></span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> user_name</span><br><span class=\"line\">)a</span><br><span class=\"line\"><span class=\"keyword\">where</span> a.level <span class=\"operator\">&lt;</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"偏移分析函数\"><a href=\"#偏移分析函数\" class=\"headerlink\" title=\"偏移分析函数\"></a>偏移分析函数</h2><h3 id=\"lag、lead\"><a href=\"#lag、lead\" class=\"headerlink\" title=\"lag、lead\"></a>lag、lead</h3><p>lag() 函数，允许您向上偏移多行并从当前行访问偏移行的数据</p>\n<p>lead() 函数，允许您向下看多行并从当前行访问偏移行的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 向上偏移</span><br><span class=\"line\">lag(&lt;expression&gt;[,offset[, default_value]]) over (partition by expr,... order by expr [asc|desc],...) </span><br><span class=\"line\"># 向下偏移</span><br><span class=\"line\">lead(&lt;expression&gt;[,offset[, default_value]]) over (partition by expr,... order by expr [asc|desc],...) </span><br></pre></td></tr></table></figure>\n\n<p>执行到当前分组的某一行时，返回偏移offset行的行的expression字段的值，如果偏移量超过了分组或窗口范围，返回default_value。</p>\n<p>如果不写offset参数，默认偏移1行。</p>\n<p>如果不写default_value参数，默认值为null。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> user_name,pay_time,</span><br><span class=\"line\">       <span class=\"built_in\">lag</span>(pay_time,<span class=\"number\">1</span>,pay_time) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lag1,</span><br><span class=\"line\">\t\t\t<span class=\"comment\">-- 没有传入偏移量，那么默认就是1，找不到的话，此处也没有给默认值，为 null</span></span><br><span class=\"line\">\t\t\t <span class=\"built_in\">lag</span>(pay_time) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time)lag1_s,</span><br><span class=\"line\">       <span class=\"built_in\">lag</span>(pay_time,<span class=\"number\">2</span>,pay_time) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lag2,</span><br><span class=\"line\">       <span class=\"built_in\">lag</span>(pay_time,<span class=\"number\">2</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time)lag2_s</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> user_trade</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> user_name <span class=\"keyword\">in</span> (<span class=\"string\">&#x27;King&#x27;</span>,<span class=\"string\">&#x27;West&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_22-54-39.jpg\"></p>\n<p><strong>在实际应用当中，若要用到取今天和昨天的某字段差值时，Lag和Lead函数的应用就显得尤为重要。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">10</span>: 查询出支付时间间隔超过<span class=\"number\">100</span>天的用户数</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> a.user_name)</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> </span><br><span class=\"line\">  \tuser_name,pay_time, </span><br><span class=\"line\">  \t<span class=\"built_in\">lead</span>(pay_time,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lead_time </span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">)a</span><br><span class=\"line\"><span class=\"keyword\">where</span> a.lead_time <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span></span><br><span class=\"line\"><span class=\"keyword\">and</span> datediff(a.lead_time,a.pay_time) <span class=\"operator\">&gt;</span> <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">11</span>: 查询出每年支付时间间隔最长的用户</span><br><span class=\"line\"># ✅</span><br><span class=\"line\"><span class=\"keyword\">select</span> b.user_name, <span class=\"keyword\">year</span>(b.pay_time), b.diff_time</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> </span><br><span class=\"line\">\t\t\ta.user_name, a.pay_time, </span><br><span class=\"line\">\t\t\ta.lead_time, datediff(a.lead_time,a.pay_time) diff_time, </span><br><span class=\"line\">\t\t\t<span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> <span class=\"keyword\">year</span>(a.pay_time) <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> datediff(a.lead_time,a.pay_time) <span class=\"keyword\">desc</span>) _rank</span><br><span class=\"line\">\t\t<span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> user_name, pay_time, <span class=\"built_in\">lead</span>(pay_time,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name, <span class=\"keyword\">year</span>(pay_time) <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lead_time</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t\t)a</span><br><span class=\"line\">\t\t<span class=\"keyword\">where</span> a.lead_time <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span></span><br><span class=\"line\">\t)b</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> b._rank <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"># ❌，错误原因：</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">在第2层子查询计算出了每年每个用户的支付间隔后，外套一层查询，并按年分组，然后用max（）选出每组，也就是每年间隔时间最长的人，</span></span><br><span class=\"line\"><span class=\"comment\">这时发现，在select中只有max(b.diff_time)时不会报错，但加上b.user_name就会报错。</span></span><br><span class=\"line\"><span class=\"comment\">这时因为，一年中存在多个用户的支付时间间隔并列最长，这时max(b.diff_time)会默认返回第一个(还是随机一个），但是user_name有多个，系统不知道该返回哪个，就会报错了。</span></span><br><span class=\"line\"><span class=\"comment\">所以这里不能用max，应该用rank()函数，这样就考虑到了并列最大的情况。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> b.user_name, <span class=\"built_in\">max</span>(b.diff_time)</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> a.user_name, a.pay_time, a.lead_time, datediff(a.lead_time,a.pay_time) diff_time</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> user_name, pay_time, <span class=\"built_in\">lead</span>(pay_time,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name, <span class=\"keyword\">year</span>(pay_time) <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lead_time</span><br><span class=\"line\">\t\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t)a</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> a.lead_time <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span></span><br><span class=\"line\">)b</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">year</span>(b.pay_time)</span><br></pre></td></tr></table></figure>\n\n<p><strong>max()并列最大错误测试：</strong></p>\n<p>测试表数据</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-07-31.jpg\"></p>\n<p>只select max()不报错</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-08-38.jpg\"></p>\n<p>select user_id报错</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-09-15.jpg\"></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>聚合窗口函数 不能 在第一次select时同时执行，必须先select完毕，结果集再作为新表通过子查询使用聚合窗口函数。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 报错❌</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\t<span class=\"keyword\">month</span>(pay_time) <span class=\"keyword\">as</span> _month, </span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time))</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\"><span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\"></span><br><span class=\"line\"># 正确✅</span><br><span class=\"line\"><span class=\"keyword\">select</span> a._month, a._pay_mount_sum, <span class=\"built_in\">sum</span>(a._pay_amount_sum) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> a._month)</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time) <span class=\"keyword\">as</span> _month, <span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">as</span> _pay_amount_sum</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\">)a</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>排序窗口函数、偏移分析函数 可以 在第一次select时同时执行。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ✅</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\tuser_name,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) goods_c_count,</span><br><span class=\"line\">\t<span class=\"built_in\">row_number</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _row_number,</span><br><span class=\"line\">\t<span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _rank,</span><br><span class=\"line\">\t<span class=\"built_in\">dense_rank</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _dense_rank </span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\tuser_trade </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">\t<span class=\"keyword\">YEAR</span> ( pay_time ) <span class=\"operator\">=</span> <span class=\"number\">2020</span> </span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> <span class=\"keyword\">MONTH</span> ( pay_time ) <span class=\"operator\">=</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\tuser_name</span><br><span class=\"line\">\t</span><br><span class=\"line\"># ✅</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\"> \tuser_name,pay_time, </span><br><span class=\"line\"> \t<span class=\"built_in\">lead</span>(pay_time,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lead_time </span><br><span class=\"line\"><span class=\"keyword\">from</span> user_trade</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p>字典的目录就是一种索引机制，提高检索的效率。</p>\n<ul>\n<li>索引可以提升查询速度，会影响where和order by。</li>\n<li>索引是针对字段的，需要添加到字段上。给某一列添加索引的时候，数据库会将这一列的数据进行提取、转换、再存储。存储下来的数据就是索引。当查询的时候，会先查询索引数据，能够更快速的找到相关信息。</li>\n<li>索引在大量数据场景下效果明显。</li>\n</ul>\n<h2 id=\"常见索引分类\"><a href=\"#常见索引分类\" class=\"headerlink\" title=\"常见索引分类\"></a>常见索引分类</h2><ul>\n<li><p>从索引的存储结构划分:B Tree索引、Hash索引、fulltext全文索引、R Tree索引(了解) </p>\n</li>\n<li><p><strong>从应用层次划分:主键索引、唯一索引、普通索引、复合索引</strong> </p>\n</li>\n<li><p>从索引的键值(字段)类型划分:主键索引、辅助索引(二级索引) </p>\n</li>\n<li><p>从索引数据和内容数据逻辑关系划分:聚集索引(聚簇索引)、非聚集索引(非聚簇索 引)</p>\n</li>\n</ul>\n<h2 id=\"主键索引-primary-key\"><a href=\"#主键索引-primary-key\" class=\"headerlink\" title=\"主键索引(primary key)\"></a>主键索引(primary key)</h2><ul>\n<li>数据表添加主键的时候，会自动穿件逐渐索引，主键索引也是一种唯一索引。</li>\n<li>一个表可以没有主见，但最多只能有一个主键，且主键是唯一的、不能为Null。</li>\n<li>根据主键进行where条件查询，效率高。</li>\n</ul>\n<h2 id=\"唯一索引-unique\"><a href=\"#唯一索引-unique\" class=\"headerlink\" title=\"唯一索引(unique)\"></a>唯一索引(unique)</h2><p>特点：索引列的值只能出现一次，不能重复，保证唯一。</p>\n<p>在许多场合，人们创建唯一索引不是为了提高查询速度，而是为了避免数据重复。（使用唯一约束效果相同）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建表的时候直接添加唯一索引</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> 表名( </span><br><span class=\"line\">  列名 类型(长度),</span><br><span class=\"line\">\t<span class=\"keyword\">UNIQUE</span> [索引名称] (列名)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"># 在已有的表上创建索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名[长度])</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> index index_dname <span class=\"keyword\">on</span> test_index(dname);</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改表结构添加索引</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 表名 <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> 索引名( 列名 )</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"普通索引-normal-index\"><a href=\"#普通索引-normal-index\" class=\"headerlink\" title=\"普通索引(normal index)\"></a>普通索引(normal index)</h2><p>普通索引的唯一任务是加快检索的速度。一般为需要where条件查询或order by排序的列添加普通索引。</p>\n<p>普通索引不要求数据唯一、非空。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在已有的表上创建索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名[长度])</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改表结构添加索引</span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 表名 <span class=\"keyword\">add</span> index 索引名 (列名)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h2><p>创建普通索引时，同时写入多个字段。</p>\n<p>复合索引一般用在，需要对多个字段进行where条件查询或order by排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在已有的表上创建索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名<span class=\"number\">1</span>, 列名<span class=\"number\">2</span>,...)</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改表结构添加索引</span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 表名 <span class=\"keyword\">add</span> index 索引名 (列名<span class=\"number\">1</span>， 列名<span class=\"number\">2</span>,...)</span><br></pre></td></tr></table></figure>\n\n<p>⚠️注意：创建复合索引时要注意字段顺序，创建索引时字段的顺序，要和查询条件中字段的顺序保持一致。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">where</span> 字段<span class=\"number\">1</span><span class=\"operator\">=</span>‘’ <span class=\"keyword\">and</span> 字段<span class=\"number\">2</span><span class=\"operator\">=</span>‘’\t<span class=\"comment\">-- 字段1，字段2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(字段<span class=\"number\">1</span>, 字段<span class=\"number\">2</span>) <span class=\"comment\">-- 字段1，字段2；不能写成 字段2，字段1</span></span><br></pre></td></tr></table></figure>\n\n<p>⚠️注意：区别复合索引和多个单列索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 复合索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名<span class=\"number\">1</span>, 列名<span class=\"number\">2</span>) <span class=\"comment\">-- 字段顺序要和查询条件中保持一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 多个单列索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名<span class=\"number\">1</span>) <span class=\"comment\">-- 不需要考虑字段顺序</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 表名 <span class=\"keyword\">drop</span> index 索引名;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h1><p>概念：</p>\n<ul>\n<li>视图是一种虚拟表。（与之对应的是实体表，比如通过create语句创建的表）</li>\n<li>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。</li>\n<li> 向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句。</li>\n<li>视图向用户提供基表（实体表或者其他视图）数据的另一种表现形式。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> 视图名 [column_list] <span class=\"keyword\">as</span> <span class=\"keyword\">select</span>语句;</span><br><span class=\"line\"><span class=\"keyword\">view</span>: 表示视图</span><br><span class=\"line\">column_list: 可选参数，表示属性清单，指定视图中各个属性的名称，默认情况下，与 <span class=\"keyword\">SELECT</span>语句中查询的属性相同</span><br><span class=\"line\"><span class=\"keyword\">as</span> : 表示视图要执行的操作</span><br><span class=\"line\"><span class=\"keyword\">select</span>语句: 向视图提供数据内容</span><br></pre></td></tr></table></figure>\n\n<p>作用：</p>\n<ul>\n<li>权限控制时可以使用</li>\n<li>简化复杂的多表查询</li>\n</ul>\n<p>sql中视图的概念类似于编程中封装函数的概念，将一段复杂的sql语句封装成一个视图，之后只需通过引用视图名进行查询就能得到结果。并且可以决定从视图中只查询某几个字段的数据，做到权限控制，就像函数可以指定返回的值一样。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">1</span>: 查询各个分类下的商品平均价格</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> cp_view <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> category c</span><br><span class=\"line\"><span class=\"keyword\">join</span> products p</span><br><span class=\"line\"><span class=\"keyword\">on</span> c.cid <span class=\"operator\">=</span> p.category_id; <span class=\"comment\">-- 注意这里必须有分号;结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> cname, <span class=\"built_in\">avg</span>(price)</span><br><span class=\"line\"><span class=\"keyword\">from</span> cp_view</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> cname</span><br><span class=\"line\"></span><br><span class=\"line\"># 普通写法</span><br><span class=\"line\"><span class=\"keyword\">select</span> cname, <span class=\"built_in\">avg</span>(price)</span><br><span class=\"line\"><span class=\"keyword\">from</span> products p <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> category c</span><br><span class=\"line\"><span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> c.cname</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">2</span>: 查询鞋服分类下最贵的商品的全部信息</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> cp_view2 <span class=\"keyword\">as</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span> c.cid, c.cname, p.pid,p.pname, p.price, p.flag, <span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> c.cname <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> p.price <span class=\"keyword\">desc</span>) _rank</span><br><span class=\"line\"><span class=\"keyword\">from</span> products p <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> category c </span><br><span class=\"line\"><span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> cp_view2 <span class=\"keyword\">where</span> cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;鞋服&#x27;</span> <span class=\"keyword\">and</span> _rank <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 普通写法</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\"><span class=\"keyword\">select</span> c.cid, c.cname, p.pid,p.pname, p.price, p.flag, <span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> c.cname <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> p.price <span class=\"keyword\">desc</span>) _rank</span><br><span class=\"line\"><span class=\"keyword\">from</span> products p <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> category c </span><br><span class=\"line\"><span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid </span><br><span class=\"line\">)a</span><br><span class=\"line\"><span class=\"keyword\">where</span> a.cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;鞋服&#x27;</span> <span class=\"keyword\">and</span> a._rank <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>视图和表的区别：</p>\n<ul>\n<li>视图是建立在表的基础上，表存储数据库中的数据，而视图只是做一个数据的展示 。</li>\n<li>通过视图不能改变表中数据(一般情况下视图中的数据都是表中的列 经过计算得到的结果, 不允许更新)。</li>\n<li> 删除视图，表不受影响，而删除表，视图不再起作用。</li>\n</ul>\n<h1 id=\"作业——知识点\"><a href=\"#作业——知识点\" class=\"headerlink\" title=\"作业——知识点\"></a>作业——知识点</h1><h2 id=\"留存\"><a href=\"#留存\" class=\"headerlink\" title=\"留存\"></a>留存</h2><p>留存：指基准日到APP的用户在之后的n日当天返回APP的人数。</p>\n<p>留存率 = 基准日之后的n天当日返回的用户数 / 基准日的用户数 * 100%。</p>\n<p>留存代表一个用户愿意再次使用你的产品;而一个产品能够被用户再次使用，意味着这个产品是能够满</p>\n<p>足用户长期需求的，能够让用户产生一定粘性的产品。</p>\n<p>活跃用户 = 新增用户 + 留存用户</p>\n<p>如今互联网产品大多为免费产品，依靠持续的广告转化、用户持续的购买转化、用户持续的会员付费来维持收益。</p>\n<p>持续的广告转化、购买、会员付费，我们就 需要每天都有一定量的用户来完成以上过程，也就是说我们需要我们的产品每天都是有活跃用户的。</p>\n<p>从活跃用户的构成，我们就知道怎么维持我们的活跃用户规模：一方面持续有新用户流入，另一方 面持续有留存用户留存。</p>\n<p>为什么留存用户重要?部分有过从业经验的同学应该知道，产品的自然新增用户是比较少的，如果 我们仅靠产品自然用户增长，那么必然我们的活跃用户量级会非常小，虽然能够获得收益，但是这部分 收益很可能养不起我们的公司;但是如果我们想要用购买新用户的方式获得持续的较大规模的用户池， 又会产生比较大的成本，这样做容易亏本。所以我们需要新增留存两手抓;想方设法留住我们新增的用 户，让其长期地在我们的产品内产生价值，这样做，比起单做新增，在成本和效果上都是要好的。</p>\n<p><strong>留存的主要应用场景有两个：</strong></p>\n<ul>\n<li><p>一个是产品整体视角的持续留存情况;也就是我们需要定期分析用户在产品的留存是否维持在一个正常 的范围，有没有突然地涨跌情况，如果有的话问题出在哪里，为什么会出现这样的问题，如何解决留存 异常的问题。遇到这类问题首先需要确定的是整体用户的留存异常还是个别群体用户的留存异常，如果 是整体用户的留存异常，我们需要分析我们的产品是否发生异常，可以通过用户的行为路径确定异常产 品位置;如果是个别用户的留存异常，需要通过用户拆解的方法来定位有异常的用户群体，然后通过这 类用户的特征来分析问题原因。</p>\n</li>\n<li><p>一个是新增用户视角的每批新增用户留存情况。一般出现在计算投放ROI的场景，也就是我们投放一批 用户，能够给我们带来多少收益。我们会用这些用户的“整个生命周期能够带来的收入”(LTV)去除以 “投放时的支出”来计算我们的ROI。“整个生命周期能够带来的收入”计算的是引入一批新用户，当用户完 全流失时，这部分用户所带来的所有收入。但是有时我们需要提前预估新用户在整个生命周期能够带来 的收入，我们就需要首先用留存来估计用户的生命周期，然后用估计出的生命周期再去计算用户的整个 生命周期能够带来的收入。</p>\n</li>\n</ul>\n<p><strong>什么企业不关心留存：</strong> </p>\n<p>需要用户产生持续活跃，持续转化，持续消费的企业都关心用户的留存。那么，什么样的企业不关心用户留存?</p>\n<ul>\n<li><p>部分线下企业存在数据难以获取的问题，所以对留存关注比较少，比如线下的商场，除非用户产生购买 行为，否则很难探知用户在什么情况下有回流。</p>\n</li>\n<li><p>部分存在一锤子买卖的企业也不太关心留存，比如说用户在一次买断商品后再也不会产生后续购买或价 值转化行为，这类企业也不怎么关注留存。比如PC单机游戏;比如一次付费的工具类产品(线上线下类 工具都存在这个情况)。</p>\n</li>\n</ul>\n<h2 id=\"周同比\"><a href=\"#周同比\" class=\"headerlink\" title=\"周同比\"></a>周同比</h2><p>周同比：周同比适用于以周为周期变动的数据，用于观察每天的数据较上周同一天的数据变化。</p>\n<p>现有互联网数据多以周为周期变动，一周内每一天的数据都有其特点:</p>\n<ul>\n<li><p>如工作类APP，周一会是每一周的高峰，然后向周五逐渐递减，周五到周六又会有一个锐减的过 程，周日与周六趋于平缓;</p>\n</li>\n<li><p>如娱乐类APP，周一会较周末锐减，然后向周四逐渐递减，周五会有一个跃升的过程，周六会再次 跃升，周日会较周六下降;</p>\n</li>\n</ul>\n<p>一般遇到这样的变动趋势，如果单纯的分析每一天较上一天的变动情况，就容易分析出错误结论。所 以，在我们分析带有周期类数据时，一定要先将周期提炼出来，使用周期的同比数据做分析，会得出更 有价值，更加准确的结论。</p>\n<h2 id=\"平台模式\"><a href=\"#平台模式\" class=\"headerlink\" title=\"平台模式\"></a>平台模式</h2><p>如今的大多数内容APP都是以平台模式运营的。</p>\n<p>什么叫做平台模式?</p>\n<p>比如我们现在能接触到的大多数内容产品“抖音”、“Bilibili”、“微博”、“今日头条”等等。我们使用到的这个 APP，是由APP的制作公司提供的，也就是这个APP会有几个主要的页面，每个页面怎么引导用户进入内 容页面，播放内容的方式有哪些、内容间切换会用什么方式等等，都是我们的APP制作公司决定的;而 我们在这个APP里看到的大多数内容，都是由内容作者提供的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"窗口函数\"><a href=\"#窗口函数\" class=\"headerlink\" title=\"窗口函数\"></a>窗口函数</h1><p>窗口函数（也叫分析函数），从MySQL8.0开始支持。</p>\n<p>窗口在数据中限定出一个范围，函数对这个范围内的集合进行统计。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名() over(子句)</span><br></pre></td></tr></table></figure>\n\n<p>over就是窗口，通过子句限定窗口的范围，函数在该范围内执行。</p>\n<p>over中的子句具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数名() over(partition by 分组字段1,分组字段2... order by &lt;排序字段&gt; rows between &lt;范围起始行数&gt; and &lt;范围结束行数&gt;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>⚠️注意：</strong></p>\n<ul>\n<li><strong>子句间<em>没有</em>逗号，间隔</strong></li>\n<li><strong>over子句中多个字段用逗号，分割，不是用and</strong></li>\n</ul>\n<p>具体示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 选出D1行至D2行的记录集合，在该集合内，按照B分组，按照C排序，最后每一组对A求和</span><br><span class=\"line\">sum(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...) </span><br><span class=\"line\">avg(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...)</span><br><span class=\"line\"></span><br><span class=\"line\">A: 需要被加工的字段名称 </span><br><span class=\"line\">B: 分组的字段名称</span><br><span class=\"line\">C: 排序的字段名称</span><br><span class=\"line\">D: 计算的行数范围</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rows between 2 preceding(在..之前) and current row # 范围：当前查询位置的前2行——当前行，共3行</span><br><span class=\"line\">rows between unbounded(无限) preceding(在..之前) and current row # 范围：当前查询位置的前所有行——当前行</span><br><span class=\"line\">rows between current row and unbounded(无限) following(在...之后) # 范围：当前查询位置的当前行——之后的所有行</span><br><span class=\"line\">rows between 3 preceding and current row # 范围：当前查询位置的前3行——当前行，共4行</span><br><span class=\"line\">rows between 3 preceding and 1 following # 范围：当前查询位置的前3行——后1行，共5行</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>当不指定rows between时，窗口规范默认是：该partition分组中rows between unbounded preceding and current row</li>\n<li>当不指定order by 和 rows between时, 窗口规范默认是：该partition分组中rows between unbounded preceding and unbounded following</li>\n<li>当不指定partition时，order by的作用范围是整个数据表；指定partition时，order by的作用范围是当前分组</li>\n<li>当over子句中什么都不写时，窗口规范默认是整张表全部数据</li>\n</ul>\n<p><strong>⚠️注意：where优先级&gt;over，where是对源数据进行过滤，过滤后的结果集再执行over或group by等操作。</strong></p>\n<h2 id=\"聚合类窗口函数\"><a href=\"#聚合类窗口函数\" class=\"headerlink\" title=\"聚合类窗口函数\"></a>聚合类窗口函数</h2><ul>\n<li>sum()</li>\n<li>count()</li>\n<li>avg()</li>\n<li>Max()</li>\n<li>min()</li>\n</ul>\n<p>窗口函数下的聚合函数 和 普通场景下的聚合函数区别：</p>\n<p>普通场景下的聚合函数是将多条记录聚合为一条**(多到一)<strong>；窗口函数下是每条记录都会执 行，有几条记录执行完还是几条</strong>(多到多)**。</p>\n<h3 id=\"累计计算\"><a href=\"#累计计算\" class=\"headerlink\" title=\"累计计算\"></a>累计计算</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">1</span>：查询出<span class=\"number\">2019</span>年每月的支付总额和当年累积支付总额</span><br><span class=\"line\"><span class=\"keyword\">select</span> a._month, a._pay_mount_sum, <span class=\"built_in\">sum</span>(a._pay_mount_sum) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> a._month)</span><br><span class=\"line\"><span class=\"keyword\">from</span></span><br><span class=\"line\">(</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time) <span class=\"keyword\">as</span> _month, <span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">as</span> _pay_mount_sum</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\">)a</span><br><span class=\"line\"></span><br><span class=\"line\"># ❌错误写法</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time), <span class=\"built_in\">sum</span>(pay_amount)，<span class=\"built_in\">sum</span>(<span class=\"built_in\">sum</span>(pay_amount)) <span class=\"keyword\">over</span>(<span class=\"keyword\">month</span>(pay_time))</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\"><span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\"># 这么写的想法：<span class=\"keyword\">group</span> <span class=\"keyword\">by</span>分组已经取得了月份、每个月支付总额，那么再直接用窗口函数就能取得每个月的累计支付总额</span><br><span class=\"line\"># 错误原因：<span class=\"keyword\">group</span> <span class=\"keyword\">by</span>只是完成了按月分组，必须还要完成<span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time), <span class=\"built_in\">sum</span>(pay_amount)才能获取最终的数据集，如果在 <span class=\"keyword\">select</span>中加入窗口函数，此时并没有取得数据集，窗口函数也就无法执行。所以需要子查询的方式，先让<span class=\"keyword\">group</span> <span class=\"keyword\">by</span>完成<span class=\"keyword\">select</span>取得数据集，再将数 据集作为表通过子查询执行窗口函数</span><br><span class=\"line\"></span><br><span class=\"line\"># 需求<span class=\"number\">2</span>：查询出<span class=\"number\">2018</span><span class=\"number\">-2019</span>年每月的支付总额和当年累积支付总额</span><br><span class=\"line\"><span class=\"keyword\">select</span> a._year,a._month,<span class=\"built_in\">sum</span>(a.pay_amount_sum) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> a._year <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> a._month)</span><br><span class=\"line\"><span class=\"keyword\">from</span></span><br><span class=\"line\">(</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"keyword\">year</span>(pay_time) _year, <span class=\"keyword\">month</span>(pay_time) _month, <span class=\"built_in\">sum</span>(pay_amount) pay_amount_sum</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">year</span>(pay_time), <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\">\t<span class=\"keyword\">having</span> _year <span class=\"keyword\">in</span> (<span class=\"number\">2018</span>,<span class=\"number\">2019</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> _year, _month</span><br><span class=\"line\">)a</span><br><span class=\"line\"></span><br><span class=\"line\"># 需求<span class=\"number\">3</span>: 查询出<span class=\"number\">2019</span>年每个月的近三月移动平均支付金额</span><br><span class=\"line\"><span class=\"keyword\">select</span> a._month, a._pay_amount, <span class=\"built_in\">avg</span>(a._pay_amount) <span class=\"keyword\">over</span>(<span class=\"keyword\">rows</span> <span class=\"keyword\">between</span> <span class=\"number\">2</span> preceding <span class=\"keyword\">and</span> <span class=\"keyword\">current</span> <span class=\"type\">row</span>)</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time) _month, <span class=\"built_in\">sum</span>(pay_amount) _pay_amount</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> _month</span><br><span class=\"line\">\t<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> _month</span><br><span class=\"line\">)a</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"排序窗口函数\"><a href=\"#排序窗口函数\" class=\"headerlink\" title=\"排序窗口函数\"></a>排序窗口函数</h2><h3 id=\"rank、dense-rank、row-number\"><a href=\"#rank、dense-rank、row-number\" class=\"headerlink\" title=\"rank、dense_rank、row_number\"></a>rank、dense_rank、row_number</h3><ul>\n<li>rank() over(partition by &lt;分组字段&gt; order by &lt;排序字段&gt;)，返回排序后的排名（并列排名占用名次）</li>\n<li>Dense_rank() over(partition by &lt;分组字段&gt; order by &lt;排序字段&gt;)，返回排序后的排名（并列排名不占用名次）</li>\n<li>Row_number() over(partition by &lt;分组字段&gt; order by &lt;排序字段&gt;)，返回排序后的行号（从1开始）</li>\n</ul>\n<p>⚠️这三种排序函数不需要参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 语法</span><br><span class=\"line\">row_number(无参数) over(......) </span><br><span class=\"line\">rank(无参数) over(......) </span><br><span class=\"line\">dense_rank(无参数) over(......)</span><br><span class=\"line\"></span><br><span class=\"line\">在rank()函数，如果有并列情况，会占用下一个名次的位置，比如，成绩为100的学生有三个并列第一，那么99分的学生是第二名，通过rank()函数，名次是：1,1,1,4；</span><br><span class=\"line\"></span><br><span class=\"line\">在dense()函数中，如果有并列的情况，不会占用下一个名词，同用上个例子，名次是：1,1,1,2；</span><br><span class=\"line\"></span><br><span class=\"line\">在row_number()函数中，会忽略并列的情况，同用上述例子，名次是：1,2,3,4;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">5</span>: <span class=\"number\">2020</span>年<span class=\"number\">1</span>月，购买商品品类数的用户排名</span><br><span class=\"line\"># 本案例中 不需要先子查询再对子查询结果使用排序函数。要考虑两个问题，一是所使用的函数是在生成数据集的同时就能使用，还是要生成完毕才可以使用；二是在使用函数的时，是否已经生成了数据集。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\tuser_name,</span><br><span class=\"line\">\t<span class=\"comment\">-- 这里使用distinct去重，因为一个用户可能在不同的时间购买了同一个品类的商品</span></span><br><span class=\"line\">\t<span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) goods_c_count,</span><br><span class=\"line\">\t<span class=\"built_in\">row_number</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _row_number,</span><br><span class=\"line\">\t<span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _rank,</span><br><span class=\"line\">\t<span class=\"built_in\">dense_rank</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _dense_rank </span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\tuser_trade </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">\t<span class=\"keyword\">YEAR</span> ( pay_time ) <span class=\"operator\">=</span> <span class=\"number\">2020</span> </span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> <span class=\"keyword\">MONTH</span> ( pay_time ) <span class=\"operator\">=</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\tuser_name</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_18-26-26.jpg\"></p>\n<h3 id=\"ntile\"><a href=\"#ntile\" class=\"headerlink\" title=\"ntile\"></a>ntile</h3><ul>\n<li>ntile(n) over(partition by &lt;分组字段A&gt; order by &lt;排序字段B&gt;)</li>\n</ul>\n<p><strong>n</strong>:切分的片数<br><strong>A</strong>:分组的字段名称<br><strong>B</strong>:排序的字段名称</p>\n<p>ntile(<strong>n</strong>)，用于将分组数据按照顺序切分成n片，返回当前切片值。</p>\n<p>Ntile(n) over(partition by &lt;分组字段A&gt; order by &lt;排序字段B&gt;)函数简单的说，就是对将个分组（没有分组就是整张表）的数据，先按照order by字段排序，然后分成n组，然后按照排序给每个组排名。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">6</span>: 查询出将<span class=\"number\">2020</span>年<span class=\"number\">2</span>月的支付用户，按照支付金额分成<span class=\"number\">5</span>组后的结果</span><br><span class=\"line\"><span class=\"keyword\">select</span> user_name, <span class=\"built_in\">sum</span>(pay_amount) pay_amount, <span class=\"built_in\">ntile</span>(<span class=\"number\">5</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">desc</span>)level</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\"><span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2020</span></span><br><span class=\"line\"><span class=\"keyword\">and</span> <span class=\"keyword\">month</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> user_name</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_21-42-58.jpg\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">7</span>：查询出<span class=\"number\">2020</span>年支付金额排名前<span class=\"number\">30</span><span class=\"operator\">%</span>的所有用户</span><br><span class=\"line\"><span class=\"keyword\">select</span> a.user_name, a.pay_amount, a.level</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> user_name, <span class=\"built_in\">sum</span>(pay_amount)pay_amount, <span class=\"built_in\">ntile</span>(<span class=\"number\">10</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">desc</span>) level</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2020</span></span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> user_name</span><br><span class=\"line\">)a</span><br><span class=\"line\"><span class=\"keyword\">where</span> a.level <span class=\"operator\">&lt;</span> <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"偏移分析函数\"><a href=\"#偏移分析函数\" class=\"headerlink\" title=\"偏移分析函数\"></a>偏移分析函数</h2><h3 id=\"lag、lead\"><a href=\"#lag、lead\" class=\"headerlink\" title=\"lag、lead\"></a>lag、lead</h3><p>lag() 函数，允许您向上偏移多行并从当前行访问偏移行的数据</p>\n<p>lead() 函数，允许您向下看多行并从当前行访问偏移行的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 向上偏移</span><br><span class=\"line\">lag(&lt;expression&gt;[,offset[, default_value]]) over (partition by expr,... order by expr [asc|desc],...) </span><br><span class=\"line\"># 向下偏移</span><br><span class=\"line\">lead(&lt;expression&gt;[,offset[, default_value]]) over (partition by expr,... order by expr [asc|desc],...) </span><br></pre></td></tr></table></figure>\n\n<p>执行到当前分组的某一行时，返回偏移offset行的行的expression字段的值，如果偏移量超过了分组或窗口范围，返回default_value。</p>\n<p>如果不写offset参数，默认偏移1行。</p>\n<p>如果不写default_value参数，默认值为null。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> user_name,pay_time,</span><br><span class=\"line\">       <span class=\"built_in\">lag</span>(pay_time,<span class=\"number\">1</span>,pay_time) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lag1,</span><br><span class=\"line\">\t\t\t<span class=\"comment\">-- 没有传入偏移量，那么默认就是1，找不到的话，此处也没有给默认值，为 null</span></span><br><span class=\"line\">\t\t\t <span class=\"built_in\">lag</span>(pay_time) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time)lag1_s,</span><br><span class=\"line\">       <span class=\"built_in\">lag</span>(pay_time,<span class=\"number\">2</span>,pay_time) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lag2,</span><br><span class=\"line\">       <span class=\"built_in\">lag</span>(pay_time,<span class=\"number\">2</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time)lag2_s</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> user_trade</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> user_name <span class=\"keyword\">in</span> (<span class=\"string\">&#x27;King&#x27;</span>,<span class=\"string\">&#x27;West&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_22-54-39.jpg\"></p>\n<p><strong>在实际应用当中，若要用到取今天和昨天的某字段差值时，Lag和Lead函数的应用就显得尤为重要。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">10</span>: 查询出支付时间间隔超过<span class=\"number\">100</span>天的用户数</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> a.user_name)</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> </span><br><span class=\"line\">  \tuser_name,pay_time, </span><br><span class=\"line\">  \t<span class=\"built_in\">lead</span>(pay_time,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lead_time </span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">)a</span><br><span class=\"line\"><span class=\"keyword\">where</span> a.lead_time <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span></span><br><span class=\"line\"><span class=\"keyword\">and</span> datediff(a.lead_time,a.pay_time) <span class=\"operator\">&gt;</span> <span class=\"number\">100</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">11</span>: 查询出每年支付时间间隔最长的用户</span><br><span class=\"line\"># ✅</span><br><span class=\"line\"><span class=\"keyword\">select</span> b.user_name, <span class=\"keyword\">year</span>(b.pay_time), b.diff_time</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> </span><br><span class=\"line\">\t\t\ta.user_name, a.pay_time, </span><br><span class=\"line\">\t\t\ta.lead_time, datediff(a.lead_time,a.pay_time) diff_time, </span><br><span class=\"line\">\t\t\t<span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> <span class=\"keyword\">year</span>(a.pay_time) <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> datediff(a.lead_time,a.pay_time) <span class=\"keyword\">desc</span>) _rank</span><br><span class=\"line\">\t\t<span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">select</span> user_name, pay_time, <span class=\"built_in\">lead</span>(pay_time,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name, <span class=\"keyword\">year</span>(pay_time) <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lead_time</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t\t)a</span><br><span class=\"line\">\t\t<span class=\"keyword\">where</span> a.lead_time <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span></span><br><span class=\"line\">\t)b</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> b._rank <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"># ❌，错误原因：</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">在第2层子查询计算出了每年每个用户的支付间隔后，外套一层查询，并按年分组，然后用max（）选出每组，也就是每年间隔时间最长的人，</span></span><br><span class=\"line\"><span class=\"comment\">这时发现，在select中只有max(b.diff_time)时不会报错，但加上b.user_name就会报错。</span></span><br><span class=\"line\"><span class=\"comment\">这时因为，一年中存在多个用户的支付时间间隔并列最长，这时max(b.diff_time)会默认返回第一个(还是随机一个），但是user_name有多个，系统不知道该返回哪个，就会报错了。</span></span><br><span class=\"line\"><span class=\"comment\">所以这里不能用max，应该用rank()函数，这样就考虑到了并列最大的情况。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> b.user_name, <span class=\"built_in\">max</span>(b.diff_time)</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> a.user_name, a.pay_time, a.lead_time, datediff(a.lead_time,a.pay_time) diff_time</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> user_name, pay_time, <span class=\"built_in\">lead</span>(pay_time,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name, <span class=\"keyword\">year</span>(pay_time) <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lead_time</span><br><span class=\"line\">\t\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t)a</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> a.lead_time <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span></span><br><span class=\"line\">)b</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">year</span>(b.pay_time)</span><br></pre></td></tr></table></figure>\n\n<p><strong>max()并列最大错误测试：</strong></p>\n<p>测试表数据</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-07-31.jpg\"></p>\n<p>只select max()不报错</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-08-38.jpg\"></p>\n<p>select user_id报错</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-09-15.jpg\"></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><ul>\n<li>聚合窗口函数 不能 在第一次select时同时执行，必须先select完毕，结果集再作为新表通过子查询使用聚合窗口函数。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 报错❌</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\t<span class=\"keyword\">month</span>(pay_time) <span class=\"keyword\">as</span> _month, </span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time))</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\"><span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\"></span><br><span class=\"line\"># 正确✅</span><br><span class=\"line\"><span class=\"keyword\">select</span> a._month, a._pay_mount_sum, <span class=\"built_in\">sum</span>(a._pay_amount_sum) <span class=\"keyword\">over</span>(<span class=\"keyword\">order</span> <span class=\"keyword\">by</span> a._month)</span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"keyword\">month</span>(pay_time) <span class=\"keyword\">as</span> _month, <span class=\"built_in\">sum</span>(pay_amount) <span class=\"keyword\">as</span> _pay_amount_sum</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> user_trade</span><br><span class=\"line\">\t<span class=\"keyword\">where</span> <span class=\"keyword\">year</span>(pay_time) <span class=\"operator\">=</span> <span class=\"number\">2019</span></span><br><span class=\"line\">\t<span class=\"keyword\">group</span> <span class=\"keyword\">by</span> <span class=\"keyword\">month</span>(pay_time)</span><br><span class=\"line\">)a</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>排序窗口函数、偏移分析函数 可以 在第一次select时同时执行。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># ✅</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\tuser_name,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) goods_c_count,</span><br><span class=\"line\">\t<span class=\"built_in\">row_number</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _row_number,</span><br><span class=\"line\">\t<span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _rank,</span><br><span class=\"line\">\t<span class=\"built_in\">dense_rank</span>() <span class=\"keyword\">over</span> ( <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"built_in\">count</span>( <span class=\"keyword\">DISTINCT</span> goods_category ) ) _dense_rank </span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\tuser_trade </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">\t<span class=\"keyword\">YEAR</span> ( pay_time ) <span class=\"operator\">=</span> <span class=\"number\">2020</span> </span><br><span class=\"line\">\t<span class=\"keyword\">AND</span> <span class=\"keyword\">MONTH</span> ( pay_time ) <span class=\"operator\">=</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\tuser_name</span><br><span class=\"line\">\t</span><br><span class=\"line\"># ✅</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\"> \tuser_name,pay_time, </span><br><span class=\"line\"> \t<span class=\"built_in\">lead</span>(pay_time,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_name <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> pay_time) lead_time </span><br><span class=\"line\"><span class=\"keyword\">from</span> user_trade</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><p>字典的目录就是一种索引机制，提高检索的效率。</p>\n<ul>\n<li>索引可以提升查询速度，会影响where和order by。</li>\n<li>索引是针对字段的，需要添加到字段上。给某一列添加索引的时候，数据库会将这一列的数据进行提取、转换、再存储。存储下来的数据就是索引。当查询的时候，会先查询索引数据，能够更快速的找到相关信息。</li>\n<li>索引在大量数据场景下效果明显。</li>\n</ul>\n<h2 id=\"常见索引分类\"><a href=\"#常见索引分类\" class=\"headerlink\" title=\"常见索引分类\"></a>常见索引分类</h2><ul>\n<li><p>从索引的存储结构划分:B Tree索引、Hash索引、fulltext全文索引、R Tree索引(了解) </p>\n</li>\n<li><p><strong>从应用层次划分:主键索引、唯一索引、普通索引、复合索引</strong> </p>\n</li>\n<li><p>从索引的键值(字段)类型划分:主键索引、辅助索引(二级索引) </p>\n</li>\n<li><p>从索引数据和内容数据逻辑关系划分:聚集索引(聚簇索引)、非聚集索引(非聚簇索 引)</p>\n</li>\n</ul>\n<h2 id=\"主键索引-primary-key\"><a href=\"#主键索引-primary-key\" class=\"headerlink\" title=\"主键索引(primary key)\"></a>主键索引(primary key)</h2><ul>\n<li>数据表添加主键的时候，会自动穿件逐渐索引，主键索引也是一种唯一索引。</li>\n<li>一个表可以没有主见，但最多只能有一个主键，且主键是唯一的、不能为Null。</li>\n<li>根据主键进行where条件查询，效率高。</li>\n</ul>\n<h2 id=\"唯一索引-unique\"><a href=\"#唯一索引-unique\" class=\"headerlink\" title=\"唯一索引(unique)\"></a>唯一索引(unique)</h2><p>特点：索引列的值只能出现一次，不能重复，保证唯一。</p>\n<p>在许多场合，人们创建唯一索引不是为了提高查询速度，而是为了避免数据重复。（使用唯一约束效果相同）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建表的时候直接添加唯一索引</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> 表名( </span><br><span class=\"line\">  列名 类型(长度),</span><br><span class=\"line\">\t<span class=\"keyword\">UNIQUE</span> [索引名称] (列名)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"># 在已有的表上创建索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名[长度])</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> index index_dname <span class=\"keyword\">on</span> test_index(dname);</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改表结构添加索引</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 表名 <span class=\"keyword\">ADD</span> <span class=\"keyword\">UNIQUE</span> 索引名( 列名 )</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"普通索引-normal-index\"><a href=\"#普通索引-normal-index\" class=\"headerlink\" title=\"普通索引(normal index)\"></a>普通索引(normal index)</h2><p>普通索引的唯一任务是加快检索的速度。一般为需要where条件查询或order by排序的列添加普通索引。</p>\n<p>普通索引不要求数据唯一、非空。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在已有的表上创建索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名[长度])</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改表结构添加索引</span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 表名 <span class=\"keyword\">add</span> index 索引名 (列名)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h2><p>创建普通索引时，同时写入多个字段。</p>\n<p>复合索引一般用在，需要对多个字段进行where条件查询或order by排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在已有的表上创建索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名<span class=\"number\">1</span>, 列名<span class=\"number\">2</span>,...)</span><br><span class=\"line\"></span><br><span class=\"line\"># 修改表结构添加索引</span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 表名 <span class=\"keyword\">add</span> index 索引名 (列名<span class=\"number\">1</span>， 列名<span class=\"number\">2</span>,...)</span><br></pre></td></tr></table></figure>\n\n<p>⚠️注意：创建复合索引时要注意字段顺序，创建索引时字段的顺序，要和查询条件中字段的顺序保持一致。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">where</span> 字段<span class=\"number\">1</span><span class=\"operator\">=</span>‘’ <span class=\"keyword\">and</span> 字段<span class=\"number\">2</span><span class=\"operator\">=</span>‘’\t<span class=\"comment\">-- 字段1，字段2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(字段<span class=\"number\">1</span>, 字段<span class=\"number\">2</span>) <span class=\"comment\">-- 字段1，字段2；不能写成 字段2，字段1</span></span><br></pre></td></tr></table></figure>\n\n<p>⚠️注意：区别复合索引和多个单列索引。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 复合索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名<span class=\"number\">1</span>, 列名<span class=\"number\">2</span>) <span class=\"comment\">-- 字段顺序要和查询条件中保持一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 多个单列索引</span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名<span class=\"number\">1</span>) <span class=\"comment\">-- 不需要考虑字段顺序</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> index 索引名 <span class=\"keyword\">on</span> 表名(列名<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 表名 <span class=\"keyword\">drop</span> index 索引名;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h1><p>概念：</p>\n<ul>\n<li>视图是一种虚拟表。（与之对应的是实体表，比如通过create语句创建的表）</li>\n<li>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。</li>\n<li> 向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句。</li>\n<li>视图向用户提供基表（实体表或者其他视图）数据的另一种表现形式。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> 视图名 [column_list] <span class=\"keyword\">as</span> <span class=\"keyword\">select</span>语句;</span><br><span class=\"line\"><span class=\"keyword\">view</span>: 表示视图</span><br><span class=\"line\">column_list: 可选参数，表示属性清单，指定视图中各个属性的名称，默认情况下，与 <span class=\"keyword\">SELECT</span>语句中查询的属性相同</span><br><span class=\"line\"><span class=\"keyword\">as</span> : 表示视图要执行的操作</span><br><span class=\"line\"><span class=\"keyword\">select</span>语句: 向视图提供数据内容</span><br></pre></td></tr></table></figure>\n\n<p>作用：</p>\n<ul>\n<li>权限控制时可以使用</li>\n<li>简化复杂的多表查询</li>\n</ul>\n<p>sql中视图的概念类似于编程中封装函数的概念，将一段复杂的sql语句封装成一个视图，之后只需通过引用视图名进行查询就能得到结果。并且可以决定从视图中只查询某几个字段的数据，做到权限控制，就像函数可以指定返回的值一样。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">1</span>: 查询各个分类下的商品平均价格</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> cp_view <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> category c</span><br><span class=\"line\"><span class=\"keyword\">join</span> products p</span><br><span class=\"line\"><span class=\"keyword\">on</span> c.cid <span class=\"operator\">=</span> p.category_id; <span class=\"comment\">-- 注意这里必须有分号;结束</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> cname, <span class=\"built_in\">avg</span>(price)</span><br><span class=\"line\"><span class=\"keyword\">from</span> cp_view</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> cname</span><br><span class=\"line\"></span><br><span class=\"line\"># 普通写法</span><br><span class=\"line\"><span class=\"keyword\">select</span> cname, <span class=\"built_in\">avg</span>(price)</span><br><span class=\"line\"><span class=\"keyword\">from</span> products p <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> category c</span><br><span class=\"line\"><span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> c.cname</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 需求<span class=\"number\">2</span>: 查询鞋服分类下最贵的商品的全部信息</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> cp_view2 <span class=\"keyword\">as</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span> c.cid, c.cname, p.pid,p.pname, p.price, p.flag, <span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> c.cname <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> p.price <span class=\"keyword\">desc</span>) _rank</span><br><span class=\"line\"><span class=\"keyword\">from</span> products p <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> category c </span><br><span class=\"line\"><span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> cp_view2 <span class=\"keyword\">where</span> cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;鞋服&#x27;</span> <span class=\"keyword\">and</span> _rank <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"># 普通写法</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> (</span><br><span class=\"line\"><span class=\"keyword\">select</span> c.cid, c.cname, p.pid,p.pname, p.price, p.flag, <span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> c.cname <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> p.price <span class=\"keyword\">desc</span>) _rank</span><br><span class=\"line\"><span class=\"keyword\">from</span> products p <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> category c </span><br><span class=\"line\"><span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid </span><br><span class=\"line\">)a</span><br><span class=\"line\"><span class=\"keyword\">where</span> a.cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;鞋服&#x27;</span> <span class=\"keyword\">and</span> a._rank <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>视图和表的区别：</p>\n<ul>\n<li>视图是建立在表的基础上，表存储数据库中的数据，而视图只是做一个数据的展示 。</li>\n<li>通过视图不能改变表中数据(一般情况下视图中的数据都是表中的列 经过计算得到的结果, 不允许更新)。</li>\n<li> 删除视图，表不受影响，而删除表，视图不再起作用。</li>\n</ul>\n<h1 id=\"作业——知识点\"><a href=\"#作业——知识点\" class=\"headerlink\" title=\"作业——知识点\"></a>作业——知识点</h1><h2 id=\"留存\"><a href=\"#留存\" class=\"headerlink\" title=\"留存\"></a>留存</h2><p>留存：指基准日到APP的用户在之后的n日当天返回APP的人数。</p>\n<p>留存率 = 基准日之后的n天当日返回的用户数 / 基准日的用户数 * 100%。</p>\n<p>留存代表一个用户愿意再次使用你的产品;而一个产品能够被用户再次使用，意味着这个产品是能够满</p>\n<p>足用户长期需求的，能够让用户产生一定粘性的产品。</p>\n<p>活跃用户 = 新增用户 + 留存用户</p>\n<p>如今互联网产品大多为免费产品，依靠持续的广告转化、用户持续的购买转化、用户持续的会员付费来维持收益。</p>\n<p>持续的广告转化、购买、会员付费，我们就 需要每天都有一定量的用户来完成以上过程，也就是说我们需要我们的产品每天都是有活跃用户的。</p>\n<p>从活跃用户的构成，我们就知道怎么维持我们的活跃用户规模：一方面持续有新用户流入，另一方 面持续有留存用户留存。</p>\n<p>为什么留存用户重要?部分有过从业经验的同学应该知道，产品的自然新增用户是比较少的，如果 我们仅靠产品自然用户增长，那么必然我们的活跃用户量级会非常小，虽然能够获得收益，但是这部分 收益很可能养不起我们的公司;但是如果我们想要用购买新用户的方式获得持续的较大规模的用户池， 又会产生比较大的成本，这样做容易亏本。所以我们需要新增留存两手抓;想方设法留住我们新增的用 户，让其长期地在我们的产品内产生价值，这样做，比起单做新增，在成本和效果上都是要好的。</p>\n<p><strong>留存的主要应用场景有两个：</strong></p>\n<ul>\n<li><p>一个是产品整体视角的持续留存情况;也就是我们需要定期分析用户在产品的留存是否维持在一个正常 的范围，有没有突然地涨跌情况，如果有的话问题出在哪里，为什么会出现这样的问题，如何解决留存 异常的问题。遇到这类问题首先需要确定的是整体用户的留存异常还是个别群体用户的留存异常，如果 是整体用户的留存异常，我们需要分析我们的产品是否发生异常，可以通过用户的行为路径确定异常产 品位置;如果是个别用户的留存异常，需要通过用户拆解的方法来定位有异常的用户群体，然后通过这 类用户的特征来分析问题原因。</p>\n</li>\n<li><p>一个是新增用户视角的每批新增用户留存情况。一般出现在计算投放ROI的场景，也就是我们投放一批 用户，能够给我们带来多少收益。我们会用这些用户的“整个生命周期能够带来的收入”(LTV)去除以 “投放时的支出”来计算我们的ROI。“整个生命周期能够带来的收入”计算的是引入一批新用户，当用户完 全流失时，这部分用户所带来的所有收入。但是有时我们需要提前预估新用户在整个生命周期能够带来 的收入，我们就需要首先用留存来估计用户的生命周期，然后用估计出的生命周期再去计算用户的整个 生命周期能够带来的收入。</p>\n</li>\n</ul>\n<p><strong>什么企业不关心留存：</strong> </p>\n<p>需要用户产生持续活跃，持续转化，持续消费的企业都关心用户的留存。那么，什么样的企业不关心用户留存?</p>\n<ul>\n<li><p>部分线下企业存在数据难以获取的问题，所以对留存关注比较少，比如线下的商场，除非用户产生购买 行为，否则很难探知用户在什么情况下有回流。</p>\n</li>\n<li><p>部分存在一锤子买卖的企业也不太关心留存，比如说用户在一次买断商品后再也不会产生后续购买或价 值转化行为，这类企业也不怎么关注留存。比如PC单机游戏;比如一次付费的工具类产品(线上线下类 工具都存在这个情况)。</p>\n</li>\n</ul>\n<h2 id=\"周同比\"><a href=\"#周同比\" class=\"headerlink\" title=\"周同比\"></a>周同比</h2><p>周同比：周同比适用于以周为周期变动的数据，用于观察每天的数据较上周同一天的数据变化。</p>\n<p>现有互联网数据多以周为周期变动，一周内每一天的数据都有其特点:</p>\n<ul>\n<li><p>如工作类APP，周一会是每一周的高峰，然后向周五逐渐递减，周五到周六又会有一个锐减的过 程，周日与周六趋于平缓;</p>\n</li>\n<li><p>如娱乐类APP，周一会较周末锐减，然后向周四逐渐递减，周五会有一个跃升的过程，周六会再次 跃升，周日会较周六下降;</p>\n</li>\n</ul>\n<p>一般遇到这样的变动趋势，如果单纯的分析每一天较上一天的变动情况，就容易分析出错误结论。所 以，在我们分析带有周期类数据时，一定要先将周期提炼出来，使用周期的同比数据做分析，会得出更 有价值，更加准确的结论。</p>\n<h2 id=\"平台模式\"><a href=\"#平台模式\" class=\"headerlink\" title=\"平台模式\"></a>平台模式</h2><p>如今的大多数内容APP都是以平台模式运营的。</p>\n<p>什么叫做平台模式?</p>\n<p>比如我们现在能接触到的大多数内容产品“抖音”、“Bilibili”、“微博”、“今日头条”等等。我们使用到的这个 APP，是由APP的制作公司提供的，也就是这个APP会有几个主要的页面，每个页面怎么引导用户进入内 容页面，播放内容的方式有哪些、内容间切换会用什么方式等等，都是我们的APP制作公司决定的;而 我们在这个APP里看到的大多数内容，都是由内容作者提供的。</p>\n"},{"title":"自建应用字段编辑+JqueryWeUI","date":"2017-06-15T08:53:15.000Z","description":"使用JQueryWeUI时遇到select组件没有提供点击蒙版关闭组件，以及不点击确定关闭控件后再次打开控件默认值的问题","_content":"> 在使用JqueryWeUI做自建应用各种字段编辑交互的时候遇到不少问题\n\n# select控件\n## 点击蒙版关闭控件\n　　weui只有日期和时间控件提供了点击蒙版关闭控件的功能,但是在实际应用中select同样十分需要这种方便体验的交互，不过select控件提供了全局打开/关闭的API：\n`$(\"input\").select(\"close\")`\n　　实现方法是就是获取蒙版元素，给蒙版元素添加点击事件，手动调用`select(\"close\")`\n　　代码如下\n    ```javascript\n\t$(element).find('.weui_mask').on('click',function (e){\n\t    e.stopPropagation();\n\t    scope.value = oldValue\n\t    scope.cancel = true;\n\t    $(element).find('input').select(\"close\");\n    })\n    ```\n\n    这里需要注意的是，`$(element).find('input').select(\"close\");`实际是去执行了初始化时候的onClose方法,同时onClose回调也会执行。\n## 点击选项但不提交，再次打卡控件默认选项问题\n　　需求：一个下拉选框，选项ABC，默认选中A选项。\n现在选中B选项。\n点击蒙版关闭控件，不改变值，并且下次打开控件仍然默认选中A选项。\n点击确定关闭控件，并改变值，下次打开控件默认选中B选项。\n　　实现方法：select控件在初始化的时候提供了设置初始值的参数`input`，默认`undefiend`。并且提供了更改这些参数的方法`$(\"input\").select(\"update\", { items: [\"法官\", \"猎人\", ...] })`。\n这两个配合起来使用就能实现这个需求。\n\n　　代码如下\n　　```javascript\n\tscope.value = scope.value||'';\t\t//值\n    var oldValue = angular.copy(scope.value);\n    $(element).find('input').select({\n        input:scope.value,\n        title: new_title,\n        items: scope.list,\n        autoClose: false,\n        multi: false,\n        onChange: function(d) {\n            var chooseone= $(element).find('input').attr('data-values');\n            scope.value = chooseone;\n            scope.current_select = chooseone;\n        },\n        onOpen: function () {\n            scope.cancel = false;\n            $(element).find('.weui_mask').addClass('weui_mask_visible')\n        },\n        onClose: function () {\n            scope.$apply(function () {\n                oldValue = angular.copy(scope.value);\n                scope.valuename = angular.copy(scope.value);\t\t//显示需要\n            });\n            if(scope.isdetail&&scope.cancel==false){\n                scope.submitEdit();\t\t\t//提交数据\n            }\n            $(element).find('.weui_mask').removeClass('weui_mask_visible');\n        }\n    });\n    $(element).find('.weui_mask').on('click',function (e) {\n        e.stopPropagation();\n        scope.value = oldValue\n        scope.cancel = true;\n        $(element).find('input').select(\"close\");\n    })；\n    scope.showSelect = function () {\n        $(element).find('input').select('update',{\n            input:scope.value\n        })\n\t\t$(element).find('input').select(\"open\");\n    }\n　　```","source":"_posts/自建应用字段编辑+JqueryWeUI.md","raw":"---\ntitle: 自建应用字段编辑+JqueryWeUI\ndate: 2017-06-15 16:53:15\ntags:\n- WeUI\ncategories:\n- 问题记录\ndescription: 使用JQueryWeUI时遇到select组件没有提供点击蒙版关闭组件，以及不点击确定关闭控件后再次打开控件默认值的问题\n---\n> 在使用JqueryWeUI做自建应用各种字段编辑交互的时候遇到不少问题\n\n# select控件\n## 点击蒙版关闭控件\n　　weui只有日期和时间控件提供了点击蒙版关闭控件的功能,但是在实际应用中select同样十分需要这种方便体验的交互，不过select控件提供了全局打开/关闭的API：\n`$(\"input\").select(\"close\")`\n　　实现方法是就是获取蒙版元素，给蒙版元素添加点击事件，手动调用`select(\"close\")`\n　　代码如下\n    ```javascript\n\t$(element).find('.weui_mask').on('click',function (e){\n\t    e.stopPropagation();\n\t    scope.value = oldValue\n\t    scope.cancel = true;\n\t    $(element).find('input').select(\"close\");\n    })\n    ```\n\n    这里需要注意的是，`$(element).find('input').select(\"close\");`实际是去执行了初始化时候的onClose方法,同时onClose回调也会执行。\n## 点击选项但不提交，再次打卡控件默认选项问题\n　　需求：一个下拉选框，选项ABC，默认选中A选项。\n现在选中B选项。\n点击蒙版关闭控件，不改变值，并且下次打开控件仍然默认选中A选项。\n点击确定关闭控件，并改变值，下次打开控件默认选中B选项。\n　　实现方法：select控件在初始化的时候提供了设置初始值的参数`input`，默认`undefiend`。并且提供了更改这些参数的方法`$(\"input\").select(\"update\", { items: [\"法官\", \"猎人\", ...] })`。\n这两个配合起来使用就能实现这个需求。\n\n　　代码如下\n　　```javascript\n\tscope.value = scope.value||'';\t\t//值\n    var oldValue = angular.copy(scope.value);\n    $(element).find('input').select({\n        input:scope.value,\n        title: new_title,\n        items: scope.list,\n        autoClose: false,\n        multi: false,\n        onChange: function(d) {\n            var chooseone= $(element).find('input').attr('data-values');\n            scope.value = chooseone;\n            scope.current_select = chooseone;\n        },\n        onOpen: function () {\n            scope.cancel = false;\n            $(element).find('.weui_mask').addClass('weui_mask_visible')\n        },\n        onClose: function () {\n            scope.$apply(function () {\n                oldValue = angular.copy(scope.value);\n                scope.valuename = angular.copy(scope.value);\t\t//显示需要\n            });\n            if(scope.isdetail&&scope.cancel==false){\n                scope.submitEdit();\t\t\t//提交数据\n            }\n            $(element).find('.weui_mask').removeClass('weui_mask_visible');\n        }\n    });\n    $(element).find('.weui_mask').on('click',function (e) {\n        e.stopPropagation();\n        scope.value = oldValue\n        scope.cancel = true;\n        $(element).find('input').select(\"close\");\n    })；\n    scope.showSelect = function () {\n        $(element).find('input').select('update',{\n            input:scope.value\n        })\n\t\t$(element).find('input').select(\"open\");\n    }\n　　```","slug":"自建应用字段编辑+JqueryWeUI","published":1,"updated":"2021-05-08T15:02:01.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbp0001gwct4bk9cgqwh","content":"<blockquote>\n<p>在使用JqueryWeUI做自建应用各种字段编辑交互的时候遇到不少问题</p>\n</blockquote>\n<h1 id=\"select控件\"><a href=\"#select控件\" class=\"headerlink\" title=\"select控件\"></a>select控件</h1><h2 id=\"点击蒙版关闭控件\"><a href=\"#点击蒙版关闭控件\" class=\"headerlink\" title=\"点击蒙版关闭控件\"></a>点击蒙版关闭控件</h2><p>　　weui只有日期和时间控件提供了点击蒙版关闭控件的功能,但是在实际应用中select同样十分需要这种方便体验的交互，不过select控件提供了全局打开/关闭的API：<br><code>$(&quot;input&quot;).select(&quot;close&quot;)</code><br>　　实现方法是就是获取蒙版元素，给蒙版元素添加点击事件，手动调用<code>select(&quot;close&quot;)</code><br>　　代码如下<br>    <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(element).find(<span class=\"string\">&#x27;.weui_mask&#x27;</span>).on(<span class=\"string\">&#x27;click&#x27;</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    scope.value = oldValue</span><br><span class=\"line\">    scope.cancel = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(<span class=\"string\">&quot;close&quot;</span>);</span><br><span class=\"line\">   &#125;)</span><br></pre></td></tr></table></figure></p>\n<pre><code>这里需要注意的是，`$(element).find(&#39;input&#39;).select(&quot;close&quot;);`实际是去执行了初始化时候的onClose方法,同时onClose回调也会执行。\n</code></pre>\n<h2 id=\"点击选项但不提交，再次打卡控件默认选项问题\"><a href=\"#点击选项但不提交，再次打卡控件默认选项问题\" class=\"headerlink\" title=\"点击选项但不提交，再次打卡控件默认选项问题\"></a>点击选项但不提交，再次打卡控件默认选项问题</h2><p>　　需求：一个下拉选框，选项ABC，默认选中A选项。<br>现在选中B选项。<br>点击蒙版关闭控件，不改变值，并且下次打开控件仍然默认选中A选项。<br>点击确定关闭控件，并改变值，下次打开控件默认选中B选项。<br>　　实现方法：select控件在初始化的时候提供了设置初始值的参数<code>input</code>，默认<code>undefiend</code>。并且提供了更改这些参数的方法<code>$(&quot;input&quot;).select(&quot;update&quot;, &#123; items: [&quot;法官&quot;, &quot;猎人&quot;, ...] &#125;)</code>。<br>这两个配合起来使用就能实现这个需求。</p>\n<p>　　代码如下<br>　　<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scope.value = scope.value||<span class=\"string\">&#x27;&#x27;</span>;\t\t<span class=\"comment\">//值</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> oldValue = angular.copy(scope.value);</span><br><span class=\"line\">   $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(&#123;</span><br><span class=\"line\">       input:scope.value,</span><br><span class=\"line\">       title: new_title,</span><br><span class=\"line\">       items: scope.list,</span><br><span class=\"line\">       autoClose: <span class=\"literal\">false</span>,</span><br><span class=\"line\">       multi: <span class=\"literal\">false</span>,</span><br><span class=\"line\">       onChange: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">var</span> chooseone= $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).attr(<span class=\"string\">&#x27;data-values&#x27;</span>);</span><br><span class=\"line\">           scope.value = chooseone;</span><br><span class=\"line\">           scope.current_select = chooseone;</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       onOpen: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           scope.cancel = <span class=\"literal\">false</span>;</span><br><span class=\"line\">           $(element).find(<span class=\"string\">&#x27;.weui_mask&#x27;</span>).addClass(<span class=\"string\">&#x27;weui_mask_visible&#x27;</span>)</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       onClose: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           scope.$apply(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">               oldValue = angular.copy(scope.value);</span><br><span class=\"line\">               scope.valuename = angular.copy(scope.value);\t\t<span class=\"comment\">//显示需要</span></span><br><span class=\"line\">           &#125;);</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(scope.isdetail&amp;&amp;scope.cancel==<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">               scope.submitEdit();\t\t\t<span class=\"comment\">//提交数据</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           $(element).find(<span class=\"string\">&#x27;.weui_mask&#x27;</span>).removeClass(<span class=\"string\">&#x27;weui_mask_visible&#x27;</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   $(element).find(<span class=\"string\">&#x27;.weui_mask&#x27;</span>).on(<span class=\"string\">&#x27;click&#x27;</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">       e.stopPropagation();</span><br><span class=\"line\">       scope.value = oldValue</span><br><span class=\"line\">       scope.cancel = <span class=\"literal\">true</span>;</span><br><span class=\"line\">       $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(<span class=\"string\">&quot;close&quot;</span>);</span><br><span class=\"line\">   &#125;)；</span><br><span class=\"line\">   scope.showSelect = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(<span class=\"string\">&#x27;update&#x27;</span>,&#123;</span><br><span class=\"line\">           input:scope.value</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">\t$(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(<span class=\"string\">&quot;open&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在使用JqueryWeUI做自建应用各种字段编辑交互的时候遇到不少问题</p>\n</blockquote>\n<h1 id=\"select控件\"><a href=\"#select控件\" class=\"headerlink\" title=\"select控件\"></a>select控件</h1><h2 id=\"点击蒙版关闭控件\"><a href=\"#点击蒙版关闭控件\" class=\"headerlink\" title=\"点击蒙版关闭控件\"></a>点击蒙版关闭控件</h2><p>　　weui只有日期和时间控件提供了点击蒙版关闭控件的功能,但是在实际应用中select同样十分需要这种方便体验的交互，不过select控件提供了全局打开/关闭的API：<br><code>$(&quot;input&quot;).select(&quot;close&quot;)</code><br>　　实现方法是就是获取蒙版元素，给蒙版元素添加点击事件，手动调用<code>select(&quot;close&quot;)</code><br>　　代码如下<br>    <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(element).find(<span class=\"string\">&#x27;.weui_mask&#x27;</span>).on(<span class=\"string\">&#x27;click&#x27;</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    scope.value = oldValue</span><br><span class=\"line\">    scope.cancel = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(<span class=\"string\">&quot;close&quot;</span>);</span><br><span class=\"line\">   &#125;)</span><br></pre></td></tr></table></figure></p>\n<pre><code>这里需要注意的是，`$(element).find(&#39;input&#39;).select(&quot;close&quot;);`实际是去执行了初始化时候的onClose方法,同时onClose回调也会执行。\n</code></pre>\n<h2 id=\"点击选项但不提交，再次打卡控件默认选项问题\"><a href=\"#点击选项但不提交，再次打卡控件默认选项问题\" class=\"headerlink\" title=\"点击选项但不提交，再次打卡控件默认选项问题\"></a>点击选项但不提交，再次打卡控件默认选项问题</h2><p>　　需求：一个下拉选框，选项ABC，默认选中A选项。<br>现在选中B选项。<br>点击蒙版关闭控件，不改变值，并且下次打开控件仍然默认选中A选项。<br>点击确定关闭控件，并改变值，下次打开控件默认选中B选项。<br>　　实现方法：select控件在初始化的时候提供了设置初始值的参数<code>input</code>，默认<code>undefiend</code>。并且提供了更改这些参数的方法<code>$(&quot;input&quot;).select(&quot;update&quot;, &#123; items: [&quot;法官&quot;, &quot;猎人&quot;, ...] &#125;)</code>。<br>这两个配合起来使用就能实现这个需求。</p>\n<p>　　代码如下<br>　　<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scope.value = scope.value||<span class=\"string\">&#x27;&#x27;</span>;\t\t<span class=\"comment\">//值</span></span><br><span class=\"line\">   <span class=\"keyword\">var</span> oldValue = angular.copy(scope.value);</span><br><span class=\"line\">   $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(&#123;</span><br><span class=\"line\">       input:scope.value,</span><br><span class=\"line\">       title: new_title,</span><br><span class=\"line\">       items: scope.list,</span><br><span class=\"line\">       autoClose: <span class=\"literal\">false</span>,</span><br><span class=\"line\">       multi: <span class=\"literal\">false</span>,</span><br><span class=\"line\">       onChange: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d</span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">var</span> chooseone= $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).attr(<span class=\"string\">&#x27;data-values&#x27;</span>);</span><br><span class=\"line\">           scope.value = chooseone;</span><br><span class=\"line\">           scope.current_select = chooseone;</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       onOpen: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           scope.cancel = <span class=\"literal\">false</span>;</span><br><span class=\"line\">           $(element).find(<span class=\"string\">&#x27;.weui_mask&#x27;</span>).addClass(<span class=\"string\">&#x27;weui_mask_visible&#x27;</span>)</span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       onClose: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           scope.$apply(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">               oldValue = angular.copy(scope.value);</span><br><span class=\"line\">               scope.valuename = angular.copy(scope.value);\t\t<span class=\"comment\">//显示需要</span></span><br><span class=\"line\">           &#125;);</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(scope.isdetail&amp;&amp;scope.cancel==<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">               scope.submitEdit();\t\t\t<span class=\"comment\">//提交数据</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           $(element).find(<span class=\"string\">&#x27;.weui_mask&#x27;</span>).removeClass(<span class=\"string\">&#x27;weui_mask_visible&#x27;</span>);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;);</span><br><span class=\"line\">   $(element).find(<span class=\"string\">&#x27;.weui_mask&#x27;</span>).on(<span class=\"string\">&#x27;click&#x27;</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">       e.stopPropagation();</span><br><span class=\"line\">       scope.value = oldValue</span><br><span class=\"line\">       scope.cancel = <span class=\"literal\">true</span>;</span><br><span class=\"line\">       $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(<span class=\"string\">&quot;close&quot;</span>);</span><br><span class=\"line\">   &#125;)；</span><br><span class=\"line\">   scope.showSelect = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">       $(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(<span class=\"string\">&#x27;update&#x27;</span>,&#123;</span><br><span class=\"line\">           input:scope.value</span><br><span class=\"line\">       &#125;)</span><br><span class=\"line\">\t$(element).find(<span class=\"string\">&#x27;input&#x27;</span>).select(<span class=\"string\">&quot;open&quot;</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Angular4——7.表单处理","date":"2017-12-26T08:19:44.000Z","description":"Angular表单处理模块","_content":"\n# Angular表单\n\n在Angular中存在两种表单处理方式：\n\n## 模版驱动式表单\n\n表单的数据模型是通过组件模版中的相关指令来定义的。由于使用这种方式定义表单的数据模型时，我们会受限于HTML的语法，所以，模版驱动方式只适用于一些简单的场景。\n\n## 响应式表单\n\n使用响应式表单时，通过编写TypeScript代码而不是Html代码来创建一个底层的数据模型，在定义好这个模型以后，使用一些特定的指令，将模版上的HTML元素与底层的数据模型连接在一起。\n\n## Angular表单API\n\n不管是哪种表单，都有一个对应的数据模型来存储表单的数据。在模版式表单中，数据模型是由angular基于组件模版中的指令隐式创建的。而在响应式表单中，你通过编码明确的创建数据模型然后将模版上的html元素与底层的数据模型连接起来。\n\n数据模型并不是一个任意的对象，它是一个由angular/forms模块中的一些特定的类，如FormControl，FormGroup，FormArray等组成的。在模版式表单中，是不能直接访问这些类的。\n\n响应式表单并不会替你生成HTML，模版仍然需要你自己来编写。\n\n\n\n# 模版式表单\n\n使用模版式表单时，需要引入`FormsModule`，只能使用指令定义数据模型。这些指令都来自于`FormsModule`模块。\n\n```javascript\n// app.module.ts\nimport {FormsModule} from '@angular/forms';\n@NgModule({\n  imports:[\n    FormsModule\n  ]\n})\n```\n\n##模版式表单的指令：\n\n### NgForm\n\nngForm指令代表整个表单，在Angular应用里`ngForm`指令会自动的添加到每一个`<form>`表单上。`ngForm`会隐式的创建一个`FormGroup`类的实例，这个类用来代表表单的数据模型，并且存储表单的数据。\n\n```html\n<form>\n  <div>昵称：<input type=\"text\"></div>\n  <button type=\"submit\">提交</button>\n</form>\n```\n\n+ Angular应用会自动为`<form>`元素添加`ngForm`指令。\n\n+ `ngForm`会自动拦截表单的提交事件，阻止表单的提交。Angular用一个自定义的`ngSubmit`事件来代替他。\n\n  ```html\n  <form (ngSubmit)=\"test()\">\n    <div>昵称：<input type=\"text\"></div>\n    <button type=\"submit\">提交</button>\n  </form>\n  ```\n\n+ `ngForm`会自动发现添加了`ngModel`的子元素，并将这些子元素的值会被添加到表单数据模型中。\n\n+ `ngForm`指令可以也可以在其他元素上使用，比如`<div ngForm>`，这和写一个`<form>`效果是一样的。\n\n+ 如果你不希望Angular来自动处理你的表单，你可以在`<form>`元素上明确的添加`ngNoForm`指令：\n\n  ```html\n  <form ngNoForm>...</form>\n  ```\n\n  添加了`ngNoForm`指令，angular将不再接管`<form>`表单的处理。\n\n+ `ngForm`指令创建的对象可以被一个模版本地变量引用，以便在模版中访问ngForm对象的实例。\n\n  value是一个JS对象，保存着form表单中所有字段的值。\n\n  ```html\n  <form #myForm=\"ngForm\">\n    <div>昵称：<input ngModel name=\"nickName\" type=\"text\"></div>\n  </form>\n  <div>{{myForm.value}}</div>\n\n  //昵称：Tom\n  //{nickName: Tom}\n  ```\n\n###NgModel\n\n `ngModel`指令代表表单中的一个字段，`ngModel`指令会隐式的创建一个`FormControl`类的实例，来代表字段的数据模型，并用这个`FormControl`的对象来存储字段的值。\n\n```html\n<form #myForm=\"ngForm\">\n  <div>昵称：<input ngModel name=\"nickName\" type=\"text\"></div>\n</form>\n<div>{{myForm.value}}</div>\n```\n\n+ 在`<form>`标签或者标记了`ngForm`指令的HTML元素内，使用`ngModel`指令时，不需要像双向绑定那样用`[()]`扩起来，应为这里不是双向绑定，而是表单字段的指令；也不需要绑定到组件的属性上。\n\n  但是`ngModel`指令需要为添加它的HTML元素指定`name`的值。如果不指定`name`属性的值，angular不知道以什么名字把这个字段的值添加到数据模型中。\n\n+ 与`ngForm`类似，`ngModel`指令创建的对象也可以被模版本地变量引用，并通过模版本地变量来访问这个对象的值。\n\n  ```html\n  <form #myForm=\"ngForm\">\n    <div>昵称：<input #myNickName=\"ngModel\" ngModel name=\"nickName\" type=\"text\"></div>\n  </form>\n  <div>{{myForm.value}}</div>\n  <div>昵称的值是：{{myNickName.value}}</div>\n  ```\n\n###NgModelGroup\n\n`ngModelGroup`指令代表表单的一部分，他将表单的一部分组织在一起，形成更清晰的层级关系。\n\n与`ngForm`类似，`ngModelGroup`也会创建一个`FormGroup`类型的对象。\n\n```html\n<form #myForm=\"ngForm\">\n  <div>昵称：<input ngModel name=\"nickName\" type=\"text\"></div>\n  <div ngModelGroup=\"passwordInfo\">\n    <div>密码：<input type=\"password\"></div>\n    <div>确认密码：<input type=\"password\"></div>\n  </div>\n</form>\n<div>{{myForm.value}}</div>\n\n//\n{\n  \"nickName\":\"\",\n  \"password\":{}\n}\n```\n\n#响应式表单\n\n创建响应式表单与模版式表单不同，需要两步：\n\n+ 首先通过编码创建一个数据模型。\n+ 然后使用指令将模版中的HTML元素连接到数据模型上。\n\n使用响应式表单时，需要引入`ReactiveFormsModule`模块，响应式表单的指令都来自`ReactiveFormsModule`模块。\n\n```javascript\n// app.module.ts\nimport {ReactiveFormsModule} from '@angular/forms';\n@NgModule({\n  imports:[\n    ReactiveFormsModule\n  ]\n})\n```\n\n## 数据模型\n\n数据模型是指一个用来保存表单数据的数据结构，他由定义在`FormsModule`模块中的三个类组成：\n\n+ FormControl：\n\n  他是构成表单的基本单位，通常情况下用来表示一个`<input>`元素，也可以用来表示更复杂的UI组件。\n\n  FormControl类的对象保存着与其关联的HTML元素当前的值，元素是否被修改过，以及校验状态等信息。\n\n  ```javascript\n  // ReactiveForm.component.ts\n  private nickname = new FormControl('tom');\n  ```\n\n  `FormControl`接收的参数用来制定初始值。\n\n  模版式表单中，`ngModel`指令默认会为其附着的元素创建一个`FormControl`类的对象。\n\n  ​\n\n+ FormGroup：\n\n  `FormGroup`类代表表单的一部分，也可以表示整个表单，他是多个`FormControl`的集合。\n\n  `FormGroup`将多个`FormControl`的状态和值聚合在一起。如果其中一个`FormControl`的值是无效的，也就是不符合校验规则，那么整个`FormGroup`都是无效的。\n\n  ```javascript\n  // ReactiveForm.component.ts\n  private passwordInfo = new FormGroup({\n    password: new FormControl(),\n    passwordConfirm: new FormControl()\n  })\n  ```\n\n  `FormGroup`的构造函数需要传入一个对象`{}`，这个对象里是`FormControl`。\n\n  ​\n\n+ FormArray：\n\n  `FormArray`和`FormGroup`是类似的，但是有一个额外的属性，长度，因为`FormArray`是一个数组。\n\n  `FormGroup`用来代表整个表单，或者一个表单中固定的子集。\n\n  `FormArray`用来代表一个可以增长的集合。比如，一个表单中的邮箱字段，一个用户可以拥有多个邮箱。\n\n  ```javascript\n  // ReactiveForm.component.ts\n  private emails = new FormArray([\n    new FormControl(),\n    new FormControl(),\n    new FormControl()\n  ])\n  ```\n\n  `FormArray`中的`FormControl`没有key，而`FormGroup`中的`FormControl`是要有一个key。\n\n编写一个完整的表单数据模型：\n\n```javascript\n// ReactiveForm.component.ts\nexport class ReactiveFormComponent{\n  private formModel: FormGroup;\n  constructor(){\n    this.formModel = new FormGroup({\n      nickname: new FormControl(),\n      mobile: new FormControl(),\n      emails: new FormArray([\n        new FormControl()\n      ]),\n      passwordInfo: new FormGroup({\n        password: new FormControl(),\n        passwordConfirm: new FormControl()\n      })\n    })\n  }\n}\n```\n\n##响应式表单的指令：\n\n在控制器中已经构建好了数据模型，在模版中通过指令，将表单元素和数据模型连接起来。\n\n响应式表单使用和模版式表单完全不同的指令，这些指令来自于`ReactiveFormsModule`模块。\n\n响应式表单的指令分成两种，一种是需要使用属性绑定语法`[xxx]=\"xxx\"`的指令，另一种是不需要属性绑定语法的指令。\n\n响应式表单的所有指令，都是以`form`开头的；而模版式表单的所有指令，都是以`ng`开头的。\n\n###使用属性绑定的指令：\n\n`formGroup`，`formControl`\n\n这种指令使用时必须使用属性绑定语法，就是说使用这些指令时，需要使用属性绑定的语法，用`[]`扩起来。\n\n属性绑定的指令，必须绑定到组件中的某个属性上，比如： \n\n```html\n<form [formGroup]=\"formModel\"></form>\n\nexport class ReactiveForm {\n  private formModel: FormGroup;\n}\n```\n\n指令的名字很简单，和类名一样，首字母小写。\n\n`FormArray`类没有属性绑定方式的指令，因为它是数组，没有key来对应。\n\n###不使用属性绑定的指令：\n\n`formGroupName`，`formControlName`，`formArrayName`\n\n这些以Name结尾的指令可以使用属性的名字来连接DOM元素和数据模型，它们不需要使用属性绑定语法。\n\n`formGroup`通过属性绑定将表单绑定到组件中的`formModel`属性上，`nickname`不是组件的属性，只是数据模型中的一个字段的key，因此不能用属性绑定`[formControl]=\"nickname\"`，否则会报错。\n\n```javascript\n<form [formGroup]=\"formModel\">\n\t<input formControlName=\"nickname\">\n</form>\n\nexport class ReactiveForm {\n  private formModel: FormGroup;\n  constructor(){\n  this.formModel = new FormGroup({\n   nickname: new FormControl()\n\t\t})\n\t}\n}\n```\n\n与模版式表单不同，响应式表单的指令都是不可引用的，不能像模版式表单那样用模版本地变量来引用。\n\n而在模版式表单中，不能在控制器中直接访问`FormGroup`、`FormControl`这些类。\n\nAngular是故意这么做，目的就是区分模版式表单和响应式表单。\n\n```html\n<form [formGroup]=\"formModel\" (submit)=\"createUser()\">\n  <div>昵称：<input formControlName=\"nickname\" type=\"text\"></div>\n  <div>邮箱：\n  \t<ul formArrayName=\"emails\">\n      <li *ngFor=\"let email of formModel.get('emails').controls; let i = index\">\n      \t<input [formControlName]=\"i\">\n      </li>\n    </ul>\n  </div>\n  <div>手机号：<input formControlName=\"mobile\" type=\"text\"></div>\n  <div formGroupName=\"passwordInfo\">\n    <div>密码：<input formControlName=\"password\" type=\"password\"></div>\n    <div>确认密码：<input formControlName=\"passwordConfirm\" type=\"password\"></div>\n  </div>\n  <button type=\"submit\">注册</button>\n</form>\n```\n\n```javascript\nexport class ReactiveForm {\n    private formModel: FormGroup;\n\tconstructor(){\n      this.formModel = new FormGroup({\n        nickname: new FormControl(),\n        mobile: new FormControl(),\n        emails: new FormArray([\n          new FormControl()\n        ]),\n        passwordInfo: new FormGroup({\n          password: new FormControl(),\n          passwordConfirm: new FormControl()\n        })\n      })\n  \t}\n\tcreateUser(){\n        \n    }\n}\n```\n\n**注意**：\n\n+ 处理submit事件：\n  + 模版式表单中提供了`ngSubmit`事件来处理表单提交：`<form #myForm=\"ngForm\"(ngSubmit)=\"createUser(myForm)\"`。在模版式表单中，通过把保存表单数据的模版本地变量传给控制器来获取表单数据。\n  + 响应式表单中直接处理原生的`submit`事件：`<form (submit)=\"createUser()\">`。并且，不需要传模版本地变量，因为响应式表单中本身就不能引用模版本地变量，表单的数据模型是在组件控制器中定义的，在控制器中就能直接拿到数据。\n\n## FormBuilder\n\nFormBuilder是Angular提供的一个工具类，它并没有提供新的功能，只是简化构建响应式表单数据结构的语法。\n\n```javascript\nexport class ReactiveForm{\n  private formModel: FormGroup;\n  private fb: FormBuilder = new FormBuilder();\n  constructor(){\n    this.formModel = this.fb.group({\n        nickname: [''],\n        mobile: [''],\n        emails: this.fb.array([\n          [''],\n        ]),\n        passwordInfo: this.fb.group({\n          password: [''],\n          passwordConfirm: [''],\n        })\n      })\n  }\n}\n```\n\n+ `new FormGroup({}) = new FormBuilder().group({});`\n+ `new FormControl() = new FormBuilder().[''];`\n+ `new FormArray([]) = new FormBuilder().array([]);`\n\n此外，FormBuilder还可以对表单模型进行其他的配置，比如校验表单。\n\n# 表单校验\n\n## Angular校验器\n\nangular校验器有两种，一个是自己定义的校验器，另一个是angular预定义好的校验器：\n\n### Angular预定义的校验器\n\nangular提供的校验器都在一个叫`Validators`的类中，这个类有很多方法，比如：\n\n+ `Validators.required`必填的校验器\n+ `Validators.minLength()`最小长度的校验器\n+ `Validators.maxLength()`最到长度的校验器\n\n等等。\n\n当有了定义好的校验器，包括angular提供的或者自己定义的，我们就可以配置数据模型来使用校验器。\n\n 将校验器作为参数传到表单模型的构造函数中就能进行校验：\n\n```\nthis.formModel = this.fb.group({\n  nickname:['',Validators.required]\n})\n```\n\n这个意思是nickname这个字段是必填的。\n\n也可以同时传入多个校验器，那么这个参数就是一个数组：\n\n```\nthis.formModel = this.fb.group({\n  nickname: ['', [Validators.required, Validators.minLength(5)]\n})\n```\n\nnickname这个字段是必填的，同时最小长度是5。\n\n###自定义校验器\n\n自定义的校验器实际上就是一个自定义的方法，该方法要求需要传入一个`AbstractControl`类的参数，并且该方法的返回值必须是`key`为`string`类型的对象：\n\n```\nxxx(param: AbstractControl):{[key:string]: any}{\n  return null;\n}\n```\n\n+ `AbstractControl`类是`FormGroup`，`FormControl`，`FormArray`的父类，因此，自定义校验器的参数可以是这三个类中的任意一种。\n\n当需要更复杂的校验规则时，angular提供的校验器可能无法满足需求，我们可以通过自定义的检验器来实现。\n\n## 响应式表单校验\n\n```javascript\nclass FormBuilder {\n  group(controlsConfig: {[key: string]: any}, extra: {[key: string]: any}|null = null): FormGroup\n  \n  control(formState: Object, validator?: ValidatorFn|ValidatorFn[]|null, asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormControl\n  \n  array(controlsConfig: any[], validator?: ValidatorFn|null, asyncValidator?: AsyncValidatorFn|null): FormArray\n}\n```\n\n```javascript\nimport {FormControl, FormGroup} from \"@angular/forms\";\nimport {Observable} from \"rxjs\";\n\nexport function mobileValidator(mobile: FormControl):any {\n  let value = (mobile.value || '') + '';\n  var myreg = /^(((13[0-9]{1})|(15[0-9]{1})|(18[0-9]{1}))+\\d{8})$/;\n  let valid = myreg.test(value);\n  console.log('mobile是否校验通过:'+valid);\n  return valid ? null : {mobile:true};\n}\n\nexport function mobileAsyncValidator(mobile: FormControl):any {\n  let value = (mobile.value || '') + '';\n  var myreg = /^(((13[0-9]{1})|(15[0-9]{1})|(18[0-9]{1}))+\\d{8})$/;\n  let valid = myreg.test(value);\n  console.log('mobile是否校验通过:'+valid);\n  return Observable.of(valid ? null : {mobile:true}).delay(5000);\n}\n\nexport function passwordValidator(info: FormGroup):any {\n  let password:FormControl = info.get('password') as FormControl;\n  let pConfirm:FormControl = info.get('passwordConfirm') as FormControl;\n  if(password != null && pConfirm != null) {\n    let valid:boolean = password.value === pConfirm.value;\n    console.log('password是否校验通过:'+valid);\n    return valid ? null : {password: {description:'密码和确认密码不匹配'}};\n  }\n  return null;\n}\n```\n\n```javascript\nexport class ReactivedFormComponent implements OnInit {\n\n  private formModel:FormGroup;\n\n  private fb:FormBuilder = new FormBuilder();\n\n  constructor() {\n    this.formModel = this.fb.group({\n      nickname: ['xxxx', [Validators.required, Validators.minLength(6)]],\n      emails: this.fb.array([\n        ['']\n      ]),\n      mobile: ['', mobileValidator, mobileAsyncValidator],\n      passwordInfo: this.fb.group({\n        password: ['', Validators.required],\n        passwordConfirm: ['']\n      }, {validator: passwordValidator})\n    })\n  }\n}\n```\n\n```html\n<form [formGroup]=\"formModel\" (submit)=\"createUser()\" >\n  <div>昵称:<input [class.inputHasError]=\"formModel.get('nickname').invalid\" formControlName=\"nickname\" type=\"text\" pattern=\"[a-zA-A0-9]+\"></div>\n  <div [hidden]=\"!formModel.hasError('required','nickname')\">\n    昵称是必填项\n  </div>\n  <div [hidden]=\"!formModel.hasError('minlength','nickname')\">\n    昵称的最小长度是6\n  </div>\n  <div>邮箱:\n    <ul formArrayName=\"emails\">\n      <li *ngFor=\"let email of formModel.get('emails').controls;let i = index\">\n        <input [formControlName]=\"i\">\n      </li>\n    </ul>\n    <button type=\"button\" (click)=\"addEmail()\">增加Email</button>\n  </div>\n  <div>手机号:<input formControlName=\"mobile\"  type=\"number\"></div>\n  <div [hidden]=\"formModel.get('mobile').valid || formModel.get('mobile').pristine\">\n    <div [hidden]=\"!formModel.hasError('mobile','mobile')\">\n      手机号不合法\n    </div>\n  </div>\n  <div [hidden]=\"!formModel.get('mobile').pending\">\n    正在校验手机号合法性\n  </div>\n  <div formGroupName=\"passwordInfo\">\n    <div>密码:<input formControlName=\"password\" type=\"password\"></div>\n    <div [hidden]=\"formModel.get('passwordInfo.password').valid || formModel.get('passwordInfo.password').untouched\">\n      <div [hidden]=\"!formModel.hasError('required','passwordInfo.password')\">\n        密码是必填项\n      </div>\n    </div>\n    <div>确认密码:<input formControlName=\"passwordConfirm\" type=\"password\"></div>\n  </div>\n  <div [hidden]=\"!formModel.hasError('password','passwordInfo')\">\n    {{formModel.getError('password', 'passwordInfo')?.description}}\n  </div>\n  <button type=\"submit\">注册</button>\n</form>\n<div>\n  {{formModel.status}}\n</div>\n\n```\n\n+ `FormGroup.hasError('校验器的key','被校验字段的key')`\n+ `FormGroup.getError('校验器的key','被校验字段的key')`\n+ `FormGroup.get('').`\n\n","source":"_posts/Angular4——7-表单处理.md","raw":"---\ntitle: Angular4——7.表单处理\ndate: 2017-12-26 16:19:44\ntags:\n- Angular\ncategories:\n- 学习笔记\ndescription: Angular表单处理模块\n---\n\n# Angular表单\n\n在Angular中存在两种表单处理方式：\n\n## 模版驱动式表单\n\n表单的数据模型是通过组件模版中的相关指令来定义的。由于使用这种方式定义表单的数据模型时，我们会受限于HTML的语法，所以，模版驱动方式只适用于一些简单的场景。\n\n## 响应式表单\n\n使用响应式表单时，通过编写TypeScript代码而不是Html代码来创建一个底层的数据模型，在定义好这个模型以后，使用一些特定的指令，将模版上的HTML元素与底层的数据模型连接在一起。\n\n## Angular表单API\n\n不管是哪种表单，都有一个对应的数据模型来存储表单的数据。在模版式表单中，数据模型是由angular基于组件模版中的指令隐式创建的。而在响应式表单中，你通过编码明确的创建数据模型然后将模版上的html元素与底层的数据模型连接起来。\n\n数据模型并不是一个任意的对象，它是一个由angular/forms模块中的一些特定的类，如FormControl，FormGroup，FormArray等组成的。在模版式表单中，是不能直接访问这些类的。\n\n响应式表单并不会替你生成HTML，模版仍然需要你自己来编写。\n\n\n\n# 模版式表单\n\n使用模版式表单时，需要引入`FormsModule`，只能使用指令定义数据模型。这些指令都来自于`FormsModule`模块。\n\n```javascript\n// app.module.ts\nimport {FormsModule} from '@angular/forms';\n@NgModule({\n  imports:[\n    FormsModule\n  ]\n})\n```\n\n##模版式表单的指令：\n\n### NgForm\n\nngForm指令代表整个表单，在Angular应用里`ngForm`指令会自动的添加到每一个`<form>`表单上。`ngForm`会隐式的创建一个`FormGroup`类的实例，这个类用来代表表单的数据模型，并且存储表单的数据。\n\n```html\n<form>\n  <div>昵称：<input type=\"text\"></div>\n  <button type=\"submit\">提交</button>\n</form>\n```\n\n+ Angular应用会自动为`<form>`元素添加`ngForm`指令。\n\n+ `ngForm`会自动拦截表单的提交事件，阻止表单的提交。Angular用一个自定义的`ngSubmit`事件来代替他。\n\n  ```html\n  <form (ngSubmit)=\"test()\">\n    <div>昵称：<input type=\"text\"></div>\n    <button type=\"submit\">提交</button>\n  </form>\n  ```\n\n+ `ngForm`会自动发现添加了`ngModel`的子元素，并将这些子元素的值会被添加到表单数据模型中。\n\n+ `ngForm`指令可以也可以在其他元素上使用，比如`<div ngForm>`，这和写一个`<form>`效果是一样的。\n\n+ 如果你不希望Angular来自动处理你的表单，你可以在`<form>`元素上明确的添加`ngNoForm`指令：\n\n  ```html\n  <form ngNoForm>...</form>\n  ```\n\n  添加了`ngNoForm`指令，angular将不再接管`<form>`表单的处理。\n\n+ `ngForm`指令创建的对象可以被一个模版本地变量引用，以便在模版中访问ngForm对象的实例。\n\n  value是一个JS对象，保存着form表单中所有字段的值。\n\n  ```html\n  <form #myForm=\"ngForm\">\n    <div>昵称：<input ngModel name=\"nickName\" type=\"text\"></div>\n  </form>\n  <div>{{myForm.value}}</div>\n\n  //昵称：Tom\n  //{nickName: Tom}\n  ```\n\n###NgModel\n\n `ngModel`指令代表表单中的一个字段，`ngModel`指令会隐式的创建一个`FormControl`类的实例，来代表字段的数据模型，并用这个`FormControl`的对象来存储字段的值。\n\n```html\n<form #myForm=\"ngForm\">\n  <div>昵称：<input ngModel name=\"nickName\" type=\"text\"></div>\n</form>\n<div>{{myForm.value}}</div>\n```\n\n+ 在`<form>`标签或者标记了`ngForm`指令的HTML元素内，使用`ngModel`指令时，不需要像双向绑定那样用`[()]`扩起来，应为这里不是双向绑定，而是表单字段的指令；也不需要绑定到组件的属性上。\n\n  但是`ngModel`指令需要为添加它的HTML元素指定`name`的值。如果不指定`name`属性的值，angular不知道以什么名字把这个字段的值添加到数据模型中。\n\n+ 与`ngForm`类似，`ngModel`指令创建的对象也可以被模版本地变量引用，并通过模版本地变量来访问这个对象的值。\n\n  ```html\n  <form #myForm=\"ngForm\">\n    <div>昵称：<input #myNickName=\"ngModel\" ngModel name=\"nickName\" type=\"text\"></div>\n  </form>\n  <div>{{myForm.value}}</div>\n  <div>昵称的值是：{{myNickName.value}}</div>\n  ```\n\n###NgModelGroup\n\n`ngModelGroup`指令代表表单的一部分，他将表单的一部分组织在一起，形成更清晰的层级关系。\n\n与`ngForm`类似，`ngModelGroup`也会创建一个`FormGroup`类型的对象。\n\n```html\n<form #myForm=\"ngForm\">\n  <div>昵称：<input ngModel name=\"nickName\" type=\"text\"></div>\n  <div ngModelGroup=\"passwordInfo\">\n    <div>密码：<input type=\"password\"></div>\n    <div>确认密码：<input type=\"password\"></div>\n  </div>\n</form>\n<div>{{myForm.value}}</div>\n\n//\n{\n  \"nickName\":\"\",\n  \"password\":{}\n}\n```\n\n#响应式表单\n\n创建响应式表单与模版式表单不同，需要两步：\n\n+ 首先通过编码创建一个数据模型。\n+ 然后使用指令将模版中的HTML元素连接到数据模型上。\n\n使用响应式表单时，需要引入`ReactiveFormsModule`模块，响应式表单的指令都来自`ReactiveFormsModule`模块。\n\n```javascript\n// app.module.ts\nimport {ReactiveFormsModule} from '@angular/forms';\n@NgModule({\n  imports:[\n    ReactiveFormsModule\n  ]\n})\n```\n\n## 数据模型\n\n数据模型是指一个用来保存表单数据的数据结构，他由定义在`FormsModule`模块中的三个类组成：\n\n+ FormControl：\n\n  他是构成表单的基本单位，通常情况下用来表示一个`<input>`元素，也可以用来表示更复杂的UI组件。\n\n  FormControl类的对象保存着与其关联的HTML元素当前的值，元素是否被修改过，以及校验状态等信息。\n\n  ```javascript\n  // ReactiveForm.component.ts\n  private nickname = new FormControl('tom');\n  ```\n\n  `FormControl`接收的参数用来制定初始值。\n\n  模版式表单中，`ngModel`指令默认会为其附着的元素创建一个`FormControl`类的对象。\n\n  ​\n\n+ FormGroup：\n\n  `FormGroup`类代表表单的一部分，也可以表示整个表单，他是多个`FormControl`的集合。\n\n  `FormGroup`将多个`FormControl`的状态和值聚合在一起。如果其中一个`FormControl`的值是无效的，也就是不符合校验规则，那么整个`FormGroup`都是无效的。\n\n  ```javascript\n  // ReactiveForm.component.ts\n  private passwordInfo = new FormGroup({\n    password: new FormControl(),\n    passwordConfirm: new FormControl()\n  })\n  ```\n\n  `FormGroup`的构造函数需要传入一个对象`{}`，这个对象里是`FormControl`。\n\n  ​\n\n+ FormArray：\n\n  `FormArray`和`FormGroup`是类似的，但是有一个额外的属性，长度，因为`FormArray`是一个数组。\n\n  `FormGroup`用来代表整个表单，或者一个表单中固定的子集。\n\n  `FormArray`用来代表一个可以增长的集合。比如，一个表单中的邮箱字段，一个用户可以拥有多个邮箱。\n\n  ```javascript\n  // ReactiveForm.component.ts\n  private emails = new FormArray([\n    new FormControl(),\n    new FormControl(),\n    new FormControl()\n  ])\n  ```\n\n  `FormArray`中的`FormControl`没有key，而`FormGroup`中的`FormControl`是要有一个key。\n\n编写一个完整的表单数据模型：\n\n```javascript\n// ReactiveForm.component.ts\nexport class ReactiveFormComponent{\n  private formModel: FormGroup;\n  constructor(){\n    this.formModel = new FormGroup({\n      nickname: new FormControl(),\n      mobile: new FormControl(),\n      emails: new FormArray([\n        new FormControl()\n      ]),\n      passwordInfo: new FormGroup({\n        password: new FormControl(),\n        passwordConfirm: new FormControl()\n      })\n    })\n  }\n}\n```\n\n##响应式表单的指令：\n\n在控制器中已经构建好了数据模型，在模版中通过指令，将表单元素和数据模型连接起来。\n\n响应式表单使用和模版式表单完全不同的指令，这些指令来自于`ReactiveFormsModule`模块。\n\n响应式表单的指令分成两种，一种是需要使用属性绑定语法`[xxx]=\"xxx\"`的指令，另一种是不需要属性绑定语法的指令。\n\n响应式表单的所有指令，都是以`form`开头的；而模版式表单的所有指令，都是以`ng`开头的。\n\n###使用属性绑定的指令：\n\n`formGroup`，`formControl`\n\n这种指令使用时必须使用属性绑定语法，就是说使用这些指令时，需要使用属性绑定的语法，用`[]`扩起来。\n\n属性绑定的指令，必须绑定到组件中的某个属性上，比如： \n\n```html\n<form [formGroup]=\"formModel\"></form>\n\nexport class ReactiveForm {\n  private formModel: FormGroup;\n}\n```\n\n指令的名字很简单，和类名一样，首字母小写。\n\n`FormArray`类没有属性绑定方式的指令，因为它是数组，没有key来对应。\n\n###不使用属性绑定的指令：\n\n`formGroupName`，`formControlName`，`formArrayName`\n\n这些以Name结尾的指令可以使用属性的名字来连接DOM元素和数据模型，它们不需要使用属性绑定语法。\n\n`formGroup`通过属性绑定将表单绑定到组件中的`formModel`属性上，`nickname`不是组件的属性，只是数据模型中的一个字段的key，因此不能用属性绑定`[formControl]=\"nickname\"`，否则会报错。\n\n```javascript\n<form [formGroup]=\"formModel\">\n\t<input formControlName=\"nickname\">\n</form>\n\nexport class ReactiveForm {\n  private formModel: FormGroup;\n  constructor(){\n  this.formModel = new FormGroup({\n   nickname: new FormControl()\n\t\t})\n\t}\n}\n```\n\n与模版式表单不同，响应式表单的指令都是不可引用的，不能像模版式表单那样用模版本地变量来引用。\n\n而在模版式表单中，不能在控制器中直接访问`FormGroup`、`FormControl`这些类。\n\nAngular是故意这么做，目的就是区分模版式表单和响应式表单。\n\n```html\n<form [formGroup]=\"formModel\" (submit)=\"createUser()\">\n  <div>昵称：<input formControlName=\"nickname\" type=\"text\"></div>\n  <div>邮箱：\n  \t<ul formArrayName=\"emails\">\n      <li *ngFor=\"let email of formModel.get('emails').controls; let i = index\">\n      \t<input [formControlName]=\"i\">\n      </li>\n    </ul>\n  </div>\n  <div>手机号：<input formControlName=\"mobile\" type=\"text\"></div>\n  <div formGroupName=\"passwordInfo\">\n    <div>密码：<input formControlName=\"password\" type=\"password\"></div>\n    <div>确认密码：<input formControlName=\"passwordConfirm\" type=\"password\"></div>\n  </div>\n  <button type=\"submit\">注册</button>\n</form>\n```\n\n```javascript\nexport class ReactiveForm {\n    private formModel: FormGroup;\n\tconstructor(){\n      this.formModel = new FormGroup({\n        nickname: new FormControl(),\n        mobile: new FormControl(),\n        emails: new FormArray([\n          new FormControl()\n        ]),\n        passwordInfo: new FormGroup({\n          password: new FormControl(),\n          passwordConfirm: new FormControl()\n        })\n      })\n  \t}\n\tcreateUser(){\n        \n    }\n}\n```\n\n**注意**：\n\n+ 处理submit事件：\n  + 模版式表单中提供了`ngSubmit`事件来处理表单提交：`<form #myForm=\"ngForm\"(ngSubmit)=\"createUser(myForm)\"`。在模版式表单中，通过把保存表单数据的模版本地变量传给控制器来获取表单数据。\n  + 响应式表单中直接处理原生的`submit`事件：`<form (submit)=\"createUser()\">`。并且，不需要传模版本地变量，因为响应式表单中本身就不能引用模版本地变量，表单的数据模型是在组件控制器中定义的，在控制器中就能直接拿到数据。\n\n## FormBuilder\n\nFormBuilder是Angular提供的一个工具类，它并没有提供新的功能，只是简化构建响应式表单数据结构的语法。\n\n```javascript\nexport class ReactiveForm{\n  private formModel: FormGroup;\n  private fb: FormBuilder = new FormBuilder();\n  constructor(){\n    this.formModel = this.fb.group({\n        nickname: [''],\n        mobile: [''],\n        emails: this.fb.array([\n          [''],\n        ]),\n        passwordInfo: this.fb.group({\n          password: [''],\n          passwordConfirm: [''],\n        })\n      })\n  }\n}\n```\n\n+ `new FormGroup({}) = new FormBuilder().group({});`\n+ `new FormControl() = new FormBuilder().[''];`\n+ `new FormArray([]) = new FormBuilder().array([]);`\n\n此外，FormBuilder还可以对表单模型进行其他的配置，比如校验表单。\n\n# 表单校验\n\n## Angular校验器\n\nangular校验器有两种，一个是自己定义的校验器，另一个是angular预定义好的校验器：\n\n### Angular预定义的校验器\n\nangular提供的校验器都在一个叫`Validators`的类中，这个类有很多方法，比如：\n\n+ `Validators.required`必填的校验器\n+ `Validators.minLength()`最小长度的校验器\n+ `Validators.maxLength()`最到长度的校验器\n\n等等。\n\n当有了定义好的校验器，包括angular提供的或者自己定义的，我们就可以配置数据模型来使用校验器。\n\n 将校验器作为参数传到表单模型的构造函数中就能进行校验：\n\n```\nthis.formModel = this.fb.group({\n  nickname:['',Validators.required]\n})\n```\n\n这个意思是nickname这个字段是必填的。\n\n也可以同时传入多个校验器，那么这个参数就是一个数组：\n\n```\nthis.formModel = this.fb.group({\n  nickname: ['', [Validators.required, Validators.minLength(5)]\n})\n```\n\nnickname这个字段是必填的，同时最小长度是5。\n\n###自定义校验器\n\n自定义的校验器实际上就是一个自定义的方法，该方法要求需要传入一个`AbstractControl`类的参数，并且该方法的返回值必须是`key`为`string`类型的对象：\n\n```\nxxx(param: AbstractControl):{[key:string]: any}{\n  return null;\n}\n```\n\n+ `AbstractControl`类是`FormGroup`，`FormControl`，`FormArray`的父类，因此，自定义校验器的参数可以是这三个类中的任意一种。\n\n当需要更复杂的校验规则时，angular提供的校验器可能无法满足需求，我们可以通过自定义的检验器来实现。\n\n## 响应式表单校验\n\n```javascript\nclass FormBuilder {\n  group(controlsConfig: {[key: string]: any}, extra: {[key: string]: any}|null = null): FormGroup\n  \n  control(formState: Object, validator?: ValidatorFn|ValidatorFn[]|null, asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null): FormControl\n  \n  array(controlsConfig: any[], validator?: ValidatorFn|null, asyncValidator?: AsyncValidatorFn|null): FormArray\n}\n```\n\n```javascript\nimport {FormControl, FormGroup} from \"@angular/forms\";\nimport {Observable} from \"rxjs\";\n\nexport function mobileValidator(mobile: FormControl):any {\n  let value = (mobile.value || '') + '';\n  var myreg = /^(((13[0-9]{1})|(15[0-9]{1})|(18[0-9]{1}))+\\d{8})$/;\n  let valid = myreg.test(value);\n  console.log('mobile是否校验通过:'+valid);\n  return valid ? null : {mobile:true};\n}\n\nexport function mobileAsyncValidator(mobile: FormControl):any {\n  let value = (mobile.value || '') + '';\n  var myreg = /^(((13[0-9]{1})|(15[0-9]{1})|(18[0-9]{1}))+\\d{8})$/;\n  let valid = myreg.test(value);\n  console.log('mobile是否校验通过:'+valid);\n  return Observable.of(valid ? null : {mobile:true}).delay(5000);\n}\n\nexport function passwordValidator(info: FormGroup):any {\n  let password:FormControl = info.get('password') as FormControl;\n  let pConfirm:FormControl = info.get('passwordConfirm') as FormControl;\n  if(password != null && pConfirm != null) {\n    let valid:boolean = password.value === pConfirm.value;\n    console.log('password是否校验通过:'+valid);\n    return valid ? null : {password: {description:'密码和确认密码不匹配'}};\n  }\n  return null;\n}\n```\n\n```javascript\nexport class ReactivedFormComponent implements OnInit {\n\n  private formModel:FormGroup;\n\n  private fb:FormBuilder = new FormBuilder();\n\n  constructor() {\n    this.formModel = this.fb.group({\n      nickname: ['xxxx', [Validators.required, Validators.minLength(6)]],\n      emails: this.fb.array([\n        ['']\n      ]),\n      mobile: ['', mobileValidator, mobileAsyncValidator],\n      passwordInfo: this.fb.group({\n        password: ['', Validators.required],\n        passwordConfirm: ['']\n      }, {validator: passwordValidator})\n    })\n  }\n}\n```\n\n```html\n<form [formGroup]=\"formModel\" (submit)=\"createUser()\" >\n  <div>昵称:<input [class.inputHasError]=\"formModel.get('nickname').invalid\" formControlName=\"nickname\" type=\"text\" pattern=\"[a-zA-A0-9]+\"></div>\n  <div [hidden]=\"!formModel.hasError('required','nickname')\">\n    昵称是必填项\n  </div>\n  <div [hidden]=\"!formModel.hasError('minlength','nickname')\">\n    昵称的最小长度是6\n  </div>\n  <div>邮箱:\n    <ul formArrayName=\"emails\">\n      <li *ngFor=\"let email of formModel.get('emails').controls;let i = index\">\n        <input [formControlName]=\"i\">\n      </li>\n    </ul>\n    <button type=\"button\" (click)=\"addEmail()\">增加Email</button>\n  </div>\n  <div>手机号:<input formControlName=\"mobile\"  type=\"number\"></div>\n  <div [hidden]=\"formModel.get('mobile').valid || formModel.get('mobile').pristine\">\n    <div [hidden]=\"!formModel.hasError('mobile','mobile')\">\n      手机号不合法\n    </div>\n  </div>\n  <div [hidden]=\"!formModel.get('mobile').pending\">\n    正在校验手机号合法性\n  </div>\n  <div formGroupName=\"passwordInfo\">\n    <div>密码:<input formControlName=\"password\" type=\"password\"></div>\n    <div [hidden]=\"formModel.get('passwordInfo.password').valid || formModel.get('passwordInfo.password').untouched\">\n      <div [hidden]=\"!formModel.hasError('required','passwordInfo.password')\">\n        密码是必填项\n      </div>\n    </div>\n    <div>确认密码:<input formControlName=\"passwordConfirm\" type=\"password\"></div>\n  </div>\n  <div [hidden]=\"!formModel.hasError('password','passwordInfo')\">\n    {{formModel.getError('password', 'passwordInfo')?.description}}\n  </div>\n  <button type=\"submit\">注册</button>\n</form>\n<div>\n  {{formModel.status}}\n</div>\n\n```\n\n+ `FormGroup.hasError('校验器的key','被校验字段的key')`\n+ `FormGroup.getError('校验器的key','被校验字段的key')`\n+ `FormGroup.get('').`\n\n","slug":"Angular4——7-表单处理","published":1,"updated":"2021-05-08T15:00:26.273Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbpr0023wct44wd602ly","content":"<h1 id=\"Angular表单\"><a href=\"#Angular表单\" class=\"headerlink\" title=\"Angular表单\"></a>Angular表单</h1><p>在Angular中存在两种表单处理方式：</p>\n<h2 id=\"模版驱动式表单\"><a href=\"#模版驱动式表单\" class=\"headerlink\" title=\"模版驱动式表单\"></a>模版驱动式表单</h2><p>表单的数据模型是通过组件模版中的相关指令来定义的。由于使用这种方式定义表单的数据模型时，我们会受限于HTML的语法，所以，模版驱动方式只适用于一些简单的场景。</p>\n<h2 id=\"响应式表单\"><a href=\"#响应式表单\" class=\"headerlink\" title=\"响应式表单\"></a>响应式表单</h2><p>使用响应式表单时，通过编写TypeScript代码而不是Html代码来创建一个底层的数据模型，在定义好这个模型以后，使用一些特定的指令，将模版上的HTML元素与底层的数据模型连接在一起。</p>\n<h2 id=\"Angular表单API\"><a href=\"#Angular表单API\" class=\"headerlink\" title=\"Angular表单API\"></a>Angular表单API</h2><p>不管是哪种表单，都有一个对应的数据模型来存储表单的数据。在模版式表单中，数据模型是由angular基于组件模版中的指令隐式创建的。而在响应式表单中，你通过编码明确的创建数据模型然后将模版上的html元素与底层的数据模型连接起来。</p>\n<p>数据模型并不是一个任意的对象，它是一个由angular/forms模块中的一些特定的类，如FormControl，FormGroup，FormArray等组成的。在模版式表单中，是不能直接访问这些类的。</p>\n<p>响应式表单并不会替你生成HTML，模版仍然需要你自己来编写。</p>\n<h1 id=\"模版式表单\"><a href=\"#模版式表单\" class=\"headerlink\" title=\"模版式表单\"></a>模版式表单</h1><p>使用模版式表单时，需要引入<code>FormsModule</code>，只能使用指令定义数据模型。这些指令都来自于<code>FormsModule</code>模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.module.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;FormsModule&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/forms&#x27;</span>;</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    FormsModule</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>##模版式表单的指令：</p>\n<h3 id=\"NgForm\"><a href=\"#NgForm\" class=\"headerlink\" title=\"NgForm\"></a>NgForm</h3><p>ngForm指令代表整个表单，在Angular应用里<code>ngForm</code>指令会自动的添加到每一个<code>&lt;form&gt;</code>表单上。<code>ngForm</code>会隐式的创建一个<code>FormGroup</code>类的实例，这个类用来代表表单的数据模型，并且存储表单的数据。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Angular应用会自动为<code>&lt;form&gt;</code>元素添加<code>ngForm</code>指令。</p>\n</li>\n<li><p><code>ngForm</code>会自动拦截表单的提交事件，阻止表单的提交。Angular用一个自定义的<code>ngSubmit</code>事件来代替他。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> (<span class=\"attr\">ngSubmit</span>)=<span class=\"string\">&quot;test()&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>ngForm</code>会自动发现添加了<code>ngModel</code>的子元素，并将这些子元素的值会被添加到表单数据模型中。</p>\n</li>\n<li><p><code>ngForm</code>指令可以也可以在其他元素上使用，比如<code>&lt;div ngForm&gt;</code>，这和写一个<code>&lt;form&gt;</code>效果是一样的。</p>\n</li>\n<li><p>如果你不希望Angular来自动处理你的表单，你可以在<code>&lt;form&gt;</code>元素上明确的添加<code>ngNoForm</code>指令：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">ngNoForm</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>添加了<code>ngNoForm</code>指令，angular将不再接管<code>&lt;form&gt;</code>表单的处理。</p>\n</li>\n<li><p><code>ngForm</code>指令创建的对象可以被一个模版本地变量引用，以便在模版中访问ngForm对象的实例。</p>\n<p>value是一个JS对象，保存着form表单中所有字段的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">myForm</span>=<span class=\"string\">&quot;ngForm&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nickName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;myForm.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//昵称：Tom</span><br><span class=\"line\">//&#123;nickName: Tom&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>###NgModel</p>\n<p> <code>ngModel</code>指令代表表单中的一个字段，<code>ngModel</code>指令会隐式的创建一个<code>FormControl</code>类的实例，来代表字段的数据模型，并用这个<code>FormControl</code>的对象来存储字段的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">myForm</span>=<span class=\"string\">&quot;ngForm&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nickName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;myForm.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>在<code>&lt;form&gt;</code>标签或者标记了<code>ngForm</code>指令的HTML元素内，使用<code>ngModel</code>指令时，不需要像双向绑定那样用<code>[()]</code>扩起来，应为这里不是双向绑定，而是表单字段的指令；也不需要绑定到组件的属性上。</p>\n<p>但是<code>ngModel</code>指令需要为添加它的HTML元素指定<code>name</code>的值。如果不指定<code>name</code>属性的值，angular不知道以什么名字把这个字段的值添加到数据模型中。</p>\n</li>\n<li><p>与<code>ngForm</code>类似，<code>ngModel</code>指令创建的对象也可以被模版本地变量引用，并通过模版本地变量来访问这个对象的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">myForm</span>=<span class=\"string\">&quot;ngForm&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">myNickName</span>=<span class=\"string\">&quot;ngModel&quot;</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nickName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;myForm.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称的值是：&#123;&#123;myNickName.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>###NgModelGroup</p>\n<p><code>ngModelGroup</code>指令代表表单的一部分，他将表单的一部分组织在一起，形成更清晰的层级关系。</p>\n<p>与<code>ngForm</code>类似，<code>ngModelGroup</code>也会创建一个<code>FormGroup</code>类型的对象。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">myForm</span>=<span class=\"string\">&quot;ngForm&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nickName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ngModelGroup</span>=<span class=\"string\">&quot;passwordInfo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>确认密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;myForm.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;nickName&quot;:&quot;&quot;,</span><br><span class=\"line\">  &quot;password&quot;:&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>#响应式表单</p>\n<p>创建响应式表单与模版式表单不同，需要两步：</p>\n<ul>\n<li>首先通过编码创建一个数据模型。</li>\n<li>然后使用指令将模版中的HTML元素连接到数据模型上。</li>\n</ul>\n<p>使用响应式表单时，需要引入<code>ReactiveFormsModule</code>模块，响应式表单的指令都来自<code>ReactiveFormsModule</code>模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.module.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ReactiveFormsModule&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/forms&#x27;</span>;</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    ReactiveFormsModule</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h2><p>数据模型是指一个用来保存表单数据的数据结构，他由定义在<code>FormsModule</code>模块中的三个类组成：</p>\n<ul>\n<li><p>FormControl：</p>\n<p>他是构成表单的基本单位，通常情况下用来表示一个<code>&lt;input&gt;</code>元素，也可以用来表示更复杂的UI组件。</p>\n<p>FormControl类的对象保存着与其关联的HTML元素当前的值，元素是否被修改过，以及校验状态等信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactiveForm.component.ts</span></span><br><span class=\"line\">private nickname = <span class=\"keyword\">new</span> FormControl(<span class=\"string\">&#x27;tom&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>FormControl</code>接收的参数用来制定初始值。</p>\n<p>模版式表单中，<code>ngModel</code>指令默认会为其附着的元素创建一个<code>FormControl</code>类的对象。</p>\n<p>​</p>\n</li>\n<li><p>FormGroup：</p>\n<p><code>FormGroup</code>类代表表单的一部分，也可以表示整个表单，他是多个<code>FormControl</code>的集合。</p>\n<p><code>FormGroup</code>将多个<code>FormControl</code>的状态和值聚合在一起。如果其中一个<code>FormControl</code>的值是无效的，也就是不符合校验规则，那么整个<code>FormGroup</code>都是无效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactiveForm.component.ts</span></span><br><span class=\"line\">private passwordInfo = <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">  password: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">  passwordConfirm: <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>FormGroup</code>的构造函数需要传入一个对象<code>&#123;&#125;</code>，这个对象里是<code>FormControl</code>。</p>\n<p>​</p>\n</li>\n<li><p>FormArray：</p>\n<p><code>FormArray</code>和<code>FormGroup</code>是类似的，但是有一个额外的属性，长度，因为<code>FormArray</code>是一个数组。</p>\n<p><code>FormGroup</code>用来代表整个表单，或者一个表单中固定的子集。</p>\n<p><code>FormArray</code>用来代表一个可以增长的集合。比如，一个表单中的邮箱字段，一个用户可以拥有多个邮箱。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactiveForm.component.ts</span></span><br><span class=\"line\">private emails = <span class=\"keyword\">new</span> FormArray([</span><br><span class=\"line\">  <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">  <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">  <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n\n<p><code>FormArray</code>中的<code>FormControl</code>没有key，而<code>FormGroup</code>中的<code>FormControl</code>是要有一个key。</p>\n</li>\n</ul>\n<p>编写一个完整的表单数据模型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactiveForm.component.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactiveFormComponent</span></span>&#123;</span><br><span class=\"line\">  private formModel: FormGroup;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.formModel = <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">      nickname: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">      mobile: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">      emails: <span class=\"keyword\">new</span> FormArray([</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">      ]),</span><br><span class=\"line\">      passwordInfo: <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">        password: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">        passwordConfirm: <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##响应式表单的指令：</p>\n<p>在控制器中已经构建好了数据模型，在模版中通过指令，将表单元素和数据模型连接起来。</p>\n<p>响应式表单使用和模版式表单完全不同的指令，这些指令来自于<code>ReactiveFormsModule</code>模块。</p>\n<p>响应式表单的指令分成两种，一种是需要使用属性绑定语法<code>[xxx]=&quot;xxx&quot;</code>的指令，另一种是不需要属性绑定语法的指令。</p>\n<p>响应式表单的所有指令，都是以<code>form</code>开头的；而模版式表单的所有指令，都是以<code>ng</code>开头的。</p>\n<p>###使用属性绑定的指令：</p>\n<p><code>formGroup</code>，<code>formControl</code></p>\n<p>这种指令使用时必须使用属性绑定语法，就是说使用这些指令时，需要使用属性绑定的语法，用<code>[]</code>扩起来。</p>\n<p>属性绑定的指令，必须绑定到组件中的某个属性上，比如： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> [<span class=\"attr\">formGroup</span>]=<span class=\"string\">&quot;formModel&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">export class ReactiveForm &#123;</span><br><span class=\"line\">  private formModel: FormGroup;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>指令的名字很简单，和类名一样，首字母小写。</p>\n<p><code>FormArray</code>类没有属性绑定方式的指令，因为它是数组，没有key来对应。</p>\n<p>###不使用属性绑定的指令：</p>\n<p><code>formGroupName</code>，<code>formControlName</code>，<code>formArrayName</code></p>\n<p>这些以Name结尾的指令可以使用属性的名字来连接DOM元素和数据模型，它们不需要使用属性绑定语法。</p>\n<p><code>formGroup</code>通过属性绑定将表单绑定到组件中的<code>formModel</code>属性上，<code>nickname</code>不是组件的属性，只是数据模型中的一个字段的key，因此不能用属性绑定<code>[formControl]=&quot;nickname&quot;</code>，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form [formGroup]=<span class=\"string\">&quot;formModel&quot;</span>&gt;</span><br><span class=\"line\">\t&lt;input formControlName=<span class=\"string\">&quot;nickname&quot;</span>&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactiveForm</span> </span>&#123;</span><br><span class=\"line\">  private formModel: FormGroup;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.formModel = <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">   nickname: <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与模版式表单不同，响应式表单的指令都是不可引用的，不能像模版式表单那样用模版本地变量来引用。</p>\n<p>而在模版式表单中，不能在控制器中直接访问<code>FormGroup</code>、<code>FormControl</code>这些类。</p>\n<p>Angular是故意这么做，目的就是区分模版式表单和响应式表单。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> [<span class=\"attr\">formGroup</span>]=<span class=\"string\">&quot;formModel&quot;</span> (<span class=\"attr\">submit</span>)=<span class=\"string\">&quot;createUser()&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;nickname&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>邮箱：</span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">formArrayName</span>=<span class=\"string\">&quot;emails&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let email of formModel.get(&#x27;emails&#x27;).controls; let i = index&quot;</span>&gt;</span></span><br><span class=\"line\">      \t<span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">formControlName</span>]=<span class=\"string\">&quot;i&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>手机号：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;mobile&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">formGroupName</span>=<span class=\"string\">&quot;passwordInfo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>确认密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;passwordConfirm&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>注册<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactiveForm</span> </span>&#123;</span><br><span class=\"line\">    private formModel: FormGroup;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.formModel = <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">        nickname: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">        mobile: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">        emails: <span class=\"keyword\">new</span> FormArray([</span><br><span class=\"line\">          <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">        passwordInfo: <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">          password: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">          passwordConfirm: <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">createUser</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：</p>\n<ul>\n<li>处理submit事件：<ul>\n<li>模版式表单中提供了<code>ngSubmit</code>事件来处理表单提交：<code>&lt;form #myForm=&quot;ngForm&quot;(ngSubmit)=&quot;createUser(myForm)&quot;</code>。在模版式表单中，通过把保存表单数据的模版本地变量传给控制器来获取表单数据。</li>\n<li>响应式表单中直接处理原生的<code>submit</code>事件：<code>&lt;form (submit)=&quot;createUser()&quot;&gt;</code>。并且，不需要传模版本地变量，因为响应式表单中本身就不能引用模版本地变量，表单的数据模型是在组件控制器中定义的，在控制器中就能直接拿到数据。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"FormBuilder\"><a href=\"#FormBuilder\" class=\"headerlink\" title=\"FormBuilder\"></a>FormBuilder</h2><p>FormBuilder是Angular提供的一个工具类，它并没有提供新的功能，只是简化构建响应式表单数据结构的语法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactiveForm</span></span>&#123;</span><br><span class=\"line\">  private formModel: FormGroup;</span><br><span class=\"line\">  private fb: FormBuilder = <span class=\"keyword\">new</span> FormBuilder();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.formModel = <span class=\"built_in\">this</span>.fb.group(&#123;</span><br><span class=\"line\">        nickname: [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">        mobile: [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">        emails: <span class=\"built_in\">this</span>.fb.array([</span><br><span class=\"line\">          [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">        passwordInfo: <span class=\"built_in\">this</span>.fb.group(&#123;</span><br><span class=\"line\">          password: [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">          passwordConfirm: [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>new FormGroup(&#123;&#125;) = new FormBuilder().group(&#123;&#125;);</code></li>\n<li><code>new FormControl() = new FormBuilder().[&#39;&#39;];</code></li>\n<li><code>new FormArray([]) = new FormBuilder().array([]);</code></li>\n</ul>\n<p>此外，FormBuilder还可以对表单模型进行其他的配置，比如校验表单。</p>\n<h1 id=\"表单校验\"><a href=\"#表单校验\" class=\"headerlink\" title=\"表单校验\"></a>表单校验</h1><h2 id=\"Angular校验器\"><a href=\"#Angular校验器\" class=\"headerlink\" title=\"Angular校验器\"></a>Angular校验器</h2><p>angular校验器有两种，一个是自己定义的校验器，另一个是angular预定义好的校验器：</p>\n<h3 id=\"Angular预定义的校验器\"><a href=\"#Angular预定义的校验器\" class=\"headerlink\" title=\"Angular预定义的校验器\"></a>Angular预定义的校验器</h3><p>angular提供的校验器都在一个叫<code>Validators</code>的类中，这个类有很多方法，比如：</p>\n<ul>\n<li><code>Validators.required</code>必填的校验器</li>\n<li><code>Validators.minLength()</code>最小长度的校验器</li>\n<li><code>Validators.maxLength()</code>最到长度的校验器</li>\n</ul>\n<p>等等。</p>\n<p>当有了定义好的校验器，包括angular提供的或者自己定义的，我们就可以配置数据模型来使用校验器。</p>\n<p> 将校验器作为参数传到表单模型的构造函数中就能进行校验：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.formModel &#x3D; this.fb.group(&#123;</span><br><span class=\"line\">  nickname:[&#39;&#39;,Validators.required]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这个意思是nickname这个字段是必填的。</p>\n<p>也可以同时传入多个校验器，那么这个参数就是一个数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.formModel &#x3D; this.fb.group(&#123;</span><br><span class=\"line\">  nickname: [&#39;&#39;, [Validators.required, Validators.minLength(5)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>nickname这个字段是必填的，同时最小长度是5。</p>\n<p>###自定义校验器</p>\n<p>自定义的校验器实际上就是一个自定义的方法，该方法要求需要传入一个<code>AbstractControl</code>类的参数，并且该方法的返回值必须是<code>key</code>为<code>string</code>类型的对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx(param: AbstractControl):&#123;[key:string]: any&#125;&#123;</span><br><span class=\"line\">  return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>AbstractControl</code>类是<code>FormGroup</code>，<code>FormControl</code>，<code>FormArray</code>的父类，因此，自定义校验器的参数可以是这三个类中的任意一种。</li>\n</ul>\n<p>当需要更复杂的校验规则时，angular提供的校验器可能无法满足需求，我们可以通过自定义的检验器来实现。</p>\n<h2 id=\"响应式表单校验\"><a href=\"#响应式表单校验\" class=\"headerlink\" title=\"响应式表单校验\"></a>响应式表单校验</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FormBuilder</span> </span>&#123;</span><br><span class=\"line\">  group(controlsConfig: &#123;[key: string]: any&#125;, <span class=\"attr\">extra</span>: &#123;[key: string]: any&#125;|<span class=\"literal\">null</span> = <span class=\"literal\">null</span>): FormGroup</span><br><span class=\"line\">  </span><br><span class=\"line\">  control(formState: <span class=\"built_in\">Object</span>, validator?: ValidatorFn|ValidatorFn[]|<span class=\"literal\">null</span>, asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|<span class=\"literal\">null</span>): FormControl</span><br><span class=\"line\">  </span><br><span class=\"line\">  array(controlsConfig: any[], validator?: ValidatorFn|<span class=\"literal\">null</span>, asyncValidator?: AsyncValidatorFn|<span class=\"literal\">null</span>): FormArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;FormControl, FormGroup&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@angular/forms&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;rxjs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mobileValidator</span>(<span class=\"params\">mobile: FormControl</span>):<span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> value = (mobile.value || <span class=\"string\">&#x27;&#x27;</span>) + <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myreg = <span class=\"regexp\">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> valid = myreg.test(value);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;mobile是否校验通过:&#x27;</span>+valid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> valid ? <span class=\"literal\">null</span> : &#123;<span class=\"attr\">mobile</span>:<span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mobileAsyncValidator</span>(<span class=\"params\">mobile: FormControl</span>):<span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> value = (mobile.value || <span class=\"string\">&#x27;&#x27;</span>) + <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myreg = <span class=\"regexp\">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> valid = myreg.test(value);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;mobile是否校验通过:&#x27;</span>+valid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Observable.of(valid ? <span class=\"literal\">null</span> : &#123;<span class=\"attr\">mobile</span>:<span class=\"literal\">true</span>&#125;).delay(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">passwordValidator</span>(<span class=\"params\">info: FormGroup</span>):<span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> password:FormControl = info.get(<span class=\"string\">&#x27;password&#x27;</span>) <span class=\"keyword\">as</span> FormControl;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pConfirm:FormControl = info.get(<span class=\"string\">&#x27;passwordConfirm&#x27;</span>) <span class=\"keyword\">as</span> FormControl;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(password != <span class=\"literal\">null</span> &amp;&amp; pConfirm != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> valid:boolean = password.value === pConfirm.value;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;password是否校验通过:&#x27;</span>+valid);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> valid ? <span class=\"literal\">null</span> : &#123;<span class=\"attr\">password</span>: &#123;<span class=\"attr\">description</span>:<span class=\"string\">&#x27;密码和确认密码不匹配&#x27;</span>&#125;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactivedFormComponent</span> <span class=\"title\">implements</span> <span class=\"title\">OnInit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  private formModel:FormGroup;</span><br><span class=\"line\"></span><br><span class=\"line\">  private fb:FormBuilder = <span class=\"keyword\">new</span> FormBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.formModel = <span class=\"built_in\">this</span>.fb.group(&#123;</span><br><span class=\"line\">      nickname: [<span class=\"string\">&#x27;xxxx&#x27;</span>, [Validators.required, Validators.minLength(<span class=\"number\">6</span>)]],</span><br><span class=\"line\">      emails: <span class=\"built_in\">this</span>.fb.array([</span><br><span class=\"line\">        [<span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\">      ]),</span><br><span class=\"line\">      mobile: [<span class=\"string\">&#x27;&#x27;</span>, mobileValidator, mobileAsyncValidator],</span><br><span class=\"line\">      passwordInfo: <span class=\"built_in\">this</span>.fb.group(&#123;</span><br><span class=\"line\">        password: [<span class=\"string\">&#x27;&#x27;</span>, Validators.required],</span><br><span class=\"line\">        passwordConfirm: [<span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\">      &#125;, &#123;<span class=\"attr\">validator</span>: passwordValidator&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> [<span class=\"attr\">formGroup</span>]=<span class=\"string\">&quot;formModel&quot;</span> (<span class=\"attr\">submit</span>)=<span class=\"string\">&quot;createUser()&quot;</span> &gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称:<span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">class.inputHasError</span>]=<span class=\"string\">&quot;formModel.get(&#x27;nickname&#x27;).invalid&quot;</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;nickname&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;[a-zA-A0-9]+&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;required&#x27;,&#x27;nickname&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    昵称是必填项</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;minlength&#x27;,&#x27;nickname&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    昵称的最小长度是6</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>邮箱:</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">formArrayName</span>=<span class=\"string\">&quot;emails&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let email of formModel.get(&#x27;emails&#x27;).controls;let i = index&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">formControlName</span>]=<span class=\"string\">&quot;i&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;addEmail()&quot;</span>&gt;</span>增加Email<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>手机号:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;mobile&quot;</span>  <span class=\"attr\">type</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;formModel.get(&#x27;mobile&#x27;).valid || formModel.get(&#x27;mobile&#x27;).pristine&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;mobile&#x27;,&#x27;mobile&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">      手机号不合法</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.get(&#x27;mobile&#x27;).pending&quot;</span>&gt;</span></span><br><span class=\"line\">    正在校验手机号合法性</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">formGroupName</span>=<span class=\"string\">&quot;passwordInfo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;formModel.get(&#x27;passwordInfo.password&#x27;).valid || formModel.get(&#x27;passwordInfo.password&#x27;).untouched&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;required&#x27;,&#x27;passwordInfo.password&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">        密码是必填项</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>确认密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;passwordConfirm&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;password&#x27;,&#x27;passwordInfo&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;formModel.getError(&#x27;password&#x27;, &#x27;passwordInfo&#x27;)?.description&#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>注册<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  &#123;&#123;formModel.status&#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>FormGroup.hasError(&#39;校验器的key&#39;,&#39;被校验字段的key&#39;)</code></li>\n<li><code>FormGroup.getError(&#39;校验器的key&#39;,&#39;被校验字段的key&#39;)</code></li>\n<li><code>FormGroup.get(&#39;&#39;).</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Angular表单\"><a href=\"#Angular表单\" class=\"headerlink\" title=\"Angular表单\"></a>Angular表单</h1><p>在Angular中存在两种表单处理方式：</p>\n<h2 id=\"模版驱动式表单\"><a href=\"#模版驱动式表单\" class=\"headerlink\" title=\"模版驱动式表单\"></a>模版驱动式表单</h2><p>表单的数据模型是通过组件模版中的相关指令来定义的。由于使用这种方式定义表单的数据模型时，我们会受限于HTML的语法，所以，模版驱动方式只适用于一些简单的场景。</p>\n<h2 id=\"响应式表单\"><a href=\"#响应式表单\" class=\"headerlink\" title=\"响应式表单\"></a>响应式表单</h2><p>使用响应式表单时，通过编写TypeScript代码而不是Html代码来创建一个底层的数据模型，在定义好这个模型以后，使用一些特定的指令，将模版上的HTML元素与底层的数据模型连接在一起。</p>\n<h2 id=\"Angular表单API\"><a href=\"#Angular表单API\" class=\"headerlink\" title=\"Angular表单API\"></a>Angular表单API</h2><p>不管是哪种表单，都有一个对应的数据模型来存储表单的数据。在模版式表单中，数据模型是由angular基于组件模版中的指令隐式创建的。而在响应式表单中，你通过编码明确的创建数据模型然后将模版上的html元素与底层的数据模型连接起来。</p>\n<p>数据模型并不是一个任意的对象，它是一个由angular/forms模块中的一些特定的类，如FormControl，FormGroup，FormArray等组成的。在模版式表单中，是不能直接访问这些类的。</p>\n<p>响应式表单并不会替你生成HTML，模版仍然需要你自己来编写。</p>\n<h1 id=\"模版式表单\"><a href=\"#模版式表单\" class=\"headerlink\" title=\"模版式表单\"></a>模版式表单</h1><p>使用模版式表单时，需要引入<code>FormsModule</code>，只能使用指令定义数据模型。这些指令都来自于<code>FormsModule</code>模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.module.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;FormsModule&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/forms&#x27;</span>;</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    FormsModule</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>##模版式表单的指令：</p>\n<h3 id=\"NgForm\"><a href=\"#NgForm\" class=\"headerlink\" title=\"NgForm\"></a>NgForm</h3><p>ngForm指令代表整个表单，在Angular应用里<code>ngForm</code>指令会自动的添加到每一个<code>&lt;form&gt;</code>表单上。<code>ngForm</code>会隐式的创建一个<code>FormGroup</code>类的实例，这个类用来代表表单的数据模型，并且存储表单的数据。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Angular应用会自动为<code>&lt;form&gt;</code>元素添加<code>ngForm</code>指令。</p>\n</li>\n<li><p><code>ngForm</code>会自动拦截表单的提交事件，阻止表单的提交。Angular用一个自定义的<code>ngSubmit</code>事件来代替他。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> (<span class=\"attr\">ngSubmit</span>)=<span class=\"string\">&quot;test()&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>提交<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>ngForm</code>会自动发现添加了<code>ngModel</code>的子元素，并将这些子元素的值会被添加到表单数据模型中。</p>\n</li>\n<li><p><code>ngForm</code>指令可以也可以在其他元素上使用，比如<code>&lt;div ngForm&gt;</code>，这和写一个<code>&lt;form&gt;</code>效果是一样的。</p>\n</li>\n<li><p>如果你不希望Angular来自动处理你的表单，你可以在<code>&lt;form&gt;</code>元素上明确的添加<code>ngNoForm</code>指令：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">ngNoForm</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>添加了<code>ngNoForm</code>指令，angular将不再接管<code>&lt;form&gt;</code>表单的处理。</p>\n</li>\n<li><p><code>ngForm</code>指令创建的对象可以被一个模版本地变量引用，以便在模版中访问ngForm对象的实例。</p>\n<p>value是一个JS对象，保存着form表单中所有字段的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">myForm</span>=<span class=\"string\">&quot;ngForm&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nickName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;myForm.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//昵称：Tom</span><br><span class=\"line\">//&#123;nickName: Tom&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>###NgModel</p>\n<p> <code>ngModel</code>指令代表表单中的一个字段，<code>ngModel</code>指令会隐式的创建一个<code>FormControl</code>类的实例，来代表字段的数据模型，并用这个<code>FormControl</code>的对象来存储字段的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">myForm</span>=<span class=\"string\">&quot;ngForm&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nickName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;myForm.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>在<code>&lt;form&gt;</code>标签或者标记了<code>ngForm</code>指令的HTML元素内，使用<code>ngModel</code>指令时，不需要像双向绑定那样用<code>[()]</code>扩起来，应为这里不是双向绑定，而是表单字段的指令；也不需要绑定到组件的属性上。</p>\n<p>但是<code>ngModel</code>指令需要为添加它的HTML元素指定<code>name</code>的值。如果不指定<code>name</code>属性的值，angular不知道以什么名字把这个字段的值添加到数据模型中。</p>\n</li>\n<li><p>与<code>ngForm</code>类似，<code>ngModel</code>指令创建的对象也可以被模版本地变量引用，并通过模版本地变量来访问这个对象的值。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">myForm</span>=<span class=\"string\">&quot;ngForm&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">myNickName</span>=<span class=\"string\">&quot;ngModel&quot;</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nickName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;myForm.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称的值是：&#123;&#123;myNickName.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>###NgModelGroup</p>\n<p><code>ngModelGroup</code>指令代表表单的一部分，他将表单的一部分组织在一起，形成更清晰的层级关系。</p>\n<p>与<code>ngForm</code>类似，<code>ngModelGroup</code>也会创建一个<code>FormGroup</code>类型的对象。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">myForm</span>=<span class=\"string\">&quot;ngForm&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ngModel</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;nickName&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ngModelGroup</span>=<span class=\"string\">&quot;passwordInfo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>确认密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;myForm.value&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">//</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;nickName&quot;:&quot;&quot;,</span><br><span class=\"line\">  &quot;password&quot;:&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>#响应式表单</p>\n<p>创建响应式表单与模版式表单不同，需要两步：</p>\n<ul>\n<li>首先通过编码创建一个数据模型。</li>\n<li>然后使用指令将模版中的HTML元素连接到数据模型上。</li>\n</ul>\n<p>使用响应式表单时，需要引入<code>ReactiveFormsModule</code>模块，响应式表单的指令都来自<code>ReactiveFormsModule</code>模块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// app.module.ts</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ReactiveFormsModule&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@angular/forms&#x27;</span>;</span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  imports:[</span><br><span class=\"line\">    ReactiveFormsModule</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h2><p>数据模型是指一个用来保存表单数据的数据结构，他由定义在<code>FormsModule</code>模块中的三个类组成：</p>\n<ul>\n<li><p>FormControl：</p>\n<p>他是构成表单的基本单位，通常情况下用来表示一个<code>&lt;input&gt;</code>元素，也可以用来表示更复杂的UI组件。</p>\n<p>FormControl类的对象保存着与其关联的HTML元素当前的值，元素是否被修改过，以及校验状态等信息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactiveForm.component.ts</span></span><br><span class=\"line\">private nickname = <span class=\"keyword\">new</span> FormControl(<span class=\"string\">&#x27;tom&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>FormControl</code>接收的参数用来制定初始值。</p>\n<p>模版式表单中，<code>ngModel</code>指令默认会为其附着的元素创建一个<code>FormControl</code>类的对象。</p>\n<p>​</p>\n</li>\n<li><p>FormGroup：</p>\n<p><code>FormGroup</code>类代表表单的一部分，也可以表示整个表单，他是多个<code>FormControl</code>的集合。</p>\n<p><code>FormGroup</code>将多个<code>FormControl</code>的状态和值聚合在一起。如果其中一个<code>FormControl</code>的值是无效的，也就是不符合校验规则，那么整个<code>FormGroup</code>都是无效的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactiveForm.component.ts</span></span><br><span class=\"line\">private passwordInfo = <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">  password: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">  passwordConfirm: <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><code>FormGroup</code>的构造函数需要传入一个对象<code>&#123;&#125;</code>，这个对象里是<code>FormControl</code>。</p>\n<p>​</p>\n</li>\n<li><p>FormArray：</p>\n<p><code>FormArray</code>和<code>FormGroup</code>是类似的，但是有一个额外的属性，长度，因为<code>FormArray</code>是一个数组。</p>\n<p><code>FormGroup</code>用来代表整个表单，或者一个表单中固定的子集。</p>\n<p><code>FormArray</code>用来代表一个可以增长的集合。比如，一个表单中的邮箱字段，一个用户可以拥有多个邮箱。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactiveForm.component.ts</span></span><br><span class=\"line\">private emails = <span class=\"keyword\">new</span> FormArray([</span><br><span class=\"line\">  <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">  <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">  <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure>\n\n<p><code>FormArray</code>中的<code>FormControl</code>没有key，而<code>FormGroup</code>中的<code>FormControl</code>是要有一个key。</p>\n</li>\n</ul>\n<p>编写一个完整的表单数据模型：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ReactiveForm.component.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactiveFormComponent</span></span>&#123;</span><br><span class=\"line\">  private formModel: FormGroup;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.formModel = <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">      nickname: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">      mobile: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">      emails: <span class=\"keyword\">new</span> FormArray([</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">      ]),</span><br><span class=\"line\">      passwordInfo: <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">        password: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">        passwordConfirm: <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>##响应式表单的指令：</p>\n<p>在控制器中已经构建好了数据模型，在模版中通过指令，将表单元素和数据模型连接起来。</p>\n<p>响应式表单使用和模版式表单完全不同的指令，这些指令来自于<code>ReactiveFormsModule</code>模块。</p>\n<p>响应式表单的指令分成两种，一种是需要使用属性绑定语法<code>[xxx]=&quot;xxx&quot;</code>的指令，另一种是不需要属性绑定语法的指令。</p>\n<p>响应式表单的所有指令，都是以<code>form</code>开头的；而模版式表单的所有指令，都是以<code>ng</code>开头的。</p>\n<p>###使用属性绑定的指令：</p>\n<p><code>formGroup</code>，<code>formControl</code></p>\n<p>这种指令使用时必须使用属性绑定语法，就是说使用这些指令时，需要使用属性绑定的语法，用<code>[]</code>扩起来。</p>\n<p>属性绑定的指令，必须绑定到组件中的某个属性上，比如： </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> [<span class=\"attr\">formGroup</span>]=<span class=\"string\">&quot;formModel&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">export class ReactiveForm &#123;</span><br><span class=\"line\">  private formModel: FormGroup;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>指令的名字很简单，和类名一样，首字母小写。</p>\n<p><code>FormArray</code>类没有属性绑定方式的指令，因为它是数组，没有key来对应。</p>\n<p>###不使用属性绑定的指令：</p>\n<p><code>formGroupName</code>，<code>formControlName</code>，<code>formArrayName</code></p>\n<p>这些以Name结尾的指令可以使用属性的名字来连接DOM元素和数据模型，它们不需要使用属性绑定语法。</p>\n<p><code>formGroup</code>通过属性绑定将表单绑定到组件中的<code>formModel</code>属性上，<code>nickname</code>不是组件的属性，只是数据模型中的一个字段的key，因此不能用属性绑定<code>[formControl]=&quot;nickname&quot;</code>，否则会报错。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form [formGroup]=<span class=\"string\">&quot;formModel&quot;</span>&gt;</span><br><span class=\"line\">\t&lt;input formControlName=<span class=\"string\">&quot;nickname&quot;</span>&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactiveForm</span> </span>&#123;</span><br><span class=\"line\">  private formModel: FormGroup;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.formModel = <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">   nickname: <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>与模版式表单不同，响应式表单的指令都是不可引用的，不能像模版式表单那样用模版本地变量来引用。</p>\n<p>而在模版式表单中，不能在控制器中直接访问<code>FormGroup</code>、<code>FormControl</code>这些类。</p>\n<p>Angular是故意这么做，目的就是区分模版式表单和响应式表单。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> [<span class=\"attr\">formGroup</span>]=<span class=\"string\">&quot;formModel&quot;</span> (<span class=\"attr\">submit</span>)=<span class=\"string\">&quot;createUser()&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;nickname&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>邮箱：</span><br><span class=\"line\">  \t<span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">formArrayName</span>=<span class=\"string\">&quot;emails&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let email of formModel.get(&#x27;emails&#x27;).controls; let i = index&quot;</span>&gt;</span></span><br><span class=\"line\">      \t<span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">formControlName</span>]=<span class=\"string\">&quot;i&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>手机号：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;mobile&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">formGroupName</span>=<span class=\"string\">&quot;passwordInfo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>确认密码：<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;passwordConfirm&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>注册<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactiveForm</span> </span>&#123;</span><br><span class=\"line\">    private formModel: FormGroup;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.formModel = <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">        nickname: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">        mobile: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">        emails: <span class=\"keyword\">new</span> FormArray([</span><br><span class=\"line\">          <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">        passwordInfo: <span class=\"keyword\">new</span> FormGroup(&#123;</span><br><span class=\"line\">          password: <span class=\"keyword\">new</span> FormControl(),</span><br><span class=\"line\">          passwordConfirm: <span class=\"keyword\">new</span> FormControl()</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  \t&#125;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">createUser</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意</strong>：</p>\n<ul>\n<li>处理submit事件：<ul>\n<li>模版式表单中提供了<code>ngSubmit</code>事件来处理表单提交：<code>&lt;form #myForm=&quot;ngForm&quot;(ngSubmit)=&quot;createUser(myForm)&quot;</code>。在模版式表单中，通过把保存表单数据的模版本地变量传给控制器来获取表单数据。</li>\n<li>响应式表单中直接处理原生的<code>submit</code>事件：<code>&lt;form (submit)=&quot;createUser()&quot;&gt;</code>。并且，不需要传模版本地变量，因为响应式表单中本身就不能引用模版本地变量，表单的数据模型是在组件控制器中定义的，在控制器中就能直接拿到数据。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"FormBuilder\"><a href=\"#FormBuilder\" class=\"headerlink\" title=\"FormBuilder\"></a>FormBuilder</h2><p>FormBuilder是Angular提供的一个工具类，它并没有提供新的功能，只是简化构建响应式表单数据结构的语法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactiveForm</span></span>&#123;</span><br><span class=\"line\">  private formModel: FormGroup;</span><br><span class=\"line\">  private fb: FormBuilder = <span class=\"keyword\">new</span> FormBuilder();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.formModel = <span class=\"built_in\">this</span>.fb.group(&#123;</span><br><span class=\"line\">        nickname: [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">        mobile: [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">        emails: <span class=\"built_in\">this</span>.fb.array([</span><br><span class=\"line\">          [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">        ]),</span><br><span class=\"line\">        passwordInfo: <span class=\"built_in\">this</span>.fb.group(&#123;</span><br><span class=\"line\">          password: [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">          passwordConfirm: [<span class=\"string\">&#x27;&#x27;</span>],</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>new FormGroup(&#123;&#125;) = new FormBuilder().group(&#123;&#125;);</code></li>\n<li><code>new FormControl() = new FormBuilder().[&#39;&#39;];</code></li>\n<li><code>new FormArray([]) = new FormBuilder().array([]);</code></li>\n</ul>\n<p>此外，FormBuilder还可以对表单模型进行其他的配置，比如校验表单。</p>\n<h1 id=\"表单校验\"><a href=\"#表单校验\" class=\"headerlink\" title=\"表单校验\"></a>表单校验</h1><h2 id=\"Angular校验器\"><a href=\"#Angular校验器\" class=\"headerlink\" title=\"Angular校验器\"></a>Angular校验器</h2><p>angular校验器有两种，一个是自己定义的校验器，另一个是angular预定义好的校验器：</p>\n<h3 id=\"Angular预定义的校验器\"><a href=\"#Angular预定义的校验器\" class=\"headerlink\" title=\"Angular预定义的校验器\"></a>Angular预定义的校验器</h3><p>angular提供的校验器都在一个叫<code>Validators</code>的类中，这个类有很多方法，比如：</p>\n<ul>\n<li><code>Validators.required</code>必填的校验器</li>\n<li><code>Validators.minLength()</code>最小长度的校验器</li>\n<li><code>Validators.maxLength()</code>最到长度的校验器</li>\n</ul>\n<p>等等。</p>\n<p>当有了定义好的校验器，包括angular提供的或者自己定义的，我们就可以配置数据模型来使用校验器。</p>\n<p> 将校验器作为参数传到表单模型的构造函数中就能进行校验：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.formModel &#x3D; this.fb.group(&#123;</span><br><span class=\"line\">  nickname:[&#39;&#39;,Validators.required]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这个意思是nickname这个字段是必填的。</p>\n<p>也可以同时传入多个校验器，那么这个参数就是一个数组：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">this.formModel &#x3D; this.fb.group(&#123;</span><br><span class=\"line\">  nickname: [&#39;&#39;, [Validators.required, Validators.minLength(5)]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>nickname这个字段是必填的，同时最小长度是5。</p>\n<p>###自定义校验器</p>\n<p>自定义的校验器实际上就是一个自定义的方法，该方法要求需要传入一个<code>AbstractControl</code>类的参数，并且该方法的返回值必须是<code>key</code>为<code>string</code>类型的对象：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xxx(param: AbstractControl):&#123;[key:string]: any&#125;&#123;</span><br><span class=\"line\">  return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>AbstractControl</code>类是<code>FormGroup</code>，<code>FormControl</code>，<code>FormArray</code>的父类，因此，自定义校验器的参数可以是这三个类中的任意一种。</li>\n</ul>\n<p>当需要更复杂的校验规则时，angular提供的校验器可能无法满足需求，我们可以通过自定义的检验器来实现。</p>\n<h2 id=\"响应式表单校验\"><a href=\"#响应式表单校验\" class=\"headerlink\" title=\"响应式表单校验\"></a>响应式表单校验</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FormBuilder</span> </span>&#123;</span><br><span class=\"line\">  group(controlsConfig: &#123;[key: string]: any&#125;, <span class=\"attr\">extra</span>: &#123;[key: string]: any&#125;|<span class=\"literal\">null</span> = <span class=\"literal\">null</span>): FormGroup</span><br><span class=\"line\">  </span><br><span class=\"line\">  control(formState: <span class=\"built_in\">Object</span>, validator?: ValidatorFn|ValidatorFn[]|<span class=\"literal\">null</span>, asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|<span class=\"literal\">null</span>): FormControl</span><br><span class=\"line\">  </span><br><span class=\"line\">  array(controlsConfig: any[], validator?: ValidatorFn|<span class=\"literal\">null</span>, asyncValidator?: AsyncValidatorFn|<span class=\"literal\">null</span>): FormArray</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;FormControl, FormGroup&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;@angular/forms&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">&quot;rxjs&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mobileValidator</span>(<span class=\"params\">mobile: FormControl</span>):<span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> value = (mobile.value || <span class=\"string\">&#x27;&#x27;</span>) + <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myreg = <span class=\"regexp\">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> valid = myreg.test(value);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;mobile是否校验通过:&#x27;</span>+valid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> valid ? <span class=\"literal\">null</span> : &#123;<span class=\"attr\">mobile</span>:<span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mobileAsyncValidator</span>(<span class=\"params\">mobile: FormControl</span>):<span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> value = (mobile.value || <span class=\"string\">&#x27;&#x27;</span>) + <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myreg = <span class=\"regexp\">/^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;)|(18[0-9]&#123;1&#125;))+\\d&#123;8&#125;)$/</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> valid = myreg.test(value);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;mobile是否校验通过:&#x27;</span>+valid);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Observable.of(valid ? <span class=\"literal\">null</span> : &#123;<span class=\"attr\">mobile</span>:<span class=\"literal\">true</span>&#125;).delay(<span class=\"number\">5000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">passwordValidator</span>(<span class=\"params\">info: FormGroup</span>):<span class=\"title\">any</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> password:FormControl = info.get(<span class=\"string\">&#x27;password&#x27;</span>) <span class=\"keyword\">as</span> FormControl;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> pConfirm:FormControl = info.get(<span class=\"string\">&#x27;passwordConfirm&#x27;</span>) <span class=\"keyword\">as</span> FormControl;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(password != <span class=\"literal\">null</span> &amp;&amp; pConfirm != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> valid:boolean = password.value === pConfirm.value;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;password是否校验通过:&#x27;</span>+valid);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> valid ? <span class=\"literal\">null</span> : &#123;<span class=\"attr\">password</span>: &#123;<span class=\"attr\">description</span>:<span class=\"string\">&#x27;密码和确认密码不匹配&#x27;</span>&#125;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReactivedFormComponent</span> <span class=\"title\">implements</span> <span class=\"title\">OnInit</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  private formModel:FormGroup;</span><br><span class=\"line\"></span><br><span class=\"line\">  private fb:FormBuilder = <span class=\"keyword\">new</span> FormBuilder();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.formModel = <span class=\"built_in\">this</span>.fb.group(&#123;</span><br><span class=\"line\">      nickname: [<span class=\"string\">&#x27;xxxx&#x27;</span>, [Validators.required, Validators.minLength(<span class=\"number\">6</span>)]],</span><br><span class=\"line\">      emails: <span class=\"built_in\">this</span>.fb.array([</span><br><span class=\"line\">        [<span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\">      ]),</span><br><span class=\"line\">      mobile: [<span class=\"string\">&#x27;&#x27;</span>, mobileValidator, mobileAsyncValidator],</span><br><span class=\"line\">      passwordInfo: <span class=\"built_in\">this</span>.fb.group(&#123;</span><br><span class=\"line\">        password: [<span class=\"string\">&#x27;&#x27;</span>, Validators.required],</span><br><span class=\"line\">        passwordConfirm: [<span class=\"string\">&#x27;&#x27;</span>]</span><br><span class=\"line\">      &#125;, &#123;<span class=\"attr\">validator</span>: passwordValidator&#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> [<span class=\"attr\">formGroup</span>]=<span class=\"string\">&quot;formModel&quot;</span> (<span class=\"attr\">submit</span>)=<span class=\"string\">&quot;createUser()&quot;</span> &gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>昵称:<span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">class.inputHasError</span>]=<span class=\"string\">&quot;formModel.get(&#x27;nickname&#x27;).invalid&quot;</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;nickname&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;[a-zA-A0-9]+&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;required&#x27;,&#x27;nickname&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    昵称是必填项</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;minlength&#x27;,&#x27;nickname&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    昵称的最小长度是6</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>邮箱:</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">formArrayName</span>=<span class=\"string\">&quot;emails&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">li</span> *<span class=\"attr\">ngFor</span>=<span class=\"string\">&quot;let email of formModel.get(&#x27;emails&#x27;).controls;let i = index&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> [<span class=\"attr\">formControlName</span>]=<span class=\"string\">&quot;i&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> (<span class=\"attr\">click</span>)=<span class=\"string\">&quot;addEmail()&quot;</span>&gt;</span>增加Email<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>手机号:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;mobile&quot;</span>  <span class=\"attr\">type</span>=<span class=\"string\">&quot;number&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;formModel.get(&#x27;mobile&#x27;).valid || formModel.get(&#x27;mobile&#x27;).pristine&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;mobile&#x27;,&#x27;mobile&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">      手机号不合法</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.get(&#x27;mobile&#x27;).pending&quot;</span>&gt;</span></span><br><span class=\"line\">    正在校验手机号合法性</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">formGroupName</span>=<span class=\"string\">&quot;passwordInfo&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;formModel.get(&#x27;passwordInfo.password&#x27;).valid || formModel.get(&#x27;passwordInfo.password&#x27;).untouched&quot;</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;required&#x27;,&#x27;passwordInfo.password&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">        密码是必填项</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>确认密码:<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">formControlName</span>=<span class=\"string\">&quot;passwordConfirm&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">hidden</span>]=<span class=\"string\">&quot;!formModel.hasError(&#x27;password&#x27;,&#x27;passwordInfo&#x27;)&quot;</span>&gt;</span></span><br><span class=\"line\">    &#123;&#123;formModel.getError(&#x27;password&#x27;, &#x27;passwordInfo&#x27;)?.description&#125;&#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span>&gt;</span>注册<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  &#123;&#123;formModel.status&#125;&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>FormGroup.hasError(&#39;校验器的key&#39;,&#39;被校验字段的key&#39;)</code></li>\n<li><code>FormGroup.getError(&#39;校验器的key&#39;,&#39;被校验字段的key&#39;)</code></li>\n<li><code>FormGroup.get(&#39;&#39;).</code></li>\n</ul>\n"},{"title":"ES6学习笔记","date":"2017-11-08T01:43:41.000Z","description":"《ECMAScript6入门——阮一峰》学习笔记","_content":"\n# let、const\n\n## let\n\n### 基本用法\n\nES6新增let命令，用来声明变量。用法类似var，但是所声明变量，只在let命令所在的代码块内有效。\n\n```\n{\n  let a = 10;\n  var b = 1;\n}\n\na // ReferenceError: a is not defined.\nb // 1\n```\n\nfor循环的计数器，就很适合用let命令。\n\n```\nfor (let i = 0; i < 10; i++){\n  // ...\n}\nconsole.log(i);\n// ReferenceError: i is not defined\n```\n\n### 不存在变量提升\n\nvar命令会发生“变量提升”现象。let命令没有，let声明的变量一定要在声明后使用，否则会报错：\n\n```\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n```\n\n### 暂时性死区\n\nES6规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n\n只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n\n```\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n```\n\n### 不允许重复声明\n\nlet命令不允许在相同作用域内，重复声明同一个变量。\n\n## 块级作用域\n\nlet实际上为JS新增了块级作用域。\n\nES6允许块级作用域的任意嵌套。\n\n外层作用域无法读取内层作用域的变量。\n\n内层作用域可以定义外层作用域的同名变量。\n\n块级作用域的出现，使得立即执行函数表达式不再必要。\n\n+ ES5中，函数只能声明在顶层作用域或函数作用域中。\n+ ES6中，明确允许在块级作用域中声明函数。\n\n## do表达式\n\n本质上，块级作用域是一个语句，没有返回值。\n\n现在有一个提案，使得块级作用域可以变为表达式，也就是说有返回值。办法就是在块级作用域前面加上do，变成do表达式，**返回内部最后执行的表达式的值。**\n\n```\nlet x = do {\n  let t = f();\n  t * t + 1;\n}\n```\n\n## const\n\nconst声明一个只读常量，一旦声明，常量的值就不能改变。\n\nconst一旦声明了变量，就立刻初始化，不能留到以后赋值；如果只声明不赋值，会报错。\n\nconst命令和let命令一样，只在声明所在的块级作用域内有效。\n\nconst声明的常量也不提示，同样存在暂时性死区，只能在声明的位置后面使用。\n\nconst命令和和let命令一样，不能重复声明。\n\n### const本质：\n\n`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，`const`只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\n\n```\nconst foo = {};\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // TypeError: \"foo\" is read-only\n\n```\n\n上面代码中，常量`foo`储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把`foo`指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\n\n## ES6声明变量的6中方法\n\n除了ES5的两种var和function，还有let、const、import、class。\n\n## 顶层对象的属性\n\nES6规定，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。\n\n\n\n# 变量的解构赋值\n\n## 数组的解构赋值\n\n### 基本用法\n\n```\nlet [a,b,c] = [1,2,3];\n\n// 等同于\nlet a = 1;\nlet b = 2;\nlet c = 3;\n```\n\n```\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n```\n\n```\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n```\n\n如果等号右边不是数组，会报错。\n\n```\n// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n```\n\n### 默认值：\n\n+ 解构赋值允许指定默认值。\n\n  ```\n  let [foo = true] = [];\n  foo // true\n\n  let [x, y = 'b'] = ['a']; // x='a', y='b'\n  let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n  ```\n\n  ​\t注意，ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，如果一个数组成员不严格等于`undefined`，默认值是不会生效的。\n\n  ```\n  let [x = 1] = [undefined];\n  x // 1\n\n  let [x = 1] = [null];\n  x // null\n  ```\n\n+ 默认值可以是一个表达式，但这个表达式是惰性求值的，只有在用到的时候，才会被求值。\n\n  ```\n  function f(){\n    console.log('aaa');\n  }\n\n  let [x = f()] = [1];\n  ```\n\n  ​上面代码中，因为x能取到值，所以函数f根本不会执行。\n\n+ 默认值可以引用解构赋值的其他变量，但是该变量必须已经声明。\n\n  ```\n  let [x = 1, y = x] = [];     // x=1; y=1\n  let [x = 1, y = x] = [2];    // x=2; y=2\n  let [x = 1, y = x] = [1, 2]; // x=1; y=2\n  let [x = y, y = 1] = [];     // ReferenceError\n  ```\n\n  ​最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。\n\n## 对象的解构赋值\n\n### 基本用法\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\n```\nlet { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nlet { baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // undefined\n```\n\n如果变量名与属性名不一致，必须写成下面这样。\n\n```\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n```\n\n这实际上说明，对象的解构赋值是下面形式的简写。\n\n```\nlet { foo: foo, bar: bar} = { foo: \"aaa\", bar: \"bbb\" };\n```\n\n也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。\n\n```\nlet { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n```\n\n上面代码中，`foo`是匹配的模式，`baz`才是变量。真正被赋值的是变量`baz`，而不是模式`foo`。\n\n嵌套：\n\n```\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\n```\n\n```\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p, p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\np // [\"Hello\", {y: \"World\"}]\n```\n\n```\nconst node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nlet { loc, loc: { start }, loc: { start: { line }} } = node;\nline // 1\nloc  // Object {start: Object}\nstart // Object {line: 1, column: 5}\n```\n\n嵌套赋值的例子：\n\n```\nlet obj = {};\nlet arr = [];\n\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\n\nobj // {prop:123}\narr // [true]\n```\n\n### 默认值\n\n```\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x: y = 3} = {};\ny // 3\n\nvar {x: y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"\n```\n\n+ 默认值生效的条件是，对象的属性值严格等于undefined。\n\n  ```\n  var { x = 3 } = { x: undefined };\n  x // 3\n\n  var { x = 3 } = { x: null };\n  x // null\n  ```\n\n  如果解构失败，变量的值等于undefined。\n\n  ```\n  let {foo} = {bar: 'baz'};\n  foo // undefined\n  ```\n\n+ 如果解构模式是嵌套的对象，而且自对象所在的赋属性不存在，那么将会报错。\n\n+ 如果一个已经声明的变量用于解构赋值，必须非常小心\n\n  ```\n  // 错误的写法\n  let x;\n  {x} = {x: 1};\n  // SyntaxError: syntax error\n  ```\n\n  上面代码会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生于法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决问题。\n\n  ```\n  // 正确的写法\n  let x;\n  ({x} = {x: 1});\n  ```\n\n+ 对象的解构赋值，可以很方便地将现有对象的方法，复制到某个变量。\n\n  ```\n  let { log, sin, cos } = Math;\n  ```\n\n  上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上。\n\n## 函数参数的解构赋值\n\n函数参数也可以使用解构赋值\n\n```\nfunction add ([x, y]){\n  return x + y;\n}\n\nadd([1,2]); // 3\n```\n\n上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。\n\n函数参数的解构也可以使用默认值。\n\n```\nfunction move ({x = 0, y = 0} = []){\n  return [x ,y];\n}\n\nmove({x: 3, y: 8}); // [3,8]\nmove({x: 3}); // [3,0]\nmove({}); // [0,0]\nmove(); // [0,0]\n```\n\n\n\n# 函数的扩展\n\n## 函数参数的默认值\n\nES6之前，不能直接为函数的参数指定默认值。\n\nES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\n```\nfunction log(x, y = 'World') {\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n\n+ 参数变量是默认声明的，所以在函数体内不能用let或const再次声明，否则会报错。\n\n  ```\n  function(x = 2){\n    let x = 1; // error\n    const x = 3; // error\n  }\n  ```\n\n+ 使用参数默认值时，函数不能有同名参数。\n\n  ```\n  // 不报错\n  function (x,x,y){\n    //...\n  }\n\n  // 报错\n  function (x,x,y = 1){\n    //...\n  }\n  ```\n\n+ 参数默认值不是传值，而是每次调用函数，都重新计算默认值表达式的值。\n\n  ```\n  let x = 99;\n  function( p = x + 1){\n    onsole.log(p);\n  }\n\n  foo() // 100\n\n  x = 100;\n  foo() // 101\n  ```\n\n+ 参数默认值可以和解构赋值的默认值，结合起来使用。\n\n  ```\n  function foo ({x, y = 5}){\n    console.log(x, y);\n  }\n\n  foo({}) // undefined 5\n  foo({x: 1}) // 1 5\n  foo({x: 1, y: 2}) // 1 2\n  foo() // TypeError: Cannot read property 'x' of undefined\n  ```\n\n  上面代码只是用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。\n\n  ```\n  function foo({x, y = 5} = {}) {\n    console.log(x, y);\n  }\n\n  foo() // undefined 5\n  ```\n\n+ 参数默认值的位置：\n\n  定义了默认值的参数，应该是函数的尾参数。如果非尾部的参数设置默认值，这个参数没发省略，除非显示输入undefined。\n\n  ```\n  function f(x = 1, y){\n    return [x, y];\n  }\n\n  f() // [1, undefined]\n  f(2) // [2, undefined]\n  f(, 1) // 报错\n  f(undefined, 1) // [1,1]\n  ```\n\n+ 参数作用域：\n\n  一旦设置的参数的默认值，函数进行声明初始化时，参数会单独形成一个作用域，等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值的时候，是不会出现的。\n\n  ```\n  var x = 1;\n  function f(x, y = x){\n    console.log(y);\n  }\n\n  f(2) // 2\n  ```\n\n  ```\n  let x = 1;\n  function f(x = y){\n    let x = 2;\n    console.log(y);\n  }\n\n  f() // 1\n  ```\n\n## rest参数\n\nES6引入rest参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\n下面是一个rest参数代替arguments变量的例子：\n\n```\n// arguments变量的写法\nfunction sortNumbers(){\n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// rest写法\nconst sortNumbers = (...numbers) => numbers.sort();\n```\n\narguments对象不是数组，而是类似数组的对象，所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转换为数组。rest参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。\n\n+ rest参数之后不能有其他参数，否则报错。\n\n  ```\n  // 报错\n  function f(a, ...b, c){\n    // ...\n  }\n  ```\n\n## 箭头函数\n\nES6允许使用“箭头”（=>）定义函数。\n\n```\nvar f = v => v;\n\n// 等同于\n\nvar f = function (v){\n  return v;\n}\n```\n\n+ 如果箭头函数不需要参数或者需要多个参数，就使用一个圆括号代表参数部分。\n\n  ```\n  var f = () => 5;\n  // 等同于\n  var f = function (){\n    return 5;\n  }\n\n  var sum = (num1, num2) => num1 + num2;\n  // 等同于\n  var sum = function(num1, num2){\n    return num1+ num2;\n  }\n  ```\n\n+ 如果箭头函数的代码块部分多余一条语句，就要用大括号括起来，并且使用return返回\n\n  ```\n  var sum = (num1, num2) => { return num1 + num2; }\n  ```\n\n+ 由于大括号被解释为代码块，所以箭头函数如果返回一个对象，必须在对象外面加上括号，否则会报错。\n\n  ```\n  // 报错\n  let getTempItem = id => { id: id, name: \"Temp\" };\n\n  // 不报错\n  let getTempItem = id => ({ id: id, name: \"Temp\" });\n  ```\n\n+ 箭头函数的一个作用是简化回调函数\n\n  ```\n  // 正常函数写法\n  [1,2,3].map(function (x) {\n    return x * x;\n  });\n\n  // 箭头函数写法\n  [1,2,3].map(x => x * x);\n  ```\n\n### 使用注意\n\n1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n```\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\nvar id = 21;\n\nfoo.call({ id: 42 });\n// id: 42\n```\n\n上面代码中，`setTimeout`的参数是一个箭头函数，这个箭头函数的定义生效是在`foo`函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时`this`应该指向全局对象`window`，这时应该输出`21`。但是，箭头函数导致`this`总是指向函数定义生效时所在的对象（本例是`{id: 42}`），所以输出的是`42`。\n\n`this`指向的固定化，并不是因为箭头函数内部有绑定`this`的机制，实际原因是箭头函数根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`。正是因为它没有`this`，所以也就不能用作构造函数。\n\n```\nfunction foo() {\n  return () => {\n    return () => {\n      return () => {\n        console.log('id:', this.id);\n      };\n    };\n  };\n}\n\nvar f = foo.call({id: 1});\n\nvar t1 = f.call({id: 2})()(); // id: 1\nvar t2 = f().call({id: 3})(); // id: 1\nvar t3 = f()().call({id: 4}); // id: 1\n```\n\n上面代码之中，只有一个`this`，就是函数`foo`的`this`，所以`t1`、`t2`、`t3`都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的`this`，它们的`this`其实都是最外层`foo`函数的`this`。\n\n除了`this`，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：`arguments`、`super`、`new.target`。\n\n另外，由于箭头函数没有自己的`this`，所以当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变`this`的指向。\n\n```\n(function() {\n  return [\n    (() => this.x).bind({ x: 'inner' })()\n  ];\n}).call({ x: 'outer' });\n// ['outer']\n```\n\n2. 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n3. 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n4. 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。\n\n# Promise对象\n\n## 基本用法\n\nES6规定，Promise对象是一个构造函数，用来生成Promise实例\n\n```\nconst promise = new Promise(function(resolve, reject){\n  // ...some code\n  \n  if(/*异步操作成功*/){\n    resolve(value);\n  }else{\n    reject(error);\n  }\n})\n```\n\n# Class的基本用法\n\n## 简介\n\nJS语言中，生成实例对象的传统方法是构造函数。\n\n```\nfunction Point(x, y){\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function (){\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n```\n\nES6提供了更接近传统语言的写法，引入了**Class（类）**这个概念，作为对象的模版。通过Class关键字，可以定义类。\n\n基本上，ES6 的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的`class`改写，就是下面这样。\n\n```\n// 定义类\nclass Point {\n  constructor(x, y){\n    this.x = x;\n    this.y = y;\n  }\n  toString(){\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n\n+ 上面定义类一个“类”，里面有一个constructor方法，这就是构造方法，而`this`关键字则代表实例对象，也就是说，ES5点构造函数Point，对应ES6的Point类的构造方法。\n\n+ Point类除了构造方法，还定义了一个toString方法。定义“类”方法的时候，前面不需要家`function`关键字。\n\n+ 方法之间不需要逗号间隔，加了会报错。\n\n+ ES6的类，完全可以看成是构造函数的另一种写法：\n\n  ```\n  class Point {\n    // ...\n  }\n\n  typeof Point // \"function\"\n  Point === Point.prototype.constructor // true\n  ```\n\n  上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\n\n+ 使用的时候，也是直接对类使用new命令，跟构造函数的用法一致。\n\n  ```\n  class Bar {\n    doStuff(){\n      console.log('stuff');\n    }\n  }\n\n  var b = new Bar();\n  b.doStuff(); // \"stuff\"\n  ```\n\n+ 构造函数的`prototype`属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype`属性上面。\n\n  ```\n  class Point {\n    constructor() {\n      // ...\n    }\n\n    toString() {\n      // ...\n    }\n\n    toValue() {\n      // ...\n    }\n  }\n\n  // 等同于\n\n  Point.prototype = {\n    constructor() {},\n    toString() {},\n    toValue() {},\n  };\n  ```\n\n  在类的实例上面调用方法，其实就是调用原型上的方法。\n\n  ```\n  class B {}\n  let b = new B();\n\n  b.constructor === B.prototype.constructor // true\n\n  ```\n\n  上面代码中，`b`是`B`类的实例，它的`constructor`方法就是`B`类原型的`constructor`方法。\n\n+ 由于类的方法都定义在`prototype`对象上面，所以类的新方法可以添加在`prototype`对象上面。`Object.assign`方法可以很方便地一次向类添加多个方法。\n\n  ```\n  class Point {\n    constructor(){\n      // ...\n    }\n  }\n\n  Object.assign(Point.prototype, {\n    toString(){},\n    toValue(){}\n  });\n  ```\n\n+ `prototype`对象的`constructor`属性，直接指向“类”的本身，这与 ES5 的行为是一致的。\n\n  ```\n  Point.prototype.constructor === Point // true\n  ```\n\n+ 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\n\n  ```\n  class Point {\n    constructor(x, y) {\n      // ...\n    }\n\n    toString() {\n      // ...\n    }\n  }\n\n  Object.keys(Point.prototype)\n  // []\n  Object.getOwnPropertyNames(Point.prototype)\n  // [\"constructor\",\"toString\"]\n\n  ```\n\n  上面代码中，`toString`方法是`Point`类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。\n\n+ 类的属性名，可以采用表达式。\n\n  ```\n  let methodName = 'getArea';\n\n  class Square {\n    constructor(length) {\n      // ...\n    }\n\n    [methodName]() {\n      // ...\n    }\n  }\n  ```\n\n## 严格模式\n\n类和模块的内部，默认就是严格模式，所以不需要使用`use strict`指定运行模式。\n\n## constructor方法\n\n+ `constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。\n\n+ 一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。\n\n  ```\n  class Point {\n  }\n\n  // 等同于\n  class Point {\n    constructor() {}\n  }\n  ```\n\n+ `constructor`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。\n\n  ```\n  class Foo {\n    constructor() {\n      return Object.create(null);\n    }\n  }\n\n  new Foo() instanceof Foo\n  // false\n\n  ```\n\n  上面代码中，`constructor`函数返回一个全新的对象，结果导致实例对象不是`Foo`类的实例。\n\n+ 类必须使用`new`调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。\n\n## 类的实例\n\n+ 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。\n\n  ```\n  //定义类\n  class Point {\n\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    toString() {\n      return '(' + this.x + ', ' + this.y + ')';\n    }\n\n  }\n\n  var point = new Point(2, 3);\n\n  point.toString() // (2, 3)\n\n  point.hasOwnProperty('x') // true\n  point.hasOwnProperty('y') // true\n  point.hasOwnProperty('toString') // false\n  point.__proto__.hasOwnProperty('toString') // true\n\n  ```\n\n  上面代码中，`x`和`y`都是实例对象`point`自身的属性（因为定义在`this`变量上），所以`hasOwnProperty`方法返回`true`，而`toString`是原型对象的属性（因为定义在`Point`类上），所以`hasOwnProperty`方法返回`false`。这些都与 ES5 的行为保持一致。\n\n+ 与 ES5 一样，类的所有实例共享一个原型对象。\n\n  ```\n  var p1 = new Point(2,3);\n  var p2 = new Point(3,2);\n\n  p1.__proto__ === p2.__proto__\n  //true\n\n  ```\n\n  上面代码中，`p1`和`p2`都是`Point`的实例，它们的原型都是`Point.prototype`，所以`__proto__`属性是相等的。\n\n  这也意味着，可以通过实例的`__proto__`属性为“类”添加方法。\n\n  > `__proto__` 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 `Object.getPrototypeOf` 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\n\n  ```\n  var p1 = new Point(2,3);\n  var p2 = new Point(3,2);\n\n  p1.__proto__.printName = function () { return 'Oops' };\n\n  p1.printName() // \"Oops\"\n  p2.printName() // \"Oops\"\n\n  var p3 = new Point(4,2);\n  p3.printName() // \"Oops\"\n\n  ```\n\n  上面代码在`p1`的原型上添加了一个`printName`方法，由于`p1`的原型就是`p2`的原型，因此`p2`也可以调用这个方法。而且，此后新建的实例`p3`也可以调用这个方法。这意味着，使用实例的`__proto__`属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\n\n## Class表达式\n\n与函数一样，类也可以使用表达式的形式定义。\n\n```\nconst MyClass = class Me {\n  getClassName() {\n    return Me.name;\n  }\n};\n\n```\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是`MyClass`而不是`Me`，`Me`只在 Class 的内部代码可用，指代当前类。\n\n```\nlet inst = new MyClass();\ninst.getClassName() // Me\nMe.name // ReferenceError: Me is not defined\n\n```\n\n上面代码表示，`Me`只在 Class 内部有定义。\n\n如果类的内部没用到的话，可以省略`Me`，也就是可以写成下面的形式。\n\n```\nconst MyClass = class { /* ... */ };\n```\n\n## 不存在变量提升\n\n类不存在变量提升（hoist），这一点与 ES5 完全不同。\n\n```\nnew Foo(); // ReferenceError\nclass Foo {}\n```\n# 模块\n\nES6的模块自动采用严格模式，不管你有没有在模块头部加上“use strict\"。\n\n## export命令\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。\n\n### export输出变量\n\n```\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n```\n\n或者\n\n```\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n```\n\n优先使用第二种写法。\n\n### export输出函数、类\n\n```\nexport function multiply(x, y) {\n  return x * y;\n};\n```\n\n或者\n\n```\nfunction v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n```\n\n上面使用了`as`关键字重命名了函数v1，v2的对外接口。\n\n### 注意\n\n这样写是错的：\n\n```\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n```\n\n这样写才正确：\n\n```\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n```\n\n函数和类也一样\n\n```\n// 报错\nfunction f() {}\nexport f;\n\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n```\n\n## import命令\n\n使用了`export`命令定义了模块对外的接口以后，其他js文件就可以通过`import`命令加载这个模块。\n\n### import输入变量\n\n```\nimport {firstName, lastName, year} from './profile';\n\nfunction setName(element) {\n  element.textContent = firstName + ' ' + lastName;\n}\n```\n\n如果想为输入的变量重新取一个名字，`import`命令要使用`as`关键字，将输入的变量重命名。\n\n```\nimport { lastName as surname } from './profile';\n```\n\n由于`import`是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\n\n```\n// 报错\nimport { 'f' + 'oo' } from 'my_module';\n\n// 报错\nlet module = 'my_module';\nimport { foo } from module;\n\n// 报错\nif (x === 1) {\n  import { foo } from 'module1';\n} else {\n  import { foo } from 'module2';\n}\n```\n\n最后，`import`语句会执行所加载的模块，因此可以有下面的写法。\n\n```\nimport 'lodash';\n\n```\n\n上面代码仅仅执行`lodash`模块，但是不输入任何值。\n\n## 模块的整体加载\n\n除了指定加载某个输出值，还可以使用整体加载，即用星号（`*`）指定一个对象，所有输出值都加载在这个对象上面。\n\n下面是一个`circle.js`文件，它输出两个方法`area`和`circumference`。\n\n```\n// circle.js\n\nexport function area(radius) {\n  return Math.PI * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * Math.PI * radius;\n}\n\n```\n\n现在，加载这个模块。\n\n```\n// main.js\n\nimport { area, circumference } from './circle';\n\nconsole.log('圆面积：' + area(4));\nconsole.log('圆周长：' + circumference(14));\n\n```\n\n上面写法是逐一指定要加载的方法，整体加载的写法如下。\n\n```\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n```\n\n注意，模块整体加载所在的那个对象（上例是`circle`），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。\n\n```\nimport * as circle from './circle';\n\n// 下面两行都是不允许的\ncircle.foo = 'hello';\ncircle.area = function () {};\n```","source":"_posts/ES6学习笔记.md","raw":"---\ntitle: ES6学习笔记\ndate: 2017-11-08 09:43:41\ntags:\n- javaScript\n- ES6\ncategories:\n- 学习笔记\ndescription: 《ECMAScript6入门——阮一峰》学习笔记\n---\n\n# let、const\n\n## let\n\n### 基本用法\n\nES6新增let命令，用来声明变量。用法类似var，但是所声明变量，只在let命令所在的代码块内有效。\n\n```\n{\n  let a = 10;\n  var b = 1;\n}\n\na // ReferenceError: a is not defined.\nb // 1\n```\n\nfor循环的计数器，就很适合用let命令。\n\n```\nfor (let i = 0; i < 10; i++){\n  // ...\n}\nconsole.log(i);\n// ReferenceError: i is not defined\n```\n\n### 不存在变量提升\n\nvar命令会发生“变量提升”现象。let命令没有，let声明的变量一定要在声明后使用，否则会报错：\n\n```\n// var 的情况\nconsole.log(foo); // 输出undefined\nvar foo = 2;\n\n// let 的情况\nconsole.log(bar); // 报错ReferenceError\nlet bar = 2;\n```\n\n### 暂时性死区\n\nES6规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n在代码块内，使用`let`命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n\n只要块级作用域内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。\n\n```\nif (true) {\n  // TDZ开始\n  tmp = 'abc'; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp; // TDZ结束\n  console.log(tmp); // undefined\n\n  tmp = 123;\n  console.log(tmp); // 123\n}\n```\n\n### 不允许重复声明\n\nlet命令不允许在相同作用域内，重复声明同一个变量。\n\n## 块级作用域\n\nlet实际上为JS新增了块级作用域。\n\nES6允许块级作用域的任意嵌套。\n\n外层作用域无法读取内层作用域的变量。\n\n内层作用域可以定义外层作用域的同名变量。\n\n块级作用域的出现，使得立即执行函数表达式不再必要。\n\n+ ES5中，函数只能声明在顶层作用域或函数作用域中。\n+ ES6中，明确允许在块级作用域中声明函数。\n\n## do表达式\n\n本质上，块级作用域是一个语句，没有返回值。\n\n现在有一个提案，使得块级作用域可以变为表达式，也就是说有返回值。办法就是在块级作用域前面加上do，变成do表达式，**返回内部最后执行的表达式的值。**\n\n```\nlet x = do {\n  let t = f();\n  t * t + 1;\n}\n```\n\n## const\n\nconst声明一个只读常量，一旦声明，常量的值就不能改变。\n\nconst一旦声明了变量，就立刻初始化，不能留到以后赋值；如果只声明不赋值，会报错。\n\nconst命令和let命令一样，只在声明所在的块级作用域内有效。\n\nconst声明的常量也不提示，同样存在暂时性死区，只能在声明的位置后面使用。\n\nconst命令和和let命令一样，不能重复声明。\n\n### const本质：\n\n`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，`const`只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。\n\n```\nconst foo = {};\n\n// 为 foo 添加一个属性，可以成功\nfoo.prop = 123;\nfoo.prop // 123\n\n// 将 foo 指向另一个对象，就会报错\nfoo = {}; // TypeError: \"foo\" is read-only\n\n```\n\n上面代码中，常量`foo`储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把`foo`指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。\n\n## ES6声明变量的6中方法\n\n除了ES5的两种var和function，还有let、const、import、class。\n\n## 顶层对象的属性\n\nES6规定，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。\n\n\n\n# 变量的解构赋值\n\n## 数组的解构赋值\n\n### 基本用法\n\n```\nlet [a,b,c] = [1,2,3];\n\n// 等同于\nlet a = 1;\nlet b = 2;\nlet c = 3;\n```\n\n```\nlet [foo, [[bar], baz]] = [1, [[2], 3]];\nfoo // 1\nbar // 2\nbaz // 3\n\nlet [ , , third] = [\"foo\", \"bar\", \"baz\"];\nthird // \"baz\"\n\nlet [x, , y] = [1, 2, 3];\nx // 1\ny // 3\n\nlet [head, ...tail] = [1, 2, 3, 4];\nhead // 1\ntail // [2, 3, 4]\n\nlet [x, y, ...z] = ['a'];\nx // \"a\"\ny // undefined\nz // []\n```\n\n```\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n\nlet [a, [b], d] = [1, [2, 3], 4];\na // 1\nb // 2\nd // 4\n```\n\n如果等号右边不是数组，会报错。\n\n```\n// 报错\nlet [foo] = 1;\nlet [foo] = false;\nlet [foo] = NaN;\nlet [foo] = undefined;\nlet [foo] = null;\nlet [foo] = {};\n```\n\n### 默认值：\n\n+ 解构赋值允许指定默认值。\n\n  ```\n  let [foo = true] = [];\n  foo // true\n\n  let [x, y = 'b'] = ['a']; // x='a', y='b'\n  let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'\n  ```\n\n  ​\t注意，ES6 内部使用严格相等运算符（`===`），判断一个位置是否有值。所以，如果一个数组成员不严格等于`undefined`，默认值是不会生效的。\n\n  ```\n  let [x = 1] = [undefined];\n  x // 1\n\n  let [x = 1] = [null];\n  x // null\n  ```\n\n+ 默认值可以是一个表达式，但这个表达式是惰性求值的，只有在用到的时候，才会被求值。\n\n  ```\n  function f(){\n    console.log('aaa');\n  }\n\n  let [x = f()] = [1];\n  ```\n\n  ​上面代码中，因为x能取到值，所以函数f根本不会执行。\n\n+ 默认值可以引用解构赋值的其他变量，但是该变量必须已经声明。\n\n  ```\n  let [x = 1, y = x] = [];     // x=1; y=1\n  let [x = 1, y = x] = [2];    // x=2; y=2\n  let [x = 1, y = x] = [1, 2]; // x=1; y=2\n  let [x = y, y = 1] = [];     // ReferenceError\n  ```\n\n  ​最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。\n\n## 对象的解构赋值\n\n### 基本用法\n\n对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。\n\n```\nlet { bar, foo } = { foo: \"aaa\", bar: \"bbb\" };\nfoo // \"aaa\"\nbar // \"bbb\"\n\nlet { baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // undefined\n```\n\n如果变量名与属性名不一致，必须写成下面这样。\n\n```\nlet { foo: baz } = { foo: 'aaa', bar: 'bbb' };\nbaz // \"aaa\"\n\nlet obj = { first: 'hello', last: 'world' };\nlet { first: f, last: l } = obj;\nf // 'hello'\nl // 'world'\n```\n\n这实际上说明，对象的解构赋值是下面形式的简写。\n\n```\nlet { foo: foo, bar: bar} = { foo: \"aaa\", bar: \"bbb\" };\n```\n\n也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。\n\n```\nlet { foo: baz } = { foo: \"aaa\", bar: \"bbb\" };\nbaz // \"aaa\"\nfoo // error: foo is not defined\n```\n\n上面代码中，`foo`是匹配的模式，`baz`才是变量。真正被赋值的是变量`baz`，而不是模式`foo`。\n\n嵌套：\n\n```\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\n```\n\n```\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p, p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\np // [\"Hello\", {y: \"World\"}]\n```\n\n```\nconst node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nlet { loc, loc: { start }, loc: { start: { line }} } = node;\nline // 1\nloc  // Object {start: Object}\nstart // Object {line: 1, column: 5}\n```\n\n嵌套赋值的例子：\n\n```\nlet obj = {};\nlet arr = [];\n\n({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });\n\nobj // {prop:123}\narr // [true]\n```\n\n### 默认值\n\n```\nvar {x = 3} = {};\nx // 3\n\nvar {x, y = 5} = {x: 1};\nx // 1\ny // 5\n\nvar {x: y = 3} = {};\ny // 3\n\nvar {x: y = 3} = {x: 5};\ny // 5\n\nvar { message: msg = 'Something went wrong' } = {};\nmsg // \"Something went wrong\"\n```\n\n+ 默认值生效的条件是，对象的属性值严格等于undefined。\n\n  ```\n  var { x = 3 } = { x: undefined };\n  x // 3\n\n  var { x = 3 } = { x: null };\n  x // null\n  ```\n\n  如果解构失败，变量的值等于undefined。\n\n  ```\n  let {foo} = {bar: 'baz'};\n  foo // undefined\n  ```\n\n+ 如果解构模式是嵌套的对象，而且自对象所在的赋属性不存在，那么将会报错。\n\n+ 如果一个已经声明的变量用于解构赋值，必须非常小心\n\n  ```\n  // 错误的写法\n  let x;\n  {x} = {x: 1};\n  // SyntaxError: syntax error\n  ```\n\n  上面代码会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生于法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决问题。\n\n  ```\n  // 正确的写法\n  let x;\n  ({x} = {x: 1});\n  ```\n\n+ 对象的解构赋值，可以很方便地将现有对象的方法，复制到某个变量。\n\n  ```\n  let { log, sin, cos } = Math;\n  ```\n\n  上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上。\n\n## 函数参数的解构赋值\n\n函数参数也可以使用解构赋值\n\n```\nfunction add ([x, y]){\n  return x + y;\n}\n\nadd([1,2]); // 3\n```\n\n上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。\n\n函数参数的解构也可以使用默认值。\n\n```\nfunction move ({x = 0, y = 0} = []){\n  return [x ,y];\n}\n\nmove({x: 3, y: 8}); // [3,8]\nmove({x: 3}); // [3,0]\nmove({}); // [0,0]\nmove(); // [0,0]\n```\n\n\n\n# 函数的扩展\n\n## 函数参数的默认值\n\nES6之前，不能直接为函数的参数指定默认值。\n\nES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\n\n```\nfunction log(x, y = 'World') {\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n\n+ 参数变量是默认声明的，所以在函数体内不能用let或const再次声明，否则会报错。\n\n  ```\n  function(x = 2){\n    let x = 1; // error\n    const x = 3; // error\n  }\n  ```\n\n+ 使用参数默认值时，函数不能有同名参数。\n\n  ```\n  // 不报错\n  function (x,x,y){\n    //...\n  }\n\n  // 报错\n  function (x,x,y = 1){\n    //...\n  }\n  ```\n\n+ 参数默认值不是传值，而是每次调用函数，都重新计算默认值表达式的值。\n\n  ```\n  let x = 99;\n  function( p = x + 1){\n    onsole.log(p);\n  }\n\n  foo() // 100\n\n  x = 100;\n  foo() // 101\n  ```\n\n+ 参数默认值可以和解构赋值的默认值，结合起来使用。\n\n  ```\n  function foo ({x, y = 5}){\n    console.log(x, y);\n  }\n\n  foo({}) // undefined 5\n  foo({x: 1}) // 1 5\n  foo({x: 1, y: 2}) // 1 2\n  foo() // TypeError: Cannot read property 'x' of undefined\n  ```\n\n  上面代码只是用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。\n\n  ```\n  function foo({x, y = 5} = {}) {\n    console.log(x, y);\n  }\n\n  foo() // undefined 5\n  ```\n\n+ 参数默认值的位置：\n\n  定义了默认值的参数，应该是函数的尾参数。如果非尾部的参数设置默认值，这个参数没发省略，除非显示输入undefined。\n\n  ```\n  function f(x = 1, y){\n    return [x, y];\n  }\n\n  f() // [1, undefined]\n  f(2) // [2, undefined]\n  f(, 1) // 报错\n  f(undefined, 1) // [1,1]\n  ```\n\n+ 参数作用域：\n\n  一旦设置的参数的默认值，函数进行声明初始化时，参数会单独形成一个作用域，等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值的时候，是不会出现的。\n\n  ```\n  var x = 1;\n  function f(x, y = x){\n    console.log(y);\n  }\n\n  f(2) // 2\n  ```\n\n  ```\n  let x = 1;\n  function f(x = y){\n    let x = 2;\n    console.log(y);\n  }\n\n  f() // 1\n  ```\n\n## rest参数\n\nES6引入rest参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n\n下面是一个rest参数代替arguments变量的例子：\n\n```\n// arguments变量的写法\nfunction sortNumbers(){\n  return Array.prototype.slice.call(arguments).sort();\n}\n\n// rest写法\nconst sortNumbers = (...numbers) => numbers.sort();\n```\n\narguments对象不是数组，而是类似数组的对象，所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转换为数组。rest参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。\n\n+ rest参数之后不能有其他参数，否则报错。\n\n  ```\n  // 报错\n  function f(a, ...b, c){\n    // ...\n  }\n  ```\n\n## 箭头函数\n\nES6允许使用“箭头”（=>）定义函数。\n\n```\nvar f = v => v;\n\n// 等同于\n\nvar f = function (v){\n  return v;\n}\n```\n\n+ 如果箭头函数不需要参数或者需要多个参数，就使用一个圆括号代表参数部分。\n\n  ```\n  var f = () => 5;\n  // 等同于\n  var f = function (){\n    return 5;\n  }\n\n  var sum = (num1, num2) => num1 + num2;\n  // 等同于\n  var sum = function(num1, num2){\n    return num1+ num2;\n  }\n  ```\n\n+ 如果箭头函数的代码块部分多余一条语句，就要用大括号括起来，并且使用return返回\n\n  ```\n  var sum = (num1, num2) => { return num1 + num2; }\n  ```\n\n+ 由于大括号被解释为代码块，所以箭头函数如果返回一个对象，必须在对象外面加上括号，否则会报错。\n\n  ```\n  // 报错\n  let getTempItem = id => { id: id, name: \"Temp\" };\n\n  // 不报错\n  let getTempItem = id => ({ id: id, name: \"Temp\" });\n  ```\n\n+ 箭头函数的一个作用是简化回调函数\n\n  ```\n  // 正常函数写法\n  [1,2,3].map(function (x) {\n    return x * x;\n  });\n\n  // 箭头函数写法\n  [1,2,3].map(x => x * x);\n  ```\n\n### 使用注意\n\n1. 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。\n\n```\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);\n}\n\nvar id = 21;\n\nfoo.call({ id: 42 });\n// id: 42\n```\n\n上面代码中，`setTimeout`的参数是一个箭头函数，这个箭头函数的定义生效是在`foo`函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时`this`应该指向全局对象`window`，这时应该输出`21`。但是，箭头函数导致`this`总是指向函数定义生效时所在的对象（本例是`{id: 42}`），所以输出的是`42`。\n\n`this`指向的固定化，并不是因为箭头函数内部有绑定`this`的机制，实际原因是箭头函数根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`。正是因为它没有`this`，所以也就不能用作构造函数。\n\n```\nfunction foo() {\n  return () => {\n    return () => {\n      return () => {\n        console.log('id:', this.id);\n      };\n    };\n  };\n}\n\nvar f = foo.call({id: 1});\n\nvar t1 = f.call({id: 2})()(); // id: 1\nvar t2 = f().call({id: 3})(); // id: 1\nvar t3 = f()().call({id: 4}); // id: 1\n```\n\n上面代码之中，只有一个`this`，就是函数`foo`的`this`，所以`t1`、`t2`、`t3`都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的`this`，它们的`this`其实都是最外层`foo`函数的`this`。\n\n除了`this`，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：`arguments`、`super`、`new.target`。\n\n另外，由于箭头函数没有自己的`this`，所以当然也就不能用`call()`、`apply()`、`bind()`这些方法去改变`this`的指向。\n\n```\n(function() {\n  return [\n    (() => this.x).bind({ x: 'inner' })()\n  ];\n}).call({ x: 'outer' });\n// ['outer']\n```\n\n2. 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。\n3. 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。\n4. 不可以使用`yield`命令，因此箭头函数不能用作 Generator 函数。\n\n# Promise对象\n\n## 基本用法\n\nES6规定，Promise对象是一个构造函数，用来生成Promise实例\n\n```\nconst promise = new Promise(function(resolve, reject){\n  // ...some code\n  \n  if(/*异步操作成功*/){\n    resolve(value);\n  }else{\n    reject(error);\n  }\n})\n```\n\n# Class的基本用法\n\n## 简介\n\nJS语言中，生成实例对象的传统方法是构造函数。\n\n```\nfunction Point(x, y){\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function (){\n  return '(' + this.x + ', ' + this.y + ')';\n};\n\nvar p = new Point(1, 2);\n```\n\nES6提供了更接近传统语言的写法，引入了**Class（类）**这个概念，作为对象的模版。通过Class关键字，可以定义类。\n\n基本上，ES6 的`class`可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的`class`改写，就是下面这样。\n\n```\n// 定义类\nclass Point {\n  constructor(x, y){\n    this.x = x;\n    this.y = y;\n  }\n  toString(){\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n\n+ 上面定义类一个“类”，里面有一个constructor方法，这就是构造方法，而`this`关键字则代表实例对象，也就是说，ES5点构造函数Point，对应ES6的Point类的构造方法。\n\n+ Point类除了构造方法，还定义了一个toString方法。定义“类”方法的时候，前面不需要家`function`关键字。\n\n+ 方法之间不需要逗号间隔，加了会报错。\n\n+ ES6的类，完全可以看成是构造函数的另一种写法：\n\n  ```\n  class Point {\n    // ...\n  }\n\n  typeof Point // \"function\"\n  Point === Point.prototype.constructor // true\n  ```\n\n  上面代码表明，类的数据类型就是函数，类本身就指向构造函数。\n\n+ 使用的时候，也是直接对类使用new命令，跟构造函数的用法一致。\n\n  ```\n  class Bar {\n    doStuff(){\n      console.log('stuff');\n    }\n  }\n\n  var b = new Bar();\n  b.doStuff(); // \"stuff\"\n  ```\n\n+ 构造函数的`prototype`属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的`prototype`属性上面。\n\n  ```\n  class Point {\n    constructor() {\n      // ...\n    }\n\n    toString() {\n      // ...\n    }\n\n    toValue() {\n      // ...\n    }\n  }\n\n  // 等同于\n\n  Point.prototype = {\n    constructor() {},\n    toString() {},\n    toValue() {},\n  };\n  ```\n\n  在类的实例上面调用方法，其实就是调用原型上的方法。\n\n  ```\n  class B {}\n  let b = new B();\n\n  b.constructor === B.prototype.constructor // true\n\n  ```\n\n  上面代码中，`b`是`B`类的实例，它的`constructor`方法就是`B`类原型的`constructor`方法。\n\n+ 由于类的方法都定义在`prototype`对象上面，所以类的新方法可以添加在`prototype`对象上面。`Object.assign`方法可以很方便地一次向类添加多个方法。\n\n  ```\n  class Point {\n    constructor(){\n      // ...\n    }\n  }\n\n  Object.assign(Point.prototype, {\n    toString(){},\n    toValue(){}\n  });\n  ```\n\n+ `prototype`对象的`constructor`属性，直接指向“类”的本身，这与 ES5 的行为是一致的。\n\n  ```\n  Point.prototype.constructor === Point // true\n  ```\n\n+ 类的内部所有定义的方法，都是不可枚举的（non-enumerable）。\n\n  ```\n  class Point {\n    constructor(x, y) {\n      // ...\n    }\n\n    toString() {\n      // ...\n    }\n  }\n\n  Object.keys(Point.prototype)\n  // []\n  Object.getOwnPropertyNames(Point.prototype)\n  // [\"constructor\",\"toString\"]\n\n  ```\n\n  上面代码中，`toString`方法是`Point`类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。\n\n+ 类的属性名，可以采用表达式。\n\n  ```\n  let methodName = 'getArea';\n\n  class Square {\n    constructor(length) {\n      // ...\n    }\n\n    [methodName]() {\n      // ...\n    }\n  }\n  ```\n\n## 严格模式\n\n类和模块的内部，默认就是严格模式，所以不需要使用`use strict`指定运行模式。\n\n## constructor方法\n\n+ `constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。\n\n+ 一个类必须有`constructor`方法，如果没有显式定义，一个空的`constructor`方法会被默认添加。\n\n  ```\n  class Point {\n  }\n\n  // 等同于\n  class Point {\n    constructor() {}\n  }\n  ```\n\n+ `constructor`方法默认返回实例对象（即`this`），完全可以指定返回另外一个对象。\n\n  ```\n  class Foo {\n    constructor() {\n      return Object.create(null);\n    }\n  }\n\n  new Foo() instanceof Foo\n  // false\n\n  ```\n\n  上面代码中，`constructor`函数返回一个全新的对象，结果导致实例对象不是`Foo`类的实例。\n\n+ 类必须使用`new`调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用`new`也可以执行。\n\n## 类的实例\n\n+ 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在`this`对象上），否则都是定义在原型上（即定义在`class`上）。\n\n  ```\n  //定义类\n  class Point {\n\n    constructor(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n\n    toString() {\n      return '(' + this.x + ', ' + this.y + ')';\n    }\n\n  }\n\n  var point = new Point(2, 3);\n\n  point.toString() // (2, 3)\n\n  point.hasOwnProperty('x') // true\n  point.hasOwnProperty('y') // true\n  point.hasOwnProperty('toString') // false\n  point.__proto__.hasOwnProperty('toString') // true\n\n  ```\n\n  上面代码中，`x`和`y`都是实例对象`point`自身的属性（因为定义在`this`变量上），所以`hasOwnProperty`方法返回`true`，而`toString`是原型对象的属性（因为定义在`Point`类上），所以`hasOwnProperty`方法返回`false`。这些都与 ES5 的行为保持一致。\n\n+ 与 ES5 一样，类的所有实例共享一个原型对象。\n\n  ```\n  var p1 = new Point(2,3);\n  var p2 = new Point(3,2);\n\n  p1.__proto__ === p2.__proto__\n  //true\n\n  ```\n\n  上面代码中，`p1`和`p2`都是`Point`的实例，它们的原型都是`Point.prototype`，所以`__proto__`属性是相等的。\n\n  这也意味着，可以通过实例的`__proto__`属性为“类”添加方法。\n\n  > `__proto__` 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 `Object.getPrototypeOf` 方法来获取实例对象的原型，然后再来为原型添加方法/属性。\n\n  ```\n  var p1 = new Point(2,3);\n  var p2 = new Point(3,2);\n\n  p1.__proto__.printName = function () { return 'Oops' };\n\n  p1.printName() // \"Oops\"\n  p2.printName() // \"Oops\"\n\n  var p3 = new Point(4,2);\n  p3.printName() // \"Oops\"\n\n  ```\n\n  上面代码在`p1`的原型上添加了一个`printName`方法，由于`p1`的原型就是`p2`的原型，因此`p2`也可以调用这个方法。而且，此后新建的实例`p3`也可以调用这个方法。这意味着，使用实例的`__proto__`属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。\n\n## Class表达式\n\n与函数一样，类也可以使用表达式的形式定义。\n\n```\nconst MyClass = class Me {\n  getClassName() {\n    return Me.name;\n  }\n};\n\n```\n\n上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是`MyClass`而不是`Me`，`Me`只在 Class 的内部代码可用，指代当前类。\n\n```\nlet inst = new MyClass();\ninst.getClassName() // Me\nMe.name // ReferenceError: Me is not defined\n\n```\n\n上面代码表示，`Me`只在 Class 内部有定义。\n\n如果类的内部没用到的话，可以省略`Me`，也就是可以写成下面的形式。\n\n```\nconst MyClass = class { /* ... */ };\n```\n\n## 不存在变量提升\n\n类不存在变量提升（hoist），这一点与 ES5 完全不同。\n\n```\nnew Foo(); // ReferenceError\nclass Foo {}\n```\n# 模块\n\nES6的模块自动采用严格模式，不管你有没有在模块头部加上“use strict\"。\n\n## export命令\n\n一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量。\n\n### export输出变量\n\n```\nexport var firstName = 'Michael';\nexport var lastName = 'Jackson';\nexport var year = 1958;\n```\n\n或者\n\n```\nvar firstName = 'Michael';\nvar lastName = 'Jackson';\nvar year = 1958;\n\nexport {firstName, lastName, year};\n```\n\n优先使用第二种写法。\n\n### export输出函数、类\n\n```\nexport function multiply(x, y) {\n  return x * y;\n};\n```\n\n或者\n\n```\nfunction v1() { ... }\nfunction v2() { ... }\n\nexport {\n  v1 as streamV1,\n  v2 as streamV2,\n  v2 as streamLatestVersion\n};\n```\n\n上面使用了`as`关键字重命名了函数v1，v2的对外接口。\n\n### 注意\n\n这样写是错的：\n\n```\n// 报错\nexport 1;\n\n// 报错\nvar m = 1;\nexport m;\n```\n\n这样写才正确：\n\n```\n// 写法一\nexport var m = 1;\n\n// 写法二\nvar m = 1;\nexport {m};\n\n// 写法三\nvar n = 1;\nexport {n as m};\n```\n\n函数和类也一样\n\n```\n// 报错\nfunction f() {}\nexport f;\n\n// 正确\nexport function f() {};\n\n// 正确\nfunction f() {}\nexport {f};\n```\n\n## import命令\n\n使用了`export`命令定义了模块对外的接口以后，其他js文件就可以通过`import`命令加载这个模块。\n\n### import输入变量\n\n```\nimport {firstName, lastName, year} from './profile';\n\nfunction setName(element) {\n  element.textContent = firstName + ' ' + lastName;\n}\n```\n\n如果想为输入的变量重新取一个名字，`import`命令要使用`as`关键字，将输入的变量重命名。\n\n```\nimport { lastName as surname } from './profile';\n```\n\n由于`import`是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。\n\n```\n// 报错\nimport { 'f' + 'oo' } from 'my_module';\n\n// 报错\nlet module = 'my_module';\nimport { foo } from module;\n\n// 报错\nif (x === 1) {\n  import { foo } from 'module1';\n} else {\n  import { foo } from 'module2';\n}\n```\n\n最后，`import`语句会执行所加载的模块，因此可以有下面的写法。\n\n```\nimport 'lodash';\n\n```\n\n上面代码仅仅执行`lodash`模块，但是不输入任何值。\n\n## 模块的整体加载\n\n除了指定加载某个输出值，还可以使用整体加载，即用星号（`*`）指定一个对象，所有输出值都加载在这个对象上面。\n\n下面是一个`circle.js`文件，它输出两个方法`area`和`circumference`。\n\n```\n// circle.js\n\nexport function area(radius) {\n  return Math.PI * radius * radius;\n}\n\nexport function circumference(radius) {\n  return 2 * Math.PI * radius;\n}\n\n```\n\n现在，加载这个模块。\n\n```\n// main.js\n\nimport { area, circumference } from './circle';\n\nconsole.log('圆面积：' + area(4));\nconsole.log('圆周长：' + circumference(14));\n\n```\n\n上面写法是逐一指定要加载的方法，整体加载的写法如下。\n\n```\nimport * as circle from './circle';\n\nconsole.log('圆面积：' + circle.area(4));\nconsole.log('圆周长：' + circle.circumference(14));\n```\n\n注意，模块整体加载所在的那个对象（上例是`circle`），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。\n\n```\nimport * as circle from './circle';\n\n// 下面两行都是不允许的\ncircle.foo = 'hello';\ncircle.area = function () {};\n```","slug":"ES6学习笔记","published":1,"updated":"2021-05-08T14:59:44.839Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbps0024wct43sumehbt","content":"<h1 id=\"let、const\"><a href=\"#let、const\" class=\"headerlink\" title=\"let、const\"></a>let、const</h1><h2 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6新增let命令，用来声明变量。用法类似var，但是所声明变量，只在let命令所在的代码块内有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  let a &#x3D; 10;</span><br><span class=\"line\">  var b &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a &#x2F;&#x2F; ReferenceError: a is not defined.</span><br><span class=\"line\">b &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>\n\n<p>for循环的计数器，就很适合用let命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i);</span><br><span class=\"line\">&#x2F;&#x2F; ReferenceError: i is not defined</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>var命令会发生“变量提升”现象。let命令没有，let声明的变量一定要在声明后使用，否则会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; var 的情况</span><br><span class=\"line\">console.log(foo); &#x2F;&#x2F; 输出undefined</span><br><span class=\"line\">var foo &#x3D; 2;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; let 的情况</span><br><span class=\"line\">console.log(bar); &#x2F;&#x2F; 报错ReferenceError</span><br><span class=\"line\">let bar &#x3D; 2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>ES6规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>\n<p>在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>\n<p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (true) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; TDZ开始</span><br><span class=\"line\">  tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError</span><br><span class=\"line\">  console.log(tmp); &#x2F;&#x2F; ReferenceError</span><br><span class=\"line\"></span><br><span class=\"line\">  let tmp; &#x2F;&#x2F; TDZ结束</span><br><span class=\"line\">  console.log(tmp); &#x2F;&#x2F; undefined</span><br><span class=\"line\"></span><br><span class=\"line\">  tmp &#x3D; 123;</span><br><span class=\"line\">  console.log(tmp); &#x2F;&#x2F; 123</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h3><p>let命令不允许在相同作用域内，重复声明同一个变量。</p>\n<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>let实际上为JS新增了块级作用域。</p>\n<p>ES6允许块级作用域的任意嵌套。</p>\n<p>外层作用域无法读取内层作用域的变量。</p>\n<p>内层作用域可以定义外层作用域的同名变量。</p>\n<p>块级作用域的出现，使得立即执行函数表达式不再必要。</p>\n<ul>\n<li>ES5中，函数只能声明在顶层作用域或函数作用域中。</li>\n<li>ES6中，明确允许在块级作用域中声明函数。</li>\n</ul>\n<h2 id=\"do表达式\"><a href=\"#do表达式\" class=\"headerlink\" title=\"do表达式\"></a>do表达式</h2><p>本质上，块级作用域是一个语句，没有返回值。</p>\n<p>现在有一个提案，使得块级作用域可以变为表达式，也就是说有返回值。办法就是在块级作用域前面加上do，变成do表达式，<strong>返回内部最后执行的表达式的值。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x &#x3D; do &#123;</span><br><span class=\"line\">  let t &#x3D; f();</span><br><span class=\"line\">  t * t + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><p>const声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n<p>const一旦声明了变量，就立刻初始化，不能留到以后赋值；如果只声明不赋值，会报错。</p>\n<p>const命令和let命令一样，只在声明所在的块级作用域内有效。</p>\n<p>const声明的常量也不提示，同样存在暂时性死区，只能在声明的位置后面使用。</p>\n<p>const命令和和let命令一样，不能重复声明。</p>\n<h3 id=\"const本质：\"><a href=\"#const本质：\" class=\"headerlink\" title=\"const本质：\"></a>const本质：</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const foo &#x3D; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 为 foo 添加一个属性，可以成功</span><br><span class=\"line\">foo.prop &#x3D; 123;</span><br><span class=\"line\">foo.prop &#x2F;&#x2F; 123</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将 foo 指向另一个对象，就会报错</span><br><span class=\"line\">foo &#x3D; &#123;&#125;; &#x2F;&#x2F; TypeError: &quot;foo&quot; is read-only</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>\n<h2 id=\"ES6声明变量的6中方法\"><a href=\"#ES6声明变量的6中方法\" class=\"headerlink\" title=\"ES6声明变量的6中方法\"></a>ES6声明变量的6中方法</h2><p>除了ES5的两种var和function，还有let、const、import、class。</p>\n<h2 id=\"顶层对象的属性\"><a href=\"#顶层对象的属性\" class=\"headerlink\" title=\"顶层对象的属性\"></a>顶层对象的属性</h2><p>ES6规定，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</p>\n<h1 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a>变量的解构赋值</h1><h2 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h2><h3 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a,b,c] &#x3D; [1,2,3];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">let a &#x3D; 1;</span><br><span class=\"line\">let b &#x3D; 2;</span><br><span class=\"line\">let c &#x3D; 3;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo, [[bar], baz]] &#x3D; [1, [[2], 3]];</span><br><span class=\"line\">foo &#x2F;&#x2F; 1</span><br><span class=\"line\">bar &#x2F;&#x2F; 2</span><br><span class=\"line\">baz &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">let [ , , third] &#x3D; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class=\"line\">third &#x2F;&#x2F; &quot;baz&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, , y] &#x3D; [1, 2, 3];</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\">y &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">let [head, ...tail] &#x3D; [1, 2, 3, 4];</span><br><span class=\"line\">head &#x2F;&#x2F; 1</span><br><span class=\"line\">tail &#x2F;&#x2F; [2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, y, ...z] &#x3D; [&#39;a&#39;];</span><br><span class=\"line\">x &#x2F;&#x2F; &quot;a&quot;</span><br><span class=\"line\">y &#x2F;&#x2F; undefined</span><br><span class=\"line\">z &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x, y] &#x3D; [1, 2, 3];</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\">y &#x2F;&#x2F; 2</span><br><span class=\"line\"></span><br><span class=\"line\">let [a, [b], d] &#x3D; [1, [2, 3], 4];</span><br><span class=\"line\">a &#x2F;&#x2F; 1</span><br><span class=\"line\">b &#x2F;&#x2F; 2</span><br><span class=\"line\">d &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>\n\n<p>如果等号右边不是数组，会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">let [foo] &#x3D; 1;</span><br><span class=\"line\">let [foo] &#x3D; false;</span><br><span class=\"line\">let [foo] &#x3D; NaN;</span><br><span class=\"line\">let [foo] &#x3D; undefined;</span><br><span class=\"line\">let [foo] &#x3D; null;</span><br><span class=\"line\">let [foo] &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认值：\"><a href=\"#默认值：\" class=\"headerlink\" title=\"默认值：\"></a>默认值：</h3><ul>\n<li><p>解构赋值允许指定默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo &#x3D; true] &#x3D; [];</span><br><span class=\"line\">foo &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;</span><br><span class=\"line\">let [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;, undefined]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;</span><br></pre></td></tr></table></figure>\n\n<p>​    注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x &#x3D; 1] &#x3D; [undefined];</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\"></span><br><span class=\"line\">let [x &#x3D; 1] &#x3D; [null];</span><br><span class=\"line\">x &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure></li>\n<li><p>默认值可以是一个表达式，但这个表达式是惰性求值的，只有在用到的时候，才会被求值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f()&#123;</span><br><span class=\"line\">  console.log(&#39;aaa&#39;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let [x &#x3D; f()] &#x3D; [1];</span><br></pre></td></tr></table></figure>\n\n<p>​上面代码中，因为x能取到值，所以函数f根本不会执行。</p>\n</li>\n<li><p>默认值可以引用解构赋值的其他变量，但是该变量必须已经声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x &#x3D; 1, y &#x3D; x] &#x3D; [];     &#x2F;&#x2F; x&#x3D;1; y&#x3D;1</span><br><span class=\"line\">let [x &#x3D; 1, y &#x3D; x] &#x3D; [2];    &#x2F;&#x2F; x&#x3D;2; y&#x3D;2</span><br><span class=\"line\">let [x &#x3D; 1, y &#x3D; x] &#x3D; [1, 2]; &#x2F;&#x2F; x&#x3D;1; y&#x3D;2</span><br><span class=\"line\">let [x &#x3D; y, y &#x3D; 1] &#x3D; [];     &#x2F;&#x2F; ReferenceError</span><br></pre></td></tr></table></figure>\n\n<p>​最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。</p>\n</li>\n</ul>\n<h2 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h2><h3 id=\"基本用法-2\"><a href=\"#基本用法-2\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; bar, foo &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class=\"line\">foo &#x2F;&#x2F; &quot;aaa&quot;</span><br><span class=\"line\">bar &#x2F;&#x2F; &quot;bbb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; baz &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class=\"line\">baz &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>\n\n<p>如果变量名与属性名不一致，必须写成下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; foo: baz &#125; &#x3D; &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;</span><br><span class=\"line\">baz &#x2F;&#x2F; &quot;aaa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj &#x3D; &#123; first: &#39;hello&#39;, last: &#39;world&#39; &#125;;</span><br><span class=\"line\">let &#123; first: f, last: l &#125; &#x3D; obj;</span><br><span class=\"line\">f &#x2F;&#x2F; &#39;hello&#39;</span><br><span class=\"line\">l &#x2F;&#x2F; &#39;world&#39;</span><br></pre></td></tr></table></figure>\n\n<p>这实际上说明，对象的解构赋值是下面形式的简写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; foo: foo, bar: bar&#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; foo: baz &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class=\"line\">baz &#x2F;&#x2F; &quot;aaa&quot;</span><br><span class=\"line\">foo &#x2F;&#x2F; error: foo is not defined</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>\n<p>嵌套：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">  p: [</span><br><span class=\"line\">    &#39;Hello&#39;,</span><br><span class=\"line\">    &#123; y: &#39;World&#39; &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; p: [x, &#123; y &#125;] &#125; &#x3D; obj;</span><br><span class=\"line\">x &#x2F;&#x2F; &quot;Hello&quot;</span><br><span class=\"line\">y &#x2F;&#x2F; &quot;World&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">  p: [</span><br><span class=\"line\">    &#39;Hello&#39;,</span><br><span class=\"line\">    &#123; y: &#39;World&#39; &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; p, p: [x, &#123; y &#125;] &#125; &#x3D; obj;</span><br><span class=\"line\">x &#x2F;&#x2F; &quot;Hello&quot;</span><br><span class=\"line\">y &#x2F;&#x2F; &quot;World&quot;</span><br><span class=\"line\">p &#x2F;&#x2F; [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const node &#x3D; &#123;</span><br><span class=\"line\">  loc: &#123;</span><br><span class=\"line\">    start: &#123;</span><br><span class=\"line\">      line: 1,</span><br><span class=\"line\">      column: 5</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; &#x3D; node;</span><br><span class=\"line\">line &#x2F;&#x2F; 1</span><br><span class=\"line\">loc  &#x2F;&#x2F; Object &#123;start: Object&#125;</span><br><span class=\"line\">start &#x2F;&#x2F; Object &#123;line: 1, column: 5&#125;</span><br></pre></td></tr></table></figure>\n\n<p>嵌套赋值的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">let arr &#x3D; [];</span><br><span class=\"line\"></span><br><span class=\"line\">(&#123; foo: obj.prop, bar: arr[0] &#125; &#x3D; &#123; foo: 123, bar: true &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj &#x2F;&#x2F; &#123;prop:123&#125;</span><br><span class=\"line\">arr &#x2F;&#x2F; [true]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var &#123;x &#x3D; 3&#125; &#x3D; &#123;&#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123;x, y &#x3D; 5&#125; &#x3D; &#123;x: 1&#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\">y &#x2F;&#x2F; 5</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123;x: y &#x3D; 3&#125; &#x3D; &#123;&#125;;</span><br><span class=\"line\">y &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123;x: y &#x3D; 3&#125; &#x3D; &#123;x: 5&#125;;</span><br><span class=\"line\">y &#x2F;&#x2F; 5</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123; message: msg &#x3D; &#39;Something went wrong&#39; &#125; &#x3D; &#123;&#125;;</span><br><span class=\"line\">msg &#x2F;&#x2F; &quot;Something went wrong&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>默认值生效的条件是，对象的属性值严格等于undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var &#123; x &#x3D; 3 &#125; &#x3D; &#123; x: undefined &#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123; x &#x3D; 3 &#125; &#x3D; &#123; x: null &#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>\n\n<p>如果解构失败，变量的值等于undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo&#125; &#x3D; &#123;bar: &#39;baz&#39;&#125;;</span><br><span class=\"line\">foo &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure></li>\n<li><p>如果解构模式是嵌套的对象，而且自对象所在的赋属性不存在，那么将会报错。</p>\n</li>\n<li><p>如果一个已经声明的变量用于解构赋值，必须非常小心</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 错误的写法</span><br><span class=\"line\">let x;</span><br><span class=\"line\">&#123;x&#125; &#x3D; &#123;x: 1&#125;;</span><br><span class=\"line\">&#x2F;&#x2F; SyntaxError: syntax error</span><br></pre></td></tr></table></figure>\n\n<p>上面代码会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生于法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 正确的写法</span><br><span class=\"line\">let x;</span><br><span class=\"line\">(&#123;x&#125; &#x3D; &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure></li>\n<li><p>对象的解构赋值，可以很方便地将现有对象的方法，复制到某个变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; log, sin, cos &#125; &#x3D; Math;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上。</p>\n</li>\n</ul>\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><p>函数参数也可以使用解构赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add ([x, y])&#123;</span><br><span class=\"line\">  return x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add([1,2]); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。</p>\n<p>函数参数的解构也可以使用默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function move (&#123;x &#x3D; 0, y &#x3D; 0&#125; &#x3D; [])&#123;</span><br><span class=\"line\">  return [x ,y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">move(&#123;x: 3, y: 8&#125;); &#x2F;&#x2F; [3,8]</span><br><span class=\"line\">move(&#123;x: 3&#125;); &#x2F;&#x2F; [3,0]</span><br><span class=\"line\">move(&#123;&#125;); &#x2F;&#x2F; [0,0]</span><br><span class=\"line\">move(); &#x2F;&#x2F; [0,0]</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h1><h2 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h2><p>ES6之前，不能直接为函数的参数指定默认值。</p>\n<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(x, y &#x3D; &#39;World&#39;) &#123;</span><br><span class=\"line\">  console.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">log(&#39;Hello&#39;) &#x2F;&#x2F; Hello World</span><br><span class=\"line\">log(&#39;Hello&#39;, &#39;China&#39;) &#x2F;&#x2F; Hello China</span><br><span class=\"line\">log(&#39;Hello&#39;, &#39;&#39;) &#x2F;&#x2F; Hello</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>参数变量是默认声明的，所以在函数体内不能用let或const再次声明，否则会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(x &#x3D; 2)&#123;</span><br><span class=\"line\">  let x &#x3D; 1; &#x2F;&#x2F; error</span><br><span class=\"line\">  const x &#x3D; 3; &#x2F;&#x2F; error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>使用参数默认值时，函数不能有同名参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 不报错</span><br><span class=\"line\">function (x,x,y)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F;...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">function (x,x,y &#x3D; 1)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F;...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>参数默认值不是传值，而是每次调用函数，都重新计算默认值表达式的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x &#x3D; 99;</span><br><span class=\"line\">function( p &#x3D; x + 1)&#123;</span><br><span class=\"line\">  onsole.log(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo() &#x2F;&#x2F; 100</span><br><span class=\"line\"></span><br><span class=\"line\">x &#x3D; 100;</span><br><span class=\"line\">foo() &#x2F;&#x2F; 101</span><br></pre></td></tr></table></figure></li>\n<li><p>参数默认值可以和解构赋值的默认值，结合起来使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo (&#123;x, y &#x3D; 5&#125;)&#123;</span><br><span class=\"line\">  console.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(&#123;&#125;) &#x2F;&#x2F; undefined 5</span><br><span class=\"line\">foo(&#123;x: 1&#125;) &#x2F;&#x2F; 1 5</span><br><span class=\"line\">foo(&#123;x: 1, y: 2&#125;) &#x2F;&#x2F; 1 2</span><br><span class=\"line\">foo() &#x2F;&#x2F; TypeError: Cannot read property &#39;x&#39; of undefined</span><br></pre></td></tr></table></figure>\n\n<p>上面代码只是用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(&#123;x, y &#x3D; 5&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class=\"line\">  console.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo() &#x2F;&#x2F; undefined 5</span><br></pre></td></tr></table></figure></li>\n<li><p>参数默认值的位置：</p>\n<p>定义了默认值的参数，应该是函数的尾参数。如果非尾部的参数设置默认值，这个参数没发省略，除非显示输入undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(x &#x3D; 1, y)&#123;</span><br><span class=\"line\">  return [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; [1, undefined]</span><br><span class=\"line\">f(2) &#x2F;&#x2F; [2, undefined]</span><br><span class=\"line\">f(, 1) &#x2F;&#x2F; 报错</span><br><span class=\"line\">f(undefined, 1) &#x2F;&#x2F; [1,1]</span><br></pre></td></tr></table></figure></li>\n<li><p>参数作用域：</p>\n<p>一旦设置的参数的默认值，函数进行声明初始化时，参数会单独形成一个作用域，等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值的时候，是不会出现的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">function f(x, y &#x3D; x)&#123;</span><br><span class=\"line\">  console.log(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(2) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x &#x3D; 1;</span><br><span class=\"line\">function f(x &#x3D; y)&#123;</span><br><span class=\"line\">  let x &#x3D; 2;</span><br><span class=\"line\">  console.log(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h2><p>ES6引入rest参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>\n<p>下面是一个rest参数代替arguments变量的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; arguments变量的写法</span><br><span class=\"line\">function sortNumbers()&#123;</span><br><span class=\"line\">  return Array.prototype.slice.call(arguments).sort();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; rest写法</span><br><span class=\"line\">const sortNumbers &#x3D; (...numbers) &#x3D;&gt; numbers.sort();</span><br></pre></td></tr></table></figure>\n\n<p>arguments对象不是数组，而是类似数组的对象，所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转换为数组。rest参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。</p>\n<ul>\n<li><p>rest参数之后不能有其他参数，否则报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">function f(a, ...b, c)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6允许使用“箭头”（=&gt;）定义函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; v &#x3D;&gt; v;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\"></span><br><span class=\"line\">var f &#x3D; function (v)&#123;</span><br><span class=\"line\">  return v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果箭头函数不需要参数或者需要多个参数，就使用一个圆括号代表参数部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; () &#x3D;&gt; 5;</span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">var f &#x3D; function ()&#123;</span><br><span class=\"line\">  return 5;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var sum &#x3D; (num1, num2) &#x3D;&gt; num1 + num2;</span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">var sum &#x3D; function(num1, num2)&#123;</span><br><span class=\"line\">  return num1+ num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>如果箭头函数的代码块部分多余一条语句，就要用大括号括起来，并且使用return返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sum &#x3D; (num1, num2) &#x3D;&gt; &#123; return num1 + num2; &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>由于大括号被解释为代码块，所以箭头函数如果返回一个对象，必须在对象外面加上括号，否则会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">let getTempItem &#x3D; id &#x3D;&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 不报错</span><br><span class=\"line\">let getTempItem &#x3D; id &#x3D;&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);</span><br></pre></td></tr></table></figure></li>\n<li><p>箭头函数的一个作用是简化回调函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 正常函数写法</span><br><span class=\"line\">[1,2,3].map(function (x) &#123;</span><br><span class=\"line\">  return x * x;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 箭头函数写法</span><br><span class=\"line\">[1,2,3].map(x &#x3D;&gt; x * x);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ol>\n<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;id:&#39;, this.id);</span><br><span class=\"line\">  &#125;, 100);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var id &#x3D; 21;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(&#123; id: 42 &#125;);</span><br><span class=\"line\">&#x2F;&#x2F; id: 42</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>），所以输出的是<code>42</code>。</p>\n<p><code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  return () &#x3D;&gt; &#123;</span><br><span class=\"line\">    return () &#x3D;&gt; &#123;</span><br><span class=\"line\">      return () &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(&#39;id:&#39;, this.id);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var f &#x3D; foo.call(&#123;id: 1&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var t1 &#x3D; f.call(&#123;id: 2&#125;)()(); &#x2F;&#x2F; id: 1</span><br><span class=\"line\">var t2 &#x3D; f().call(&#123;id: 3&#125;)(); &#x2F;&#x2F; id: 1</span><br><span class=\"line\">var t3 &#x3D; f()().call(&#123;id: 4&#125;); &#x2F;&#x2F; id: 1</span><br></pre></td></tr></table></figure>\n\n<p>上面代码之中，只有一个<code>this</code>，就是函数<code>foo</code>的<code>this</code>，所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。</p>\n<p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>\n<p>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  return [</span><br><span class=\"line\">    (() &#x3D;&gt; this.x).bind(&#123; x: &#39;inner&#39; &#125;)()</span><br><span class=\"line\">  ];</span><br><span class=\"line\">&#125;).call(&#123; x: &#39;outer&#39; &#125;);</span><br><span class=\"line\">&#x2F;&#x2F; [&#39;outer&#39;]</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>\n<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>\n<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li>\n</ol>\n<h1 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a>Promise对象</h1><h2 id=\"基本用法-3\"><a href=\"#基本用法-3\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...some code</span><br><span class=\"line\">  </span><br><span class=\"line\">  if(&#x2F;*异步操作成功*&#x2F;)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Class的基本用法\"><a href=\"#Class的基本用法\" class=\"headerlink\" title=\"Class的基本用法\"></a>Class的基本用法</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>JS语言中，生成实例对象的传统方法是构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Point(x, y)&#123;</span><br><span class=\"line\">  this.x &#x3D; x;</span><br><span class=\"line\">  this.y &#x3D; y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString &#x3D; function ()&#123;</span><br><span class=\"line\">  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p &#x3D; new Point(1, 2);</span><br></pre></td></tr></table></figure>\n\n<p>ES6提供了更接近传统语言的写法，引入了<strong>Class（类）</strong>这个概念，作为对象的模版。通过Class关键字，可以定义类。</p>\n<p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 定义类</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor(x, y)&#123;</span><br><span class=\"line\">    this.x &#x3D; x;</span><br><span class=\"line\">    this.y &#x3D; y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  toString()&#123;</span><br><span class=\"line\">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>上面定义类一个“类”，里面有一个constructor方法，这就是构造方法，而<code>this</code>关键字则代表实例对象，也就是说，ES5点构造函数Point，对应ES6的Point类的构造方法。</p>\n</li>\n<li><p>Point类除了构造方法，还定义了一个toString方法。定义“类”方法的时候，前面不需要家<code>function</code>关键字。</p>\n</li>\n<li><p>方法之间不需要逗号间隔，加了会报错。</p>\n</li>\n<li><p>ES6的类，完全可以看成是构造函数的另一种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof Point &#x2F;&#x2F; &quot;function&quot;</span><br><span class=\"line\">Point &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>\n</li>\n<li><p>使用的时候，也是直接对类使用new命令，跟构造函数的用法一致。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Bar &#123;</span><br><span class=\"line\">  doStuff()&#123;</span><br><span class=\"line\">    console.log(&#39;stuff&#39;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b &#x3D; new Bar();</span><br><span class=\"line\">b.doStuff(); &#x2F;&#x2F; &quot;stuff&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toValue() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype &#x3D; &#123;</span><br><span class=\"line\">  constructor() &#123;&#125;,</span><br><span class=\"line\">  toString() &#123;&#125;,</span><br><span class=\"line\">  toValue() &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class B &#123;&#125;</span><br><span class=\"line\">let b &#x3D; new B();</span><br><span class=\"line\"></span><br><span class=\"line\">b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor</code>方法就是<code>B</code>类原型的<code>constructor</code>方法。</p>\n</li>\n<li><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor()&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(Point.prototype, &#123;</span><br><span class=\"line\">  toString()&#123;&#125;,</span><br><span class=\"line\">  toValue()&#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li><p><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.prototype.constructor &#x3D;&#x3D;&#x3D; Point &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li>\n<li><p>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor(x, y) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.keys(Point.prototype)</span><br><span class=\"line\">&#x2F;&#x2F; []</span><br><span class=\"line\">Object.getOwnPropertyNames(Point.prototype)</span><br><span class=\"line\">&#x2F;&#x2F; [&quot;constructor&quot;,&quot;toString&quot;]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>toString</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</p>\n</li>\n<li><p>类的属性名，可以采用表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let methodName &#x3D; &#39;getArea&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Square &#123;</span><br><span class=\"line\">  constructor(length) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [methodName]() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。</p>\n<h2 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h2><ul>\n<li><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。</p>\n</li>\n<li><p>一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    return Object.create(null);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Foo() instanceof Foo</span><br><span class=\"line\">&#x2F;&#x2F; false</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p>\n</li>\n<li><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>\n</li>\n</ul>\n<h2 id=\"类的实例\"><a href=\"#类的实例\" class=\"headerlink\" title=\"类的实例\"></a>类的实例</h2><ul>\n<li><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;定义类</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(x, y) &#123;</span><br><span class=\"line\">    this.x &#x3D; x;</span><br><span class=\"line\">    this.y &#x3D; y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var point &#x3D; new Point(2, 3);</span><br><span class=\"line\"></span><br><span class=\"line\">point.toString() &#x2F;&#x2F; (2, 3)</span><br><span class=\"line\"></span><br><span class=\"line\">point.hasOwnProperty(&#39;x&#39;) &#x2F;&#x2F; true</span><br><span class=\"line\">point.hasOwnProperty(&#39;y&#39;) &#x2F;&#x2F; true</span><br><span class=\"line\">point.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; false</span><br><span class=\"line\">point.__proto__.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致。</p>\n</li>\n<li><p>与 ES5 一样，类的所有实例共享一个原型对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 &#x3D; new Point(2,3);</span><br><span class=\"line\">var p2 &#x3D; new Point(3,2);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.__proto__ &#x3D;&#x3D;&#x3D; p2.__proto__</span><br><span class=\"line\">&#x2F;&#x2F;true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p>\n<p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p>\n<blockquote>\n<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 &#x3D; new Point(2,3);</span><br><span class=\"line\">var p2 &#x3D; new Point(3,2);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.__proto__.printName &#x3D; function () &#123; return &#39;Oops&#39; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">p1.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class=\"line\">p2.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var p3 &#x3D; new Point(4,2);</span><br><span class=\"line\">p3.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码在<code>p1</code>的原型上添加了一个<code>printName</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>\n</li>\n</ul>\n<h2 id=\"Class表达式\"><a href=\"#Class表达式\" class=\"headerlink\" title=\"Class表达式\"></a>Class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyClass &#x3D; class Me &#123;</span><br><span class=\"line\">  getClassName() &#123;</span><br><span class=\"line\">    return Me.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>MyClass</code>而不是<code>Me</code>，<code>Me</code>只在 Class 的内部代码可用，指代当前类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let inst &#x3D; new MyClass();</span><br><span class=\"line\">inst.getClassName() &#x2F;&#x2F; Me</span><br><span class=\"line\">Me.name &#x2F;&#x2F; ReferenceError: Me is not defined</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示，<code>Me</code>只在 Class 内部有定义。</p>\n<p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyClass &#x3D; class &#123; &#x2F;* ... *&#x2F; &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"不存在变量提升-1\"><a href=\"#不存在变量提升-1\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h2><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Foo(); &#x2F;&#x2F; ReferenceError</span><br><span class=\"line\">class Foo &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上“use strict”。</p>\n<h2 id=\"export命令\"><a href=\"#export命令\" class=\"headerlink\" title=\"export命令\"></a>export命令</h2><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。</p>\n<h3 id=\"export输出变量\"><a href=\"#export输出变量\" class=\"headerlink\" title=\"export输出变量\"></a>export输出变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var firstName &#x3D; &#39;Michael&#39;;</span><br><span class=\"line\">export var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class=\"line\">export var year &#x3D; 1958;</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var firstName &#x3D; &#39;Michael&#39;;</span><br><span class=\"line\">var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class=\"line\">var year &#x3D; 1958;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>优先使用第二种写法。</p>\n<h3 id=\"export输出函数、类\"><a href=\"#export输出函数、类\" class=\"headerlink\" title=\"export输出函数、类\"></a>export输出函数、类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function multiply(x, y) &#123;</span><br><span class=\"line\">  return x * y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function v1() &#123; ... &#125;</span><br><span class=\"line\">function v2() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;</span><br><span class=\"line\">  v1 as streamV1,</span><br><span class=\"line\">  v2 as streamV2,</span><br><span class=\"line\">  v2 as streamLatestVersion</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面使用了<code>as</code>关键字重命名了函数v1，v2的对外接口。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>这样写是错的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">export 1;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">var m &#x3D; 1;</span><br><span class=\"line\">export m;</span><br></pre></td></tr></table></figure>\n\n<p>这样写才正确：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 写法一</span><br><span class=\"line\">export var m &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 写法二</span><br><span class=\"line\">var m &#x3D; 1;</span><br><span class=\"line\">export &#123;m&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 写法三</span><br><span class=\"line\">var n &#x3D; 1;</span><br><span class=\"line\">export &#123;n as m&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>函数和类也一样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">export f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 正确</span><br><span class=\"line\">export function f() &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 正确</span><br><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">export &#123;f&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"import命令\"><a href=\"#import命令\" class=\"headerlink\" title=\"import命令\"></a>import命令</h2><p>使用了<code>export</code>命令定义了模块对外的接口以后，其他js文件就可以通过<code>import</code>命令加载这个模块。</p>\n<h3 id=\"import输入变量\"><a href=\"#import输入变量\" class=\"headerlink\" title=\"import输入变量\"></a>import输入变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;firstName, lastName, year&#125; from &#39;.&#x2F;profile&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">function setName(element) &#123;</span><br><span class=\"line\">  element.textContent &#x3D; firstName + &#39; &#39; + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; lastName as surname &#125; from &#39;.&#x2F;profile&#39;;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">import &#123; &#39;f&#39; + &#39;oo&#39; &#125; from &#39;my_module&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">let module &#x3D; &#39;my_module&#39;;</span><br><span class=\"line\">import &#123; foo &#125; from module;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">if (x &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class=\"line\">  import &#123; foo &#125; from &#39;module1&#39;;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  import &#123; foo &#125; from &#39;module2&#39;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#39;lodash&#39;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>\n<h2 id=\"模块的整体加载\"><a href=\"#模块的整体加载\" class=\"headerlink\" title=\"模块的整体加载\"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p>\n<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; circle.js</span><br><span class=\"line\"></span><br><span class=\"line\">export function area(radius) &#123;</span><br><span class=\"line\">  return Math.PI * radius * radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function circumference(radius) &#123;</span><br><span class=\"line\">  return 2 * Math.PI * radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>现在，加载这个模块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; main.js</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; area, circumference &#125; from &#39;.&#x2F;circle&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;圆面积：&#39; + area(4));</span><br><span class=\"line\">console.log(&#39;圆周长：&#39; + circumference(14));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as circle from &#39;.&#x2F;circle&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;圆面积：&#39; + circle.area(4));</span><br><span class=\"line\">console.log(&#39;圆周长：&#39; + circle.circumference(14));</span><br></pre></td></tr></table></figure>\n\n<p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as circle from &#39;.&#x2F;circle&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 下面两行都是不允许的</span><br><span class=\"line\">circle.foo &#x3D; &#39;hello&#39;;</span><br><span class=\"line\">circle.area &#x3D; function () &#123;&#125;;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"let、const\"><a href=\"#let、const\" class=\"headerlink\" title=\"let、const\"></a>let、const</h1><h2 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h2><h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>ES6新增let命令，用来声明变量。用法类似var，但是所声明变量，只在let命令所在的代码块内有效。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  let a &#x3D; 10;</span><br><span class=\"line\">  var b &#x3D; 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a &#x2F;&#x2F; ReferenceError: a is not defined.</span><br><span class=\"line\">b &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>\n\n<p>for循环的计数器，就很适合用let命令。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let i &#x3D; 0; i &lt; 10; i++)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i);</span><br><span class=\"line\">&#x2F;&#x2F; ReferenceError: i is not defined</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不存在变量提升\"><a href=\"#不存在变量提升\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h3><p>var命令会发生“变量提升”现象。let命令没有，let声明的变量一定要在声明后使用，否则会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; var 的情况</span><br><span class=\"line\">console.log(foo); &#x2F;&#x2F; 输出undefined</span><br><span class=\"line\">var foo &#x3D; 2;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; let 的情况</span><br><span class=\"line\">console.log(bar); &#x2F;&#x2F; 报错ReferenceError</span><br><span class=\"line\">let bar &#x3D; 2;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"暂时性死区\"><a href=\"#暂时性死区\" class=\"headerlink\" title=\"暂时性死区\"></a>暂时性死区</h3><p>ES6规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>\n<p>在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>\n<p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (true) &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; TDZ开始</span><br><span class=\"line\">  tmp &#x3D; &#39;abc&#39;; &#x2F;&#x2F; ReferenceError</span><br><span class=\"line\">  console.log(tmp); &#x2F;&#x2F; ReferenceError</span><br><span class=\"line\"></span><br><span class=\"line\">  let tmp; &#x2F;&#x2F; TDZ结束</span><br><span class=\"line\">  console.log(tmp); &#x2F;&#x2F; undefined</span><br><span class=\"line\"></span><br><span class=\"line\">  tmp &#x3D; 123;</span><br><span class=\"line\">  console.log(tmp); &#x2F;&#x2F; 123</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不允许重复声明\"><a href=\"#不允许重复声明\" class=\"headerlink\" title=\"不允许重复声明\"></a>不允许重复声明</h3><p>let命令不允许在相同作用域内，重复声明同一个变量。</p>\n<h2 id=\"块级作用域\"><a href=\"#块级作用域\" class=\"headerlink\" title=\"块级作用域\"></a>块级作用域</h2><p>let实际上为JS新增了块级作用域。</p>\n<p>ES6允许块级作用域的任意嵌套。</p>\n<p>外层作用域无法读取内层作用域的变量。</p>\n<p>内层作用域可以定义外层作用域的同名变量。</p>\n<p>块级作用域的出现，使得立即执行函数表达式不再必要。</p>\n<ul>\n<li>ES5中，函数只能声明在顶层作用域或函数作用域中。</li>\n<li>ES6中，明确允许在块级作用域中声明函数。</li>\n</ul>\n<h2 id=\"do表达式\"><a href=\"#do表达式\" class=\"headerlink\" title=\"do表达式\"></a>do表达式</h2><p>本质上，块级作用域是一个语句，没有返回值。</p>\n<p>现在有一个提案，使得块级作用域可以变为表达式，也就是说有返回值。办法就是在块级作用域前面加上do，变成do表达式，<strong>返回内部最后执行的表达式的值。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x &#x3D; do &#123;</span><br><span class=\"line\">  let t &#x3D; f();</span><br><span class=\"line\">  t * t + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h2><p>const声明一个只读常量，一旦声明，常量的值就不能改变。</p>\n<p>const一旦声明了变量，就立刻初始化，不能留到以后赋值；如果只声明不赋值，会报错。</p>\n<p>const命令和let命令一样，只在声明所在的块级作用域内有效。</p>\n<p>const声明的常量也不提示，同样存在暂时性死区，只能在声明的位置后面使用。</p>\n<p>const命令和和let命令一样，不能重复声明。</p>\n<h3 id=\"const本质：\"><a href=\"#const本质：\" class=\"headerlink\" title=\"const本质：\"></a>const本质：</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const foo &#x3D; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 为 foo 添加一个属性，可以成功</span><br><span class=\"line\">foo.prop &#x3D; 123;</span><br><span class=\"line\">foo.prop &#x2F;&#x2F; 123</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将 foo 指向另一个对象，就会报错</span><br><span class=\"line\">foo &#x3D; &#123;&#125;; &#x2F;&#x2F; TypeError: &quot;foo&quot; is read-only</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，常量<code>foo</code>储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>\n<h2 id=\"ES6声明变量的6中方法\"><a href=\"#ES6声明变量的6中方法\" class=\"headerlink\" title=\"ES6声明变量的6中方法\"></a>ES6声明变量的6中方法</h2><p>除了ES5的两种var和function，还有let、const、import、class。</p>\n<h2 id=\"顶层对象的属性\"><a href=\"#顶层对象的属性\" class=\"headerlink\" title=\"顶层对象的属性\"></a>顶层对象的属性</h2><p>ES6规定，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</p>\n<h1 id=\"变量的解构赋值\"><a href=\"#变量的解构赋值\" class=\"headerlink\" title=\"变量的解构赋值\"></a>变量的解构赋值</h1><h2 id=\"数组的解构赋值\"><a href=\"#数组的解构赋值\" class=\"headerlink\" title=\"数组的解构赋值\"></a>数组的解构赋值</h2><h3 id=\"基本用法-1\"><a href=\"#基本用法-1\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [a,b,c] &#x3D; [1,2,3];</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">let a &#x3D; 1;</span><br><span class=\"line\">let b &#x3D; 2;</span><br><span class=\"line\">let c &#x3D; 3;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo, [[bar], baz]] &#x3D; [1, [[2], 3]];</span><br><span class=\"line\">foo &#x2F;&#x2F; 1</span><br><span class=\"line\">bar &#x2F;&#x2F; 2</span><br><span class=\"line\">baz &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">let [ , , third] &#x3D; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class=\"line\">third &#x2F;&#x2F; &quot;baz&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, , y] &#x3D; [1, 2, 3];</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\">y &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">let [head, ...tail] &#x3D; [1, 2, 3, 4];</span><br><span class=\"line\">head &#x2F;&#x2F; 1</span><br><span class=\"line\">tail &#x2F;&#x2F; [2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, y, ...z] &#x3D; [&#39;a&#39;];</span><br><span class=\"line\">x &#x2F;&#x2F; &quot;a&quot;</span><br><span class=\"line\">y &#x2F;&#x2F; undefined</span><br><span class=\"line\">z &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x, y] &#x3D; [1, 2, 3];</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\">y &#x2F;&#x2F; 2</span><br><span class=\"line\"></span><br><span class=\"line\">let [a, [b], d] &#x3D; [1, [2, 3], 4];</span><br><span class=\"line\">a &#x2F;&#x2F; 1</span><br><span class=\"line\">b &#x2F;&#x2F; 2</span><br><span class=\"line\">d &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>\n\n<p>如果等号右边不是数组，会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">let [foo] &#x3D; 1;</span><br><span class=\"line\">let [foo] &#x3D; false;</span><br><span class=\"line\">let [foo] &#x3D; NaN;</span><br><span class=\"line\">let [foo] &#x3D; undefined;</span><br><span class=\"line\">let [foo] &#x3D; null;</span><br><span class=\"line\">let [foo] &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认值：\"><a href=\"#默认值：\" class=\"headerlink\" title=\"默认值：\"></a>默认值：</h3><ul>\n<li><p>解构赋值允许指定默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [foo &#x3D; true] &#x3D; [];</span><br><span class=\"line\">foo &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br><span class=\"line\">let [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;</span><br><span class=\"line\">let [x, y &#x3D; &#39;b&#39;] &#x3D; [&#39;a&#39;, undefined]; &#x2F;&#x2F; x&#x3D;&#39;a&#39;, y&#x3D;&#39;b&#39;</span><br></pre></td></tr></table></figure>\n\n<p>​    注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，如果一个数组成员不严格等于<code>undefined</code>，默认值是不会生效的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x &#x3D; 1] &#x3D; [undefined];</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\"></span><br><span class=\"line\">let [x &#x3D; 1] &#x3D; [null];</span><br><span class=\"line\">x &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure></li>\n<li><p>默认值可以是一个表达式，但这个表达式是惰性求值的，只有在用到的时候，才会被求值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f()&#123;</span><br><span class=\"line\">  console.log(&#39;aaa&#39;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let [x &#x3D; f()] &#x3D; [1];</span><br></pre></td></tr></table></figure>\n\n<p>​上面代码中，因为x能取到值，所以函数f根本不会执行。</p>\n</li>\n<li><p>默认值可以引用解构赋值的其他变量，但是该变量必须已经声明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let [x &#x3D; 1, y &#x3D; x] &#x3D; [];     &#x2F;&#x2F; x&#x3D;1; y&#x3D;1</span><br><span class=\"line\">let [x &#x3D; 1, y &#x3D; x] &#x3D; [2];    &#x2F;&#x2F; x&#x3D;2; y&#x3D;2</span><br><span class=\"line\">let [x &#x3D; 1, y &#x3D; x] &#x3D; [1, 2]; &#x2F;&#x2F; x&#x3D;1; y&#x3D;2</span><br><span class=\"line\">let [x &#x3D; y, y &#x3D; 1] &#x3D; [];     &#x2F;&#x2F; ReferenceError</span><br></pre></td></tr></table></figure>\n\n<p>​最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。</p>\n</li>\n</ul>\n<h2 id=\"对象的解构赋值\"><a href=\"#对象的解构赋值\" class=\"headerlink\" title=\"对象的解构赋值\"></a>对象的解构赋值</h2><h3 id=\"基本用法-2\"><a href=\"#基本用法-2\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; bar, foo &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class=\"line\">foo &#x2F;&#x2F; &quot;aaa&quot;</span><br><span class=\"line\">bar &#x2F;&#x2F; &quot;bbb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; baz &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class=\"line\">baz &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>\n\n<p>如果变量名与属性名不一致，必须写成下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; foo: baz &#125; &#x3D; &#123; foo: &#39;aaa&#39;, bar: &#39;bbb&#39; &#125;;</span><br><span class=\"line\">baz &#x2F;&#x2F; &quot;aaa&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">let obj &#x3D; &#123; first: &#39;hello&#39;, last: &#39;world&#39; &#125;;</span><br><span class=\"line\">let &#123; first: f, last: l &#125; &#x3D; obj;</span><br><span class=\"line\">f &#x2F;&#x2F; &#39;hello&#39;</span><br><span class=\"line\">l &#x2F;&#x2F; &#39;world&#39;</span><br></pre></td></tr></table></figure>\n\n<p>这实际上说明，对象的解构赋值是下面形式的简写。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; foo: foo, bar: bar&#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; foo: baz &#125; &#x3D; &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class=\"line\">baz &#x2F;&#x2F; &quot;aaa&quot;</span><br><span class=\"line\">foo &#x2F;&#x2F; error: foo is not defined</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>foo</code>是匹配的模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>。</p>\n<p>嵌套：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">  p: [</span><br><span class=\"line\">    &#39;Hello&#39;,</span><br><span class=\"line\">    &#123; y: &#39;World&#39; &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; p: [x, &#123; y &#125;] &#125; &#x3D; obj;</span><br><span class=\"line\">x &#x2F;&#x2F; &quot;Hello&quot;</span><br><span class=\"line\">y &#x2F;&#x2F; &quot;World&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">  p: [</span><br><span class=\"line\">    &#39;Hello&#39;,</span><br><span class=\"line\">    &#123; y: &#39;World&#39; &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; p, p: [x, &#123; y &#125;] &#125; &#x3D; obj;</span><br><span class=\"line\">x &#x2F;&#x2F; &quot;Hello&quot;</span><br><span class=\"line\">y &#x2F;&#x2F; &quot;World&quot;</span><br><span class=\"line\">p &#x2F;&#x2F; [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const node &#x3D; &#123;</span><br><span class=\"line\">  loc: &#123;</span><br><span class=\"line\">    start: &#123;</span><br><span class=\"line\">      line: 1,</span><br><span class=\"line\">      column: 5</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; &#x3D; node;</span><br><span class=\"line\">line &#x2F;&#x2F; 1</span><br><span class=\"line\">loc  &#x2F;&#x2F; Object &#123;start: Object&#125;</span><br><span class=\"line\">start &#x2F;&#x2F; Object &#123;line: 1, column: 5&#125;</span><br></pre></td></tr></table></figure>\n\n<p>嵌套赋值的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;&#125;;</span><br><span class=\"line\">let arr &#x3D; [];</span><br><span class=\"line\"></span><br><span class=\"line\">(&#123; foo: obj.prop, bar: arr[0] &#125; &#x3D; &#123; foo: 123, bar: true &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">obj &#x2F;&#x2F; &#123;prop:123&#125;</span><br><span class=\"line\">arr &#x2F;&#x2F; [true]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var &#123;x &#x3D; 3&#125; &#x3D; &#123;&#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123;x, y &#x3D; 5&#125; &#x3D; &#123;x: 1&#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\">y &#x2F;&#x2F; 5</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123;x: y &#x3D; 3&#125; &#x3D; &#123;&#125;;</span><br><span class=\"line\">y &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123;x: y &#x3D; 3&#125; &#x3D; &#123;x: 5&#125;;</span><br><span class=\"line\">y &#x2F;&#x2F; 5</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123; message: msg &#x3D; &#39;Something went wrong&#39; &#125; &#x3D; &#123;&#125;;</span><br><span class=\"line\">msg &#x2F;&#x2F; &quot;Something went wrong&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>默认值生效的条件是，对象的属性值严格等于undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var &#123; x &#x3D; 3 &#125; &#x3D; &#123; x: undefined &#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; 3</span><br><span class=\"line\"></span><br><span class=\"line\">var &#123; x &#x3D; 3 &#125; &#x3D; &#123; x: null &#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>\n\n<p>如果解构失败，变量的值等于undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;foo&#125; &#x3D; &#123;bar: &#39;baz&#39;&#125;;</span><br><span class=\"line\">foo &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure></li>\n<li><p>如果解构模式是嵌套的对象，而且自对象所在的赋属性不存在，那么将会报错。</p>\n</li>\n<li><p>如果一个已经声明的变量用于解构赋值，必须非常小心</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 错误的写法</span><br><span class=\"line\">let x;</span><br><span class=\"line\">&#123;x&#125; &#x3D; &#123;x: 1&#125;;</span><br><span class=\"line\">&#x2F;&#x2F; SyntaxError: syntax error</span><br></pre></td></tr></table></figure>\n\n<p>上面代码会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生于法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 正确的写法</span><br><span class=\"line\">let x;</span><br><span class=\"line\">(&#123;x&#125; &#x3D; &#123;x: 1&#125;);</span><br></pre></td></tr></table></figure></li>\n<li><p>对象的解构赋值，可以很方便地将现有对象的方法，复制到某个变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123; log, sin, cos &#125; &#x3D; Math;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上。</p>\n</li>\n</ul>\n<h2 id=\"函数参数的解构赋值\"><a href=\"#函数参数的解构赋值\" class=\"headerlink\" title=\"函数参数的解构赋值\"></a>函数参数的解构赋值</h2><p>函数参数也可以使用解构赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add ([x, y])&#123;</span><br><span class=\"line\">  return x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add([1,2]); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。</p>\n<p>函数参数的解构也可以使用默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function move (&#123;x &#x3D; 0, y &#x3D; 0&#125; &#x3D; [])&#123;</span><br><span class=\"line\">  return [x ,y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">move(&#123;x: 3, y: 8&#125;); &#x2F;&#x2F; [3,8]</span><br><span class=\"line\">move(&#123;x: 3&#125;); &#x2F;&#x2F; [3,0]</span><br><span class=\"line\">move(&#123;&#125;); &#x2F;&#x2F; [0,0]</span><br><span class=\"line\">move(); &#x2F;&#x2F; [0,0]</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"函数的扩展\"><a href=\"#函数的扩展\" class=\"headerlink\" title=\"函数的扩展\"></a>函数的扩展</h1><h2 id=\"函数参数的默认值\"><a href=\"#函数参数的默认值\" class=\"headerlink\" title=\"函数参数的默认值\"></a>函数参数的默认值</h2><p>ES6之前，不能直接为函数的参数指定默认值。</p>\n<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(x, y &#x3D; &#39;World&#39;) &#123;</span><br><span class=\"line\">  console.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">log(&#39;Hello&#39;) &#x2F;&#x2F; Hello World</span><br><span class=\"line\">log(&#39;Hello&#39;, &#39;China&#39;) &#x2F;&#x2F; Hello China</span><br><span class=\"line\">log(&#39;Hello&#39;, &#39;&#39;) &#x2F;&#x2F; Hello</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>参数变量是默认声明的，所以在函数体内不能用let或const再次声明，否则会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(x &#x3D; 2)&#123;</span><br><span class=\"line\">  let x &#x3D; 1; &#x2F;&#x2F; error</span><br><span class=\"line\">  const x &#x3D; 3; &#x2F;&#x2F; error</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>使用参数默认值时，函数不能有同名参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 不报错</span><br><span class=\"line\">function (x,x,y)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F;...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">function (x,x,y &#x3D; 1)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F;...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>参数默认值不是传值，而是每次调用函数，都重新计算默认值表达式的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x &#x3D; 99;</span><br><span class=\"line\">function( p &#x3D; x + 1)&#123;</span><br><span class=\"line\">  onsole.log(p);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo() &#x2F;&#x2F; 100</span><br><span class=\"line\"></span><br><span class=\"line\">x &#x3D; 100;</span><br><span class=\"line\">foo() &#x2F;&#x2F; 101</span><br></pre></td></tr></table></figure></li>\n<li><p>参数默认值可以和解构赋值的默认值，结合起来使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo (&#123;x, y &#x3D; 5&#125;)&#123;</span><br><span class=\"line\">  console.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(&#123;&#125;) &#x2F;&#x2F; undefined 5</span><br><span class=\"line\">foo(&#123;x: 1&#125;) &#x2F;&#x2F; 1 5</span><br><span class=\"line\">foo(&#123;x: 1, y: 2&#125;) &#x2F;&#x2F; 1 2</span><br><span class=\"line\">foo() &#x2F;&#x2F; TypeError: Cannot read property &#39;x&#39; of undefined</span><br></pre></td></tr></table></figure>\n\n<p>上面代码只是用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(&#123;x, y &#x3D; 5&#125; &#x3D; &#123;&#125;) &#123;</span><br><span class=\"line\">  console.log(x, y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo() &#x2F;&#x2F; undefined 5</span><br></pre></td></tr></table></figure></li>\n<li><p>参数默认值的位置：</p>\n<p>定义了默认值的参数，应该是函数的尾参数。如果非尾部的参数设置默认值，这个参数没发省略，除非显示输入undefined。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(x &#x3D; 1, y)&#123;</span><br><span class=\"line\">  return [x, y];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; [1, undefined]</span><br><span class=\"line\">f(2) &#x2F;&#x2F; [2, undefined]</span><br><span class=\"line\">f(, 1) &#x2F;&#x2F; 报错</span><br><span class=\"line\">f(undefined, 1) &#x2F;&#x2F; [1,1]</span><br></pre></td></tr></table></figure></li>\n<li><p>参数作用域：</p>\n<p>一旦设置的参数的默认值，函数进行声明初始化时，参数会单独形成一个作用域，等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值的时候，是不会出现的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">function f(x, y &#x3D; x)&#123;</span><br><span class=\"line\">  console.log(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(2) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let x &#x3D; 1;</span><br><span class=\"line\">function f(x &#x3D; y)&#123;</span><br><span class=\"line\">  let x &#x3D; 2;</span><br><span class=\"line\">  console.log(y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"rest参数\"><a href=\"#rest参数\" class=\"headerlink\" title=\"rest参数\"></a>rest参数</h2><p>ES6引入rest参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>\n<p>下面是一个rest参数代替arguments变量的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; arguments变量的写法</span><br><span class=\"line\">function sortNumbers()&#123;</span><br><span class=\"line\">  return Array.prototype.slice.call(arguments).sort();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; rest写法</span><br><span class=\"line\">const sortNumbers &#x3D; (...numbers) &#x3D;&gt; numbers.sort();</span><br></pre></td></tr></table></figure>\n\n<p>arguments对象不是数组，而是类似数组的对象，所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转换为数组。rest参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。</p>\n<ul>\n<li><p>rest参数之后不能有其他参数，否则报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">function f(a, ...b, c)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><p>ES6允许使用“箭头”（=&gt;）定义函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; v &#x3D;&gt; v;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\"></span><br><span class=\"line\">var f &#x3D; function (v)&#123;</span><br><span class=\"line\">  return v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>如果箭头函数不需要参数或者需要多个参数，就使用一个圆括号代表参数部分。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f &#x3D; () &#x3D;&gt; 5;</span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">var f &#x3D; function ()&#123;</span><br><span class=\"line\">  return 5;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var sum &#x3D; (num1, num2) &#x3D;&gt; num1 + num2;</span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">var sum &#x3D; function(num1, num2)&#123;</span><br><span class=\"line\">  return num1+ num2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>如果箭头函数的代码块部分多余一条语句，就要用大括号括起来，并且使用return返回</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var sum &#x3D; (num1, num2) &#x3D;&gt; &#123; return num1 + num2; &#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>由于大括号被解释为代码块，所以箭头函数如果返回一个对象，必须在对象外面加上括号，否则会报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">let getTempItem &#x3D; id &#x3D;&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 不报错</span><br><span class=\"line\">let getTempItem &#x3D; id &#x3D;&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);</span><br></pre></td></tr></table></figure></li>\n<li><p>箭头函数的一个作用是简化回调函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 正常函数写法</span><br><span class=\"line\">[1,2,3].map(function (x) &#123;</span><br><span class=\"line\">  return x * x;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 箭头函数写法</span><br><span class=\"line\">[1,2,3].map(x &#x3D;&gt; x * x);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h3><ol>\n<li>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;id:&#39;, this.id);</span><br><span class=\"line\">  &#125;, 100);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var id &#x3D; 21;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.call(&#123; id: 42 &#125;);</span><br><span class=\"line\">&#x2F;&#x2F; id: 42</span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>），所以输出的是<code>42</code>。</p>\n<p><code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  return () &#x3D;&gt; &#123;</span><br><span class=\"line\">    return () &#x3D;&gt; &#123;</span><br><span class=\"line\">      return () &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(&#39;id:&#39;, this.id);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var f &#x3D; foo.call(&#123;id: 1&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var t1 &#x3D; f.call(&#123;id: 2&#125;)()(); &#x2F;&#x2F; id: 1</span><br><span class=\"line\">var t2 &#x3D; f().call(&#123;id: 3&#125;)(); &#x2F;&#x2F; id: 1</span><br><span class=\"line\">var t3 &#x3D; f()().call(&#123;id: 4&#125;); &#x2F;&#x2F; id: 1</span><br></pre></td></tr></table></figure>\n\n<p>上面代码之中，只有一个<code>this</code>，就是函数<code>foo</code>的<code>this</code>，所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。</p>\n<p>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</p>\n<p>另外，由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function() &#123;</span><br><span class=\"line\">  return [</span><br><span class=\"line\">    (() &#x3D;&gt; this.x).bind(&#123; x: &#39;inner&#39; &#125;)()</span><br><span class=\"line\">  ];</span><br><span class=\"line\">&#125;).call(&#123; x: &#39;outer&#39; &#125;);</span><br><span class=\"line\">&#x2F;&#x2F; [&#39;outer&#39;]</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</li>\n<li>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li>\n<li>不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</li>\n</ol>\n<h1 id=\"Promise对象\"><a href=\"#Promise对象\" class=\"headerlink\" title=\"Promise对象\"></a>Promise对象</h1><h2 id=\"基本用法-3\"><a href=\"#基本用法-3\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h2><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...some code</span><br><span class=\"line\">  </span><br><span class=\"line\">  if(&#x2F;*异步操作成功*&#x2F;)&#123;</span><br><span class=\"line\">    resolve(value);</span><br><span class=\"line\">  &#125;else&#123;</span><br><span class=\"line\">    reject(error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Class的基本用法\"><a href=\"#Class的基本用法\" class=\"headerlink\" title=\"Class的基本用法\"></a>Class的基本用法</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>JS语言中，生成实例对象的传统方法是构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Point(x, y)&#123;</span><br><span class=\"line\">  this.x &#x3D; x;</span><br><span class=\"line\">  this.y &#x3D; y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype.toString &#x3D; function ()&#123;</span><br><span class=\"line\">  return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p &#x3D; new Point(1, 2);</span><br></pre></td></tr></table></figure>\n\n<p>ES6提供了更接近传统语言的写法，引入了<strong>Class（类）</strong>这个概念，作为对象的模版。通过Class关键字，可以定义类。</p>\n<p>基本上，ES6 的<code>class</code>可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的<code>class</code>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的<code>class</code>改写，就是下面这样。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 定义类</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor(x, y)&#123;</span><br><span class=\"line\">    this.x &#x3D; x;</span><br><span class=\"line\">    this.y &#x3D; y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  toString()&#123;</span><br><span class=\"line\">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>上面定义类一个“类”，里面有一个constructor方法，这就是构造方法，而<code>this</code>关键字则代表实例对象，也就是说，ES5点构造函数Point，对应ES6的Point类的构造方法。</p>\n</li>\n<li><p>Point类除了构造方法，还定义了一个toString方法。定义“类”方法的时候，前面不需要家<code>function</code>关键字。</p>\n</li>\n<li><p>方法之间不需要逗号间隔，加了会报错。</p>\n</li>\n<li><p>ES6的类，完全可以看成是构造函数的另一种写法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof Point &#x2F;&#x2F; &quot;function&quot;</span><br><span class=\"line\">Point &#x3D;&#x3D;&#x3D; Point.prototype.constructor &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>\n\n<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>\n</li>\n<li><p>使用的时候，也是直接对类使用new命令，跟构造函数的用法一致。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Bar &#123;</span><br><span class=\"line\">  doStuff()&#123;</span><br><span class=\"line\">    console.log(&#39;stuff&#39;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b &#x3D; new Bar();</span><br><span class=\"line\">b.doStuff(); &#x2F;&#x2F; &quot;stuff&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toValue() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\"></span><br><span class=\"line\">Point.prototype &#x3D; &#123;</span><br><span class=\"line\">  constructor() &#123;&#125;,</span><br><span class=\"line\">  toString() &#123;&#125;,</span><br><span class=\"line\">  toValue() &#123;&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class B &#123;&#125;</span><br><span class=\"line\">let b &#x3D; new B();</span><br><span class=\"line\"></span><br><span class=\"line\">b.constructor &#x3D;&#x3D;&#x3D; B.prototype.constructor &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor</code>方法就是<code>B</code>类原型的<code>constructor</code>方法。</p>\n</li>\n<li><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor()&#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(Point.prototype, &#123;</span><br><span class=\"line\">  toString()&#123;&#125;,</span><br><span class=\"line\">  toValue()&#123;&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></li>\n<li><p><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point.prototype.constructor &#x3D;&#x3D;&#x3D; Point &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li>\n<li><p>类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor(x, y) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.keys(Point.prototype)</span><br><span class=\"line\">&#x2F;&#x2F; []</span><br><span class=\"line\">Object.getOwnPropertyNames(Point.prototype)</span><br><span class=\"line\">&#x2F;&#x2F; [&quot;constructor&quot;,&quot;toString&quot;]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>toString</code>方法是<code>Point</code>类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。</p>\n</li>\n<li><p>类的属性名，可以采用表达式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let methodName &#x3D; &#39;getArea&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Square &#123;</span><br><span class=\"line\">  constructor(length) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [methodName]() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h2><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。</p>\n<h2 id=\"constructor方法\"><a href=\"#constructor方法\" class=\"headerlink\" title=\"constructor方法\"></a>constructor方法</h2><ul>\n<li><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法。</p>\n</li>\n<li><p>一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">  constructor() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>constructor</code>方法默认返回实例对象（即<code>this</code>），完全可以指定返回另外一个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    return Object.create(null);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">new Foo() instanceof Foo</span><br><span class=\"line\">&#x2F;&#x2F; false</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p>\n</li>\n<li><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>\n</li>\n</ul>\n<h2 id=\"类的实例\"><a href=\"#类的实例\" class=\"headerlink\" title=\"类的实例\"></a>类的实例</h2><ul>\n<li><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;定义类</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(x, y) &#123;</span><br><span class=\"line\">    this.x &#x3D; x;</span><br><span class=\"line\">    this.y &#x3D; y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var point &#x3D; new Point(2, 3);</span><br><span class=\"line\"></span><br><span class=\"line\">point.toString() &#x2F;&#x2F; (2, 3)</span><br><span class=\"line\"></span><br><span class=\"line\">point.hasOwnProperty(&#39;x&#39;) &#x2F;&#x2F; true</span><br><span class=\"line\">point.hasOwnProperty(&#39;y&#39;) &#x2F;&#x2F; true</span><br><span class=\"line\">point.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; false</span><br><span class=\"line\">point.__proto__.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code>自身的属性（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与 ES5 的行为保持一致。</p>\n</li>\n<li><p>与 ES5 一样，类的所有实例共享一个原型对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 &#x3D; new Point(2,3);</span><br><span class=\"line\">var p2 &#x3D; new Point(3,2);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.__proto__ &#x3D;&#x3D;&#x3D; p2.__proto__</span><br><span class=\"line\">&#x2F;&#x2F;true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>p1</code>和<code>p2</code>都是<code>Point</code>的实例，它们的原型都是<code>Point.prototype</code>，所以<code>__proto__</code>属性是相等的。</p>\n<p>这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p>\n<blockquote>\n<p><code>__proto__</code> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 &#x3D; new Point(2,3);</span><br><span class=\"line\">var p2 &#x3D; new Point(3,2);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.__proto__.printName &#x3D; function () &#123; return &#39;Oops&#39; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">p1.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class=\"line\">p2.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var p3 &#x3D; new Point(4,2);</span><br><span class=\"line\">p3.printName() &#x2F;&#x2F; &quot;Oops&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码在<code>p1</code>的原型上添加了一个<code>printName</code>方法，由于<code>p1</code>的原型就是<code>p2</code>的原型，因此<code>p2</code>也可以调用这个方法。而且，此后新建的实例<code>p3</code>也可以调用这个方法。这意味着，使用实例的<code>__proto__</code>属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。</p>\n</li>\n</ul>\n<h2 id=\"Class表达式\"><a href=\"#Class表达式\" class=\"headerlink\" title=\"Class表达式\"></a>Class表达式</h2><p>与函数一样，类也可以使用表达式的形式定义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyClass &#x3D; class Me &#123;</span><br><span class=\"line\">  getClassName() &#123;</span><br><span class=\"line\">    return Me.name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是<code>MyClass</code>而不是<code>Me</code>，<code>Me</code>只在 Class 的内部代码可用，指代当前类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let inst &#x3D; new MyClass();</span><br><span class=\"line\">inst.getClassName() &#x2F;&#x2F; Me</span><br><span class=\"line\">Me.name &#x2F;&#x2F; ReferenceError: Me is not defined</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码表示，<code>Me</code>只在 Class 内部有定义。</p>\n<p>如果类的内部没用到的话，可以省略<code>Me</code>，也就是可以写成下面的形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const MyClass &#x3D; class &#123; &#x2F;* ... *&#x2F; &#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"不存在变量提升-1\"><a href=\"#不存在变量提升-1\" class=\"headerlink\" title=\"不存在变量提升\"></a>不存在变量提升</h2><p>类不存在变量提升（hoist），这一点与 ES5 完全不同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Foo(); &#x2F;&#x2F; ReferenceError</span><br><span class=\"line\">class Foo &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h1><p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上“use strict”。</p>\n<h2 id=\"export命令\"><a href=\"#export命令\" class=\"headerlink\" title=\"export命令\"></a>export命令</h2><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。</p>\n<h3 id=\"export输出变量\"><a href=\"#export输出变量\" class=\"headerlink\" title=\"export输出变量\"></a>export输出变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var firstName &#x3D; &#39;Michael&#39;;</span><br><span class=\"line\">export var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class=\"line\">export var year &#x3D; 1958;</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var firstName &#x3D; &#39;Michael&#39;;</span><br><span class=\"line\">var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class=\"line\">var year &#x3D; 1958;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>优先使用第二种写法。</p>\n<h3 id=\"export输出函数、类\"><a href=\"#export输出函数、类\" class=\"headerlink\" title=\"export输出函数、类\"></a>export输出函数、类</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function multiply(x, y) &#123;</span><br><span class=\"line\">  return x * y;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>或者</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function v1() &#123; ... &#125;</span><br><span class=\"line\">function v2() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;</span><br><span class=\"line\">  v1 as streamV1,</span><br><span class=\"line\">  v2 as streamV2,</span><br><span class=\"line\">  v2 as streamLatestVersion</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面使用了<code>as</code>关键字重命名了函数v1，v2的对外接口。</p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>这样写是错的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">export 1;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">var m &#x3D; 1;</span><br><span class=\"line\">export m;</span><br></pre></td></tr></table></figure>\n\n<p>这样写才正确：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 写法一</span><br><span class=\"line\">export var m &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 写法二</span><br><span class=\"line\">var m &#x3D; 1;</span><br><span class=\"line\">export &#123;m&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 写法三</span><br><span class=\"line\">var n &#x3D; 1;</span><br><span class=\"line\">export &#123;n as m&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>函数和类也一样</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">export f;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 正确</span><br><span class=\"line\">export function f() &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 正确</span><br><span class=\"line\">function f() &#123;&#125;</span><br><span class=\"line\">export &#123;f&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"import命令\"><a href=\"#import命令\" class=\"headerlink\" title=\"import命令\"></a>import命令</h2><p>使用了<code>export</code>命令定义了模块对外的接口以后，其他js文件就可以通过<code>import</code>命令加载这个模块。</p>\n<h3 id=\"import输入变量\"><a href=\"#import输入变量\" class=\"headerlink\" title=\"import输入变量\"></a>import输入变量</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;firstName, lastName, year&#125; from &#39;.&#x2F;profile&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">function setName(element) &#123;</span><br><span class=\"line\">  element.textContent &#x3D; firstName + &#39; &#39; + lastName;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果想为输入的变量重新取一个名字，<code>import</code>命令要使用<code>as</code>关键字，将输入的变量重命名。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; lastName as surname &#125; from &#39;.&#x2F;profile&#39;;</span><br></pre></td></tr></table></figure>\n\n<p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">import &#123; &#39;f&#39; + &#39;oo&#39; &#125; from &#39;my_module&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">let module &#x3D; &#39;my_module&#39;;</span><br><span class=\"line\">import &#123; foo &#125; from module;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 报错</span><br><span class=\"line\">if (x &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class=\"line\">  import &#123; foo &#125; from &#39;module1&#39;;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  import &#123; foo &#125; from &#39;module2&#39;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#39;lodash&#39;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p>\n<h2 id=\"模块的整体加载\"><a href=\"#模块的整体加载\" class=\"headerlink\" title=\"模块的整体加载\"></a>模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p>\n<p>下面是一个<code>circle.js</code>文件，它输出两个方法<code>area</code>和<code>circumference</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; circle.js</span><br><span class=\"line\"></span><br><span class=\"line\">export function area(radius) &#123;</span><br><span class=\"line\">  return Math.PI * radius * radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export function circumference(radius) &#123;</span><br><span class=\"line\">  return 2 * Math.PI * radius;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>现在，加载这个模块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; main.js</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123; area, circumference &#125; from &#39;.&#x2F;circle&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;圆面积：&#39; + area(4));</span><br><span class=\"line\">console.log(&#39;圆周长：&#39; + circumference(14));</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上面写法是逐一指定要加载的方法，整体加载的写法如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as circle from &#39;.&#x2F;circle&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;圆面积：&#39; + circle.area(4));</span><br><span class=\"line\">console.log(&#39;圆周长：&#39; + circle.circumference(14));</span><br></pre></td></tr></table></figure>\n\n<p>注意，模块整体加载所在的那个对象（上例是<code>circle</code>），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as circle from &#39;.&#x2F;circle&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 下面两行都是不允许的</span><br><span class=\"line\">circle.foo &#x3D; &#39;hello&#39;;</span><br><span class=\"line\">circle.area &#x3D; function () &#123;&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"Git学习笔记","date":"2017-10-03T14:46:03.000Z","description":"Git学习笔记","_content":"\n> [廖雪峰的Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n>\n> [Git操作详解——阮一峰](http://www.ruanyifeng.com/blog/2014/06/git_remote.html)\n>\n> [Git权威指南](http://www.worldhello.net/gotgit/)\n\n### 安装Git\n\ngit --version\n查看git版本\n\ngit config\n配置git\n\n### 新建本地版本库\n\n版本库（repository）、仓库一个意思，不同说法\n\n可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n+ 方法一\n\n  新建一个文件夹learngit，进入文件夹，使用`git init`命令初始化（新建）一个版本库\n\n  ```\n  $ cd learngit\n  $ git init\n  ```\n\n+ 方法二\n\n  直接使用`git init <name>`命令，git自动新建一个名为<name>的文件夹同时初始化\n\n  ```\n  $ git init learngit\n  ```\n\n### 添加修改到版本库\n\n工作区进行工作（修改，新建，删除）-git add-工作区修改添加到暂存区(stage)-git commit-暂存区提交修改\n\n![](https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0)\n\ngit add\n添加新建文件、修改到暂存区\n\ngit commit -m \"***\"\n提交暂存区的修改\n\ngit log\n查看提交日志\n\ngit status\n查看工作区状态 git status -s -b， -s显示精简输出，-b显示当前工作分支名称\n\ngit branch\n查看当前工作分支名称\n\n### 版本回退\n\n版本库中HEAD指针移动到指定的那个版本，同时用该版本更新工作区\n\n+ 方法一\n\n  `$ git reset --hard commit_id`\n\n  commit_id是每个版本的版本号，版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n\n  `$ git log`可以查看提交日志，有每次提交的commit_id（版本号）\n\n  `$ git log --pretty=oneline`简介输出提交日志\n\n  `$ git reflog`显示整个本地仓储的commit, 包括所有branch的commit, 甚至包括已经撤销的commit, 只要HEAD发生了变化, 就会在reflog里面看得到. git log只包括当前分支的commit.\n\n+ 方法二\n\n  `$ git reset —hard HEAD^`\n\n  HEAD是版本库中指向当前版本的指针，HEAD 表示当前版本， HEAD^ 表示上一个版本，HEAD^^ 表示上上个版本\n\n可以用`git diff`命令检测工作区、暂存区、版本库是否同步\n\n`$ git diff` 比较工作区和暂存区\n\n`$ git diff --cached` 比较暂存区和版本库\n\n`$ git diff HEAD` 比较工作区和版本库\n\n### 撤销修改\n\n`git checkout`这个命令有多个用途，撤销修改，切换分支\n\n#### 撤销工作区修改\n\n+ 方法一：手动恢复工作区文件的修改\n\n+ 方法二：`$ git checkout -- file`\n\n  撤销工作区修改，如果暂存区里有add，就和暂存区的版本一致，如果没有，就和版本库中最近一次commit版本一致\n\ngit checkout -- file 中 -- 用来区分 分支／文件名 ，-- 的名称叫做double dash，是bash的内置命令，用来标记可选命令选项的结束。即在它后面的带 -- 的字符串，不被当做是一个命令选项。\n\n**例如**\n\n有个文件的名字就叫master，和master分支名字一摸一样，那么 git checkout master就是切换到master分支，如果想撤销master文件中的修改，git checkout -- master 就不会把master当作分支名。所以只要文件名不和分支名或其他命令关键字重复，git checkout file也是撤销，不会变成切换分支\n\n#### 撤销暂存区修改\n\ngit reset HEAD file 撤销暂存区的add，工作区的修改没变，只是状态变为未暂存：Changes not staged for commit\n\n### 删除文件\n\n删除文件也是一种修改\n\n版本库中也需要删除该文件 并提交\n\n```\n$ git rm file\n$ git commit -m \"...\"\n```\n\n### 远程仓库\n\n项目托管到github\n\n#### 注册GitHub账户\n\n#### 生成sshkey\n\n​\tssh-keygen -t rsa -C \"GitHub账户邮箱\"\n\n​\t一直回车\n​\t成功生成ssh\n\n#### 添加sshKey到GitHub账户\n\n​\t登陆GitHub，settings，SSH and GPG Keys, New SSh Keys,将本地生成的ssh文件夹下的公钥（id_rsa.pub）中的内容复制，点击add ssh key 添加成功\n\n​\t为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n\n​\t**多台电脑ssh key添加到一个GitHub账户**\n\n​\t当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n\n​\t***我有一台电脑，注册了2个GitHub账户，一个工作，一个博客，如何操作？***\n\n#### 建立GitHub远程仓库\n\n​\t上述步骤只是注册了GitHub账户，并且添加了你电脑上的ssh key，保证你的电脑和你的GitHub能够相互通信，但GitHub仓库!=GitHub账户，GitHub远程仓库还需要建立，点击猫咪回到首页，start a project 或者 new repository都可创建一个新的github远程仓库\n\n​\t点击后，输入一个仓库名称，点击“Create repository”按钮，就成功地创建了一个新的Git仓库\n\n#### git remote\n\n​\t为了便于管理，Git要求每个远程主机都必须指定一个主机名。`git remote`命令就用于管理主机名。\n\n​\t不带选项的时候，`git remote`命令列出所有远程主机。\n\n> ```\n> $ git remote\n> origin\n> ```\n\n​\t使用  `-v`选项，可以参看远程主机的网址。\n\n> ```\n> $ git remote -v\n> origin  git@github.com:jquery/jquery.git (fetch)\n> origin  git@github.com:jquery/jquery.git (push)\n> ```\n\n​\t上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。\n\n​\t克隆版本库的时候，所使用的远程主机自动被Git命名为`origin`。如果想用其他的主机名，需要用`git clone`命令的`-o`选项指定。\n\n> ```\n> $ git clone -o jQuery https://github.com/jquery/jquery.git\n> $ git remote\n> jQuery\n>\n> ```\n\n​\t上面命令表示，克隆的时候，指定远程主机叫做jQuery。\n\n​\t`git remote show`命令加上主机名，可以查看该主机的详细信息。\n\n> ```\n> $ git remote show <主机名>\n>\n> ```\n\n​\t`git remote add`命令用于添加远程主机。\n\n> ```\n> $ git remote add <主机名> <网址>\n>\n> ```\n\n​\t`git remote rm`命令用于删除远程主机。\n\n> ```\n> $ git remote rm <主机名>\n>\n> ```\n\n​\t`git remote rename`命令用于远程主机的改名。\n\n> ```\n> $ git remote rename <原主机名> <新主机名>\n> ```\n\n​\t**GitHub仓库不添加本地ssh key，仍然可以关联，但无法push或clone**\n\n#### git clone\n\n​\t远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到`git clone`命令。\n\n> ```\n> $ git clone <版本库的网址>\n> ```\n\n​\t比如，克隆jQuery的版本库。\n\n> ```\n> $ git clone https://github.com/jquery/jquery.git\n>\n> ```\n\n​\t该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为`git clone`命令的第二个参数。\n\n> ```\n> $ git clone <版本库的网址> <本地目录名>\n>\n> ```\n\n​\t`git clone`支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。\n\n> ```\n> $ git clone http[s]://example.com/path/to/repo.git/\n> $ git clone ssh://example.com/path/to/repo.git/\n> $ git clone git://example.com/path/to/repo.git/\n> $ git clone /opt/git/project.git \n> $ git clone file:///opt/git/project.git\n> $ git clone ftp[s]://example.com/path/to/repo.git/\n> $ git clone rsync://example.com/path/to/repo.git/\n> ```\n\n​\tSSH协议还有另一种写法。\n\n> ```\n> $ git clone [user@]example.com:path/to/repo.git/\n>\n> ```\n\n​\t通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考[官方文档](http://git-scm.com/book/en/Git-on-the-Server-The-Protocols)。\n\n#### git fetch\n\n​\t一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到`git fetch`命令。\n\n> ```\n> $ git fetch <远程主机名>\n>\n> ```\n\n​\t上面命令将某个远程主机的更新，全部取回本地。\n\n​\t`git fetch`命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。\n\n​\t默认情况下，`git fetch`取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。\n\n> ```\n> $ git fetch <远程主机名> <分支名>\n>\n> ```\n\n​\t比如，取回`origin`主机的`master`分支。\n\n> ```\n> $ git fetch origin master\n>\n> ```\n\n​\t所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如`origin`主机的`master`，就要用`origin/master`读取。\n\n​\t\t`git branch`命令的`-r`选项，可以用来查看远程分支，`-a`选项查看所有分支。\n\n> ```\n> $ git branch -r\n> origin/master\n>\n> $ git branch -a\n> * master\n>   remotes/origin/master\n>\n> ```\n\n​\t上面命令表示，本地主机的当前分支是`master`，远程分支是`origin/master`。\n\n​\t取回远程主机的更新以后，可以在它的基础上，使用`git checkout`命令创建一个新的分支。\n\n> ```\n> $ git checkout -b newBrach origin/master\n>\n> ```\n\n​\t上面命令表示，在`origin/master`的基础上，创建一个新分支。\n\n​\t此外，也可以使用`git merge`命令或者`git rebase`命令，在本地分支上合并远程分支。\n\n> ```\n> $ git merge origin/master\n> # 或者\n> $ git rebase origin/master\n>\n> ```\n\n​\t上面命令表示在当前分支上，合并`origin/master`。\n\n#### git pull\n\n​\t`git pull`命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。\n\n> ```\n> $ git pull <远程主机名> <远程分支名>:<本地分支名>\n> ```\n\n​\t比如，取回`origin`主机的`next`分支，与本地的`master`分支合并，需要写成下面这样。\n\n> ```\n> $ git pull origin next:master\n> ```\n\n​\t如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\n\n> ```\n> $ git pull origin next\n>\n> ```\n\n​\t上面命令表示，取回`origin/next`分支，再与当前分支合并。实质上，这等同于先做`git fetch`，再做`git merge`。\n\n> ```\n> $ git fetch origin\n> $ git merge origin/next\n>\n> ```\n\n​\t在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在`git clone`的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的`master`分支自动\"追踪\"`origin/master`分支。\n\nGit也允许手动建立追踪关系。\n\n> ```\n> git branch --set-upstream master origin/next\n>\n> ```\n\n​\t上面命令指定`master`分支追踪`origin/next`分支。\n\n​\t如果当前分支与远程分支存在追踪关系，`git pull`就可以省略远程分支名。\n\n> ```\n> $ git pull origin\n>\n> ```\n\n​\t上面命令表示，本地的当前分支自动与对应的`origin`主机\"追踪分支\"（remote-tracking branch）进行合并。\n\n​\t如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n\n> ```\n> $ git pull\n>\n> ```\n\n​\t上面命令表示，当前分支自动与唯一一个追踪分支进行合并。\n\n​\t如果合并需要采用rebase模式，可以使用`--rebase`选项。\n\n> ```\n> $ git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n>\n> ```\n\n​\t如果远程主机删除了某个分支，默认情况下，`git pull` 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致`git pull`不知不觉删除了本地分支。\n\n​\t但是，你可以改变这个行为，加上参数 `-p` 就会在本地删除远程已经删除的分支。\n\n> ```\n> $ git pull -p\n> # 等同于下面的命令\n> $ git fetch --prune origin \n> $ git fetch -p\n> ```\n\n#### git push\n\n​\t`git push`命令用于将本地分支的更新，推送到远程主机。它的格式与`git pull`命令相仿。\n\n> ```\n> $ git push <远程主机名> <本地分支名>:<远程分支名>\n> ```\n\n​\t注意，分支推送顺序的写法是<来源地>:<目的地>，所以`git pull`是<远程分支>:<本地分支>，而`git push`是<本地分支>:<远程分支>。\n\n​\t如果省略远程分支名，则表示将本地分支推送与之存在\"追踪关系\"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。\n\n> ```\n> $ git push origin master\n> ```\n\n​\t上面命令表示，将本地的`master`分支推送到`origin`主机的`master`分支。如果后者不存在，则会被新建。\n\n​\t如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\n\n> ```\n> $ git push origin :master\n> # 等同于\n> $ git push origin --delete master\n> ```\n\n​\t上面命令表示删除`origin`主机的`master`分支。\n\n​\t如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n\n> ```\n> $ git push origin\n> ```\n\n​\t上面命令表示，将当前分支推送到`origin`主机的对应分支。\n\n​\t如果当前分支只有一个追踪分支，那么主机名都可以省略。\n\n> ```\n> $ git push\n> ```\n\n​\t如果当前分支与多个主机存在追踪关系，则可以使用`-u`选项指定一个默认主机，这样后面就可以不加任何参数使用`git push`。\n\n> ```\n> $ git push -u origin master\n> ```\n\n​\t上面命令将本地的`master`分支推送到`origin`主机，同时指定`origin`为默认主机，后面就可以不加任何参数使用`git push`了。\n\n​\t不带任何参数的`git push`，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用`git config`命令。\n\n> ```\n> $ git config --global push.default matching\n> # 或者\n> $ git config --global push.default simple\n> ```\n\n​\t还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用`--all`选项。\n\n> ```\n> $ git push --all origin\n> ```\n\n​\t上面命令表示，将所有本地分支都推送到`origin`主机。\n\n​\t如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做`git pull`合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用`--force`选项。\n\n> ```\n> $ git push --force origin \n> ```\n\n​\t上面命令使用`--force`选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用`--force`选项。\n\n​\t最后，`git push`不会推送标签（tag），除非使用`--tags`选项。\n\n> ```\n> $ git push origin --tags\n> ```\n\n### 分支管理\n\n**创建分支**\ngit branch <分支名>\ngit checkout -b <分支名>\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n$ git branch <分支名>\n$ git checkout <分支名>\n\n**查看分支**\ngit branch\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n\n**合并分支**\ngit merge <分支名>\ngit merge命令用于合并<分支名>分支到当前分支。\ngit merge 默认使用“Fast-forward\"快速合并模式，当两个分支分别有新的提交时，快速合并会产生冲突，需要手动修改冲突\n\n**删除分支**\ngit branch -d <分支名>\n\n\n\n# issues\n\n2018.1.23\n\ndesc：昨天想把做完的股票管理应用放到github上。\n\n新建了一个github仓库，写了readme。so，现在这个远程仓库除了readme什么也没有。\n\nwebstorm打开股票应用，now，本地的仓库和远程的仓库是两个素不相识的路人。现在使用`git remote`查看远程仓库没有任何反应，应为还没有给远程仓库指定主机名，本地仓库还不知道有远程仓库这么个人。\n\n\n\n先给新建的git仓库起个名字：\n\n```\ngit remote add stock git@github.com:Yu-Sen/StockManageApp.git\n```\n\n现在本地仓库终于知道这个名叫stock的git仓库了，使用`git remote -v`可以看出端倪：\n\n```\nEthandeMBP:webpackDemo ethan$ git remote -v\ntest    git@github.com:Yu-Sen/test.git (fetch)\ntest    git@github.com:Yu-Sen/test.git (push)\n```\n\n（本地仓库已经add，commit过了）现在我可以把本地仓库的内容push到git仓库上了吧：\n\n```\ngit push\n```\n\nAh ho，报错了：\n\n```\nEthandeMBP:webpackDemo ethan$ git push\nfatal: No configured push destination.\nEither specify the URL from the command-line or configure a remote repository using\n\n    git remote add <name> <url>\n\nand then push using the remote name\n\n    git push <name>\n```\n\n报错原因：本地仓库的master分支和远程仓库的master分支还没有建立追踪关系，git push的完整写法是`git push 主机名 本地分支:远程分支`，只有当本地分支和远程分支存在追踪关系的时候才可以省略参数\n\n`git push 主机名 本地分支`：省略远程分支名，当指定的本地分支有追踪的远程分支时（两个分支通常同名），如果远程分支不存在，则会自动新建\n\n`git push 主机名`：省略本地分支名和远程分支名，当当前所在的本地分支有追踪的远程分支时\n\n`git push`：省略主机名、本地分支、远程分支，当前所在本地分支有且只有一个追踪的远程分支时\n\n```\nEthandeMBP:webpackDemo ethan$ git push test\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream test master\n```\n\n再次使用`git push test`命令，push失败，提示当前分支master没有关联分支，使用`—set-upstream`来设置关联分支：\n\n```\nEthandeMBP:webpackDemo ethan$ git push --set-upstream test master\nTo github.com:Yu-Sen/test.git\n ! [rejected]        master -> master (fetch first)\nerror: failed to push some refs to 'git@github.com:Yu-Sen/test.git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n又报错了？好吧，错误说远程仓库中含有本地仓库没有的文件，所以push被拒绝，在push前需要先pull一下，如果看到关于fast-forwards的提示，在`git push —help`中查看具体说明：\n\n```\nEthandeMBP:webpackDemo ethan$ git pull\nfatal: No remote repository specified.  Please, specify either a URL or a\nremote name from which new revisions should be fetched.\n```\n\n直接使用git pull报错，原因是当前本地分支没有追踪任何远程分支，只有当前本地分支追踪了远程分支时，才可以省略\n\n好吧，这次写全一点：\n\n```\nEthandeMBP:webpackDemo ethan$ git pull test master\nFrom github.com:Yu-Sen/test\n * branch            master     -> FETCH_HEAD\nfatal: refusing to merge unrelated histories\n```\n\nfatal，致命错误！无法合并，why？因为在较新版本的git中，如果要pull合并两个不同的项目，需要加一句`—allow-unrelated-histories`。\n\n","source":"_posts/Git学习笔记.md","raw":"---\ntitle: Git学习笔记\ndate: 2017-10-03 22:46:03\ntags:\n- git\ncategories:\n- 学习笔记\ndescription: Git学习笔记\t\n---\n\n> [廖雪峰的Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n>\n> [Git操作详解——阮一峰](http://www.ruanyifeng.com/blog/2014/06/git_remote.html)\n>\n> [Git权威指南](http://www.worldhello.net/gotgit/)\n\n### 安装Git\n\ngit --version\n查看git版本\n\ngit config\n配置git\n\n### 新建本地版本库\n\n版本库（repository）、仓库一个意思，不同说法\n\n可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\n\n+ 方法一\n\n  新建一个文件夹learngit，进入文件夹，使用`git init`命令初始化（新建）一个版本库\n\n  ```\n  $ cd learngit\n  $ git init\n  ```\n\n+ 方法二\n\n  直接使用`git init <name>`命令，git自动新建一个名为<name>的文件夹同时初始化\n\n  ```\n  $ git init learngit\n  ```\n\n### 添加修改到版本库\n\n工作区进行工作（修改，新建，删除）-git add-工作区修改添加到暂存区(stage)-git commit-暂存区提交修改\n\n![](https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0)\n\ngit add\n添加新建文件、修改到暂存区\n\ngit commit -m \"***\"\n提交暂存区的修改\n\ngit log\n查看提交日志\n\ngit status\n查看工作区状态 git status -s -b， -s显示精简输出，-b显示当前工作分支名称\n\ngit branch\n查看当前工作分支名称\n\n### 版本回退\n\n版本库中HEAD指针移动到指定的那个版本，同时用该版本更新工作区\n\n+ 方法一\n\n  `$ git reset --hard commit_id`\n\n  commit_id是每个版本的版本号，版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\n\n  `$ git log`可以查看提交日志，有每次提交的commit_id（版本号）\n\n  `$ git log --pretty=oneline`简介输出提交日志\n\n  `$ git reflog`显示整个本地仓储的commit, 包括所有branch的commit, 甚至包括已经撤销的commit, 只要HEAD发生了变化, 就会在reflog里面看得到. git log只包括当前分支的commit.\n\n+ 方法二\n\n  `$ git reset —hard HEAD^`\n\n  HEAD是版本库中指向当前版本的指针，HEAD 表示当前版本， HEAD^ 表示上一个版本，HEAD^^ 表示上上个版本\n\n可以用`git diff`命令检测工作区、暂存区、版本库是否同步\n\n`$ git diff` 比较工作区和暂存区\n\n`$ git diff --cached` 比较暂存区和版本库\n\n`$ git diff HEAD` 比较工作区和版本库\n\n### 撤销修改\n\n`git checkout`这个命令有多个用途，撤销修改，切换分支\n\n#### 撤销工作区修改\n\n+ 方法一：手动恢复工作区文件的修改\n\n+ 方法二：`$ git checkout -- file`\n\n  撤销工作区修改，如果暂存区里有add，就和暂存区的版本一致，如果没有，就和版本库中最近一次commit版本一致\n\ngit checkout -- file 中 -- 用来区分 分支／文件名 ，-- 的名称叫做double dash，是bash的内置命令，用来标记可选命令选项的结束。即在它后面的带 -- 的字符串，不被当做是一个命令选项。\n\n**例如**\n\n有个文件的名字就叫master，和master分支名字一摸一样，那么 git checkout master就是切换到master分支，如果想撤销master文件中的修改，git checkout -- master 就不会把master当作分支名。所以只要文件名不和分支名或其他命令关键字重复，git checkout file也是撤销，不会变成切换分支\n\n#### 撤销暂存区修改\n\ngit reset HEAD file 撤销暂存区的add，工作区的修改没变，只是状态变为未暂存：Changes not staged for commit\n\n### 删除文件\n\n删除文件也是一种修改\n\n版本库中也需要删除该文件 并提交\n\n```\n$ git rm file\n$ git commit -m \"...\"\n```\n\n### 远程仓库\n\n项目托管到github\n\n#### 注册GitHub账户\n\n#### 生成sshkey\n\n​\tssh-keygen -t rsa -C \"GitHub账户邮箱\"\n\n​\t一直回车\n​\t成功生成ssh\n\n#### 添加sshKey到GitHub账户\n\n​\t登陆GitHub，settings，SSH and GPG Keys, New SSh Keys,将本地生成的ssh文件夹下的公钥（id_rsa.pub）中的内容复制，点击add ssh key 添加成功\n\n​\t为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。\n\n​\t**多台电脑ssh key添加到一个GitHub账户**\n\n​\t当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。\n\n​\t***我有一台电脑，注册了2个GitHub账户，一个工作，一个博客，如何操作？***\n\n#### 建立GitHub远程仓库\n\n​\t上述步骤只是注册了GitHub账户，并且添加了你电脑上的ssh key，保证你的电脑和你的GitHub能够相互通信，但GitHub仓库!=GitHub账户，GitHub远程仓库还需要建立，点击猫咪回到首页，start a project 或者 new repository都可创建一个新的github远程仓库\n\n​\t点击后，输入一个仓库名称，点击“Create repository”按钮，就成功地创建了一个新的Git仓库\n\n#### git remote\n\n​\t为了便于管理，Git要求每个远程主机都必须指定一个主机名。`git remote`命令就用于管理主机名。\n\n​\t不带选项的时候，`git remote`命令列出所有远程主机。\n\n> ```\n> $ git remote\n> origin\n> ```\n\n​\t使用  `-v`选项，可以参看远程主机的网址。\n\n> ```\n> $ git remote -v\n> origin  git@github.com:jquery/jquery.git (fetch)\n> origin  git@github.com:jquery/jquery.git (push)\n> ```\n\n​\t上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。\n\n​\t克隆版本库的时候，所使用的远程主机自动被Git命名为`origin`。如果想用其他的主机名，需要用`git clone`命令的`-o`选项指定。\n\n> ```\n> $ git clone -o jQuery https://github.com/jquery/jquery.git\n> $ git remote\n> jQuery\n>\n> ```\n\n​\t上面命令表示，克隆的时候，指定远程主机叫做jQuery。\n\n​\t`git remote show`命令加上主机名，可以查看该主机的详细信息。\n\n> ```\n> $ git remote show <主机名>\n>\n> ```\n\n​\t`git remote add`命令用于添加远程主机。\n\n> ```\n> $ git remote add <主机名> <网址>\n>\n> ```\n\n​\t`git remote rm`命令用于删除远程主机。\n\n> ```\n> $ git remote rm <主机名>\n>\n> ```\n\n​\t`git remote rename`命令用于远程主机的改名。\n\n> ```\n> $ git remote rename <原主机名> <新主机名>\n> ```\n\n​\t**GitHub仓库不添加本地ssh key，仍然可以关联，但无法push或clone**\n\n#### git clone\n\n​\t远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到`git clone`命令。\n\n> ```\n> $ git clone <版本库的网址>\n> ```\n\n​\t比如，克隆jQuery的版本库。\n\n> ```\n> $ git clone https://github.com/jquery/jquery.git\n>\n> ```\n\n​\t该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为`git clone`命令的第二个参数。\n\n> ```\n> $ git clone <版本库的网址> <本地目录名>\n>\n> ```\n\n​\t`git clone`支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。\n\n> ```\n> $ git clone http[s]://example.com/path/to/repo.git/\n> $ git clone ssh://example.com/path/to/repo.git/\n> $ git clone git://example.com/path/to/repo.git/\n> $ git clone /opt/git/project.git \n> $ git clone file:///opt/git/project.git\n> $ git clone ftp[s]://example.com/path/to/repo.git/\n> $ git clone rsync://example.com/path/to/repo.git/\n> ```\n\n​\tSSH协议还有另一种写法。\n\n> ```\n> $ git clone [user@]example.com:path/to/repo.git/\n>\n> ```\n\n​\t通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考[官方文档](http://git-scm.com/book/en/Git-on-the-Server-The-Protocols)。\n\n#### git fetch\n\n​\t一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到`git fetch`命令。\n\n> ```\n> $ git fetch <远程主机名>\n>\n> ```\n\n​\t上面命令将某个远程主机的更新，全部取回本地。\n\n​\t`git fetch`命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。\n\n​\t默认情况下，`git fetch`取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。\n\n> ```\n> $ git fetch <远程主机名> <分支名>\n>\n> ```\n\n​\t比如，取回`origin`主机的`master`分支。\n\n> ```\n> $ git fetch origin master\n>\n> ```\n\n​\t所取回的更新，在本地主机上要用\"远程主机名/分支名\"的形式读取。比如`origin`主机的`master`，就要用`origin/master`读取。\n\n​\t\t`git branch`命令的`-r`选项，可以用来查看远程分支，`-a`选项查看所有分支。\n\n> ```\n> $ git branch -r\n> origin/master\n>\n> $ git branch -a\n> * master\n>   remotes/origin/master\n>\n> ```\n\n​\t上面命令表示，本地主机的当前分支是`master`，远程分支是`origin/master`。\n\n​\t取回远程主机的更新以后，可以在它的基础上，使用`git checkout`命令创建一个新的分支。\n\n> ```\n> $ git checkout -b newBrach origin/master\n>\n> ```\n\n​\t上面命令表示，在`origin/master`的基础上，创建一个新分支。\n\n​\t此外，也可以使用`git merge`命令或者`git rebase`命令，在本地分支上合并远程分支。\n\n> ```\n> $ git merge origin/master\n> # 或者\n> $ git rebase origin/master\n>\n> ```\n\n​\t上面命令表示在当前分支上，合并`origin/master`。\n\n#### git pull\n\n​\t`git pull`命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。\n\n> ```\n> $ git pull <远程主机名> <远程分支名>:<本地分支名>\n> ```\n\n​\t比如，取回`origin`主机的`next`分支，与本地的`master`分支合并，需要写成下面这样。\n\n> ```\n> $ git pull origin next:master\n> ```\n\n​\t如果远程分支是与当前分支合并，则冒号后面的部分可以省略。\n\n> ```\n> $ git pull origin next\n>\n> ```\n\n​\t上面命令表示，取回`origin/next`分支，再与当前分支合并。实质上，这等同于先做`git fetch`，再做`git merge`。\n\n> ```\n> $ git fetch origin\n> $ git merge origin/next\n>\n> ```\n\n​\t在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在`git clone`的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的`master`分支自动\"追踪\"`origin/master`分支。\n\nGit也允许手动建立追踪关系。\n\n> ```\n> git branch --set-upstream master origin/next\n>\n> ```\n\n​\t上面命令指定`master`分支追踪`origin/next`分支。\n\n​\t如果当前分支与远程分支存在追踪关系，`git pull`就可以省略远程分支名。\n\n> ```\n> $ git pull origin\n>\n> ```\n\n​\t上面命令表示，本地的当前分支自动与对应的`origin`主机\"追踪分支\"（remote-tracking branch）进行合并。\n\n​\t如果当前分支只有一个追踪分支，连远程主机名都可以省略。\n\n> ```\n> $ git pull\n>\n> ```\n\n​\t上面命令表示，当前分支自动与唯一一个追踪分支进行合并。\n\n​\t如果合并需要采用rebase模式，可以使用`--rebase`选项。\n\n> ```\n> $ git pull --rebase <远程主机名> <远程分支名>:<本地分支名>\n>\n> ```\n\n​\t如果远程主机删除了某个分支，默认情况下，`git pull` 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致`git pull`不知不觉删除了本地分支。\n\n​\t但是，你可以改变这个行为，加上参数 `-p` 就会在本地删除远程已经删除的分支。\n\n> ```\n> $ git pull -p\n> # 等同于下面的命令\n> $ git fetch --prune origin \n> $ git fetch -p\n> ```\n\n#### git push\n\n​\t`git push`命令用于将本地分支的更新，推送到远程主机。它的格式与`git pull`命令相仿。\n\n> ```\n> $ git push <远程主机名> <本地分支名>:<远程分支名>\n> ```\n\n​\t注意，分支推送顺序的写法是<来源地>:<目的地>，所以`git pull`是<远程分支>:<本地分支>，而`git push`是<本地分支>:<远程分支>。\n\n​\t如果省略远程分支名，则表示将本地分支推送与之存在\"追踪关系\"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。\n\n> ```\n> $ git push origin master\n> ```\n\n​\t上面命令表示，将本地的`master`分支推送到`origin`主机的`master`分支。如果后者不存在，则会被新建。\n\n​\t如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。\n\n> ```\n> $ git push origin :master\n> # 等同于\n> $ git push origin --delete master\n> ```\n\n​\t上面命令表示删除`origin`主机的`master`分支。\n\n​\t如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。\n\n> ```\n> $ git push origin\n> ```\n\n​\t上面命令表示，将当前分支推送到`origin`主机的对应分支。\n\n​\t如果当前分支只有一个追踪分支，那么主机名都可以省略。\n\n> ```\n> $ git push\n> ```\n\n​\t如果当前分支与多个主机存在追踪关系，则可以使用`-u`选项指定一个默认主机，这样后面就可以不加任何参数使用`git push`。\n\n> ```\n> $ git push -u origin master\n> ```\n\n​\t上面命令将本地的`master`分支推送到`origin`主机，同时指定`origin`为默认主机，后面就可以不加任何参数使用`git push`了。\n\n​\t不带任何参数的`git push`，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用`git config`命令。\n\n> ```\n> $ git config --global push.default matching\n> # 或者\n> $ git config --global push.default simple\n> ```\n\n​\t还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用`--all`选项。\n\n> ```\n> $ git push --all origin\n> ```\n\n​\t上面命令表示，将所有本地分支都推送到`origin`主机。\n\n​\t如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做`git pull`合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用`--force`选项。\n\n> ```\n> $ git push --force origin \n> ```\n\n​\t上面命令使用`--force`选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用`--force`选项。\n\n​\t最后，`git push`不会推送标签（tag），除非使用`--tags`选项。\n\n> ```\n> $ git push origin --tags\n> ```\n\n### 分支管理\n\n**创建分支**\ngit branch <分支名>\ngit checkout -b <分支名>\ngit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：\n$ git branch <分支名>\n$ git checkout <分支名>\n\n**查看分支**\ngit branch\ngit branch命令会列出所有分支，当前分支前面会标一个*号。\n\n**合并分支**\ngit merge <分支名>\ngit merge命令用于合并<分支名>分支到当前分支。\ngit merge 默认使用“Fast-forward\"快速合并模式，当两个分支分别有新的提交时，快速合并会产生冲突，需要手动修改冲突\n\n**删除分支**\ngit branch -d <分支名>\n\n\n\n# issues\n\n2018.1.23\n\ndesc：昨天想把做完的股票管理应用放到github上。\n\n新建了一个github仓库，写了readme。so，现在这个远程仓库除了readme什么也没有。\n\nwebstorm打开股票应用，now，本地的仓库和远程的仓库是两个素不相识的路人。现在使用`git remote`查看远程仓库没有任何反应，应为还没有给远程仓库指定主机名，本地仓库还不知道有远程仓库这么个人。\n\n\n\n先给新建的git仓库起个名字：\n\n```\ngit remote add stock git@github.com:Yu-Sen/StockManageApp.git\n```\n\n现在本地仓库终于知道这个名叫stock的git仓库了，使用`git remote -v`可以看出端倪：\n\n```\nEthandeMBP:webpackDemo ethan$ git remote -v\ntest    git@github.com:Yu-Sen/test.git (fetch)\ntest    git@github.com:Yu-Sen/test.git (push)\n```\n\n（本地仓库已经add，commit过了）现在我可以把本地仓库的内容push到git仓库上了吧：\n\n```\ngit push\n```\n\nAh ho，报错了：\n\n```\nEthandeMBP:webpackDemo ethan$ git push\nfatal: No configured push destination.\nEither specify the URL from the command-line or configure a remote repository using\n\n    git remote add <name> <url>\n\nand then push using the remote name\n\n    git push <name>\n```\n\n报错原因：本地仓库的master分支和远程仓库的master分支还没有建立追踪关系，git push的完整写法是`git push 主机名 本地分支:远程分支`，只有当本地分支和远程分支存在追踪关系的时候才可以省略参数\n\n`git push 主机名 本地分支`：省略远程分支名，当指定的本地分支有追踪的远程分支时（两个分支通常同名），如果远程分支不存在，则会自动新建\n\n`git push 主机名`：省略本地分支名和远程分支名，当当前所在的本地分支有追踪的远程分支时\n\n`git push`：省略主机名、本地分支、远程分支，当前所在本地分支有且只有一个追踪的远程分支时\n\n```\nEthandeMBP:webpackDemo ethan$ git push test\nfatal: The current branch master has no upstream branch.\nTo push the current branch and set the remote as upstream, use\n\n    git push --set-upstream test master\n```\n\n再次使用`git push test`命令，push失败，提示当前分支master没有关联分支，使用`—set-upstream`来设置关联分支：\n\n```\nEthandeMBP:webpackDemo ethan$ git push --set-upstream test master\nTo github.com:Yu-Sen/test.git\n ! [rejected]        master -> master (fetch first)\nerror: failed to push some refs to 'git@github.com:Yu-Sen/test.git'\nhint: Updates were rejected because the remote contains work that you do\nhint: not have locally. This is usually caused by another repository pushing\nhint: to the same ref. You may want to first integrate the remote changes\nhint: (e.g., 'git pull ...') before pushing again.\nhint: See the 'Note about fast-forwards' in 'git push --help' for details.\n```\n\n又报错了？好吧，错误说远程仓库中含有本地仓库没有的文件，所以push被拒绝，在push前需要先pull一下，如果看到关于fast-forwards的提示，在`git push —help`中查看具体说明：\n\n```\nEthandeMBP:webpackDemo ethan$ git pull\nfatal: No remote repository specified.  Please, specify either a URL or a\nremote name from which new revisions should be fetched.\n```\n\n直接使用git pull报错，原因是当前本地分支没有追踪任何远程分支，只有当前本地分支追踪了远程分支时，才可以省略\n\n好吧，这次写全一点：\n\n```\nEthandeMBP:webpackDemo ethan$ git pull test master\nFrom github.com:Yu-Sen/test\n * branch            master     -> FETCH_HEAD\nfatal: refusing to merge unrelated histories\n```\n\nfatal，致命错误！无法合并，why？因为在较新版本的git中，如果要pull合并两个不同的项目，需要加一句`—allow-unrelated-histories`。\n\n","slug":"Git学习笔记","published":1,"updated":"2021-05-08T14:59:28.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbps0026wct47rgwhdbv","content":"<blockquote>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">廖雪峰的Git教程</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/06/git_remote.html\">Git操作详解——阮一峰</a></p>\n<p><a href=\"http://www.worldhello.net/gotgit/\">Git权威指南</a></p>\n</blockquote>\n<h3 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h3><p>git –version<br>查看git版本</p>\n<p>git config<br>配置git</p>\n<h3 id=\"新建本地版本库\"><a href=\"#新建本地版本库\" class=\"headerlink\" title=\"新建本地版本库\"></a>新建本地版本库</h3><p>版本库（repository）、仓库一个意思，不同说法</p>\n<p>可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>\n<ul>\n<li><p>方法一</p>\n<p>新建一个文件夹learngit，进入文件夹，使用<code>git init</code>命令初始化（新建）一个版本库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd learngit</span><br><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure></li>\n<li><p>方法二</p>\n<p>直接使用<code>git init &lt;name&gt;</code>命令，git自动新建一个名为<name>的文件夹同时初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init learngit</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"添加修改到版本库\"><a href=\"#添加修改到版本库\" class=\"headerlink\" title=\"添加修改到版本库\"></a>添加修改到版本库</h3><p>工作区进行工作（修改，新建，删除）-git add-工作区修改添加到暂存区(stage)-git commit-暂存区提交修改</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0\"></p>\n<p>git add<br>添加新建文件、修改到暂存区</p>\n<p>git commit -m “***”<br>提交暂存区的修改</p>\n<p>git log<br>查看提交日志</p>\n<p>git status<br>查看工作区状态 git status -s -b， -s显示精简输出，-b显示当前工作分支名称</p>\n<p>git branch<br>查看当前工作分支名称</p>\n<h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><p>版本库中HEAD指针移动到指定的那个版本，同时用该版本更新工作区</p>\n<ul>\n<li><p>方法一</p>\n<p><code>$ git reset --hard commit_id</code></p>\n<p>commit_id是每个版本的版本号，版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>\n<p><code>$ git log</code>可以查看提交日志，有每次提交的commit_id（版本号）</p>\n<p><code>$ git log --pretty=oneline</code>简介输出提交日志</p>\n<p><code>$ git reflog</code>显示整个本地仓储的commit, 包括所有branch的commit, 甚至包括已经撤销的commit, 只要HEAD发生了变化, 就会在reflog里面看得到. git log只包括当前分支的commit.</p>\n</li>\n<li><p>方法二</p>\n<p><code>$ git reset —hard HEAD^</code></p>\n<p>HEAD是版本库中指向当前版本的指针，HEAD 表示当前版本， HEAD^ 表示上一个版本，HEAD^^ 表示上上个版本</p>\n</li>\n</ul>\n<p>可以用<code>git diff</code>命令检测工作区、暂存区、版本库是否同步</p>\n<p><code>$ git diff</code> 比较工作区和暂存区</p>\n<p><code>$ git diff --cached</code> 比较暂存区和版本库</p>\n<p><code>$ git diff HEAD</code> 比较工作区和版本库</p>\n<h3 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h3><p><code>git checkout</code>这个命令有多个用途，撤销修改，切换分支</p>\n<h4 id=\"撤销工作区修改\"><a href=\"#撤销工作区修改\" class=\"headerlink\" title=\"撤销工作区修改\"></a>撤销工作区修改</h4><ul>\n<li><p>方法一：手动恢复工作区文件的修改</p>\n</li>\n<li><p>方法二：<code>$ git checkout -- file</code></p>\n<p>撤销工作区修改，如果暂存区里有add，就和暂存区的版本一致，如果没有，就和版本库中最近一次commit版本一致</p>\n</li>\n</ul>\n<p>git checkout – file 中 – 用来区分 分支／文件名 ，– 的名称叫做double dash，是bash的内置命令，用来标记可选命令选项的结束。即在它后面的带 – 的字符串，不被当做是一个命令选项。</p>\n<p><strong>例如</strong></p>\n<p>有个文件的名字就叫master，和master分支名字一摸一样，那么 git checkout master就是切换到master分支，如果想撤销master文件中的修改，git checkout – master 就不会把master当作分支名。所以只要文件名不和分支名或其他命令关键字重复，git checkout file也是撤销，不会变成切换分支</p>\n<h4 id=\"撤销暂存区修改\"><a href=\"#撤销暂存区修改\" class=\"headerlink\" title=\"撤销暂存区修改\"></a>撤销暂存区修改</h4><p>git reset HEAD file 撤销暂存区的add，工作区的修改没变，只是状态变为未暂存：Changes not staged for commit</p>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><p>删除文件也是一种修改</p>\n<p>版本库中也需要删除该文件 并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm file</span><br><span class=\"line\">$ git commit -m &quot;...&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h3><p>项目托管到github</p>\n<h4 id=\"注册GitHub账户\"><a href=\"#注册GitHub账户\" class=\"headerlink\" title=\"注册GitHub账户\"></a>注册GitHub账户</h4><h4 id=\"生成sshkey\"><a href=\"#生成sshkey\" class=\"headerlink\" title=\"生成sshkey\"></a>生成sshkey</h4><p>​    ssh-keygen -t rsa -C “GitHub账户邮箱”</p>\n<p>​    一直回车<br>​    成功生成ssh</p>\n<h4 id=\"添加sshKey到GitHub账户\"><a href=\"#添加sshKey到GitHub账户\" class=\"headerlink\" title=\"添加sshKey到GitHub账户\"></a>添加sshKey到GitHub账户</h4><p>​    登陆GitHub，settings，SSH and GPG Keys, New SSh Keys,将本地生成的ssh文件夹下的公钥（id_rsa.pub）中的内容复制，点击add ssh key 添加成功</p>\n<p>​    为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>\n<p>​    <strong>多台电脑ssh key添加到一个GitHub账户</strong></p>\n<p>​    当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>\n<p>​    <em><strong>我有一台电脑，注册了2个GitHub账户，一个工作，一个博客，如何操作？</strong></em></p>\n<h4 id=\"建立GitHub远程仓库\"><a href=\"#建立GitHub远程仓库\" class=\"headerlink\" title=\"建立GitHub远程仓库\"></a>建立GitHub远程仓库</h4><p>​    上述步骤只是注册了GitHub账户，并且添加了你电脑上的ssh key，保证你的电脑和你的GitHub能够相互通信，但GitHub仓库!=GitHub账户，GitHub远程仓库还需要建立，点击猫咪回到首页，start a project 或者 new repository都可创建一个新的github远程仓库</p>\n<p>​    点击后，输入一个仓库名称，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>\n<h4 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h4><p>​    为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p>\n<p>​    不带选项的时候，<code>git remote</code>命令列出所有远程主机。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote</span><br><span class=\"line\">origin</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    使用  <code>-v</code>选项，可以参看远程主机的网址。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br><span class=\"line\">origin  git@github.com:jquery&#x2F;jquery.git (fetch)</span><br><span class=\"line\">origin  git@github.com:jquery&#x2F;jquery.git (push)</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>\n<p>​    克隆版本库的时候，所使用的远程主机自动被Git命名为<code>origin</code>。如果想用其他的主机名，需要用<code>git clone</code>命令的<code>-o</code>选项指定。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone -o jQuery https:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery.git</span><br><span class=\"line\">$ git remote</span><br><span class=\"line\">jQuery</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p>\n<p>​    <code>git remote show</code>命令加上主机名，可以查看该主机的详细信息。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote show &lt;主机名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <code>git remote add</code>命令用于添加远程主机。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <code>git remote rm</code>命令用于删除远程主机。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote rm &lt;主机名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <code>git remote rename</code>命令用于远程主机的改名。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <strong>GitHub仓库不添加本地ssh key，仍然可以关联，但无法push或clone</strong></p>\n<h4 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h4><p>​    远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    比如，克隆jQuery的版本库。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery.git</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为<code>git clone</code>命令的第二个参数。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone http[s]:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\">$ git clone ssh:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\">$ git clone git:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\">$ git clone &#x2F;opt&#x2F;git&#x2F;project.git </span><br><span class=\"line\">$ git clone file:&#x2F;&#x2F;&#x2F;opt&#x2F;git&#x2F;project.git</span><br><span class=\"line\">$ git clone ftp[s]:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\">$ git clone rsync:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    SSH协议还有另一种写法。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone [user@]example.com:path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考<a href=\"http://git-scm.com/book/en/Git-on-the-Server-The-Protocols\">官方文档</a>。</p>\n<h4 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch\"></a>git fetch</h4><p>​    一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch &lt;远程主机名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令将某个远程主机的更新，全部取回本地。</p>\n<p>​    <code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>\n<p>​    默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    比如，取回<code>origin</code>主机的<code>master</code>分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch origin master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如<code>origin</code>主机的<code>master</code>，就要用<code>origin/master</code>读取。</p>\n<p>​        <code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -r</span><br><span class=\"line\">origin&#x2F;master</span><br><span class=\"line\"></span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes&#x2F;origin&#x2F;master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。</p>\n<p>​    取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b newBrach origin&#x2F;master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，在<code>origin/master</code>的基础上，创建一个新分支。</p>\n<p>​    此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge origin&#x2F;master</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ git rebase origin&#x2F;master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示在当前分支上，合并<code>origin/master</code>。</p>\n<h4 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h4><p>​    <code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin next:master</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin next</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再做<code>git merge</code>。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch origin</span><br><span class=\"line\">$ git merge origin&#x2F;next</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p>\n<p>Git也允许手动建立追踪关系。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream master origin&#x2F;next</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。</p>\n<p>​    如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”（remote-tracking branch）进行合并。</p>\n<p>​    如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>\n<p>​    如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。</p>\n<p>​    但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull -p</span><br><span class=\"line\"># 等同于下面的命令</span><br><span class=\"line\">$ git fetch --prune origin </span><br><span class=\"line\">$ git fetch -p</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h4><p>​    <code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>\n<p>​    如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。</p>\n<p>​    如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin :master</span><br><span class=\"line\"># 等同于</span><br><span class=\"line\">$ git push origin --delete master</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示删除<code>origin</code>主机的<code>master</code>分支。</p>\n<p>​    如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，将当前分支推送到<code>origin</code>主机的对应分支。</p>\n<p>​    如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定<code>origin</code>为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p>\n<p>​    不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用<code>git config</code>命令。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global push.default matching</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ git config --global push.default simple</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<code>--all</code>选项。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push --all origin</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，将所有本地分支都推送到<code>origin</code>主机。</p>\n<p>​    如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>--force</code>选项。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push --force origin </span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令使用<code>--force</code>选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用<code>--force</code>选项。</p>\n<p>​    最后，<code>git push</code>不会推送标签（tag），除非使用<code>--tags</code>选项。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin --tags</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h3><p><strong>创建分支</strong><br>git branch &lt;分支名&gt;<br>git checkout -b &lt;分支名&gt;<br>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：<br>$ git branch &lt;分支名&gt;<br>$ git checkout &lt;分支名&gt;</p>\n<p><strong>查看分支</strong><br>git branch<br>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>\n<p><strong>合并分支</strong><br>git merge &lt;分支名&gt;<br>git merge命令用于合并&lt;分支名&gt;分支到当前分支。<br>git merge 默认使用“Fast-forward”快速合并模式，当两个分支分别有新的提交时，快速合并会产生冲突，需要手动修改冲突</p>\n<p><strong>删除分支</strong><br>git branch -d &lt;分支名&gt;</p>\n<h1 id=\"issues\"><a href=\"#issues\" class=\"headerlink\" title=\"issues\"></a>issues</h1><p>2018.1.23</p>\n<p>desc：昨天想把做完的股票管理应用放到github上。</p>\n<p>新建了一个github仓库，写了readme。so，现在这个远程仓库除了readme什么也没有。</p>\n<p>webstorm打开股票应用，now，本地的仓库和远程的仓库是两个素不相识的路人。现在使用<code>git remote</code>查看远程仓库没有任何反应，应为还没有给远程仓库指定主机名，本地仓库还不知道有远程仓库这么个人。</p>\n<p>先给新建的git仓库起个名字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add stock git@github.com:Yu-Sen&#x2F;StockManageApp.git</span><br></pre></td></tr></table></figure>\n\n<p>现在本地仓库终于知道这个名叫stock的git仓库了，使用<code>git remote -v</code>可以看出端倪：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git remote -v</span><br><span class=\"line\">test    git@github.com:Yu-Sen&#x2F;test.git (fetch)</span><br><span class=\"line\">test    git@github.com:Yu-Sen&#x2F;test.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>（本地仓库已经add，commit过了）现在我可以把本地仓库的内容push到git仓库上了吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>Ah ho，报错了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git push</span><br><span class=\"line\">fatal: No configured push destination.</span><br><span class=\"line\">Either specify the URL from the command-line or configure a remote repository using</span><br><span class=\"line\"></span><br><span class=\"line\">    git remote add &lt;name&gt; &lt;url&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">and then push using the remote name</span><br><span class=\"line\"></span><br><span class=\"line\">    git push &lt;name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>报错原因：本地仓库的master分支和远程仓库的master分支还没有建立追踪关系，git push的完整写法是<code>git push 主机名 本地分支:远程分支</code>，只有当本地分支和远程分支存在追踪关系的时候才可以省略参数</p>\n<p><code>git push 主机名 本地分支</code>：省略远程分支名，当指定的本地分支有追踪的远程分支时（两个分支通常同名），如果远程分支不存在，则会自动新建</p>\n<p><code>git push 主机名</code>：省略本地分支名和远程分支名，当当前所在的本地分支有追踪的远程分支时</p>\n<p><code>git push</code>：省略主机名、本地分支、远程分支，当前所在本地分支有且只有一个追踪的远程分支时</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git push test</span><br><span class=\"line\">fatal: The current branch master has no upstream branch.</span><br><span class=\"line\">To push the current branch and set the remote as upstream, use</span><br><span class=\"line\"></span><br><span class=\"line\">    git push --set-upstream test master</span><br></pre></td></tr></table></figure>\n\n<p>再次使用<code>git push test</code>命令，push失败，提示当前分支master没有关联分支，使用<code>—set-upstream</code>来设置关联分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git push --set-upstream test master</span><br><span class=\"line\">To github.com:Yu-Sen&#x2F;test.git</span><br><span class=\"line\"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class=\"line\">error: failed to push some refs to &#39;git@github.com:Yu-Sen&#x2F;test.git&#39;</span><br><span class=\"line\">hint: Updates were rejected because the remote contains work that you do</span><br><span class=\"line\">hint: not have locally. This is usually caused by another repository pushing</span><br><span class=\"line\">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class=\"line\">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class=\"line\">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure>\n\n<p>又报错了？好吧，错误说远程仓库中含有本地仓库没有的文件，所以push被拒绝，在push前需要先pull一下，如果看到关于fast-forwards的提示，在<code>git push —help</code>中查看具体说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git pull</span><br><span class=\"line\">fatal: No remote repository specified.  Please, specify either a URL or a</span><br><span class=\"line\">remote name from which new revisions should be fetched.</span><br></pre></td></tr></table></figure>\n\n<p>直接使用git pull报错，原因是当前本地分支没有追踪任何远程分支，只有当前本地分支追踪了远程分支时，才可以省略</p>\n<p>好吧，这次写全一点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git pull test master</span><br><span class=\"line\">From github.com:Yu-Sen&#x2F;test</span><br><span class=\"line\"> * branch            master     -&gt; FETCH_HEAD</span><br><span class=\"line\">fatal: refusing to merge unrelated histories</span><br></pre></td></tr></table></figure>\n\n<p>fatal，致命错误！无法合并，why？因为在较新版本的git中，如果要pull合并两个不同的项目，需要加一句<code>—allow-unrelated-histories</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p><a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\">廖雪峰的Git教程</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/06/git_remote.html\">Git操作详解——阮一峰</a></p>\n<p><a href=\"http://www.worldhello.net/gotgit/\">Git权威指南</a></p>\n</blockquote>\n<h3 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h3><p>git –version<br>查看git版本</p>\n<p>git config<br>配置git</p>\n<h3 id=\"新建本地版本库\"><a href=\"#新建本地版本库\" class=\"headerlink\" title=\"新建本地版本库\"></a>新建本地版本库</h3><p>版本库（repository）、仓库一个意思，不同说法</p>\n<p>可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>\n<ul>\n<li><p>方法一</p>\n<p>新建一个文件夹learngit，进入文件夹，使用<code>git init</code>命令初始化（新建）一个版本库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ cd learngit</span><br><span class=\"line\">$ git init</span><br></pre></td></tr></table></figure></li>\n<li><p>方法二</p>\n<p>直接使用<code>git init &lt;name&gt;</code>命令，git自动新建一个名为<name>的文件夹同时初始化</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init learngit</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"添加修改到版本库\"><a href=\"#添加修改到版本库\" class=\"headerlink\" title=\"添加修改到版本库\"></a>添加修改到版本库</h3><p>工作区进行工作（修改，新建，删除）-git add-工作区修改添加到暂存区(stage)-git commit-暂存区提交修改</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/001384907702917346729e9afbf4127b6dfbae9207af016000/0\"></p>\n<p>git add<br>添加新建文件、修改到暂存区</p>\n<p>git commit -m “***”<br>提交暂存区的修改</p>\n<p>git log<br>查看提交日志</p>\n<p>git status<br>查看工作区状态 git status -s -b， -s显示精简输出，-b显示当前工作分支名称</p>\n<p>git branch<br>查看当前工作分支名称</p>\n<h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><p>版本库中HEAD指针移动到指定的那个版本，同时用该版本更新工作区</p>\n<ul>\n<li><p>方法一</p>\n<p><code>$ git reset --hard commit_id</code></p>\n<p>commit_id是每个版本的版本号，版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>\n<p><code>$ git log</code>可以查看提交日志，有每次提交的commit_id（版本号）</p>\n<p><code>$ git log --pretty=oneline</code>简介输出提交日志</p>\n<p><code>$ git reflog</code>显示整个本地仓储的commit, 包括所有branch的commit, 甚至包括已经撤销的commit, 只要HEAD发生了变化, 就会在reflog里面看得到. git log只包括当前分支的commit.</p>\n</li>\n<li><p>方法二</p>\n<p><code>$ git reset —hard HEAD^</code></p>\n<p>HEAD是版本库中指向当前版本的指针，HEAD 表示当前版本， HEAD^ 表示上一个版本，HEAD^^ 表示上上个版本</p>\n</li>\n</ul>\n<p>可以用<code>git diff</code>命令检测工作区、暂存区、版本库是否同步</p>\n<p><code>$ git diff</code> 比较工作区和暂存区</p>\n<p><code>$ git diff --cached</code> 比较暂存区和版本库</p>\n<p><code>$ git diff HEAD</code> 比较工作区和版本库</p>\n<h3 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h3><p><code>git checkout</code>这个命令有多个用途，撤销修改，切换分支</p>\n<h4 id=\"撤销工作区修改\"><a href=\"#撤销工作区修改\" class=\"headerlink\" title=\"撤销工作区修改\"></a>撤销工作区修改</h4><ul>\n<li><p>方法一：手动恢复工作区文件的修改</p>\n</li>\n<li><p>方法二：<code>$ git checkout -- file</code></p>\n<p>撤销工作区修改，如果暂存区里有add，就和暂存区的版本一致，如果没有，就和版本库中最近一次commit版本一致</p>\n</li>\n</ul>\n<p>git checkout – file 中 – 用来区分 分支／文件名 ，– 的名称叫做double dash，是bash的内置命令，用来标记可选命令选项的结束。即在它后面的带 – 的字符串，不被当做是一个命令选项。</p>\n<p><strong>例如</strong></p>\n<p>有个文件的名字就叫master，和master分支名字一摸一样，那么 git checkout master就是切换到master分支，如果想撤销master文件中的修改，git checkout – master 就不会把master当作分支名。所以只要文件名不和分支名或其他命令关键字重复，git checkout file也是撤销，不会变成切换分支</p>\n<h4 id=\"撤销暂存区修改\"><a href=\"#撤销暂存区修改\" class=\"headerlink\" title=\"撤销暂存区修改\"></a>撤销暂存区修改</h4><p>git reset HEAD file 撤销暂存区的add，工作区的修改没变，只是状态变为未暂存：Changes not staged for commit</p>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><p>删除文件也是一种修改</p>\n<p>版本库中也需要删除该文件 并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm file</span><br><span class=\"line\">$ git commit -m &quot;...&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h3><p>项目托管到github</p>\n<h4 id=\"注册GitHub账户\"><a href=\"#注册GitHub账户\" class=\"headerlink\" title=\"注册GitHub账户\"></a>注册GitHub账户</h4><h4 id=\"生成sshkey\"><a href=\"#生成sshkey\" class=\"headerlink\" title=\"生成sshkey\"></a>生成sshkey</h4><p>​    ssh-keygen -t rsa -C “GitHub账户邮箱”</p>\n<p>​    一直回车<br>​    成功生成ssh</p>\n<h4 id=\"添加sshKey到GitHub账户\"><a href=\"#添加sshKey到GitHub账户\" class=\"headerlink\" title=\"添加sshKey到GitHub账户\"></a>添加sshKey到GitHub账户</h4><p>​    登陆GitHub，settings，SSH and GPG Keys, New SSh Keys,将本地生成的ssh文件夹下的公钥（id_rsa.pub）中的内容复制，点击add ssh key 添加成功</p>\n<p>​    为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>\n<p>​    <strong>多台电脑ssh key添加到一个GitHub账户</strong></p>\n<p>​    当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>\n<p>​    <em><strong>我有一台电脑，注册了2个GitHub账户，一个工作，一个博客，如何操作？</strong></em></p>\n<h4 id=\"建立GitHub远程仓库\"><a href=\"#建立GitHub远程仓库\" class=\"headerlink\" title=\"建立GitHub远程仓库\"></a>建立GitHub远程仓库</h4><p>​    上述步骤只是注册了GitHub账户，并且添加了你电脑上的ssh key，保证你的电脑和你的GitHub能够相互通信，但GitHub仓库!=GitHub账户，GitHub远程仓库还需要建立，点击猫咪回到首页，start a project 或者 new repository都可创建一个新的github远程仓库</p>\n<p>​    点击后，输入一个仓库名称，点击“Create repository”按钮，就成功地创建了一个新的Git仓库</p>\n<h4 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h4><p>​    为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p>\n<p>​    不带选项的时候，<code>git remote</code>命令列出所有远程主机。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote</span><br><span class=\"line\">origin</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    使用  <code>-v</code>选项，可以参看远程主机的网址。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote -v</span><br><span class=\"line\">origin  git@github.com:jquery&#x2F;jquery.git (fetch)</span><br><span class=\"line\">origin  git@github.com:jquery&#x2F;jquery.git (push)</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>\n<p>​    克隆版本库的时候，所使用的远程主机自动被Git命名为<code>origin</code>。如果想用其他的主机名，需要用<code>git clone</code>命令的<code>-o</code>选项指定。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone -o jQuery https:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery.git</span><br><span class=\"line\">$ git remote</span><br><span class=\"line\">jQuery</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p>\n<p>​    <code>git remote show</code>命令加上主机名，可以查看该主机的详细信息。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote show &lt;主机名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <code>git remote add</code>命令用于添加远程主机。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add &lt;主机名&gt; &lt;网址&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <code>git remote rm</code>命令用于删除远程主机。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote rm &lt;主机名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <code>git remote rename</code>命令用于远程主机的改名。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <strong>GitHub仓库不添加本地ssh key，仍然可以关联，但无法push或clone</strong></p>\n<h4 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h4><p>​    远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone &lt;版本库的网址&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    比如，克隆jQuery的版本库。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https:&#x2F;&#x2F;github.com&#x2F;jquery&#x2F;jquery.git</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为<code>git clone</code>命令的第二个参数。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    <code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone http[s]:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\">$ git clone ssh:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\">$ git clone git:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\">$ git clone &#x2F;opt&#x2F;git&#x2F;project.git </span><br><span class=\"line\">$ git clone file:&#x2F;&#x2F;&#x2F;opt&#x2F;git&#x2F;project.git</span><br><span class=\"line\">$ git clone ftp[s]:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\">$ git clone rsync:&#x2F;&#x2F;example.com&#x2F;path&#x2F;to&#x2F;repo.git&#x2F;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    SSH协议还有另一种写法。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone [user@]example.com:path&#x2F;to&#x2F;repo.git&#x2F;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考<a href=\"http://git-scm.com/book/en/Git-on-the-Server-The-Protocols\">官方文档</a>。</p>\n<h4 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch\"></a>git fetch</h4><p>​    一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch &lt;远程主机名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令将某个远程主机的更新，全部取回本地。</p>\n<p>​    <code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>\n<p>​    默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    比如，取回<code>origin</code>主机的<code>master</code>分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch origin master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如<code>origin</code>主机的<code>master</code>，就要用<code>origin/master</code>读取。</p>\n<p>​        <code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -r</span><br><span class=\"line\">origin&#x2F;master</span><br><span class=\"line\"></span><br><span class=\"line\">$ git branch -a</span><br><span class=\"line\">* master</span><br><span class=\"line\">  remotes&#x2F;origin&#x2F;master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。</p>\n<p>​    取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b newBrach origin&#x2F;master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，在<code>origin/master</code>的基础上，创建一个新分支。</p>\n<p>​    此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge origin&#x2F;master</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ git rebase origin&#x2F;master</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示在当前分支上，合并<code>origin/master</code>。</p>\n<h4 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h4><p>​    <code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin next:master</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin next</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再做<code>git merge</code>。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git fetch origin</span><br><span class=\"line\">$ git merge origin&#x2F;next</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p>\n<p>Git也允许手动建立追踪关系。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch --set-upstream master origin&#x2F;next</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。</p>\n<p>​    如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull origin</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”（remote-tracking branch）进行合并。</p>\n<p>​    如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>\n<p>​    如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。</p>\n<p>​    但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git pull -p</span><br><span class=\"line\"># 等同于下面的命令</span><br><span class=\"line\">$ git fetch --prune origin </span><br><span class=\"line\">$ git fetch -p</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h4 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h4><p>​    <code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>\n<p>​    如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。</p>\n<p>​    如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin :master</span><br><span class=\"line\"># 等同于</span><br><span class=\"line\">$ git push origin --delete master</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示删除<code>origin</code>主机的<code>master</code>分支。</p>\n<p>​    如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，将当前分支推送到<code>origin</code>主机的对应分支。</p>\n<p>​    如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push -u origin master</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定<code>origin</code>为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p>\n<p>​    不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用<code>git config</code>命令。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git config --global push.default matching</span><br><span class=\"line\"># 或者</span><br><span class=\"line\">$ git config --global push.default simple</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<code>--all</code>选项。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push --all origin</span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令表示，将所有本地分支都推送到<code>origin</code>主机。</p>\n<p>​    如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>--force</code>选项。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push --force origin </span><br></pre></td></tr></table></figure>\n</blockquote>\n<p>​    上面命令使用<code>--force</code>选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用<code>--force</code>选项。</p>\n<p>​    最后，<code>git push</code>不会推送标签（tag），除非使用<code>--tags</code>选项。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin --tags</span><br></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h3><p><strong>创建分支</strong><br>git branch &lt;分支名&gt;<br>git checkout -b &lt;分支名&gt;<br>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：<br>$ git branch &lt;分支名&gt;<br>$ git checkout &lt;分支名&gt;</p>\n<p><strong>查看分支</strong><br>git branch<br>git branch命令会列出所有分支，当前分支前面会标一个*号。</p>\n<p><strong>合并分支</strong><br>git merge &lt;分支名&gt;<br>git merge命令用于合并&lt;分支名&gt;分支到当前分支。<br>git merge 默认使用“Fast-forward”快速合并模式，当两个分支分别有新的提交时，快速合并会产生冲突，需要手动修改冲突</p>\n<p><strong>删除分支</strong><br>git branch -d &lt;分支名&gt;</p>\n<h1 id=\"issues\"><a href=\"#issues\" class=\"headerlink\" title=\"issues\"></a>issues</h1><p>2018.1.23</p>\n<p>desc：昨天想把做完的股票管理应用放到github上。</p>\n<p>新建了一个github仓库，写了readme。so，现在这个远程仓库除了readme什么也没有。</p>\n<p>webstorm打开股票应用，now，本地的仓库和远程的仓库是两个素不相识的路人。现在使用<code>git remote</code>查看远程仓库没有任何反应，应为还没有给远程仓库指定主机名，本地仓库还不知道有远程仓库这么个人。</p>\n<p>先给新建的git仓库起个名字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add stock git@github.com:Yu-Sen&#x2F;StockManageApp.git</span><br></pre></td></tr></table></figure>\n\n<p>现在本地仓库终于知道这个名叫stock的git仓库了，使用<code>git remote -v</code>可以看出端倪：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git remote -v</span><br><span class=\"line\">test    git@github.com:Yu-Sen&#x2F;test.git (fetch)</span><br><span class=\"line\">test    git@github.com:Yu-Sen&#x2F;test.git (push)</span><br></pre></td></tr></table></figure>\n\n<p>（本地仓库已经add，commit过了）现在我可以把本地仓库的内容push到git仓库上了吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push</span><br></pre></td></tr></table></figure>\n\n<p>Ah ho，报错了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git push</span><br><span class=\"line\">fatal: No configured push destination.</span><br><span class=\"line\">Either specify the URL from the command-line or configure a remote repository using</span><br><span class=\"line\"></span><br><span class=\"line\">    git remote add &lt;name&gt; &lt;url&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">and then push using the remote name</span><br><span class=\"line\"></span><br><span class=\"line\">    git push &lt;name&gt;</span><br></pre></td></tr></table></figure>\n\n<p>报错原因：本地仓库的master分支和远程仓库的master分支还没有建立追踪关系，git push的完整写法是<code>git push 主机名 本地分支:远程分支</code>，只有当本地分支和远程分支存在追踪关系的时候才可以省略参数</p>\n<p><code>git push 主机名 本地分支</code>：省略远程分支名，当指定的本地分支有追踪的远程分支时（两个分支通常同名），如果远程分支不存在，则会自动新建</p>\n<p><code>git push 主机名</code>：省略本地分支名和远程分支名，当当前所在的本地分支有追踪的远程分支时</p>\n<p><code>git push</code>：省略主机名、本地分支、远程分支，当前所在本地分支有且只有一个追踪的远程分支时</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git push test</span><br><span class=\"line\">fatal: The current branch master has no upstream branch.</span><br><span class=\"line\">To push the current branch and set the remote as upstream, use</span><br><span class=\"line\"></span><br><span class=\"line\">    git push --set-upstream test master</span><br></pre></td></tr></table></figure>\n\n<p>再次使用<code>git push test</code>命令，push失败，提示当前分支master没有关联分支，使用<code>—set-upstream</code>来设置关联分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git push --set-upstream test master</span><br><span class=\"line\">To github.com:Yu-Sen&#x2F;test.git</span><br><span class=\"line\"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class=\"line\">error: failed to push some refs to &#39;git@github.com:Yu-Sen&#x2F;test.git&#39;</span><br><span class=\"line\">hint: Updates were rejected because the remote contains work that you do</span><br><span class=\"line\">hint: not have locally. This is usually caused by another repository pushing</span><br><span class=\"line\">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class=\"line\">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class=\"line\">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure>\n\n<p>又报错了？好吧，错误说远程仓库中含有本地仓库没有的文件，所以push被拒绝，在push前需要先pull一下，如果看到关于fast-forwards的提示，在<code>git push —help</code>中查看具体说明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git pull</span><br><span class=\"line\">fatal: No remote repository specified.  Please, specify either a URL or a</span><br><span class=\"line\">remote name from which new revisions should be fetched.</span><br></pre></td></tr></table></figure>\n\n<p>直接使用git pull报错，原因是当前本地分支没有追踪任何远程分支，只有当前本地分支追踪了远程分支时，才可以省略</p>\n<p>好吧，这次写全一点：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EthandeMBP:webpackDemo ethan$ git pull test master</span><br><span class=\"line\">From github.com:Yu-Sen&#x2F;test</span><br><span class=\"line\"> * branch            master     -&gt; FETCH_HEAD</span><br><span class=\"line\">fatal: refusing to merge unrelated histories</span><br></pre></td></tr></table></figure>\n\n<p>fatal，致命错误！无法合并，why？因为在较新版本的git中，如果要pull合并两个不同的项目，需要加一句<code>—allow-unrelated-histories</code>。</p>\n"},{"title":"【数据分析】第二阶段：MySQL数据分析实战（一）","date":"2021-05-04T09:40:02.000Z","description":"基础语句、聚合、分组、约束、多表查询","_content":"\n# MySQL基础\n\n## 数据库基本概念\n\n数据库是按照数据结构来组织、存储和管理数据的仓库。其本质是一个文件系统，以文件的形式将数据保存在电脑上。\n\n```mermaid\ngraph LR\n文件 --> 文件系统 --> 计算机磁盘\n```\n\n数据库（DB），数据库管理系统（DBMS）\n\n关系型数据库（RDB）：关系型数据库是创建在关系模型基础上的数据库。\n\n关系模型：有明确的行和列的二维表格模型。（就像excel表一样）\n\nIOE：IBM小型机，Oracle数据库，EMC易安信。\n\n客户端与服务端建立连接；写SQL，执行SQL语句操作MySQL数据库。\n\n字段：表中每一列成为一个字段，字段有自己的属性，如字段类型、字段大小等，字段类型决定了字段能够存储哪种数据。字段属性在建表时就必须定义好。\n\n索引：索引是一种单独的、物理的数据库结构。它依赖于表建立。\n\n视图：视图是从一张或多张表中到处的表（也称虚拟表），是用户产看表中数据的一种方式。\n\n## MySQL数据库\n\nMySQL是C和C++编写的。\n\nMySQL支持多线程。\n\nMySQL存储引擎：存储引擎是MySQL数据库的核心。它决定了数据如何存储，查询的时候如何搜索数据，索引如何创建等等。\n\n常用存储引擎：\n\n- InnoDB：MySQL5.1版本之后默认存储引擎。\n- MyISAM：MySQL5.1版本之前默认存储引擎。\n- Memory\n\nMySQL数据类型主要分为数值型、字符串型、日期时间型三大类。\n\n字符串型char和varchar：\n\n- char固定长度，char(5)会在内存中占用5个字符的空间，即使只存入了3个字符。\n\n- varchar可变长度，varchar(5)存入3个字符，就只占用3个字符的空间。\n- char浪费空间，但查询时整体匹配，效率更高，比如存入abc，查询时会直接匹配整体是否是abc。\n- varchar节省空间，但查询时不是整体匹配，效率不高，比如存入abc，查询时先匹配a再匹配b再匹配c。\n\nMySQL Server安装目录下，bin目录下的mysql就是自带的命令行客户端。\n\n访问数据库命令行：mysql -h127.0.01 -uroot -p123456\n\n- mysql：使用mysql客户端访问服务端\n- -h127.0.01：当前服务端是本机，所以使用-h127.0.0.1指定访问本地127.0.0.1地址的服务。因为服务端在本地，这部分也可以不写会自动访问本地服务。\n- -uroot：登陆用户是root\n- -p123456：登陆密码是123456\n\n# SQL语句\n\nSQL语句按功能分为以下几类：\n\n- DDL语句（Data Definition Language 数据定义语言)\n- DML语句（Data Manipulation Language 数据操作语言)\n- DQL语句（Data QueryLanguage 数据查询语言)\n- DCL语句（Data Controll Language 数据控制语言)\n\n**SQL语句的执行顺序：1、最先执行from tab；2、where语句是对条件加以限定；3、分组语句【group by…… having】；4、聚合函数；5、select语句；6、order by排序语句。**\n\n## 增删改\n\n```sql\n-- 新建数据库 create database 数据库名;\nCREATE DATABASE db1;\n-- 新建数据库，并指定字符集 create database 数据库名 character set 字符集;\nCREATE DATABASE db1_1 CHARACTER SET utf8;\n\n-- 切换数据库 从db1 切换到 db1_1 \nUSE db1_1;\n-- 查看当前正在使用的数据库 \nSELECT DATABASE();\n-- 查看Mysql中有哪些数据库 \nSHOW DATABASES;\n-- 查看一个数据库的定义信息 \nSHOW CREATE DATABASE db1_1;\n\n-- 将数据库db1 的字符集 修改为 utf8 \nALTER DATABASE db1 CHARACTER SET utf8;\n-- 查看当前数据库的基本信息，发现编码已更改 \nSHOW CREATE DATABASE db1;\n\n-- 删除某个数据库 \nDROP DATABASE db1_1;\n\n-- 创建表\n/* CREATE TABLE 表名(\n字段名称1 字段类型(长度)，\n字段名称2 字段类型 注意 最后一列不要加逗号\n);*/\nCREATE TABLE category(\ncid INT,\n    cname VARCHAR(20)\n);\n\n/* \n快速创建一个表结构相同的表(仅复制表结构，不会复制数据)\ncreate table 新表名 like 旧表名;\n*/\n-- 创建一个表结构与 test1 相同的 test2表 \nCREATE TABLE test2 LIKE test1;\n-- 查看表结构 \nDESC test2;\n\n-- 查看当前数据库中的所有表名 \nSHOW TABLES;\n-- 显示当前数据表的结构 \nDESC category;\n-- 查看创建表的SQL语句\nSHOW CREATE TABLE category;\n\n-- 直接删除 test1 表 \nDROP TABLE test1;\n-- 先判断表是否存在 再删除test2表\nDROP TABLE IF EXISTS test2;\n\n-- 修改表名 rename table 旧表名 to 新表名;\nRENAME TABLE category TO category1;\n\n-- 向表中添加列 alter table 表名 add 字段名称 字段类型\n# 为分类表添加一个新的字段为 分类描述 cdesc varchar(20) \nALTER TABLE category ADD cdesc VARCHAR(20);\n\n-- 修改表中列的数据类型或长度 alter table 表名 modify 字段名称 字段类型\nALTER TABLE category MODIFY cdesc VARCHAR(50);\n\n-- 修改列名称 alter table 表名 change 旧列名 新列名 类型(长度);\nALTER TABLE category CHANGE cdesc description VARCHAR(30);\n\n-- 删除列 alter table 表名 drop 列名;\nALTER TABLE category DROP description;\n\n-- 插入数据，插入数据是插入一行数据\n-- insert into 表名 (字段名1，字段名2...) values(字段值1，字段值2...);\n-- 方式1: 插入全部字段， 将所有字段名都写出来\nINSERT INTO student (sid,sname,age,sex,address) VALUES(1,'孙悟 空 ',20,'男 ','花 果 山 ');\n-- 方式2: 插入全部字段，不写字段名\nINSERT INTO student VALUES(2,'孙悟饭',10,'男','地球');\n-- 方式3:插入指定字段的值\nINSERT INTO category (cname) VALUES('白骨精');\n\n-- 更改数据，更新数据是更新某一列数据\n-- 不带条件的修改 update 表名 set 列名 = 值\nUPDATE student SET sex = '女';\n-- 带条件的修改 update 表名 set 列名 = 值 [where 条件表达式:字段名 = 值 ]\nUPDATE student SET sex = '男' WHERE sid = 3;\n-- 一次修改多个列\nUPDATE student SET age = 20,address = '北京' WHERE sid = 2;\n\n-- 删除数据\ndelete from 表名;\ntruncate table 表名;\n-- 指定条件 删除数据\ndelete from 表名 [where 字段名 = 值];\n```\n\n**当一个表中数据条数非常多，又要做删除动作的时候，如果用delete会很慢，那我们可以使用 truncate 。**\n\n**delete from 表名; 不推荐. 有多少条记录 就执行多少次删除操作. 效率低。**\n\n**truncate table 表名: 推荐. 先删除整张表, 然后再重新创建一张一模一样的表. 效率高。**\n\n## 查\n\n```sql\n-- 查询所有数据\nselect * from 表名\n-- 查询某一列\nselect 列名1,列名2 from 表名\n-- 使用 AS关键字,为列起别名 \nSELECT eid AS '编号', ename AS '姓名' , sex AS '性别' FROM emp;\n-- AS 可以省略 \nSELECT eid '编号', ename '姓名' , sex '性别' FROM emp;\n-- 使用distinct 关键字,去掉重复部门信息 \nSELECT DISTINCT dept_name FROM emp;\n-- 运算查询 (查询结果参与运算)\nSELECT ename , salary + 1000 FROM emp;\n```\n\n| **比较运算符**     | **说明**                                                     |\n| ------------------ | ------------------------------------------------------------ |\n| \\> < <= >= = <> != | 大于、小于、小于(大于)等于、等于、不等于                     |\n| BETWEEN ...AND...  | 显示在某一区间的值 <br />例如: 2000-10000之间: Between 2000 and 10000 |\n| IN(集合)           | 集合表示多个值,使用逗号分隔,<br />例如: name in (悟空，八戒) in中的每个数据都会作为一次条件,只要满足条件就会显示 |\n| LIKE '%张%'        | 模糊查询<br />通配符%，表示匹配任意多个字符串<br />通配符_，表示匹配一个字符<br />where name like '%王%'; -- name中有王的<br />where name like '王%'; -- name中以王开头的<br />where name like '\\_王%'；-- name中第二个字是王的 |\n| IS NULL            | 查询某一列为NULL的值, 注: 不能写 = NULL                      |\n| **逻辑运算符**     |                                                              |\n| And &&             | 多个条件同时成立                                             |\n| Or \\|\\|            | 多个条件任一成立                                             |\n| Not                | 不成立，取反。<br />和IS NULL组合使用，就是查询字段不是Null的数据。<br />where dept_name IS NOT NULL; |\n\n## 核心查询\n\n### 排序\n\n```\nSELECT 字段名 FROM 表名 [WHERE 字段 = 值] ORDER BY 字段名 [ASC / DESC]\n```\n\n```sql\n-- 默认升序排序 ASC\nSELECT * FROM emp ORDER BY salary;\n-- 降序排序\nSELECT * FROM emp ORDER BY salary DESC;\n-- 组合排序\nSELECT * FROM emp ORDER BY salary DESC, eid DESC;\n```\n\nOrder by不会影响源数据，只用于展示结果。\n\n### 聚合\n\n也称为聚合统计或者聚合查询，使用聚合函数纵向查询，对某一列的值进行计算，然后返回一个单一的值(另外聚合函数会忽略null空 值。\n\n聚合函数：\n\n- count(字段) 统计指定列不为NULL的记录行数。\n- sum(字段) 计算指定列的数值和。\n- max(字段) 计算指定列的最大值。\n- min(字段) 计算指定列的最小值。\n- avg(字段) 计算指定列的平均值\n\n```\nSELECT 聚合函数(字段名) FROM 表名;\n```\n\n```sql\n#1 查询员工的总数\n-- 统计表中的记录条数 使用 count()\nSELECT COUNT(eid) FROM emp; -- 使用某一个字段 \nSELECT COUNT(*) FROM emp; -- 使用 *\nSELECT COUNT(1) FROM emp; -- 使用 1,与 * 效果一样\n-- 下面这条SQL 得到的总条数不准确,因为count函数忽略了空值 \n-- 所以使用时注意不要使用带有null的列进行统计\nSELECT COUNT(dept_name) FROM emp;\n\n#2 查看员工总薪水、最高薪水、最小薪水、薪水的平均值\n-- sum函数求和, max函数求最大, min函数求最小, avg函数求平均值 \nSELECT\n\tSUM(salary) AS '总薪水', \n\tMAX(salary) AS '最高薪水', \n\tMIN(salary) AS '最低薪水', \n\tAVG(salary) AS '平均薪水'\nFROM emp;\n\n#3 查询薪水大于4000员工的个数\nSELECT COUNT(*) FROM emp WHERE salary > 4000;\n\n#4 查询部门为'教学部'的所有员工的个数\nSELECT COUNT(*) FROM emp WHERE dept_name = '教学部';\n\n#5 查询部门为'市场部'所有员工的平均薪水 SELECT\nAVG(salary) AS '市场部平均薪资' FROM emp WHERE dept_name = '市场部';\n```\n\n**⚠️注意：where中不能使用聚合函数，只能通过子查询实现**。[https://blog.csdn.net/fanbaodan/article/details/84304782](https://blog.csdn.net/fanbaodan/article/details/84304782)\n\n### 分组\n\n分组查询指的是使用GROUP BY 语句，对查询的信息进行分组，相同数据作为一组。\n\n```sql\n-- 语法\nSELECT 分组字段/聚合函数 FROM 表名 [where 条件] GROUP BY 分组字段 [HAVING 条件];\n-- select后必须出现要分组的字段，除了分组字段、聚合函数，不能出现其他字段\n-- where先对源数据过滤，having对分组聚合统计后的数据再过滤\n```\n\nGroup by 后可以跟多个字段，按照多个字段进行分组\n\n```sql\nSELECT 分组字段1, 分组字段2, 聚合函数 FROM 表名 [where 条件] GROUP BY 分组字段1, 分组字段2 [HAVING 条件];\n```\n\n```sql\n# store_id 和 salesdate 相同的分为一组\nselect store_id, sum(sales_volume), salesdate\nfrom store_table\ngroup by store_id, salesdate\n```\n\n分组的目的是为了统计，所以分组一般会与聚合函数一起使用。只进行分组是没有意义的。\n\n```sql\n-- 只分组不统计 这样写没有意义\nSELECT * FROM emp GROUP BY sex; \n-- 分组返回每组的第一条数据\n```\n\n示例：\n\n```sql\n#1 通过性别字段 进行分组,求各组的平均薪资\nselect sex,avg(salary)'平均薪资' from emp GROUP BY sex;\n\n#2 查询每个部门的平均薪资 \nselect dept_name'部门',avg(salary)'平均薪资' from emp GROUP BY dept_name;\n\n#3 查询每个部门的平均薪资, 部门名称不能为null\nselect dept_name'部门',avg(salary)'平均薪资' from emp where dept_name is not null GROUP BY dept_name;\n\n#4 查询平均薪资大于6000的部门\n-- 先对源数据where过滤掉部门为null的数据，接着按部门分组聚合统计各部门的平均薪资，最后再通过having过滤出平均薪资大于6000的部门。\nSELECT\n\tdept_name '部门',\n\tavg( salary ) '平均薪资' \nFROM\n\temp \nWHERE\n\tdept_name IS NOT NULL \nGROUP BY\n\tdept_name \nHAVING\n\tavg( salary ) > 6000;\n```\n\n**where和having的区别**\n\n- where 进行分组前的过滤，where 后面不能写聚合函数\n- having 是分组后的过滤，having 后面可以写聚合函数\n\n### limit\n\nlimit是限制的意思,用于限制返回的查询结果的行数 (可以通过limit指定查询多少行数据)\n\nlimit 语法是 MySql的方言,用来完成分页\n\n```sql\nSELECT 字段1,字段2... FROM 表名 LIMIT offset , length;\n```\n\noffset 起始行数，从0开始记数， 如果省略 则默认为 0。\nlength 返回的行数。\n\n```sql\n# 查询emp表中的前5条数据\n-- 参数1:起始值,默认是0; 参数2:要查询的条数 \nSELECT * FROM emp LIMIT 5;\nSELECT * FROM emp LIMIT 0 , 5;\n# 查询emp表中 从第4条开始,查询6条 -- 起始值默认是从0开始的.\nSELECT * FROM emp LIMIT 3 , 6;\n```\n\n**分页**\n\n```sql\n-- 分页操作 每页显示3条数据\nSELECT * FROM emp LIMIT 0,3; -- 第1页 \nSELECT * FROM emp LIMIT 3,3; -- 第2页\nSELECT * FROM emp LIMIT 6,3; -- 第3页\n-- 分页公式 起始索引 =(当前页 -1)* 每页条数 \n-- limit是MySql中的方言\n/*\n分页，每页显示3条\n第1页，1，2，3\n第2页，4，5，6\n第3页，7，8，9\n第1页，第1条开始，相对第1条偏移0条，显示3条\n第2页，第4条开始，相对第1条偏移3条，显示3条\n第3页，第7条开始，相对第1条偏移6条，显示3条\n当前页偏移量=当前页之前所有页的显示条数总和\n当前页偏移量计算公式：（页数-1）*每页显示条数\n*/\n```\n\n## SQL约束\n\n约束，就是对数据进一步限制，从而保证数据的有效性、正确性、完整性。违反约束的数据将无法插入到数据表中。\n\n约束是针对字段的。\n\n常见约束：\n\n- 主键（primary key）\n- 唯一（unique）\n- 非空（not null）\n- 外键（foreign key）\n- 默认值（default）\n\n### 主键\n\n作用：用来唯一标识数据表中的每一条记录。\n\n特点：不可重复，唯一，非空。\n\n```\n字段名 字段类型 primary key\nprimary key(字段名)\n```\n\n```sql\n# 方式1 创建一个带主键的表 \nCREATE TABLE emp2(eid INT PRIMARY KEY, ename VARCHAR(20));\n\n# 方式2 创建一个带主键的表 \nCREATE TABLE emp2(eid INT, ename VARCHAR(20), PRIMARY KEY(eid));\n\n# 方式3 向已经创建的表添加主键\nALTER TABLE emp2 ADD PRIMARY KEY(eid);\n\n-- 删除表中的主键\nALTER TABLE emp2 DROP PRIMARY KEY;\n```\n\n#### 主键自增\n\n```\n关键字:\nAUTO_INCREMENT 表示自动增长(字段类型必须是整数类型)\n```\n\n数据库在插入数据时，如果主键自增字段不填写数据，数据库会以自增的形式自动生成主键字段的值。默认从1或者上一条记录的主键字段值开始自增，也可以指定起始值。\n\n```sql\n-- 创建主键自增的表 \nCREATE TABLE emp2(\n  -- 关键字 AUTO_INCREMENT,主键类型必须是整数类型 \n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20),\n  sex CHAR(1)\n);\n\n-- 创建主键自增的表,自定义自增起始值 \nCREATE TABLE emp2(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20),\n  sex CHAR(1)\n)AUTO_INCREMENT=100;\n```\n\n**delete**删除数据不会影响自增，自增会接着删除前的数据自增。\n\n**truncate**删除数据再自增会从1开始，因为truncate是将表删除再复制一个表结构相同的新表。\n\n### 非空\n\n特点：该列不允许为null\n\n```\n字段名 字段类型 not null\n```\n\n```sql\n# 非空约束\nCREATE TABLE emp2(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  -- 添加非空约束, ename字段不能为空 \n  ename VARCHAR(20) NOT NULL,\n  sex CHAR(1)\n);\n```\n\n**空字符串('')不等于null，可以插入**。\n\n```sql\n# 插入''成功\ninsert into emp2 (ename,sex) values('','男');\t-- OK, Time: 0.000000s\n```\n\n### 唯一\n\n特点：该列的值不能重复（对null会忽略不做判断）\n\n```\n字段名 字段值 unique\n```\n\n```sql\n#创建emp3表 为ename 字段添加唯一约束 \nCREATE TABLE emp3(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20) UNIQUE,\n  sex CHAR(1)\n);\n```\n\n主键约束和唯一约束的区别：\n\n- 主键约束，唯一且不能够为空(主键约束=非空约束+唯一约束)。\n- 唯一约束，唯一 但是可以为空。\n- 一个表中只能有一个主键，但是可以有多个唯一约束。\n\n### 默认值\n\n作用：用来指定该列的默认值。\n\n```\n字段名 字段类型 DEFAULT 默认值\n```\n\n```sql\n-- 创建带有默认值的表 \nCREATE TABLE emp4(\n\teid INT PRIMARY KEY AUTO_INCREMENT, \n\tename VARCHAR(20),\n  -- 为sex字段添加默认值\n\tsex CHAR(1) DEFAULT '女'\n);\n\n-- 添加数据 使用默认值\nINSERT INTO emp4(ename,sex) VALUES('张三',DEFAULT); \nINSERT INTO emp4(ename) VALUES('李四');\n```\n\n### 外键约束\n\n数据表A中某一个字段，指向数据表B中的主键，那么数据表A中的这一字段就是外键。\n\n在这种关系场景中，外键所在的表叫做从表，外键所指向表叫做主表。\n\n作用：使两张数据表产生对应关系。\n\n特点：\n\n- 从表插入数据时，外键字段的值必须在主表主键字段中存在，外键字段类型必须和主表主键字段类型保持一致。\n\n- 一张表可以有多个外键。表明该表与多个表有关联。\n\n```sql\n-- 新建表时添加外键\n[CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名);\n-- 已有表添加外键\nALTER TABLE 从表名 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主键字段名);\n\n-- 删除外键\nalter table 从表名 drop foreign key 外键约束名称\n\n-- 添加外键\nALTER TABLE 从表 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主 键字段名);\n```\n\n```sql\n-- 添加外键约束，创建employee表\nCREATE TABLE employee(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20),\n  age INT,\n  dept_id INT, -- 外键字段类型要和主表的主键字段类型保持一致 \n  -- 添加外键约束\n  CONSTRAINT emp_dept_fk FOREIGN KEY(dept_id) REFERENCES department(id)\n);\n\n-- 添加数据 (从表外键对应主表主键)\nINSERT INTO employee (ename, age, dept_id) VALUES ('张百万', 20, 1); \nINSERT INTO employee (ename, age, dept_id) VALUES ('赵四', 21, 1); \nINSERT INTO employee (ename, age, dept_id) VALUES ('广坤', 20, 2); \nINSERT INTO employee (ename, age, dept_id) VALUES ('小斌', 20, 2); \n\n-- 插入一条有问题的数据 (部门id在主表主键中不存在)\n-- Cannot add or update a child row: a foreign key constraint fails \nINSERT INTO employee (ename, age, dept_id) VALUES ('错误', 18, 3);\n\n-- 删除employee 表中的外键约束,外键约束名 emp_dept_fk \nALTER TABLE employee DROP FOREIGN KEY emp_dept_fk;\n\n-- 可以省略外键名称, 系统会自动生成一个\nALTER TABLE employee ADD FOREIGN KEY (dept_id) REFERENCES department (id);\n```\n\n**注意事项**\n\n- 添加数据时, 应该先添加主表中的数据。\n- 删除数据时,应该先删除从表中的数据。\n- 从表外键类型必须与主表主键类型一致 否则创建失败。\n\n#### 级联删除\n\n删除主表数据的同时，自动删除掉从表数据\n\n```\n级联删除\nON DELETE CASCADE\n```\n\n```sql\n-- 重新创建添加级联操作 \nCREATE TABLE employee(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20),\n  age INT,\n  dept_id INT,\n  CONSTRAINT emp_dept_fk FOREIGN KEY(dept_id) REFERENCES department(id) -- 添加级联删除\n  ON DELETE CASCADE\n);\n```\n\n## 多表查询\n\n查询多张表(至少涉及2张表),获取到需要的数据。\n\n### 交叉连接查询\n\n直接使用select语句查询两张表。\n\n```\nSELECT 字段名 FROM 表1, 表2;\n```\n\n交叉连接查询会产生笛卡尔积，查询结果有误\n\n#### 笛卡尔积\n\n![img](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-05_19-44-43.jpg)\n\n### 内连接查询\n\n#### 隐式内连接\n\n交叉连接查询+where条件过滤\n\n```\nSELECT 字段名 FROM 左表, 右表 WHERE 连接条件;\n```\n\n```sql\n# 隐式内连接\nSELECT * FROM products,category WHERE category_id = cid;\n\n#查询 格力空调是属于哪一分类下的商品\nSELECT \np.pname, c.cname\nFROM \nproducts p , category c \nWHERE \np.category_id = c.cid \nAND p.pname = '格力空调';\n```\n\n#### 显示内连接\n\n使用**[inner] join ... on ...关键字**。\n\n```\nSELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]] -- inner 可以省略\n```\n\n```sql\n# 显式内连接查询\nSELECT * FROM products p INNER JOIN category c ON p.category_id = c.cid;\n\n# 查询鞋服分类下,价格大于500的商品名称和价格\nSELECT \np.pname,p.price\nFROM products p INNER JOIN category c \nON p.category_id = c.cid \nWHERE p.price > 500 AND cname = '鞋服';\n```\n\n### 外连接查询\n\n#### 左外连接\n\n使用left [outer] join ... on ...关键字\n\n```\nSELECT 字段名 FROM 左表 LEFT [OUTER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]]\n```\n\n特点：\n\n- 左表为基准, 右表去查询左表\n- 返回结果时，左表数据正常展示，右表在左表中查询得到的数据正常展示，查询不到的展示为Null\n\n```sql\n# 左外连接查询\nselect * from category c left join products p on c.cid = p.category_id;\n\n# 分类表中有汽车类目，商品表中并并没有该类目的商品\nc001\t家电\tp001\t小 米 电 视 机 \t5000\t1\tc001\nc001\t家电\tp002\t格 力 空 调 \t3000\t1\tc001\nc001\t家电\tp003\t美 的 冰 箱 \t4500\t1\tc001\nc002\t鞋服\tp004\t篮 球 鞋 \t800\t1\tc002\nc002\t鞋服\tp005\t运 动 裤 \t200\t1\tc002\nc002\t鞋服\tp006\tT 恤 \t300\t1\tc002\nc002\t鞋服\tp007\t冲 锋 衣 \t2000\t1\tc002\nc003\t化妆品\tp008\t神 仙 水 \t800\t1\tc003\nc003\t化妆品\tp009\t大 宝 \t200\t1\tc003\nc004\t汽车\t\n\n# 查询每个分类下的商品个数\nselect \nc.cname, count(p.pid) \nfrom \ncategory c left join products p \non c.cid = p.category_id \ngroup by c.cname;\n```\n\n#### 右外连接\n\n使用 right [outer] join ... on ... 关键字\n\n```\nSELECT 字段名 FROM 左表 RIGHT [OUTER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]]\n```\n\n特点：和左外连接一样，只是以右表为基准。\n\n### 小结\n\n![img](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-05_21-50-07.jpg)\n\n2个以上表如何多表查询，思路是先选2个进行查询，将查询结果当作一个新的表，再和下一个表进行多表查询，以此类推。\n\n### join on and 和 join on where and\n\n在使用left join时，on和where条件的区别如下：  \n\n1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。（实际上左连接中如果and语句是对左表进行过滤的，那么不管真假都不起任何作用。如果是对右表过滤的，那么左表所有记录都返回，右表筛选以后再与左表连接返回） \n\n2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉，on后的条件用来生成左右表关联的临时表，where后的条件对临时表中的记录进行过滤。\n\n 在使用inner join时，不管是对左表还是右表进行筛选，on and和on where都会对生成的临时表进行过滤。\n\n————————————————\n版权声明：本文为CSDN博主「行者摩罗」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/xingzhemoluo/article/details/39677891\n\n## 合并查询\n\nunion和union all\n\nunion/union all操作符用来合并多个select语句的结果集（就是查询结果）。\n\nunion 和 union all 都要满足以下条件才能合并：\n\n- 要合并的结果集，列数必须相同，列的顺序必须一致，列的字段类型也必须相似。\n\nunion 和 union all 的区别：\n\n- union：消除重复行，重复检查期间，null值会被算在内。\n- union all：不消除重复行，只是将结果集合并后就返回。\n- 执行效率上，union all 要比 union 快很多。\n\n```sql\nSELECT column1 [, column2 ]\nFROM table1 [, table2 ]\n[WHERE condition]\nUNION / UNION ALL\nSELECT column1 [, column2 ]\nFROM table1 [, table2 ]\n[WHERE condition]\n```\n\n## 子查询\n\n子查询概念：一条select 查询语句的结果, 作为另一条 select 语句的一部分。\n\n特点：\n\n- 子查询必须放在小括号中\n- 整个sql至少会有两个select关键字\n\n子查询常见分类\n\n- **where型子查询**：将子查询的结果, 作为父查询的比较条件\n- **from型子查询 **：将子查询的结果, 作为 一张表,提供给父层查询使用\n- **exists型子查询**：子查询的结果是单列多行, 类似一个数组, 父层查询使用 IN 函数 ,包含子查询的结果\n\n### where型子查询\n\n当子查询的结果是一个值时（单行单列）\n\n```\nSELECT 查询字段 FROM 表 WHERE 字段 = (子查询);\n```\n\n```sql\n# 子查询的方式, 查询价格最高的商品信息\nselect * from products where price = (select max(price) from products);\n\n# 查询化妆品分类下的 商品名称 商品价格\n-- 子查询\nselect p.pname, p.price from products p where p.category_id = (select cid from category where cname = '化妆品');\n-- 内连接查询\nselect  p.pname,p.price from products p join category c on p.category_id = c.cid where c.cname = '化妆品';\n```\n\n### exists型子查询\n\n当子查询的结果是一个集合时（多行单列），需要用where ... in (子查询)\n\n```\nSELECT 查询字段 FROM 表 WHERE 字段 in (子查询);\n```\n\n```sql\n# 查询价格小于两千的商品,来自于哪些分类(名称)\nselect cname from category where cid in (select category_id from products where price < 2000);\n\n# 查询家电类 与 鞋服类下面的全部商品信息\nselect * from products where category_id in (select cid from category where cname in('家电','鞋服'));\n```\n\n### from型子查询\n\n当子查询的结果是一个表（多列多行）\n\n```\nSELECT 查询字段 FROM (子查询)表别名 WHERE 条件;\n```\n\n```sql\n# 查询商品中,价格大于500的商品信息,包括 商品名称 商品价格 商品所属分类名称\n-- 子查询\nselect p.pname,p.price,c.cname from (select * from products where price > 500) p join category c on p.category_id = c.cid;\n-- 内连接查询\nselect p.pname,p.price,c.cname from products p  join category c on p.category_id = c.cid where p.price > 500;\n```\n\n**当子查询作为一张表的时候，需要起别名，否则无法访问表中的字段。**\n\n# SQL语句执行顺序\n\n```\n1. from \n2. join \n3. on \n4. where \n5. group by(开始使用select中的别名，后面的语句中都可以使用)\n6.  avg,sum.... \n7. having \n8. select \n9. distinct \n10. order by\n11. limit \n```\n\n```\n1、FROM  table1 left join table2 on 将table1和table2中的数据产生笛卡尔积，生成Temp1\n\n2、JOIN table2  所以先是确定表，再确定关联条件\n\n3、ON table1.column = table2.columu 确定表的绑定条件 由Temp1产生中间表Temp2\n\n4、WHERE  对中间表Temp2产生的结果进行过滤  产生中间表Temp3\n\n5、GROUP BY 对中间表Temp3进行分组，产生中间表Temp4\n\n6、HAVING  对分组后的记录进行聚合 产生中间表Temp5\n\n7、SELECT  对中间表Temp5进行列筛选，产生中间表 Temp6\n\n8、DISTINCT 对中间表 Temp6进行去重，产生中间表 Temp7\n\n9、ORDER BY 对Temp7中的数据进行排序，产生中间表Temp8\n\n10、LIMIT 对中间表Temp8进行分页，产生中间表Temp9\n```\n\n# 案例1\n\n```sql\n# 查询线索(二级渠道jdsc)后续转化成交车型详情。\n-- 在二级渠道jdsc下，成交的线索，的车型详情\n-- 线索表中二级渠道下的线索 和 订单表中的线索 的 交集。所以使用内连接查询。\nselect * from clue_day c, order_day o where c.clue_id = o.clue_id and c.ca_n = 'jdsc';\nselect * from clue_day c join order_day o on c.clue_id = o.clue_id where c.ca_n = 'jdsc';\n```\n\n# 案例2\n\n```sql\n# 统计所有渠道(按照二级渠道)的转化率\n-- 转化率 = 该渠道下订单数/该渠道下线索数。订单数是线索数的子集，所以使用外连接查询。\n-- 统计每一个二级渠道的转化率：按二级渠道分组聚合统计\nselect c.ca_n, count(o.order_id)/count(c.clue_id) \nfrom clue_day c left join order_day o \non c.clue_id = o.clue_id \ngroup by c.ca_n;\n```\n\n# 案例3\n\n```sql\n# 查询各城市线索数并计算所有城市线索总数\n-- 各城市线索数只需要用到clue表一张表，因此不需要多表查询\n-- 各城市线索数，需要按城市分组求和\n-- 各城市线索数，加起来就是所有城市线索总数，因此是子查询❌\n-- 错误原因：子查询无法将两个结果展示在一张表中\n-- 使用合并查询，将两个结果拼在一张表中。\n-- 所有城市线索总数，也不需要先计算各城市线索数再求和，直接对clue表的线索求和即可。\n\nselect c.city_id,count(c.clue_id)clue_num from clue_day c group by c.city_id\nunion\nselect '总计',count(c.clue_id) from clue_day c;\n```\n\n# 案例4\n\n日期直接相减做了一个隐式转换操作，将时间转换为整数，但并不是用unix_timestamp转换，而是直接把年月日时分秒拼起来，如2013-04-21 16:59:33 直接转换为20130421165933，所以得到的结果是错误的。\n\nUnix_timestamp([日期])函数：返回自'1970-01-01 00:00:00'的到当前日期[指定日期]的秒数差。\n\nDatediff(d1,d2)函数：返回d1-d2的天数差\n\nCeil()函数：向上取整\n\n```sql\n-- 找出优质渠道，做重点投入\n-- 我们对于优质渠道(以二级渠道来说)的定义: \n-- 该二级渠道内平均转化周期< 整体平均转化周期\n-- 该二级渠道的线索量 > 各二级渠道平均线索量\n\n/*\n\t针对《二级渠道内平均转化周期》和《二级渠道的线索量》的分析\n\t转化周期:成单日期 — 线索创建日期 平均:avg\n\t渠道线索量:分组 count统计\n*/\n-- 这里需要注意：二级渠道线索量是所有二级渠道的，其中包括未成单的二级渠道。\n-- 因此这里使用关联查询时，首先排除内连接，因为内连接只能查出成单的二级渠道\n-- 其次使用外连接时，clue表应该作为主表将渠道全部展示出来\nselect ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \nfrom clue_day c left join order_day o on c.clue_id = o.clue_id\nwhere created_at is not null and clue_created_at is not NULL\ngroup by ca_n\n\n-- 二级渠道平均线索量\nselect ceil(avg(clue_num)) from (\n  select ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \n  from clue_day c left join order_day o \ton c.clue_id = o.clue_id\n  where created_at is not null and clue_created_at is not NULL\n  group by ca_n\n)a -- 子查询作为一张表时，必须有别名才能访问其中的字段\n\n-- 整体平均转化周期\nSELECT avg(datediff( created_at, clue_created_at )) \nFROM clue_day c LEFT JOIN order_day o ON c.clue_id = o.clue_id \nWHERE created_at IS NOT NULL AND clue_created_at IS NOT NULL\n\n-- 查询结果\nselect ca_n, avg_time, clue_num from (\n  -- 《二级渠道内平均转化周期》和《二级渠道的线索量》\n  select ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \n  from clue_day c left join order_day o on c.clue_id = o.clue_id\n  where created_at is not null and clue_created_at is not NULL\n  group by ca_n\n)\nWHERE avg_time < (\n  -- 整体平均转化周期\n\tSELECT avg(datediff( created_at, clue_created_at )) \n\tFROM clue_day c LEFT JOIN order_day o ON c.clue_id = o.clue_id \n\tWHERE created_at IS NOT NULL AND clue_created_at IS NOT NULL \n\t) \nAND clue_num > (\n  -- 二级渠道平均线索量\n  select ceil(avg(clue_num)) from (\n    select ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \n    from clue_day c left join order_day o \ton c.clue_id = o.clue_id\n    where created_at is not null and clue_created_at is not NULL\n    group by ca_n\n\t)a \n);\n```\n\n一段sql查询多次作为子查询被使用，可以用with 别名 as (子查询) 优化：\n\n```sql\n-- 《二级渠道内平均转化周期》和《二级渠道的线索量》\nwith ca_value as (\n  select ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \n  from clue_day c left join order_day o on c.clue_id = o.clue_id\n  where created_at is not null and clue_created_at is not NULL\n  group by ca_n\n)\n-- 查询结果\nselect ca_n, avg_time, clue_num from ca_value\nWHERE avg_time < (\n\tSELECT avg(datediff( created_at, clue_created_at )) \n\tFROM clue_day c LEFT JOIN order_day o ON c.clue_id = o.clue_id \n\tWHERE created_at IS NOT NULL AND clue_created_at IS NOT NULL \n\t) \nAND clue_num > (SELECT ceil(avg( clue_num )) FROM ca_value);\n```\n\n**⚠️注意**：[with...as...的用法](https://bbs.csdn.net/topics/390280176)\n\n# 扩展\n\n```sql\ncase\n when 条件1 then 结果1\n when 条件2 then 结果2\n ...\n else 结果（默认null） -- 上面条件都不满足时，返回else结果；如果不写else，默认也返回null\n end\n```\n\n\n\n","source":"_posts/【数据分析】第二阶段：MySQL数据分析实战（一）.md","raw":"---\ntitle: 【数据分析】第二阶段：MySQL数据分析实战（一）\ndate: 2021-05-04 17:40:02\ntags:\n- 数据分析\ncategories:\n- 学习笔记\ndescription: 基础语句、聚合、分组、约束、多表查询\n---\n\n# MySQL基础\n\n## 数据库基本概念\n\n数据库是按照数据结构来组织、存储和管理数据的仓库。其本质是一个文件系统，以文件的形式将数据保存在电脑上。\n\n```mermaid\ngraph LR\n文件 --> 文件系统 --> 计算机磁盘\n```\n\n数据库（DB），数据库管理系统（DBMS）\n\n关系型数据库（RDB）：关系型数据库是创建在关系模型基础上的数据库。\n\n关系模型：有明确的行和列的二维表格模型。（就像excel表一样）\n\nIOE：IBM小型机，Oracle数据库，EMC易安信。\n\n客户端与服务端建立连接；写SQL，执行SQL语句操作MySQL数据库。\n\n字段：表中每一列成为一个字段，字段有自己的属性，如字段类型、字段大小等，字段类型决定了字段能够存储哪种数据。字段属性在建表时就必须定义好。\n\n索引：索引是一种单独的、物理的数据库结构。它依赖于表建立。\n\n视图：视图是从一张或多张表中到处的表（也称虚拟表），是用户产看表中数据的一种方式。\n\n## MySQL数据库\n\nMySQL是C和C++编写的。\n\nMySQL支持多线程。\n\nMySQL存储引擎：存储引擎是MySQL数据库的核心。它决定了数据如何存储，查询的时候如何搜索数据，索引如何创建等等。\n\n常用存储引擎：\n\n- InnoDB：MySQL5.1版本之后默认存储引擎。\n- MyISAM：MySQL5.1版本之前默认存储引擎。\n- Memory\n\nMySQL数据类型主要分为数值型、字符串型、日期时间型三大类。\n\n字符串型char和varchar：\n\n- char固定长度，char(5)会在内存中占用5个字符的空间，即使只存入了3个字符。\n\n- varchar可变长度，varchar(5)存入3个字符，就只占用3个字符的空间。\n- char浪费空间，但查询时整体匹配，效率更高，比如存入abc，查询时会直接匹配整体是否是abc。\n- varchar节省空间，但查询时不是整体匹配，效率不高，比如存入abc，查询时先匹配a再匹配b再匹配c。\n\nMySQL Server安装目录下，bin目录下的mysql就是自带的命令行客户端。\n\n访问数据库命令行：mysql -h127.0.01 -uroot -p123456\n\n- mysql：使用mysql客户端访问服务端\n- -h127.0.01：当前服务端是本机，所以使用-h127.0.0.1指定访问本地127.0.0.1地址的服务。因为服务端在本地，这部分也可以不写会自动访问本地服务。\n- -uroot：登陆用户是root\n- -p123456：登陆密码是123456\n\n# SQL语句\n\nSQL语句按功能分为以下几类：\n\n- DDL语句（Data Definition Language 数据定义语言)\n- DML语句（Data Manipulation Language 数据操作语言)\n- DQL语句（Data QueryLanguage 数据查询语言)\n- DCL语句（Data Controll Language 数据控制语言)\n\n**SQL语句的执行顺序：1、最先执行from tab；2、where语句是对条件加以限定；3、分组语句【group by…… having】；4、聚合函数；5、select语句；6、order by排序语句。**\n\n## 增删改\n\n```sql\n-- 新建数据库 create database 数据库名;\nCREATE DATABASE db1;\n-- 新建数据库，并指定字符集 create database 数据库名 character set 字符集;\nCREATE DATABASE db1_1 CHARACTER SET utf8;\n\n-- 切换数据库 从db1 切换到 db1_1 \nUSE db1_1;\n-- 查看当前正在使用的数据库 \nSELECT DATABASE();\n-- 查看Mysql中有哪些数据库 \nSHOW DATABASES;\n-- 查看一个数据库的定义信息 \nSHOW CREATE DATABASE db1_1;\n\n-- 将数据库db1 的字符集 修改为 utf8 \nALTER DATABASE db1 CHARACTER SET utf8;\n-- 查看当前数据库的基本信息，发现编码已更改 \nSHOW CREATE DATABASE db1;\n\n-- 删除某个数据库 \nDROP DATABASE db1_1;\n\n-- 创建表\n/* CREATE TABLE 表名(\n字段名称1 字段类型(长度)，\n字段名称2 字段类型 注意 最后一列不要加逗号\n);*/\nCREATE TABLE category(\ncid INT,\n    cname VARCHAR(20)\n);\n\n/* \n快速创建一个表结构相同的表(仅复制表结构，不会复制数据)\ncreate table 新表名 like 旧表名;\n*/\n-- 创建一个表结构与 test1 相同的 test2表 \nCREATE TABLE test2 LIKE test1;\n-- 查看表结构 \nDESC test2;\n\n-- 查看当前数据库中的所有表名 \nSHOW TABLES;\n-- 显示当前数据表的结构 \nDESC category;\n-- 查看创建表的SQL语句\nSHOW CREATE TABLE category;\n\n-- 直接删除 test1 表 \nDROP TABLE test1;\n-- 先判断表是否存在 再删除test2表\nDROP TABLE IF EXISTS test2;\n\n-- 修改表名 rename table 旧表名 to 新表名;\nRENAME TABLE category TO category1;\n\n-- 向表中添加列 alter table 表名 add 字段名称 字段类型\n# 为分类表添加一个新的字段为 分类描述 cdesc varchar(20) \nALTER TABLE category ADD cdesc VARCHAR(20);\n\n-- 修改表中列的数据类型或长度 alter table 表名 modify 字段名称 字段类型\nALTER TABLE category MODIFY cdesc VARCHAR(50);\n\n-- 修改列名称 alter table 表名 change 旧列名 新列名 类型(长度);\nALTER TABLE category CHANGE cdesc description VARCHAR(30);\n\n-- 删除列 alter table 表名 drop 列名;\nALTER TABLE category DROP description;\n\n-- 插入数据，插入数据是插入一行数据\n-- insert into 表名 (字段名1，字段名2...) values(字段值1，字段值2...);\n-- 方式1: 插入全部字段， 将所有字段名都写出来\nINSERT INTO student (sid,sname,age,sex,address) VALUES(1,'孙悟 空 ',20,'男 ','花 果 山 ');\n-- 方式2: 插入全部字段，不写字段名\nINSERT INTO student VALUES(2,'孙悟饭',10,'男','地球');\n-- 方式3:插入指定字段的值\nINSERT INTO category (cname) VALUES('白骨精');\n\n-- 更改数据，更新数据是更新某一列数据\n-- 不带条件的修改 update 表名 set 列名 = 值\nUPDATE student SET sex = '女';\n-- 带条件的修改 update 表名 set 列名 = 值 [where 条件表达式:字段名 = 值 ]\nUPDATE student SET sex = '男' WHERE sid = 3;\n-- 一次修改多个列\nUPDATE student SET age = 20,address = '北京' WHERE sid = 2;\n\n-- 删除数据\ndelete from 表名;\ntruncate table 表名;\n-- 指定条件 删除数据\ndelete from 表名 [where 字段名 = 值];\n```\n\n**当一个表中数据条数非常多，又要做删除动作的时候，如果用delete会很慢，那我们可以使用 truncate 。**\n\n**delete from 表名; 不推荐. 有多少条记录 就执行多少次删除操作. 效率低。**\n\n**truncate table 表名: 推荐. 先删除整张表, 然后再重新创建一张一模一样的表. 效率高。**\n\n## 查\n\n```sql\n-- 查询所有数据\nselect * from 表名\n-- 查询某一列\nselect 列名1,列名2 from 表名\n-- 使用 AS关键字,为列起别名 \nSELECT eid AS '编号', ename AS '姓名' , sex AS '性别' FROM emp;\n-- AS 可以省略 \nSELECT eid '编号', ename '姓名' , sex '性别' FROM emp;\n-- 使用distinct 关键字,去掉重复部门信息 \nSELECT DISTINCT dept_name FROM emp;\n-- 运算查询 (查询结果参与运算)\nSELECT ename , salary + 1000 FROM emp;\n```\n\n| **比较运算符**     | **说明**                                                     |\n| ------------------ | ------------------------------------------------------------ |\n| \\> < <= >= = <> != | 大于、小于、小于(大于)等于、等于、不等于                     |\n| BETWEEN ...AND...  | 显示在某一区间的值 <br />例如: 2000-10000之间: Between 2000 and 10000 |\n| IN(集合)           | 集合表示多个值,使用逗号分隔,<br />例如: name in (悟空，八戒) in中的每个数据都会作为一次条件,只要满足条件就会显示 |\n| LIKE '%张%'        | 模糊查询<br />通配符%，表示匹配任意多个字符串<br />通配符_，表示匹配一个字符<br />where name like '%王%'; -- name中有王的<br />where name like '王%'; -- name中以王开头的<br />where name like '\\_王%'；-- name中第二个字是王的 |\n| IS NULL            | 查询某一列为NULL的值, 注: 不能写 = NULL                      |\n| **逻辑运算符**     |                                                              |\n| And &&             | 多个条件同时成立                                             |\n| Or \\|\\|            | 多个条件任一成立                                             |\n| Not                | 不成立，取反。<br />和IS NULL组合使用，就是查询字段不是Null的数据。<br />where dept_name IS NOT NULL; |\n\n## 核心查询\n\n### 排序\n\n```\nSELECT 字段名 FROM 表名 [WHERE 字段 = 值] ORDER BY 字段名 [ASC / DESC]\n```\n\n```sql\n-- 默认升序排序 ASC\nSELECT * FROM emp ORDER BY salary;\n-- 降序排序\nSELECT * FROM emp ORDER BY salary DESC;\n-- 组合排序\nSELECT * FROM emp ORDER BY salary DESC, eid DESC;\n```\n\nOrder by不会影响源数据，只用于展示结果。\n\n### 聚合\n\n也称为聚合统计或者聚合查询，使用聚合函数纵向查询，对某一列的值进行计算，然后返回一个单一的值(另外聚合函数会忽略null空 值。\n\n聚合函数：\n\n- count(字段) 统计指定列不为NULL的记录行数。\n- sum(字段) 计算指定列的数值和。\n- max(字段) 计算指定列的最大值。\n- min(字段) 计算指定列的最小值。\n- avg(字段) 计算指定列的平均值\n\n```\nSELECT 聚合函数(字段名) FROM 表名;\n```\n\n```sql\n#1 查询员工的总数\n-- 统计表中的记录条数 使用 count()\nSELECT COUNT(eid) FROM emp; -- 使用某一个字段 \nSELECT COUNT(*) FROM emp; -- 使用 *\nSELECT COUNT(1) FROM emp; -- 使用 1,与 * 效果一样\n-- 下面这条SQL 得到的总条数不准确,因为count函数忽略了空值 \n-- 所以使用时注意不要使用带有null的列进行统计\nSELECT COUNT(dept_name) FROM emp;\n\n#2 查看员工总薪水、最高薪水、最小薪水、薪水的平均值\n-- sum函数求和, max函数求最大, min函数求最小, avg函数求平均值 \nSELECT\n\tSUM(salary) AS '总薪水', \n\tMAX(salary) AS '最高薪水', \n\tMIN(salary) AS '最低薪水', \n\tAVG(salary) AS '平均薪水'\nFROM emp;\n\n#3 查询薪水大于4000员工的个数\nSELECT COUNT(*) FROM emp WHERE salary > 4000;\n\n#4 查询部门为'教学部'的所有员工的个数\nSELECT COUNT(*) FROM emp WHERE dept_name = '教学部';\n\n#5 查询部门为'市场部'所有员工的平均薪水 SELECT\nAVG(salary) AS '市场部平均薪资' FROM emp WHERE dept_name = '市场部';\n```\n\n**⚠️注意：where中不能使用聚合函数，只能通过子查询实现**。[https://blog.csdn.net/fanbaodan/article/details/84304782](https://blog.csdn.net/fanbaodan/article/details/84304782)\n\n### 分组\n\n分组查询指的是使用GROUP BY 语句，对查询的信息进行分组，相同数据作为一组。\n\n```sql\n-- 语法\nSELECT 分组字段/聚合函数 FROM 表名 [where 条件] GROUP BY 分组字段 [HAVING 条件];\n-- select后必须出现要分组的字段，除了分组字段、聚合函数，不能出现其他字段\n-- where先对源数据过滤，having对分组聚合统计后的数据再过滤\n```\n\nGroup by 后可以跟多个字段，按照多个字段进行分组\n\n```sql\nSELECT 分组字段1, 分组字段2, 聚合函数 FROM 表名 [where 条件] GROUP BY 分组字段1, 分组字段2 [HAVING 条件];\n```\n\n```sql\n# store_id 和 salesdate 相同的分为一组\nselect store_id, sum(sales_volume), salesdate\nfrom store_table\ngroup by store_id, salesdate\n```\n\n分组的目的是为了统计，所以分组一般会与聚合函数一起使用。只进行分组是没有意义的。\n\n```sql\n-- 只分组不统计 这样写没有意义\nSELECT * FROM emp GROUP BY sex; \n-- 分组返回每组的第一条数据\n```\n\n示例：\n\n```sql\n#1 通过性别字段 进行分组,求各组的平均薪资\nselect sex,avg(salary)'平均薪资' from emp GROUP BY sex;\n\n#2 查询每个部门的平均薪资 \nselect dept_name'部门',avg(salary)'平均薪资' from emp GROUP BY dept_name;\n\n#3 查询每个部门的平均薪资, 部门名称不能为null\nselect dept_name'部门',avg(salary)'平均薪资' from emp where dept_name is not null GROUP BY dept_name;\n\n#4 查询平均薪资大于6000的部门\n-- 先对源数据where过滤掉部门为null的数据，接着按部门分组聚合统计各部门的平均薪资，最后再通过having过滤出平均薪资大于6000的部门。\nSELECT\n\tdept_name '部门',\n\tavg( salary ) '平均薪资' \nFROM\n\temp \nWHERE\n\tdept_name IS NOT NULL \nGROUP BY\n\tdept_name \nHAVING\n\tavg( salary ) > 6000;\n```\n\n**where和having的区别**\n\n- where 进行分组前的过滤，where 后面不能写聚合函数\n- having 是分组后的过滤，having 后面可以写聚合函数\n\n### limit\n\nlimit是限制的意思,用于限制返回的查询结果的行数 (可以通过limit指定查询多少行数据)\n\nlimit 语法是 MySql的方言,用来完成分页\n\n```sql\nSELECT 字段1,字段2... FROM 表名 LIMIT offset , length;\n```\n\noffset 起始行数，从0开始记数， 如果省略 则默认为 0。\nlength 返回的行数。\n\n```sql\n# 查询emp表中的前5条数据\n-- 参数1:起始值,默认是0; 参数2:要查询的条数 \nSELECT * FROM emp LIMIT 5;\nSELECT * FROM emp LIMIT 0 , 5;\n# 查询emp表中 从第4条开始,查询6条 -- 起始值默认是从0开始的.\nSELECT * FROM emp LIMIT 3 , 6;\n```\n\n**分页**\n\n```sql\n-- 分页操作 每页显示3条数据\nSELECT * FROM emp LIMIT 0,3; -- 第1页 \nSELECT * FROM emp LIMIT 3,3; -- 第2页\nSELECT * FROM emp LIMIT 6,3; -- 第3页\n-- 分页公式 起始索引 =(当前页 -1)* 每页条数 \n-- limit是MySql中的方言\n/*\n分页，每页显示3条\n第1页，1，2，3\n第2页，4，5，6\n第3页，7，8，9\n第1页，第1条开始，相对第1条偏移0条，显示3条\n第2页，第4条开始，相对第1条偏移3条，显示3条\n第3页，第7条开始，相对第1条偏移6条，显示3条\n当前页偏移量=当前页之前所有页的显示条数总和\n当前页偏移量计算公式：（页数-1）*每页显示条数\n*/\n```\n\n## SQL约束\n\n约束，就是对数据进一步限制，从而保证数据的有效性、正确性、完整性。违反约束的数据将无法插入到数据表中。\n\n约束是针对字段的。\n\n常见约束：\n\n- 主键（primary key）\n- 唯一（unique）\n- 非空（not null）\n- 外键（foreign key）\n- 默认值（default）\n\n### 主键\n\n作用：用来唯一标识数据表中的每一条记录。\n\n特点：不可重复，唯一，非空。\n\n```\n字段名 字段类型 primary key\nprimary key(字段名)\n```\n\n```sql\n# 方式1 创建一个带主键的表 \nCREATE TABLE emp2(eid INT PRIMARY KEY, ename VARCHAR(20));\n\n# 方式2 创建一个带主键的表 \nCREATE TABLE emp2(eid INT, ename VARCHAR(20), PRIMARY KEY(eid));\n\n# 方式3 向已经创建的表添加主键\nALTER TABLE emp2 ADD PRIMARY KEY(eid);\n\n-- 删除表中的主键\nALTER TABLE emp2 DROP PRIMARY KEY;\n```\n\n#### 主键自增\n\n```\n关键字:\nAUTO_INCREMENT 表示自动增长(字段类型必须是整数类型)\n```\n\n数据库在插入数据时，如果主键自增字段不填写数据，数据库会以自增的形式自动生成主键字段的值。默认从1或者上一条记录的主键字段值开始自增，也可以指定起始值。\n\n```sql\n-- 创建主键自增的表 \nCREATE TABLE emp2(\n  -- 关键字 AUTO_INCREMENT,主键类型必须是整数类型 \n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20),\n  sex CHAR(1)\n);\n\n-- 创建主键自增的表,自定义自增起始值 \nCREATE TABLE emp2(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20),\n  sex CHAR(1)\n)AUTO_INCREMENT=100;\n```\n\n**delete**删除数据不会影响自增，自增会接着删除前的数据自增。\n\n**truncate**删除数据再自增会从1开始，因为truncate是将表删除再复制一个表结构相同的新表。\n\n### 非空\n\n特点：该列不允许为null\n\n```\n字段名 字段类型 not null\n```\n\n```sql\n# 非空约束\nCREATE TABLE emp2(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  -- 添加非空约束, ename字段不能为空 \n  ename VARCHAR(20) NOT NULL,\n  sex CHAR(1)\n);\n```\n\n**空字符串('')不等于null，可以插入**。\n\n```sql\n# 插入''成功\ninsert into emp2 (ename,sex) values('','男');\t-- OK, Time: 0.000000s\n```\n\n### 唯一\n\n特点：该列的值不能重复（对null会忽略不做判断）\n\n```\n字段名 字段值 unique\n```\n\n```sql\n#创建emp3表 为ename 字段添加唯一约束 \nCREATE TABLE emp3(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20) UNIQUE,\n  sex CHAR(1)\n);\n```\n\n主键约束和唯一约束的区别：\n\n- 主键约束，唯一且不能够为空(主键约束=非空约束+唯一约束)。\n- 唯一约束，唯一 但是可以为空。\n- 一个表中只能有一个主键，但是可以有多个唯一约束。\n\n### 默认值\n\n作用：用来指定该列的默认值。\n\n```\n字段名 字段类型 DEFAULT 默认值\n```\n\n```sql\n-- 创建带有默认值的表 \nCREATE TABLE emp4(\n\teid INT PRIMARY KEY AUTO_INCREMENT, \n\tename VARCHAR(20),\n  -- 为sex字段添加默认值\n\tsex CHAR(1) DEFAULT '女'\n);\n\n-- 添加数据 使用默认值\nINSERT INTO emp4(ename,sex) VALUES('张三',DEFAULT); \nINSERT INTO emp4(ename) VALUES('李四');\n```\n\n### 外键约束\n\n数据表A中某一个字段，指向数据表B中的主键，那么数据表A中的这一字段就是外键。\n\n在这种关系场景中，外键所在的表叫做从表，外键所指向表叫做主表。\n\n作用：使两张数据表产生对应关系。\n\n特点：\n\n- 从表插入数据时，外键字段的值必须在主表主键字段中存在，外键字段类型必须和主表主键字段类型保持一致。\n\n- 一张表可以有多个外键。表明该表与多个表有关联。\n\n```sql\n-- 新建表时添加外键\n[CONSTRAINT] [外键约束名称] FOREIGN KEY(外键字段名) REFERENCES 主表名(主键字段名);\n-- 已有表添加外键\nALTER TABLE 从表名 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主键字段名);\n\n-- 删除外键\nalter table 从表名 drop foreign key 外键约束名称\n\n-- 添加外键\nALTER TABLE 从表 ADD [CONSTRAINT] [外键约束名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主 键字段名);\n```\n\n```sql\n-- 添加外键约束，创建employee表\nCREATE TABLE employee(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20),\n  age INT,\n  dept_id INT, -- 外键字段类型要和主表的主键字段类型保持一致 \n  -- 添加外键约束\n  CONSTRAINT emp_dept_fk FOREIGN KEY(dept_id) REFERENCES department(id)\n);\n\n-- 添加数据 (从表外键对应主表主键)\nINSERT INTO employee (ename, age, dept_id) VALUES ('张百万', 20, 1); \nINSERT INTO employee (ename, age, dept_id) VALUES ('赵四', 21, 1); \nINSERT INTO employee (ename, age, dept_id) VALUES ('广坤', 20, 2); \nINSERT INTO employee (ename, age, dept_id) VALUES ('小斌', 20, 2); \n\n-- 插入一条有问题的数据 (部门id在主表主键中不存在)\n-- Cannot add or update a child row: a foreign key constraint fails \nINSERT INTO employee (ename, age, dept_id) VALUES ('错误', 18, 3);\n\n-- 删除employee 表中的外键约束,外键约束名 emp_dept_fk \nALTER TABLE employee DROP FOREIGN KEY emp_dept_fk;\n\n-- 可以省略外键名称, 系统会自动生成一个\nALTER TABLE employee ADD FOREIGN KEY (dept_id) REFERENCES department (id);\n```\n\n**注意事项**\n\n- 添加数据时, 应该先添加主表中的数据。\n- 删除数据时,应该先删除从表中的数据。\n- 从表外键类型必须与主表主键类型一致 否则创建失败。\n\n#### 级联删除\n\n删除主表数据的同时，自动删除掉从表数据\n\n```\n级联删除\nON DELETE CASCADE\n```\n\n```sql\n-- 重新创建添加级联操作 \nCREATE TABLE employee(\n  eid INT PRIMARY KEY AUTO_INCREMENT,\n  ename VARCHAR(20),\n  age INT,\n  dept_id INT,\n  CONSTRAINT emp_dept_fk FOREIGN KEY(dept_id) REFERENCES department(id) -- 添加级联删除\n  ON DELETE CASCADE\n);\n```\n\n## 多表查询\n\n查询多张表(至少涉及2张表),获取到需要的数据。\n\n### 交叉连接查询\n\n直接使用select语句查询两张表。\n\n```\nSELECT 字段名 FROM 表1, 表2;\n```\n\n交叉连接查询会产生笛卡尔积，查询结果有误\n\n#### 笛卡尔积\n\n![img](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-05_19-44-43.jpg)\n\n### 内连接查询\n\n#### 隐式内连接\n\n交叉连接查询+where条件过滤\n\n```\nSELECT 字段名 FROM 左表, 右表 WHERE 连接条件;\n```\n\n```sql\n# 隐式内连接\nSELECT * FROM products,category WHERE category_id = cid;\n\n#查询 格力空调是属于哪一分类下的商品\nSELECT \np.pname, c.cname\nFROM \nproducts p , category c \nWHERE \np.category_id = c.cid \nAND p.pname = '格力空调';\n```\n\n#### 显示内连接\n\n使用**[inner] join ... on ...关键字**。\n\n```\nSELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]] -- inner 可以省略\n```\n\n```sql\n# 显式内连接查询\nSELECT * FROM products p INNER JOIN category c ON p.category_id = c.cid;\n\n# 查询鞋服分类下,价格大于500的商品名称和价格\nSELECT \np.pname,p.price\nFROM products p INNER JOIN category c \nON p.category_id = c.cid \nWHERE p.price > 500 AND cname = '鞋服';\n```\n\n### 外连接查询\n\n#### 左外连接\n\n使用left [outer] join ... on ...关键字\n\n```\nSELECT 字段名 FROM 左表 LEFT [OUTER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]]\n```\n\n特点：\n\n- 左表为基准, 右表去查询左表\n- 返回结果时，左表数据正常展示，右表在左表中查询得到的数据正常展示，查询不到的展示为Null\n\n```sql\n# 左外连接查询\nselect * from category c left join products p on c.cid = p.category_id;\n\n# 分类表中有汽车类目，商品表中并并没有该类目的商品\nc001\t家电\tp001\t小 米 电 视 机 \t5000\t1\tc001\nc001\t家电\tp002\t格 力 空 调 \t3000\t1\tc001\nc001\t家电\tp003\t美 的 冰 箱 \t4500\t1\tc001\nc002\t鞋服\tp004\t篮 球 鞋 \t800\t1\tc002\nc002\t鞋服\tp005\t运 动 裤 \t200\t1\tc002\nc002\t鞋服\tp006\tT 恤 \t300\t1\tc002\nc002\t鞋服\tp007\t冲 锋 衣 \t2000\t1\tc002\nc003\t化妆品\tp008\t神 仙 水 \t800\t1\tc003\nc003\t化妆品\tp009\t大 宝 \t200\t1\tc003\nc004\t汽车\t\n\n# 查询每个分类下的商品个数\nselect \nc.cname, count(p.pid) \nfrom \ncategory c left join products p \non c.cid = p.category_id \ngroup by c.cname;\n```\n\n#### 右外连接\n\n使用 right [outer] join ... on ... 关键字\n\n```\nSELECT 字段名 FROM 左表 RIGHT [OUTER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]]\n```\n\n特点：和左外连接一样，只是以右表为基准。\n\n### 小结\n\n![img](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-05_21-50-07.jpg)\n\n2个以上表如何多表查询，思路是先选2个进行查询，将查询结果当作一个新的表，再和下一个表进行多表查询，以此类推。\n\n### join on and 和 join on where and\n\n在使用left join时，on和where条件的区别如下：  \n\n1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。（实际上左连接中如果and语句是对左表进行过滤的，那么不管真假都不起任何作用。如果是对右表过滤的，那么左表所有记录都返回，右表筛选以后再与左表连接返回） \n\n2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉，on后的条件用来生成左右表关联的临时表，where后的条件对临时表中的记录进行过滤。\n\n 在使用inner join时，不管是对左表还是右表进行筛选，on and和on where都会对生成的临时表进行过滤。\n\n————————————————\n版权声明：本文为CSDN博主「行者摩罗」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/xingzhemoluo/article/details/39677891\n\n## 合并查询\n\nunion和union all\n\nunion/union all操作符用来合并多个select语句的结果集（就是查询结果）。\n\nunion 和 union all 都要满足以下条件才能合并：\n\n- 要合并的结果集，列数必须相同，列的顺序必须一致，列的字段类型也必须相似。\n\nunion 和 union all 的区别：\n\n- union：消除重复行，重复检查期间，null值会被算在内。\n- union all：不消除重复行，只是将结果集合并后就返回。\n- 执行效率上，union all 要比 union 快很多。\n\n```sql\nSELECT column1 [, column2 ]\nFROM table1 [, table2 ]\n[WHERE condition]\nUNION / UNION ALL\nSELECT column1 [, column2 ]\nFROM table1 [, table2 ]\n[WHERE condition]\n```\n\n## 子查询\n\n子查询概念：一条select 查询语句的结果, 作为另一条 select 语句的一部分。\n\n特点：\n\n- 子查询必须放在小括号中\n- 整个sql至少会有两个select关键字\n\n子查询常见分类\n\n- **where型子查询**：将子查询的结果, 作为父查询的比较条件\n- **from型子查询 **：将子查询的结果, 作为 一张表,提供给父层查询使用\n- **exists型子查询**：子查询的结果是单列多行, 类似一个数组, 父层查询使用 IN 函数 ,包含子查询的结果\n\n### where型子查询\n\n当子查询的结果是一个值时（单行单列）\n\n```\nSELECT 查询字段 FROM 表 WHERE 字段 = (子查询);\n```\n\n```sql\n# 子查询的方式, 查询价格最高的商品信息\nselect * from products where price = (select max(price) from products);\n\n# 查询化妆品分类下的 商品名称 商品价格\n-- 子查询\nselect p.pname, p.price from products p where p.category_id = (select cid from category where cname = '化妆品');\n-- 内连接查询\nselect  p.pname,p.price from products p join category c on p.category_id = c.cid where c.cname = '化妆品';\n```\n\n### exists型子查询\n\n当子查询的结果是一个集合时（多行单列），需要用where ... in (子查询)\n\n```\nSELECT 查询字段 FROM 表 WHERE 字段 in (子查询);\n```\n\n```sql\n# 查询价格小于两千的商品,来自于哪些分类(名称)\nselect cname from category where cid in (select category_id from products where price < 2000);\n\n# 查询家电类 与 鞋服类下面的全部商品信息\nselect * from products where category_id in (select cid from category where cname in('家电','鞋服'));\n```\n\n### from型子查询\n\n当子查询的结果是一个表（多列多行）\n\n```\nSELECT 查询字段 FROM (子查询)表别名 WHERE 条件;\n```\n\n```sql\n# 查询商品中,价格大于500的商品信息,包括 商品名称 商品价格 商品所属分类名称\n-- 子查询\nselect p.pname,p.price,c.cname from (select * from products where price > 500) p join category c on p.category_id = c.cid;\n-- 内连接查询\nselect p.pname,p.price,c.cname from products p  join category c on p.category_id = c.cid where p.price > 500;\n```\n\n**当子查询作为一张表的时候，需要起别名，否则无法访问表中的字段。**\n\n# SQL语句执行顺序\n\n```\n1. from \n2. join \n3. on \n4. where \n5. group by(开始使用select中的别名，后面的语句中都可以使用)\n6.  avg,sum.... \n7. having \n8. select \n9. distinct \n10. order by\n11. limit \n```\n\n```\n1、FROM  table1 left join table2 on 将table1和table2中的数据产生笛卡尔积，生成Temp1\n\n2、JOIN table2  所以先是确定表，再确定关联条件\n\n3、ON table1.column = table2.columu 确定表的绑定条件 由Temp1产生中间表Temp2\n\n4、WHERE  对中间表Temp2产生的结果进行过滤  产生中间表Temp3\n\n5、GROUP BY 对中间表Temp3进行分组，产生中间表Temp4\n\n6、HAVING  对分组后的记录进行聚合 产生中间表Temp5\n\n7、SELECT  对中间表Temp5进行列筛选，产生中间表 Temp6\n\n8、DISTINCT 对中间表 Temp6进行去重，产生中间表 Temp7\n\n9、ORDER BY 对Temp7中的数据进行排序，产生中间表Temp8\n\n10、LIMIT 对中间表Temp8进行分页，产生中间表Temp9\n```\n\n# 案例1\n\n```sql\n# 查询线索(二级渠道jdsc)后续转化成交车型详情。\n-- 在二级渠道jdsc下，成交的线索，的车型详情\n-- 线索表中二级渠道下的线索 和 订单表中的线索 的 交集。所以使用内连接查询。\nselect * from clue_day c, order_day o where c.clue_id = o.clue_id and c.ca_n = 'jdsc';\nselect * from clue_day c join order_day o on c.clue_id = o.clue_id where c.ca_n = 'jdsc';\n```\n\n# 案例2\n\n```sql\n# 统计所有渠道(按照二级渠道)的转化率\n-- 转化率 = 该渠道下订单数/该渠道下线索数。订单数是线索数的子集，所以使用外连接查询。\n-- 统计每一个二级渠道的转化率：按二级渠道分组聚合统计\nselect c.ca_n, count(o.order_id)/count(c.clue_id) \nfrom clue_day c left join order_day o \non c.clue_id = o.clue_id \ngroup by c.ca_n;\n```\n\n# 案例3\n\n```sql\n# 查询各城市线索数并计算所有城市线索总数\n-- 各城市线索数只需要用到clue表一张表，因此不需要多表查询\n-- 各城市线索数，需要按城市分组求和\n-- 各城市线索数，加起来就是所有城市线索总数，因此是子查询❌\n-- 错误原因：子查询无法将两个结果展示在一张表中\n-- 使用合并查询，将两个结果拼在一张表中。\n-- 所有城市线索总数，也不需要先计算各城市线索数再求和，直接对clue表的线索求和即可。\n\nselect c.city_id,count(c.clue_id)clue_num from clue_day c group by c.city_id\nunion\nselect '总计',count(c.clue_id) from clue_day c;\n```\n\n# 案例4\n\n日期直接相减做了一个隐式转换操作，将时间转换为整数，但并不是用unix_timestamp转换，而是直接把年月日时分秒拼起来，如2013-04-21 16:59:33 直接转换为20130421165933，所以得到的结果是错误的。\n\nUnix_timestamp([日期])函数：返回自'1970-01-01 00:00:00'的到当前日期[指定日期]的秒数差。\n\nDatediff(d1,d2)函数：返回d1-d2的天数差\n\nCeil()函数：向上取整\n\n```sql\n-- 找出优质渠道，做重点投入\n-- 我们对于优质渠道(以二级渠道来说)的定义: \n-- 该二级渠道内平均转化周期< 整体平均转化周期\n-- 该二级渠道的线索量 > 各二级渠道平均线索量\n\n/*\n\t针对《二级渠道内平均转化周期》和《二级渠道的线索量》的分析\n\t转化周期:成单日期 — 线索创建日期 平均:avg\n\t渠道线索量:分组 count统计\n*/\n-- 这里需要注意：二级渠道线索量是所有二级渠道的，其中包括未成单的二级渠道。\n-- 因此这里使用关联查询时，首先排除内连接，因为内连接只能查出成单的二级渠道\n-- 其次使用外连接时，clue表应该作为主表将渠道全部展示出来\nselect ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \nfrom clue_day c left join order_day o on c.clue_id = o.clue_id\nwhere created_at is not null and clue_created_at is not NULL\ngroup by ca_n\n\n-- 二级渠道平均线索量\nselect ceil(avg(clue_num)) from (\n  select ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \n  from clue_day c left join order_day o \ton c.clue_id = o.clue_id\n  where created_at is not null and clue_created_at is not NULL\n  group by ca_n\n)a -- 子查询作为一张表时，必须有别名才能访问其中的字段\n\n-- 整体平均转化周期\nSELECT avg(datediff( created_at, clue_created_at )) \nFROM clue_day c LEFT JOIN order_day o ON c.clue_id = o.clue_id \nWHERE created_at IS NOT NULL AND clue_created_at IS NOT NULL\n\n-- 查询结果\nselect ca_n, avg_time, clue_num from (\n  -- 《二级渠道内平均转化周期》和《二级渠道的线索量》\n  select ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \n  from clue_day c left join order_day o on c.clue_id = o.clue_id\n  where created_at is not null and clue_created_at is not NULL\n  group by ca_n\n)\nWHERE avg_time < (\n  -- 整体平均转化周期\n\tSELECT avg(datediff( created_at, clue_created_at )) \n\tFROM clue_day c LEFT JOIN order_day o ON c.clue_id = o.clue_id \n\tWHERE created_at IS NOT NULL AND clue_created_at IS NOT NULL \n\t) \nAND clue_num > (\n  -- 二级渠道平均线索量\n  select ceil(avg(clue_num)) from (\n    select ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \n    from clue_day c left join order_day o \ton c.clue_id = o.clue_id\n    where created_at is not null and clue_created_at is not NULL\n    group by ca_n\n\t)a \n);\n```\n\n一段sql查询多次作为子查询被使用，可以用with 别名 as (子查询) 优化：\n\n```sql\n-- 《二级渠道内平均转化周期》和《二级渠道的线索量》\nwith ca_value as (\n  select ca_n, avg(datediff(created_at,clue_created_at)), count(c.clue_id) \n  from clue_day c left join order_day o on c.clue_id = o.clue_id\n  where created_at is not null and clue_created_at is not NULL\n  group by ca_n\n)\n-- 查询结果\nselect ca_n, avg_time, clue_num from ca_value\nWHERE avg_time < (\n\tSELECT avg(datediff( created_at, clue_created_at )) \n\tFROM clue_day c LEFT JOIN order_day o ON c.clue_id = o.clue_id \n\tWHERE created_at IS NOT NULL AND clue_created_at IS NOT NULL \n\t) \nAND clue_num > (SELECT ceil(avg( clue_num )) FROM ca_value);\n```\n\n**⚠️注意**：[with...as...的用法](https://bbs.csdn.net/topics/390280176)\n\n# 扩展\n\n```sql\ncase\n when 条件1 then 结果1\n when 条件2 then 结果2\n ...\n else 结果（默认null） -- 上面条件都不满足时，返回else结果；如果不写else，默认也返回null\n end\n```\n\n\n\n","slug":"【数据分析】第二阶段：MySQL数据分析实战（一）","published":1,"updated":"2021-05-14T10:45:54.400Z","_id":"ckohezbq8002fwct4hlnae7s4","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"MySQL基础\"><a href=\"#MySQL基础\" class=\"headerlink\" title=\"MySQL基础\"></a>MySQL基础</h1><h2 id=\"数据库基本概念\"><a href=\"#数据库基本概念\" class=\"headerlink\" title=\"数据库基本概念\"></a>数据库基本概念</h2><p>数据库是按照数据结构来组织、存储和管理数据的仓库。其本质是一个文件系统，以文件的形式将数据保存在电脑上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">文件 --&gt; 文件系统 --&gt; 计算机磁盘</span><br></pre></td></tr></table></figure>\n\n<p>数据库（DB），数据库管理系统（DBMS）</p>\n<p>关系型数据库（RDB）：关系型数据库是创建在关系模型基础上的数据库。</p>\n<p>关系模型：有明确的行和列的二维表格模型。（就像excel表一样）</p>\n<p>IOE：IBM小型机，Oracle数据库，EMC易安信。</p>\n<p>客户端与服务端建立连接；写SQL，执行SQL语句操作MySQL数据库。</p>\n<p>字段：表中每一列成为一个字段，字段有自己的属性，如字段类型、字段大小等，字段类型决定了字段能够存储哪种数据。字段属性在建表时就必须定义好。</p>\n<p>索引：索引是一种单独的、物理的数据库结构。它依赖于表建立。</p>\n<p>视图：视图是从一张或多张表中到处的表（也称虚拟表），是用户产看表中数据的一种方式。</p>\n<h2 id=\"MySQL数据库\"><a href=\"#MySQL数据库\" class=\"headerlink\" title=\"MySQL数据库\"></a>MySQL数据库</h2><p>MySQL是C和C++编写的。</p>\n<p>MySQL支持多线程。</p>\n<p>MySQL存储引擎：存储引擎是MySQL数据库的核心。它决定了数据如何存储，查询的时候如何搜索数据，索引如何创建等等。</p>\n<p>常用存储引擎：</p>\n<ul>\n<li>InnoDB：MySQL5.1版本之后默认存储引擎。</li>\n<li>MyISAM：MySQL5.1版本之前默认存储引擎。</li>\n<li>Memory</li>\n</ul>\n<p>MySQL数据类型主要分为数值型、字符串型、日期时间型三大类。</p>\n<p>字符串型char和varchar：</p>\n<ul>\n<li><p>char固定长度，char(5)会在内存中占用5个字符的空间，即使只存入了3个字符。</p>\n</li>\n<li><p>varchar可变长度，varchar(5)存入3个字符，就只占用3个字符的空间。</p>\n</li>\n<li><p>char浪费空间，但查询时整体匹配，效率更高，比如存入abc，查询时会直接匹配整体是否是abc。</p>\n</li>\n<li><p>varchar节省空间，但查询时不是整体匹配，效率不高，比如存入abc，查询时先匹配a再匹配b再匹配c。</p>\n</li>\n</ul>\n<p>MySQL Server安装目录下，bin目录下的mysql就是自带的命令行客户端。</p>\n<p>访问数据库命令行：mysql -h127.0.01 -uroot -p123456</p>\n<ul>\n<li>mysql：使用mysql客户端访问服务端</li>\n<li>-h127.0.01：当前服务端是本机，所以使用-h127.0.0.1指定访问本地127.0.0.1地址的服务。因为服务端在本地，这部分也可以不写会自动访问本地服务。</li>\n<li>-uroot：登陆用户是root</li>\n<li>-p123456：登陆密码是123456</li>\n</ul>\n<h1 id=\"SQL语句\"><a href=\"#SQL语句\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h1><p>SQL语句按功能分为以下几类：</p>\n<ul>\n<li>DDL语句（Data Definition Language 数据定义语言)</li>\n<li>DML语句（Data Manipulation Language 数据操作语言)</li>\n<li>DQL语句（Data QueryLanguage 数据查询语言)</li>\n<li>DCL语句（Data Controll Language 数据控制语言)</li>\n</ul>\n<p><strong>SQL语句的执行顺序：1、最先执行from tab；2、where语句是对条件加以限定；3、分组语句【group by…… having】；4、聚合函数；5、select语句；6、order by排序语句。</strong></p>\n<h2 id=\"增删改\"><a href=\"#增删改\" class=\"headerlink\" title=\"增删改\"></a>增删改</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 新建数据库 create database 数据库名;</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> DATABASE db1;</span><br><span class=\"line\"><span class=\"comment\">-- 新建数据库，并指定字符集 create database 数据库名 character set 字符集;</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> DATABASE db1_1 <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 切换数据库 从db1 切换到 db1_1 </span></span><br><span class=\"line\">USE db1_1;</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前正在使用的数据库 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> DATABASE();</span><br><span class=\"line\"><span class=\"comment\">-- 查看Mysql中有哪些数据库 </span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> DATABASES;</span><br><span class=\"line\"><span class=\"comment\">-- 查看一个数据库的定义信息 </span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> DATABASE db1_1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 将数据库db1 的字符集 修改为 utf8 </span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> DATABASE db1 <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8;</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前数据库的基本信息，发现编码已更改 </span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> DATABASE db1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除某个数据库 </span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> DATABASE db1_1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建表</span></span><br><span class=\"line\"><span class=\"comment\">/* CREATE TABLE 表名(</span></span><br><span class=\"line\"><span class=\"comment\">字段名称1 字段类型(长度)，</span></span><br><span class=\"line\"><span class=\"comment\">字段名称2 字段类型 注意 最后一列不要加逗号</span></span><br><span class=\"line\"><span class=\"comment\">);*/</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> category(</span><br><span class=\"line\">cid <span class=\"type\">INT</span>,</span><br><span class=\"line\">    cname <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">快速创建一个表结构相同的表(仅复制表结构，不会复制数据)</span></span><br><span class=\"line\"><span class=\"comment\">create table 新表名 like 旧表名;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">-- 创建一个表结构与 test1 相同的 test2表 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> test2 <span class=\"keyword\">LIKE</span> test1;</span><br><span class=\"line\"><span class=\"comment\">-- 查看表结构 </span></span><br><span class=\"line\"><span class=\"keyword\">DESC</span> test2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看当前数据库中的所有表名 </span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TABLES;</span><br><span class=\"line\"><span class=\"comment\">-- 显示当前数据表的结构 </span></span><br><span class=\"line\"><span class=\"keyword\">DESC</span> category;</span><br><span class=\"line\"><span class=\"comment\">-- 查看创建表的SQL语句</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> category;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 直接删除 test1 表 </span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> test1;</span><br><span class=\"line\"><span class=\"comment\">-- 先判断表是否存在 再删除test2表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> test2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改表名 rename table 旧表名 to 新表名;</span></span><br><span class=\"line\">RENAME <span class=\"keyword\">TABLE</span> category <span class=\"keyword\">TO</span> category1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 向表中添加列 alter table 表名 add 字段名称 字段类型</span></span><br><span class=\"line\"># 为分类表添加一个新的字段为 分类描述 cdesc <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> category <span class=\"keyword\">ADD</span> cdesc <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改表中列的数据类型或长度 alter table 表名 modify 字段名称 字段类型</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> category MODIFY cdesc <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改列名称 alter table 表名 change 旧列名 新列名 类型(长度);</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> category CHANGE cdesc description <span class=\"type\">VARCHAR</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除列 alter table 表名 drop 列名;</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> category <span class=\"keyword\">DROP</span> description;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入数据，插入数据是插入一行数据</span></span><br><span class=\"line\"><span class=\"comment\">-- insert into 表名 (字段名1，字段名2...) values(字段值1，字段值2...);</span></span><br><span class=\"line\"><span class=\"comment\">-- 方式1: 插入全部字段， 将所有字段名都写出来</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> student (sid,sname,age,sex,address) <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>,<span class=\"string\">&#x27;孙悟 空 &#x27;</span>,<span class=\"number\">20</span>,<span class=\"string\">&#x27;男 &#x27;</span>,<span class=\"string\">&#x27;花 果 山 &#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 方式2: 插入全部字段，不写字段名</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> student <span class=\"keyword\">VALUES</span>(<span class=\"number\">2</span>,<span class=\"string\">&#x27;孙悟饭&#x27;</span>,<span class=\"number\">10</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;地球&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 方式3:插入指定字段的值</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> category (cname) <span class=\"keyword\">VALUES</span>(<span class=\"string\">&#x27;白骨精&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 更改数据，更新数据是更新某一列数据</span></span><br><span class=\"line\"><span class=\"comment\">-- 不带条件的修改 update 表名 set 列名 = 值</span></span><br><span class=\"line\">UPDATE student <span class=\"keyword\">SET</span> sex <span class=\"operator\">=</span> <span class=\"string\">&#x27;女&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 带条件的修改 update 表名 set 列名 = 值 [where 条件表达式:字段名 = 值 ]</span></span><br><span class=\"line\">UPDATE student <span class=\"keyword\">SET</span> sex <span class=\"operator\">=</span> <span class=\"string\">&#x27;男&#x27;</span> <span class=\"keyword\">WHERE</span> sid <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 一次修改多个列</span></span><br><span class=\"line\">UPDATE student <span class=\"keyword\">SET</span> age <span class=\"operator\">=</span> <span class=\"number\">20</span>,address <span class=\"operator\">=</span> <span class=\"string\">&#x27;北京&#x27;</span> <span class=\"keyword\">WHERE</span> sid <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除数据</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> 表名;</span><br><span class=\"line\"><span class=\"keyword\">truncate</span> <span class=\"keyword\">table</span> 表名;</span><br><span class=\"line\"><span class=\"comment\">-- 指定条件 删除数据</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> 表名 [<span class=\"keyword\">where</span> 字段名 <span class=\"operator\">=</span> 值];</span><br></pre></td></tr></table></figure>\n\n<p><strong>当一个表中数据条数非常多，又要做删除动作的时候，如果用delete会很慢，那我们可以使用 truncate 。</strong></p>\n<p><strong>delete from 表名; 不推荐. 有多少条记录 就执行多少次删除操作. 效率低。</strong></p>\n<p><strong>truncate table 表名: 推荐. 先删除整张表, 然后再重新创建一张一模一样的表. 效率高。</strong></p>\n<h2 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询所有数据</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> 表名</span><br><span class=\"line\"><span class=\"comment\">-- 查询某一列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> 列名<span class=\"number\">1</span>,列名<span class=\"number\">2</span> <span class=\"keyword\">from</span> 表名</span><br><span class=\"line\"><span class=\"comment\">-- 使用 AS关键字,为列起别名 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> eid <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;编号&#x27;</span>, ename <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;姓名&#x27;</span> , sex <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;性别&#x27;</span> <span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"><span class=\"comment\">-- AS 可以省略 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> eid <span class=\"string\">&#x27;编号&#x27;</span>, ename <span class=\"string\">&#x27;姓名&#x27;</span> , sex <span class=\"string\">&#x27;性别&#x27;</span> <span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"><span class=\"comment\">-- 使用distinct 关键字,去掉重复部门信息 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> dept_name <span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"><span class=\"comment\">-- 运算查询 (查询结果参与运算)</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ename , salary <span class=\"operator\">+</span> <span class=\"number\">1000</span> <span class=\"keyword\">FROM</span> emp;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>比较运算符</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&gt; &lt; &lt;= &gt;= = &lt;&gt; !=</td>\n<td>大于、小于、小于(大于)等于、等于、不等于</td>\n</tr>\n<tr>\n<td>BETWEEN …AND…</td>\n<td>显示在某一区间的值 <br />例如: 2000-10000之间: Between 2000 and 10000</td>\n</tr>\n<tr>\n<td>IN(集合)</td>\n<td>集合表示多个值,使用逗号分隔,<br />例如: name in (悟空，八戒) in中的每个数据都会作为一次条件,只要满足条件就会显示</td>\n</tr>\n<tr>\n<td>LIKE ‘%张%’</td>\n<td>模糊查询<br />通配符%，表示匹配任意多个字符串<br />通配符_，表示匹配一个字符<br />where name like ‘%王%’; – name中有王的<br />where name like ‘王%’; – name中以王开头的<br />where name like ‘_王%’；– name中第二个字是王的</td>\n</tr>\n<tr>\n<td>IS NULL</td>\n<td>查询某一列为NULL的值, 注: 不能写 = NULL</td>\n</tr>\n<tr>\n<td><strong>逻辑运算符</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>And &amp;&amp;</td>\n<td>多个条件同时成立</td>\n</tr>\n<tr>\n<td>Or ||</td>\n<td>多个条件任一成立</td>\n</tr>\n<tr>\n<td>Not</td>\n<td>不成立，取反。<br />和IS NULL组合使用，就是查询字段不是Null的数据。<br />where dept_name IS NOT NULL;</td>\n</tr>\n</tbody></table>\n<h2 id=\"核心查询\"><a href=\"#核心查询\" class=\"headerlink\" title=\"核心查询\"></a>核心查询</h2><h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 表名 [WHERE 字段 &#x3D; 值] ORDER BY 字段名 [ASC &#x2F; DESC]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 默认升序排序 ASC</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary;</span><br><span class=\"line\"><span class=\"comment\">-- 降序排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 组合排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>, eid <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Order by不会影响源数据，只用于展示结果。</p>\n<h3 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h3><p>也称为聚合统计或者聚合查询，使用聚合函数纵向查询，对某一列的值进行计算，然后返回一个单一的值(另外聚合函数会忽略null空 值。</p>\n<p>聚合函数：</p>\n<ul>\n<li>count(字段) 统计指定列不为NULL的记录行数。</li>\n<li>sum(字段) 计算指定列的数值和。</li>\n<li>max(字段) 计算指定列的最大值。</li>\n<li>min(字段) 计算指定列的最小值。</li>\n<li>avg(字段) 计算指定列的平均值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 聚合函数(字段名) FROM 表名;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"number\">1</span> 查询员工的总数</span><br><span class=\"line\"><span class=\"comment\">-- 统计表中的记录条数 使用 count()</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(eid) <span class=\"keyword\">FROM</span> emp; <span class=\"comment\">-- 使用某一个字段 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> emp; <span class=\"comment\">-- 使用 *</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"number\">1</span>) <span class=\"keyword\">FROM</span> emp; <span class=\"comment\">-- 使用 1,与 * 效果一样</span></span><br><span class=\"line\"><span class=\"comment\">-- 下面这条SQL 得到的总条数不准确,因为count函数忽略了空值 </span></span><br><span class=\"line\"><span class=\"comment\">-- 所以使用时注意不要使用带有null的列进行统计</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(dept_name) <span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">2</span> 查看员工总薪水、最高薪水、最小薪水、薪水的平均值</span><br><span class=\"line\"><span class=\"comment\">-- sum函数求和, max函数求最大, min函数求最小, avg函数求平均值 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\t<span class=\"built_in\">SUM</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;总薪水&#x27;</span>, </span><br><span class=\"line\">\t<span class=\"built_in\">MAX</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;最高薪水&#x27;</span>, </span><br><span class=\"line\">\t<span class=\"built_in\">MIN</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;最低薪水&#x27;</span>, </span><br><span class=\"line\">\t<span class=\"built_in\">AVG</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;平均薪水&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">3</span> 查询薪水大于<span class=\"number\">4000</span>员工的个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">WHERE</span> salary <span class=\"operator\">&gt;</span> <span class=\"number\">4000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">4</span> 查询部门为<span class=\"string\">&#x27;教学部&#x27;</span>的所有员工的个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">WHERE</span> dept_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;教学部&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">5</span> 查询部门为<span class=\"string\">&#x27;市场部&#x27;</span>所有员工的平均薪水 <span class=\"keyword\">SELECT</span></span><br><span class=\"line\"><span class=\"built_in\">AVG</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;市场部平均薪资&#x27;</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">WHERE</span> dept_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;市场部&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>⚠️注意：where中不能使用聚合函数，只能通过子查询实现</strong>。<a href=\"https://blog.csdn.net/fanbaodan/article/details/84304782\">https://blog.csdn.net/fanbaodan/article/details/84304782</a></p>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>分组查询指的是使用GROUP BY 语句，对查询的信息进行分组，相同数据作为一组。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 语法</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> 分组字段<span class=\"operator\">/</span>聚合函数 <span class=\"keyword\">FROM</span> 表名 [<span class=\"keyword\">where</span> 条件] <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> 分组字段 [<span class=\"keyword\">HAVING</span> 条件];</span><br><span class=\"line\"><span class=\"comment\">-- select后必须出现要分组的字段，除了分组字段、聚合函数，不能出现其他字段</span></span><br><span class=\"line\"><span class=\"comment\">-- where先对源数据过滤，having对分组聚合统计后的数据再过滤</span></span><br></pre></td></tr></table></figure>\n\n<p>Group by 后可以跟多个字段，按照多个字段进行分组</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 分组字段<span class=\"number\">1</span>, 分组字段<span class=\"number\">2</span>, 聚合函数 <span class=\"keyword\">FROM</span> 表名 [<span class=\"keyword\">where</span> 条件] <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> 分组字段<span class=\"number\">1</span>, 分组字段<span class=\"number\">2</span> [<span class=\"keyword\">HAVING</span> 条件];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># store_id 和 salesdate 相同的分为一组</span><br><span class=\"line\"><span class=\"keyword\">select</span> store_id, <span class=\"built_in\">sum</span>(sales_volume), salesdate</span><br><span class=\"line\"><span class=\"keyword\">from</span> store_table</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> store_id, salesdate</span><br></pre></td></tr></table></figure>\n\n<p>分组的目的是为了统计，所以分组一般会与聚合函数一起使用。只进行分组是没有意义的。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 只分组不统计 这样写没有意义</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sex; </span><br><span class=\"line\"><span class=\"comment\">-- 分组返回每组的第一条数据</span></span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"number\">1</span> 通过性别字段 进行分组,求各组的平均薪资</span><br><span class=\"line\"><span class=\"keyword\">select</span> sex,<span class=\"built_in\">avg</span>(salary)<span class=\"string\">&#x27;平均薪资&#x27;</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sex;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">2</span> 查询每个部门的平均薪资 </span><br><span class=\"line\"><span class=\"keyword\">select</span> dept_name<span class=\"string\">&#x27;部门&#x27;</span>,<span class=\"built_in\">avg</span>(salary)<span class=\"string\">&#x27;平均薪资&#x27;</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> dept_name;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">3</span> 查询每个部门的平均薪资, 部门名称不能为<span class=\"keyword\">null</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> dept_name<span class=\"string\">&#x27;部门&#x27;</span>,<span class=\"built_in\">avg</span>(salary)<span class=\"string\">&#x27;平均薪资&#x27;</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> dept_name <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> dept_name;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">4</span> 查询平均薪资大于<span class=\"number\">6000</span>的部门</span><br><span class=\"line\"><span class=\"comment\">-- 先对源数据where过滤掉部门为null的数据，接着按部门分组聚合统计各部门的平均薪资，最后再通过having过滤出平均薪资大于6000的部门。</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\tdept_name <span class=\"string\">&#x27;部门&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"built_in\">avg</span>( salary ) <span class=\"string\">&#x27;平均薪资&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\temp </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">\tdept_name <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\tdept_name </span><br><span class=\"line\"><span class=\"keyword\">HAVING</span></span><br><span class=\"line\">\t<span class=\"built_in\">avg</span>( salary ) <span class=\"operator\">&gt;</span> <span class=\"number\">6000</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>where和having的区别</strong></p>\n<ul>\n<li>where 进行分组前的过滤，where 后面不能写聚合函数</li>\n<li>having 是分组后的过滤，having 后面可以写聚合函数</li>\n</ul>\n<h3 id=\"limit\"><a href=\"#limit\" class=\"headerlink\" title=\"limit\"></a>limit</h3><p>limit是限制的意思,用于限制返回的查询结果的行数 (可以通过limit指定查询多少行数据)</p>\n<p>limit 语法是 MySql的方言,用来完成分页</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 字段<span class=\"number\">1</span>,字段<span class=\"number\">2.</span>.. <span class=\"keyword\">FROM</span> 表名 LIMIT <span class=\"keyword\">offset</span> , length;</span><br></pre></td></tr></table></figure>\n\n<p>offset 起始行数，从0开始记数， 如果省略 则默认为 0。<br>length 返回的行数。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询emp表中的前<span class=\"number\">5</span>条数据</span><br><span class=\"line\"><span class=\"comment\">-- 参数1:起始值,默认是0; 参数2:要查询的条数 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">0</span> , <span class=\"number\">5</span>;</span><br><span class=\"line\"># 查询emp表中 从第<span class=\"number\">4</span>条开始,查询<span class=\"number\">6</span>条 <span class=\"comment\">-- 起始值默认是从0开始的.</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">3</span> , <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>分页</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 分页操作 每页显示3条数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">0</span>,<span class=\"number\">3</span>; <span class=\"comment\">-- 第1页 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">3</span>,<span class=\"number\">3</span>; <span class=\"comment\">-- 第2页</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">6</span>,<span class=\"number\">3</span>; <span class=\"comment\">-- 第3页</span></span><br><span class=\"line\"><span class=\"comment\">-- 分页公式 起始索引 =(当前页 -1)* 每页条数 </span></span><br><span class=\"line\"><span class=\"comment\">-- limit是MySql中的方言</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">分页，每页显示3条</span></span><br><span class=\"line\"><span class=\"comment\">第1页，1，2，3</span></span><br><span class=\"line\"><span class=\"comment\">第2页，4，5，6</span></span><br><span class=\"line\"><span class=\"comment\">第3页，7，8，9</span></span><br><span class=\"line\"><span class=\"comment\">第1页，第1条开始，相对第1条偏移0条，显示3条</span></span><br><span class=\"line\"><span class=\"comment\">第2页，第4条开始，相对第1条偏移3条，显示3条</span></span><br><span class=\"line\"><span class=\"comment\">第3页，第7条开始，相对第1条偏移6条，显示3条</span></span><br><span class=\"line\"><span class=\"comment\">当前页偏移量=当前页之前所有页的显示条数总和</span></span><br><span class=\"line\"><span class=\"comment\">当前页偏移量计算公式：（页数-1）*每页显示条数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SQL约束\"><a href=\"#SQL约束\" class=\"headerlink\" title=\"SQL约束\"></a>SQL约束</h2><p>约束，就是对数据进一步限制，从而保证数据的有效性、正确性、完整性。违反约束的数据将无法插入到数据表中。</p>\n<p>约束是针对字段的。</p>\n<p>常见约束：</p>\n<ul>\n<li>主键（primary key）</li>\n<li>唯一（unique）</li>\n<li>非空（not null）</li>\n<li>外键（foreign key）</li>\n<li>默认值（default）</li>\n</ul>\n<h3 id=\"主键\"><a href=\"#主键\" class=\"headerlink\" title=\"主键\"></a>主键</h3><p>作用：用来唯一标识数据表中的每一条记录。</p>\n<p>特点：不可重复，唯一，非空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字段名 字段类型 primary key</span><br><span class=\"line\">primary key(字段名)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 方式<span class=\"number\">1</span> 创建一个带主键的表 </span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY, ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"># 方式<span class=\"number\">2</span> 创建一个带主键的表 </span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(eid <span class=\"type\">INT</span>, ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>), <span class=\"keyword\">PRIMARY</span> KEY(eid));</span><br><span class=\"line\"></span><br><span class=\"line\"># 方式<span class=\"number\">3</span> 向已经创建的表添加主键</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> emp2 <span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY</span> KEY(eid);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表中的主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> emp2 <span class=\"keyword\">DROP</span> <span class=\"keyword\">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"主键自增\"><a href=\"#主键自增\" class=\"headerlink\" title=\"主键自增\"></a>主键自增</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">关键字:</span><br><span class=\"line\">AUTO_INCREMENT 表示自动增长(字段类型必须是整数类型)</span><br></pre></td></tr></table></figure>\n\n<p>数据库在插入数据时，如果主键自增字段不填写数据，数据库会以自增的形式自动生成主键字段的值。默认从1或者上一条记录的主键字段值开始自增，也可以指定起始值。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建主键自增的表 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(</span><br><span class=\"line\">  <span class=\"comment\">-- 关键字 AUTO_INCREMENT,主键类型必须是整数类型 </span></span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  sex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建主键自增的表,自定义自增起始值 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  sex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">)AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>delete</strong>删除数据不会影响自增，自增会接着删除前的数据自增。</p>\n<p><strong>truncate</strong>删除数据再自增会从1开始，因为truncate是将表删除再复制一个表结构相同的新表。</p>\n<h3 id=\"非空\"><a href=\"#非空\" class=\"headerlink\" title=\"非空\"></a>非空</h3><p>特点：该列不允许为null</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字段名 字段类型 not null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 非空约束</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"comment\">-- 添加非空约束, ename字段不能为空 </span></span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  sex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><strong>空字符串(‘’)不等于null，可以插入</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 插入<span class=\"string\">&#x27;&#x27;</span>成功</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> emp2 (ename,sex) <span class=\"keyword\">values</span>(<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>);\t<span class=\"comment\">-- OK, Time: 0.000000s</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"唯一\"><a href=\"#唯一\" class=\"headerlink\" title=\"唯一\"></a>唯一</h3><p>特点：该列的值不能重复（对null会忽略不做判断）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字段名 字段值 unique</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#创建emp3表 为ename 字段添加唯一约束 </span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp3(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>) <span class=\"keyword\">UNIQUE</span>,</span><br><span class=\"line\">  sex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>主键约束和唯一约束的区别：</p>\n<ul>\n<li>主键约束，唯一且不能够为空(主键约束=非空约束+唯一约束)。</li>\n<li>唯一约束，唯一 但是可以为空。</li>\n<li>一个表中只能有一个主键，但是可以有多个唯一约束。</li>\n</ul>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p>作用：用来指定该列的默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字段名 字段类型 DEFAULT 默认值</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建带有默认值的表 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp4(</span><br><span class=\"line\">\teid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT, </span><br><span class=\"line\">\tename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  <span class=\"comment\">-- 为sex字段添加默认值</span></span><br><span class=\"line\">\tsex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;女&#x27;</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加数据 使用默认值</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> emp4(ename,sex) <span class=\"keyword\">VALUES</span>(<span class=\"string\">&#x27;张三&#x27;</span>,<span class=\"keyword\">DEFAULT</span>); </span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> emp4(ename) <span class=\"keyword\">VALUES</span>(<span class=\"string\">&#x27;李四&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外键约束\"><a href=\"#外键约束\" class=\"headerlink\" title=\"外键约束\"></a>外键约束</h3><p>数据表A中某一个字段，指向数据表B中的主键，那么数据表A中的这一字段就是外键。</p>\n<p>在这种关系场景中，外键所在的表叫做从表，外键所指向表叫做主表。</p>\n<p>作用：使两张数据表产生对应关系。</p>\n<p>特点：</p>\n<ul>\n<li><p>从表插入数据时，外键字段的值必须在主表主键字段中存在，外键字段类型必须和主表主键字段类型保持一致。</p>\n</li>\n<li><p>一张表可以有多个外键。表明该表与多个表有关联。</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 新建表时添加外键</span></span><br><span class=\"line\">[<span class=\"keyword\">CONSTRAINT</span>] [外键约束名称] <span class=\"keyword\">FOREIGN</span> KEY(外键字段名) <span class=\"keyword\">REFERENCES</span> 主表名(主键字段名);</span><br><span class=\"line\"><span class=\"comment\">-- 已有表添加外键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 从表名 <span class=\"keyword\">ADD</span> [<span class=\"keyword\">CONSTRAINT</span>] [外键约束名称] <span class=\"keyword\">FOREIGN</span> KEY (外键字段名) <span class=\"keyword\">REFERENCES</span> 主表(主键字段名);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除外键</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 从表名 <span class=\"keyword\">drop</span> <span class=\"keyword\">foreign</span> key 外键约束名称</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加外键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 从表 <span class=\"keyword\">ADD</span> [<span class=\"keyword\">CONSTRAINT</span>] [外键约束名称] <span class=\"keyword\">FOREIGN</span> KEY (外键字段名) <span class=\"keyword\">REFERENCES</span> 主表(主 键字段名);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 添加外键约束，创建employee表</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> employee(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  age <span class=\"type\">INT</span>,</span><br><span class=\"line\">  dept_id <span class=\"type\">INT</span>, <span class=\"comment\">-- 外键字段类型要和主表的主键字段类型保持一致 </span></span><br><span class=\"line\">  <span class=\"comment\">-- 添加外键约束</span></span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> emp_dept_fk <span class=\"keyword\">FOREIGN</span> KEY(dept_id) <span class=\"keyword\">REFERENCES</span> department(id)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加数据 (从表外键对应主表主键)</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;张百万&#x27;</span>, <span class=\"number\">20</span>, <span class=\"number\">1</span>); </span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;赵四&#x27;</span>, <span class=\"number\">21</span>, <span class=\"number\">1</span>); </span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;广坤&#x27;</span>, <span class=\"number\">20</span>, <span class=\"number\">2</span>); </span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小斌&#x27;</span>, <span class=\"number\">20</span>, <span class=\"number\">2</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入一条有问题的数据 (部门id在主表主键中不存在)</span></span><br><span class=\"line\"><span class=\"comment\">-- Cannot add or update a child row: a foreign key constraint fails </span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;错误&#x27;</span>, <span class=\"number\">18</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除employee 表中的外键约束,外键约束名 emp_dept_fk </span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> employee <span class=\"keyword\">DROP</span> <span class=\"keyword\">FOREIGN</span> KEY emp_dept_fk;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 可以省略外键名称, 系统会自动生成一个</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> employee <span class=\"keyword\">ADD</span> <span class=\"keyword\">FOREIGN</span> KEY (dept_id) <span class=\"keyword\">REFERENCES</span> department (id);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意事项</strong></p>\n<ul>\n<li>添加数据时, 应该先添加主表中的数据。</li>\n<li>删除数据时,应该先删除从表中的数据。</li>\n<li>从表外键类型必须与主表主键类型一致 否则创建失败。</li>\n</ul>\n<h4 id=\"级联删除\"><a href=\"#级联删除\" class=\"headerlink\" title=\"级联删除\"></a>级联删除</h4><p>删除主表数据的同时，自动删除掉从表数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">级联删除</span><br><span class=\"line\">ON DELETE CASCADE</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 重新创建添加级联操作 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> employee(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  age <span class=\"type\">INT</span>,</span><br><span class=\"line\">  dept_id <span class=\"type\">INT</span>,</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> emp_dept_fk <span class=\"keyword\">FOREIGN</span> KEY(dept_id) <span class=\"keyword\">REFERENCES</span> department(id) <span class=\"comment\">-- 添加级联删除</span></span><br><span class=\"line\">  <span class=\"keyword\">ON</span> <span class=\"keyword\">DELETE</span> CASCADE</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多表查询\"><a href=\"#多表查询\" class=\"headerlink\" title=\"多表查询\"></a>多表查询</h2><p>查询多张表(至少涉及2张表),获取到需要的数据。</p>\n<h3 id=\"交叉连接查询\"><a href=\"#交叉连接查询\" class=\"headerlink\" title=\"交叉连接查询\"></a>交叉连接查询</h3><p>直接使用select语句查询两张表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 表1, 表2;</span><br></pre></td></tr></table></figure>\n\n<p>交叉连接查询会产生笛卡尔积，查询结果有误</p>\n<h4 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h4><p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-05_19-44-43.jpg\" alt=\"img\"></p>\n<h3 id=\"内连接查询\"><a href=\"#内连接查询\" class=\"headerlink\" title=\"内连接查询\"></a>内连接查询</h3><h4 id=\"隐式内连接\"><a href=\"#隐式内连接\" class=\"headerlink\" title=\"隐式内连接\"></a>隐式内连接</h4><p>交叉连接查询+where条件过滤</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 左表, 右表 WHERE 连接条件;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 隐式内连接</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products,category <span class=\"keyword\">WHERE</span> category_id <span class=\"operator\">=</span> cid;</span><br><span class=\"line\"></span><br><span class=\"line\">#查询 格力空调是属于哪一分类下的商品</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> </span><br><span class=\"line\">p.pname, c.cname</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">products p , category c </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> </span><br><span class=\"line\">p.category_id <span class=\"operator\">=</span> c.cid </span><br><span class=\"line\"><span class=\"keyword\">AND</span> p.pname <span class=\"operator\">=</span> <span class=\"string\">&#x27;格力空调&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"显示内连接\"><a href=\"#显示内连接\" class=\"headerlink\" title=\"显示内连接\"></a>显示内连接</h4><p>使用**[inner] join … on …关键字**。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]] -- inner 可以省略</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显式内连接查询</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products p <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> category c <span class=\"keyword\">ON</span> p.category_id <span class=\"operator\">=</span> c.cid;</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询鞋服分类下,价格大于<span class=\"number\">500</span>的商品名称和价格</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> </span><br><span class=\"line\">p.pname,p.price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products p <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> category c </span><br><span class=\"line\"><span class=\"keyword\">ON</span> p.category_id <span class=\"operator\">=</span> c.cid </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> p.price <span class=\"operator\">&gt;</span> <span class=\"number\">500</span> <span class=\"keyword\">AND</span> cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;鞋服&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外连接查询\"><a href=\"#外连接查询\" class=\"headerlink\" title=\"外连接查询\"></a>外连接查询</h3><h4 id=\"左外连接\"><a href=\"#左外连接\" class=\"headerlink\" title=\"左外连接\"></a>左外连接</h4><p>使用left [outer] join … on …关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 左表 LEFT [OUTER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]]</span><br></pre></td></tr></table></figure>\n\n<p>特点：</p>\n<ul>\n<li>左表为基准, 右表去查询左表</li>\n<li>返回结果时，左表数据正常展示，右表在左表中查询得到的数据正常展示，查询不到的展示为Null</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 左外连接查询</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> category c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> products p <span class=\"keyword\">on</span> c.cid <span class=\"operator\">=</span> p.category_id;</span><br><span class=\"line\"></span><br><span class=\"line\"># 分类表中有汽车类目，商品表中并并没有该类目的商品</span><br><span class=\"line\">c001\t家电\tp001\t小 米 电 视 机 \t<span class=\"number\">5000</span>\t<span class=\"number\">1</span>\tc001</span><br><span class=\"line\">c001\t家电\tp002\t格 力 空 调 \t<span class=\"number\">3000</span>\t<span class=\"number\">1</span>\tc001</span><br><span class=\"line\">c001\t家电\tp003\t美 的 冰 箱 \t<span class=\"number\">4500</span>\t<span class=\"number\">1</span>\tc001</span><br><span class=\"line\">c002\t鞋服\tp004\t篮 球 鞋 \t<span class=\"number\">800</span>\t<span class=\"number\">1</span>\tc002</span><br><span class=\"line\">c002\t鞋服\tp005\t运 动 裤 \t<span class=\"number\">200</span>\t<span class=\"number\">1</span>\tc002</span><br><span class=\"line\">c002\t鞋服\tp006\tT 恤 \t<span class=\"number\">300</span>\t<span class=\"number\">1</span>\tc002</span><br><span class=\"line\">c002\t鞋服\tp007\t冲 锋 衣 \t<span class=\"number\">2000</span>\t<span class=\"number\">1</span>\tc002</span><br><span class=\"line\">c003\t化妆品\tp008\t神 仙 水 \t<span class=\"number\">800</span>\t<span class=\"number\">1</span>\tc003</span><br><span class=\"line\">c003\t化妆品\tp009\t大 宝 \t<span class=\"number\">200</span>\t<span class=\"number\">1</span>\tc003</span><br><span class=\"line\">c004\t汽车\t</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询每个分类下的商品个数</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">c.cname, <span class=\"built_in\">count</span>(p.pid) </span><br><span class=\"line\"><span class=\"keyword\">from</span> </span><br><span class=\"line\">category c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> products p </span><br><span class=\"line\"><span class=\"keyword\">on</span> c.cid <span class=\"operator\">=</span> p.category_id </span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> c.cname;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"右外连接\"><a href=\"#右外连接\" class=\"headerlink\" title=\"右外连接\"></a>右外连接</h4><p>使用 right [outer] join … on … 关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 左表 RIGHT [OUTER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]]</span><br></pre></td></tr></table></figure>\n\n<p>特点：和左外连接一样，只是以右表为基准。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-05_21-50-07.jpg\" alt=\"img\"></p>\n<p>2个以上表如何多表查询，思路是先选2个进行查询，将查询结果当作一个新的表，再和下一个表进行多表查询，以此类推。</p>\n<h3 id=\"join-on-and-和-join-on-where-and\"><a href=\"#join-on-and-和-join-on-where-and\" class=\"headerlink\" title=\"join on and 和 join on where and\"></a>join on and 和 join on where and</h3><p>在使用left join时，on和where条件的区别如下：  </p>\n<p>1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。（实际上左连接中如果and语句是对左表进行过滤的，那么不管真假都不起任何作用。如果是对右表过滤的，那么左表所有记录都返回，右表筛选以后再与左表连接返回） </p>\n<p>2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉，on后的条件用来生成左右表关联的临时表，where后的条件对临时表中的记录进行过滤。</p>\n<p> 在使用inner join时，不管是对左表还是右表进行筛选，on and和on where都会对生成的临时表进行过滤。</p>\n<p>————————————————<br>版权声明：本文为CSDN博主「行者摩罗」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/xingzhemoluo/article/details/39677891\">https://blog.csdn.net/xingzhemoluo/article/details/39677891</a></p>\n<h2 id=\"合并查询\"><a href=\"#合并查询\" class=\"headerlink\" title=\"合并查询\"></a>合并查询</h2><p>union和union all</p>\n<p>union/union all操作符用来合并多个select语句的结果集（就是查询结果）。</p>\n<p>union 和 union all 都要满足以下条件才能合并：</p>\n<ul>\n<li>要合并的结果集，列数必须相同，列的顺序必须一致，列的字段类型也必须相似。</li>\n</ul>\n<p>union 和 union all 的区别：</p>\n<ul>\n<li>union：消除重复行，重复检查期间，null值会被算在内。</li>\n<li>union all：不消除重复行，只是将结果集合并后就返回。</li>\n<li>执行效率上，union all 要比 union 快很多。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1 [, column2 ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">[<span class=\"keyword\">WHERE</span> <span class=\"keyword\">condition</span>]</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"operator\">/</span> <span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1 [, column2 ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">[<span class=\"keyword\">WHERE</span> <span class=\"keyword\">condition</span>]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><p>子查询概念：一条select 查询语句的结果, 作为另一条 select 语句的一部分。</p>\n<p>特点：</p>\n<ul>\n<li>子查询必须放在小括号中</li>\n<li>整个sql至少会有两个select关键字</li>\n</ul>\n<p>子查询常见分类</p>\n<ul>\n<li><strong>where型子查询</strong>：将子查询的结果, 作为父查询的比较条件</li>\n<li>**from型子查询 **：将子查询的结果, 作为 一张表,提供给父层查询使用</li>\n<li><strong>exists型子查询</strong>：子查询的结果是单列多行, 类似一个数组, 父层查询使用 IN 函数 ,包含子查询的结果</li>\n</ul>\n<h3 id=\"where型子查询\"><a href=\"#where型子查询\" class=\"headerlink\" title=\"where型子查询\"></a>where型子查询</h3><p>当子查询的结果是一个值时（单行单列）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 查询字段 FROM 表 WHERE 字段 &#x3D; (子查询);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 子查询的方式, 查询价格最高的商品信息</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> products <span class=\"keyword\">where</span> price <span class=\"operator\">=</span> (<span class=\"keyword\">select</span> <span class=\"built_in\">max</span>(price) <span class=\"keyword\">from</span> products);</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询化妆品分类下的 商品名称 商品价格</span><br><span class=\"line\"><span class=\"comment\">-- 子查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> p.pname, p.price <span class=\"keyword\">from</span> products p <span class=\"keyword\">where</span> p.category_id <span class=\"operator\">=</span> (<span class=\"keyword\">select</span> cid <span class=\"keyword\">from</span> category <span class=\"keyword\">where</span> cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;化妆品&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 内连接查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span>  p.pname,p.price <span class=\"keyword\">from</span> products p <span class=\"keyword\">join</span> category c <span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid <span class=\"keyword\">where</span> c.cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;化妆品&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"exists型子查询\"><a href=\"#exists型子查询\" class=\"headerlink\" title=\"exists型子查询\"></a>exists型子查询</h3><p>当子查询的结果是一个集合时（多行单列），需要用where … in (子查询)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 查询字段 FROM 表 WHERE 字段 in (子查询);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询价格小于两千的商品,来自于哪些分类(名称)</span><br><span class=\"line\"><span class=\"keyword\">select</span> cname <span class=\"keyword\">from</span> category <span class=\"keyword\">where</span> cid <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> category_id <span class=\"keyword\">from</span> products <span class=\"keyword\">where</span> price <span class=\"operator\">&lt;</span> <span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询家电类 与 鞋服类下面的全部商品信息</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> products <span class=\"keyword\">where</span> category_id <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> cid <span class=\"keyword\">from</span> category <span class=\"keyword\">where</span> cname <span class=\"keyword\">in</span>(<span class=\"string\">&#x27;家电&#x27;</span>,<span class=\"string\">&#x27;鞋服&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"from型子查询\"><a href=\"#from型子查询\" class=\"headerlink\" title=\"from型子查询\"></a>from型子查询</h3><p>当子查询的结果是一个表（多列多行）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 查询字段 FROM (子查询)表别名 WHERE 条件;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询商品中,价格大于<span class=\"number\">500</span>的商品信息,包括 商品名称 商品价格 商品所属分类名称</span><br><span class=\"line\"><span class=\"comment\">-- 子查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> p.pname,p.price,c.cname <span class=\"keyword\">from</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> products <span class=\"keyword\">where</span> price <span class=\"operator\">&gt;</span> <span class=\"number\">500</span>) p <span class=\"keyword\">join</span> category c <span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid;</span><br><span class=\"line\"><span class=\"comment\">-- 内连接查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> p.pname,p.price,c.cname <span class=\"keyword\">from</span> products p  <span class=\"keyword\">join</span> category c <span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid <span class=\"keyword\">where</span> p.price <span class=\"operator\">&gt;</span> <span class=\"number\">500</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当子查询作为一张表的时候，需要起别名，否则无法访问表中的字段。</strong></p>\n<h1 id=\"SQL语句执行顺序\"><a href=\"#SQL语句执行顺序\" class=\"headerlink\" title=\"SQL语句执行顺序\"></a>SQL语句执行顺序</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. from </span><br><span class=\"line\">2. join </span><br><span class=\"line\">3. on </span><br><span class=\"line\">4. where </span><br><span class=\"line\">5. group by(开始使用select中的别名，后面的语句中都可以使用)</span><br><span class=\"line\">6.  avg,sum.... </span><br><span class=\"line\">7. having </span><br><span class=\"line\">8. select </span><br><span class=\"line\">9. distinct </span><br><span class=\"line\">10. order by</span><br><span class=\"line\">11. limit </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、FROM  table1 left join table2 on 将table1和table2中的数据产生笛卡尔积，生成Temp1</span><br><span class=\"line\"></span><br><span class=\"line\">2、JOIN table2  所以先是确定表，再确定关联条件</span><br><span class=\"line\"></span><br><span class=\"line\">3、ON table1.column &#x3D; table2.columu 确定表的绑定条件 由Temp1产生中间表Temp2</span><br><span class=\"line\"></span><br><span class=\"line\">4、WHERE  对中间表Temp2产生的结果进行过滤  产生中间表Temp3</span><br><span class=\"line\"></span><br><span class=\"line\">5、GROUP BY 对中间表Temp3进行分组，产生中间表Temp4</span><br><span class=\"line\"></span><br><span class=\"line\">6、HAVING  对分组后的记录进行聚合 产生中间表Temp5</span><br><span class=\"line\"></span><br><span class=\"line\">7、SELECT  对中间表Temp5进行列筛选，产生中间表 Temp6</span><br><span class=\"line\"></span><br><span class=\"line\">8、DISTINCT 对中间表 Temp6进行去重，产生中间表 Temp7</span><br><span class=\"line\"></span><br><span class=\"line\">9、ORDER BY 对Temp7中的数据进行排序，产生中间表Temp8</span><br><span class=\"line\"></span><br><span class=\"line\">10、LIMIT 对中间表Temp8进行分页，产生中间表Temp9</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"案例1\"><a href=\"#案例1\" class=\"headerlink\" title=\"案例1\"></a>案例1</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询线索(二级渠道jdsc)后续转化成交车型详情。</span><br><span class=\"line\"><span class=\"comment\">-- 在二级渠道jdsc下，成交的线索，的车型详情</span></span><br><span class=\"line\"><span class=\"comment\">-- 线索表中二级渠道下的线索 和 订单表中的线索 的 交集。所以使用内连接查询。</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> clue_day c, order_day o <span class=\"keyword\">where</span> c.clue_id <span class=\"operator\">=</span> o.clue_id <span class=\"keyword\">and</span> c.ca_n <span class=\"operator\">=</span> <span class=\"string\">&#x27;jdsc&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">join</span> order_day o <span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id <span class=\"keyword\">where</span> c.ca_n <span class=\"operator\">=</span> <span class=\"string\">&#x27;jdsc&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"案例2\"><a href=\"#案例2\" class=\"headerlink\" title=\"案例2\"></a>案例2</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 统计所有渠道(按照二级渠道)的转化率</span><br><span class=\"line\"><span class=\"comment\">-- 转化率 = 该渠道下订单数/该渠道下线索数。订单数是线索数的子集，所以使用外连接查询。</span></span><br><span class=\"line\"><span class=\"comment\">-- 统计每一个二级渠道的转化率：按二级渠道分组聚合统计</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> c.ca_n, <span class=\"built_in\">count</span>(o.order_id)<span class=\"operator\">/</span><span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\"><span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o </span><br><span class=\"line\"><span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id </span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> c.ca_n;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"案例3\"><a href=\"#案例3\" class=\"headerlink\" title=\"案例3\"></a>案例3</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询各城市线索数并计算所有城市线索总数</span><br><span class=\"line\"><span class=\"comment\">-- 各城市线索数只需要用到clue表一张表，因此不需要多表查询</span></span><br><span class=\"line\"><span class=\"comment\">-- 各城市线索数，需要按城市分组求和</span></span><br><span class=\"line\"><span class=\"comment\">-- 各城市线索数，加起来就是所有城市线索总数，因此是子查询❌</span></span><br><span class=\"line\"><span class=\"comment\">-- 错误原因：子查询无法将两个结果展示在一张表中</span></span><br><span class=\"line\"><span class=\"comment\">-- 使用合并查询，将两个结果拼在一张表中。</span></span><br><span class=\"line\"><span class=\"comment\">-- 所有城市线索总数，也不需要先计算各城市线索数再求和，直接对clue表的线索求和即可。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> c.city_id,<span class=\"built_in\">count</span>(c.clue_id)clue_num <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> c.city_id</span><br><span class=\"line\"><span class=\"keyword\">union</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"string\">&#x27;总计&#x27;</span>,<span class=\"built_in\">count</span>(c.clue_id) <span class=\"keyword\">from</span> clue_day c;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"案例4\"><a href=\"#案例4\" class=\"headerlink\" title=\"案例4\"></a>案例4</h1><p>日期直接相减做了一个隐式转换操作，将时间转换为整数，但并不是用unix_timestamp转换，而是直接把年月日时分秒拼起来，如2013-04-21 16:59:33 直接转换为20130421165933，所以得到的结果是错误的。</p>\n<p>Unix_timestamp([日期])函数：返回自’1970-01-01 00:00:00’的到当前日期[指定日期]的秒数差。</p>\n<p>Datediff(d1,d2)函数：返回d1-d2的天数差</p>\n<p>Ceil()函数：向上取整</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 找出优质渠道，做重点投入</span></span><br><span class=\"line\"><span class=\"comment\">-- 我们对于优质渠道(以二级渠道来说)的定义: </span></span><br><span class=\"line\"><span class=\"comment\">-- 该二级渠道内平均转化周期&lt; 整体平均转化周期</span></span><br><span class=\"line\"><span class=\"comment\">-- 该二级渠道的线索量 &gt; 各二级渠道平均线索量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t针对《二级渠道内平均转化周期》和《二级渠道的线索量》的分析</span></span><br><span class=\"line\"><span class=\"comment\">\t转化周期:成单日期 — 线索创建日期 平均:avg</span></span><br><span class=\"line\"><span class=\"comment\">\t渠道线索量:分组 count统计</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">-- 这里需要注意：二级渠道线索量是所有二级渠道的，其中包括未成单的二级渠道。</span></span><br><span class=\"line\"><span class=\"comment\">-- 因此这里使用关联查询时，首先排除内连接，因为内连接只能查出成单的二级渠道</span></span><br><span class=\"line\"><span class=\"comment\">-- 其次使用外连接时，clue表应该作为主表将渠道全部展示出来</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\"><span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o <span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\"><span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 二级渠道平均线索量</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">ceil</span>(<span class=\"built_in\">avg</span>(clue_num)) <span class=\"keyword\">from</span> (</span><br><span class=\"line\">  <span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\">  <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o \t<span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\">  <span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">  <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\">)a <span class=\"comment\">-- 子查询作为一张表时，必须有别名才能访问其中的字段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 整体平均转化周期</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">avg</span>(datediff( created_at, clue_created_at )) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> clue_day c <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> order_day o <span class=\"keyword\">ON</span> c.clue_id <span class=\"operator\">=</span> o.clue_id </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">AND</span> clue_created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询结果</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> ca_n, avg_time, clue_num <span class=\"keyword\">from</span> (</span><br><span class=\"line\">  <span class=\"comment\">-- 《二级渠道内平均转化周期》和《二级渠道的线索量》</span></span><br><span class=\"line\">  <span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\">  <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o <span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\">  <span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">  <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> avg_time <span class=\"operator\">&lt;</span> (</span><br><span class=\"line\">  <span class=\"comment\">-- 整体平均转化周期</span></span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">avg</span>(datediff( created_at, clue_created_at )) </span><br><span class=\"line\">\t<span class=\"keyword\">FROM</span> clue_day c <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> order_day o <span class=\"keyword\">ON</span> c.clue_id <span class=\"operator\">=</span> o.clue_id </span><br><span class=\"line\">\t<span class=\"keyword\">WHERE</span> created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">AND</span> clue_created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\">\t) </span><br><span class=\"line\"><span class=\"keyword\">AND</span> clue_num <span class=\"operator\">&gt;</span> (</span><br><span class=\"line\">  <span class=\"comment\">-- 二级渠道平均线索量</span></span><br><span class=\"line\">  <span class=\"keyword\">select</span> <span class=\"built_in\">ceil</span>(<span class=\"built_in\">avg</span>(clue_num)) <span class=\"keyword\">from</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\">    <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o \t<span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\">    <span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\">\t)a </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>一段sql查询多次作为子查询被使用，可以用with 别名 as (子查询) 优化：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 《二级渠道内平均转化周期》和《二级渠道的线索量》</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> ca_value <span class=\"keyword\">as</span> (</span><br><span class=\"line\">  <span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\">  <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o <span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\">  <span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">  <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">-- 查询结果</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> ca_n, avg_time, clue_num <span class=\"keyword\">from</span> ca_value</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> avg_time <span class=\"operator\">&lt;</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">avg</span>(datediff( created_at, clue_created_at )) </span><br><span class=\"line\">\t<span class=\"keyword\">FROM</span> clue_day c <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> order_day o <span class=\"keyword\">ON</span> c.clue_id <span class=\"operator\">=</span> o.clue_id </span><br><span class=\"line\">\t<span class=\"keyword\">WHERE</span> created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">AND</span> clue_created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\">\t) </span><br><span class=\"line\"><span class=\"keyword\">AND</span> clue_num <span class=\"operator\">&gt;</span> (<span class=\"keyword\">SELECT</span> <span class=\"built_in\">ceil</span>(<span class=\"built_in\">avg</span>( clue_num )) <span class=\"keyword\">FROM</span> ca_value);</span><br></pre></td></tr></table></figure>\n\n<p><strong>⚠️注意</strong>：<a href=\"https://bbs.csdn.net/topics/390280176\">with…as…的用法</a></p>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span></span><br><span class=\"line\"> <span class=\"keyword\">when</span> 条件<span class=\"number\">1</span> <span class=\"keyword\">then</span> 结果<span class=\"number\">1</span></span><br><span class=\"line\"> <span class=\"keyword\">when</span> 条件<span class=\"number\">2</span> <span class=\"keyword\">then</span> 结果<span class=\"number\">2</span></span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"keyword\">else</span> 结果（默认<span class=\"keyword\">null</span>） <span class=\"comment\">-- 上面条件都不满足时，返回else结果；如果不写else，默认也返回null</span></span><br><span class=\"line\"> <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MySQL基础\"><a href=\"#MySQL基础\" class=\"headerlink\" title=\"MySQL基础\"></a>MySQL基础</h1><h2 id=\"数据库基本概念\"><a href=\"#数据库基本概念\" class=\"headerlink\" title=\"数据库基本概念\"></a>数据库基本概念</h2><p>数据库是按照数据结构来组织、存储和管理数据的仓库。其本质是一个文件系统，以文件的形式将数据保存在电脑上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">文件 --&gt; 文件系统 --&gt; 计算机磁盘</span><br></pre></td></tr></table></figure>\n\n<p>数据库（DB），数据库管理系统（DBMS）</p>\n<p>关系型数据库（RDB）：关系型数据库是创建在关系模型基础上的数据库。</p>\n<p>关系模型：有明确的行和列的二维表格模型。（就像excel表一样）</p>\n<p>IOE：IBM小型机，Oracle数据库，EMC易安信。</p>\n<p>客户端与服务端建立连接；写SQL，执行SQL语句操作MySQL数据库。</p>\n<p>字段：表中每一列成为一个字段，字段有自己的属性，如字段类型、字段大小等，字段类型决定了字段能够存储哪种数据。字段属性在建表时就必须定义好。</p>\n<p>索引：索引是一种单独的、物理的数据库结构。它依赖于表建立。</p>\n<p>视图：视图是从一张或多张表中到处的表（也称虚拟表），是用户产看表中数据的一种方式。</p>\n<h2 id=\"MySQL数据库\"><a href=\"#MySQL数据库\" class=\"headerlink\" title=\"MySQL数据库\"></a>MySQL数据库</h2><p>MySQL是C和C++编写的。</p>\n<p>MySQL支持多线程。</p>\n<p>MySQL存储引擎：存储引擎是MySQL数据库的核心。它决定了数据如何存储，查询的时候如何搜索数据，索引如何创建等等。</p>\n<p>常用存储引擎：</p>\n<ul>\n<li>InnoDB：MySQL5.1版本之后默认存储引擎。</li>\n<li>MyISAM：MySQL5.1版本之前默认存储引擎。</li>\n<li>Memory</li>\n</ul>\n<p>MySQL数据类型主要分为数值型、字符串型、日期时间型三大类。</p>\n<p>字符串型char和varchar：</p>\n<ul>\n<li><p>char固定长度，char(5)会在内存中占用5个字符的空间，即使只存入了3个字符。</p>\n</li>\n<li><p>varchar可变长度，varchar(5)存入3个字符，就只占用3个字符的空间。</p>\n</li>\n<li><p>char浪费空间，但查询时整体匹配，效率更高，比如存入abc，查询时会直接匹配整体是否是abc。</p>\n</li>\n<li><p>varchar节省空间，但查询时不是整体匹配，效率不高，比如存入abc，查询时先匹配a再匹配b再匹配c。</p>\n</li>\n</ul>\n<p>MySQL Server安装目录下，bin目录下的mysql就是自带的命令行客户端。</p>\n<p>访问数据库命令行：mysql -h127.0.01 -uroot -p123456</p>\n<ul>\n<li>mysql：使用mysql客户端访问服务端</li>\n<li>-h127.0.01：当前服务端是本机，所以使用-h127.0.0.1指定访问本地127.0.0.1地址的服务。因为服务端在本地，这部分也可以不写会自动访问本地服务。</li>\n<li>-uroot：登陆用户是root</li>\n<li>-p123456：登陆密码是123456</li>\n</ul>\n<h1 id=\"SQL语句\"><a href=\"#SQL语句\" class=\"headerlink\" title=\"SQL语句\"></a>SQL语句</h1><p>SQL语句按功能分为以下几类：</p>\n<ul>\n<li>DDL语句（Data Definition Language 数据定义语言)</li>\n<li>DML语句（Data Manipulation Language 数据操作语言)</li>\n<li>DQL语句（Data QueryLanguage 数据查询语言)</li>\n<li>DCL语句（Data Controll Language 数据控制语言)</li>\n</ul>\n<p><strong>SQL语句的执行顺序：1、最先执行from tab；2、where语句是对条件加以限定；3、分组语句【group by…… having】；4、聚合函数；5、select语句；6、order by排序语句。</strong></p>\n<h2 id=\"增删改\"><a href=\"#增删改\" class=\"headerlink\" title=\"增删改\"></a>增删改</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 新建数据库 create database 数据库名;</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> DATABASE db1;</span><br><span class=\"line\"><span class=\"comment\">-- 新建数据库，并指定字符集 create database 数据库名 character set 字符集;</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> DATABASE db1_1 <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 切换数据库 从db1 切换到 db1_1 </span></span><br><span class=\"line\">USE db1_1;</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前正在使用的数据库 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> DATABASE();</span><br><span class=\"line\"><span class=\"comment\">-- 查看Mysql中有哪些数据库 </span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> DATABASES;</span><br><span class=\"line\"><span class=\"comment\">-- 查看一个数据库的定义信息 </span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> DATABASE db1_1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 将数据库db1 的字符集 修改为 utf8 </span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> DATABASE db1 <span class=\"type\">CHARACTER</span> <span class=\"keyword\">SET</span> utf8;</span><br><span class=\"line\"><span class=\"comment\">-- 查看当前数据库的基本信息，发现编码已更改 </span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> DATABASE db1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除某个数据库 </span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> DATABASE db1_1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建表</span></span><br><span class=\"line\"><span class=\"comment\">/* CREATE TABLE 表名(</span></span><br><span class=\"line\"><span class=\"comment\">字段名称1 字段类型(长度)，</span></span><br><span class=\"line\"><span class=\"comment\">字段名称2 字段类型 注意 最后一列不要加逗号</span></span><br><span class=\"line\"><span class=\"comment\">);*/</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> category(</span><br><span class=\"line\">cid <span class=\"type\">INT</span>,</span><br><span class=\"line\">    cname <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">快速创建一个表结构相同的表(仅复制表结构，不会复制数据)</span></span><br><span class=\"line\"><span class=\"comment\">create table 新表名 like 旧表名;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">-- 创建一个表结构与 test1 相同的 test2表 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> test2 <span class=\"keyword\">LIKE</span> test1;</span><br><span class=\"line\"><span class=\"comment\">-- 查看表结构 </span></span><br><span class=\"line\"><span class=\"keyword\">DESC</span> test2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看当前数据库中的所有表名 </span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> TABLES;</span><br><span class=\"line\"><span class=\"comment\">-- 显示当前数据表的结构 </span></span><br><span class=\"line\"><span class=\"keyword\">DESC</span> category;</span><br><span class=\"line\"><span class=\"comment\">-- 查看创建表的SQL语句</span></span><br><span class=\"line\"><span class=\"keyword\">SHOW</span> <span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> category;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 直接删除 test1 表 </span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> test1;</span><br><span class=\"line\"><span class=\"comment\">-- 先判断表是否存在 再删除test2表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> test2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改表名 rename table 旧表名 to 新表名;</span></span><br><span class=\"line\">RENAME <span class=\"keyword\">TABLE</span> category <span class=\"keyword\">TO</span> category1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 向表中添加列 alter table 表名 add 字段名称 字段类型</span></span><br><span class=\"line\"># 为分类表添加一个新的字段为 分类描述 cdesc <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) </span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> category <span class=\"keyword\">ADD</span> cdesc <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改表中列的数据类型或长度 alter table 表名 modify 字段名称 字段类型</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> category MODIFY cdesc <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改列名称 alter table 表名 change 旧列名 新列名 类型(长度);</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> category CHANGE cdesc description <span class=\"type\">VARCHAR</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除列 alter table 表名 drop 列名;</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> category <span class=\"keyword\">DROP</span> description;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入数据，插入数据是插入一行数据</span></span><br><span class=\"line\"><span class=\"comment\">-- insert into 表名 (字段名1，字段名2...) values(字段值1，字段值2...);</span></span><br><span class=\"line\"><span class=\"comment\">-- 方式1: 插入全部字段， 将所有字段名都写出来</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> student (sid,sname,age,sex,address) <span class=\"keyword\">VALUES</span>(<span class=\"number\">1</span>,<span class=\"string\">&#x27;孙悟 空 &#x27;</span>,<span class=\"number\">20</span>,<span class=\"string\">&#x27;男 &#x27;</span>,<span class=\"string\">&#x27;花 果 山 &#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 方式2: 插入全部字段，不写字段名</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> student <span class=\"keyword\">VALUES</span>(<span class=\"number\">2</span>,<span class=\"string\">&#x27;孙悟饭&#x27;</span>,<span class=\"number\">10</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;地球&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 方式3:插入指定字段的值</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> category (cname) <span class=\"keyword\">VALUES</span>(<span class=\"string\">&#x27;白骨精&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 更改数据，更新数据是更新某一列数据</span></span><br><span class=\"line\"><span class=\"comment\">-- 不带条件的修改 update 表名 set 列名 = 值</span></span><br><span class=\"line\">UPDATE student <span class=\"keyword\">SET</span> sex <span class=\"operator\">=</span> <span class=\"string\">&#x27;女&#x27;</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 带条件的修改 update 表名 set 列名 = 值 [where 条件表达式:字段名 = 值 ]</span></span><br><span class=\"line\">UPDATE student <span class=\"keyword\">SET</span> sex <span class=\"operator\">=</span> <span class=\"string\">&#x27;男&#x27;</span> <span class=\"keyword\">WHERE</span> sid <span class=\"operator\">=</span> <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 一次修改多个列</span></span><br><span class=\"line\">UPDATE student <span class=\"keyword\">SET</span> age <span class=\"operator\">=</span> <span class=\"number\">20</span>,address <span class=\"operator\">=</span> <span class=\"string\">&#x27;北京&#x27;</span> <span class=\"keyword\">WHERE</span> sid <span class=\"operator\">=</span> <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除数据</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> 表名;</span><br><span class=\"line\"><span class=\"keyword\">truncate</span> <span class=\"keyword\">table</span> 表名;</span><br><span class=\"line\"><span class=\"comment\">-- 指定条件 删除数据</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> 表名 [<span class=\"keyword\">where</span> 字段名 <span class=\"operator\">=</span> 值];</span><br></pre></td></tr></table></figure>\n\n<p><strong>当一个表中数据条数非常多，又要做删除动作的时候，如果用delete会很慢，那我们可以使用 truncate 。</strong></p>\n<p><strong>delete from 表名; 不推荐. 有多少条记录 就执行多少次删除操作. 效率低。</strong></p>\n<p><strong>truncate table 表名: 推荐. 先删除整张表, 然后再重新创建一张一模一样的表. 效率高。</strong></p>\n<h2 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询所有数据</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> 表名</span><br><span class=\"line\"><span class=\"comment\">-- 查询某一列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> 列名<span class=\"number\">1</span>,列名<span class=\"number\">2</span> <span class=\"keyword\">from</span> 表名</span><br><span class=\"line\"><span class=\"comment\">-- 使用 AS关键字,为列起别名 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> eid <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;编号&#x27;</span>, ename <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;姓名&#x27;</span> , sex <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;性别&#x27;</span> <span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"><span class=\"comment\">-- AS 可以省略 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> eid <span class=\"string\">&#x27;编号&#x27;</span>, ename <span class=\"string\">&#x27;姓名&#x27;</span> , sex <span class=\"string\">&#x27;性别&#x27;</span> <span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"><span class=\"comment\">-- 使用distinct 关键字,去掉重复部门信息 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> dept_name <span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"><span class=\"comment\">-- 运算查询 (查询结果参与运算)</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> ename , salary <span class=\"operator\">+</span> <span class=\"number\">1000</span> <span class=\"keyword\">FROM</span> emp;</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>比较运算符</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&gt; &lt; &lt;= &gt;= = &lt;&gt; !=</td>\n<td>大于、小于、小于(大于)等于、等于、不等于</td>\n</tr>\n<tr>\n<td>BETWEEN …AND…</td>\n<td>显示在某一区间的值 <br />例如: 2000-10000之间: Between 2000 and 10000</td>\n</tr>\n<tr>\n<td>IN(集合)</td>\n<td>集合表示多个值,使用逗号分隔,<br />例如: name in (悟空，八戒) in中的每个数据都会作为一次条件,只要满足条件就会显示</td>\n</tr>\n<tr>\n<td>LIKE ‘%张%’</td>\n<td>模糊查询<br />通配符%，表示匹配任意多个字符串<br />通配符_，表示匹配一个字符<br />where name like ‘%王%’; – name中有王的<br />where name like ‘王%’; – name中以王开头的<br />where name like ‘_王%’；– name中第二个字是王的</td>\n</tr>\n<tr>\n<td>IS NULL</td>\n<td>查询某一列为NULL的值, 注: 不能写 = NULL</td>\n</tr>\n<tr>\n<td><strong>逻辑运算符</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>And &amp;&amp;</td>\n<td>多个条件同时成立</td>\n</tr>\n<tr>\n<td>Or ||</td>\n<td>多个条件任一成立</td>\n</tr>\n<tr>\n<td>Not</td>\n<td>不成立，取反。<br />和IS NULL组合使用，就是查询字段不是Null的数据。<br />where dept_name IS NOT NULL;</td>\n</tr>\n</tbody></table>\n<h2 id=\"核心查询\"><a href=\"#核心查询\" class=\"headerlink\" title=\"核心查询\"></a>核心查询</h2><h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 表名 [WHERE 字段 &#x3D; 值] ORDER BY 字段名 [ASC &#x2F; DESC]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 默认升序排序 ASC</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary;</span><br><span class=\"line\"><span class=\"comment\">-- 降序排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>;</span><br><span class=\"line\"><span class=\"comment\">-- 组合排序</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> salary <span class=\"keyword\">DESC</span>, eid <span class=\"keyword\">DESC</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Order by不会影响源数据，只用于展示结果。</p>\n<h3 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h3><p>也称为聚合统计或者聚合查询，使用聚合函数纵向查询，对某一列的值进行计算，然后返回一个单一的值(另外聚合函数会忽略null空 值。</p>\n<p>聚合函数：</p>\n<ul>\n<li>count(字段) 统计指定列不为NULL的记录行数。</li>\n<li>sum(字段) 计算指定列的数值和。</li>\n<li>max(字段) 计算指定列的最大值。</li>\n<li>min(字段) 计算指定列的最小值。</li>\n<li>avg(字段) 计算指定列的平均值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 聚合函数(字段名) FROM 表名;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"number\">1</span> 查询员工的总数</span><br><span class=\"line\"><span class=\"comment\">-- 统计表中的记录条数 使用 count()</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(eid) <span class=\"keyword\">FROM</span> emp; <span class=\"comment\">-- 使用某一个字段 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> emp; <span class=\"comment\">-- 使用 *</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"number\">1</span>) <span class=\"keyword\">FROM</span> emp; <span class=\"comment\">-- 使用 1,与 * 效果一样</span></span><br><span class=\"line\"><span class=\"comment\">-- 下面这条SQL 得到的总条数不准确,因为count函数忽略了空值 </span></span><br><span class=\"line\"><span class=\"comment\">-- 所以使用时注意不要使用带有null的列进行统计</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(dept_name) <span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">2</span> 查看员工总薪水、最高薪水、最小薪水、薪水的平均值</span><br><span class=\"line\"><span class=\"comment\">-- sum函数求和, max函数求最大, min函数求最小, avg函数求平均值 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\t<span class=\"built_in\">SUM</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;总薪水&#x27;</span>, </span><br><span class=\"line\">\t<span class=\"built_in\">MAX</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;最高薪水&#x27;</span>, </span><br><span class=\"line\">\t<span class=\"built_in\">MIN</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;最低薪水&#x27;</span>, </span><br><span class=\"line\">\t<span class=\"built_in\">AVG</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;平均薪水&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">3</span> 查询薪水大于<span class=\"number\">4000</span>员工的个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">WHERE</span> salary <span class=\"operator\">&gt;</span> <span class=\"number\">4000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">4</span> 查询部门为<span class=\"string\">&#x27;教学部&#x27;</span>的所有员工的个数</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">WHERE</span> dept_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;教学部&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">5</span> 查询部门为<span class=\"string\">&#x27;市场部&#x27;</span>所有员工的平均薪水 <span class=\"keyword\">SELECT</span></span><br><span class=\"line\"><span class=\"built_in\">AVG</span>(salary) <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;市场部平均薪资&#x27;</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">WHERE</span> dept_name <span class=\"operator\">=</span> <span class=\"string\">&#x27;市场部&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>⚠️注意：where中不能使用聚合函数，只能通过子查询实现</strong>。<a href=\"https://blog.csdn.net/fanbaodan/article/details/84304782\">https://blog.csdn.net/fanbaodan/article/details/84304782</a></p>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>分组查询指的是使用GROUP BY 语句，对查询的信息进行分组，相同数据作为一组。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 语法</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> 分组字段<span class=\"operator\">/</span>聚合函数 <span class=\"keyword\">FROM</span> 表名 [<span class=\"keyword\">where</span> 条件] <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> 分组字段 [<span class=\"keyword\">HAVING</span> 条件];</span><br><span class=\"line\"><span class=\"comment\">-- select后必须出现要分组的字段，除了分组字段、聚合函数，不能出现其他字段</span></span><br><span class=\"line\"><span class=\"comment\">-- where先对源数据过滤，having对分组聚合统计后的数据再过滤</span></span><br></pre></td></tr></table></figure>\n\n<p>Group by 后可以跟多个字段，按照多个字段进行分组</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 分组字段<span class=\"number\">1</span>, 分组字段<span class=\"number\">2</span>, 聚合函数 <span class=\"keyword\">FROM</span> 表名 [<span class=\"keyword\">where</span> 条件] <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> 分组字段<span class=\"number\">1</span>, 分组字段<span class=\"number\">2</span> [<span class=\"keyword\">HAVING</span> 条件];</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># store_id 和 salesdate 相同的分为一组</span><br><span class=\"line\"><span class=\"keyword\">select</span> store_id, <span class=\"built_in\">sum</span>(sales_volume), salesdate</span><br><span class=\"line\"><span class=\"keyword\">from</span> store_table</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> store_id, salesdate</span><br></pre></td></tr></table></figure>\n\n<p>分组的目的是为了统计，所以分组一般会与聚合函数一起使用。只进行分组是没有意义的。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 只分组不统计 这样写没有意义</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sex; </span><br><span class=\"line\"><span class=\"comment\">-- 分组返回每组的第一条数据</span></span><br></pre></td></tr></table></figure>\n\n<p>示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#<span class=\"number\">1</span> 通过性别字段 进行分组,求各组的平均薪资</span><br><span class=\"line\"><span class=\"keyword\">select</span> sex,<span class=\"built_in\">avg</span>(salary)<span class=\"string\">&#x27;平均薪资&#x27;</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sex;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">2</span> 查询每个部门的平均薪资 </span><br><span class=\"line\"><span class=\"keyword\">select</span> dept_name<span class=\"string\">&#x27;部门&#x27;</span>,<span class=\"built_in\">avg</span>(salary)<span class=\"string\">&#x27;平均薪资&#x27;</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> dept_name;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">3</span> 查询每个部门的平均薪资, 部门名称不能为<span class=\"keyword\">null</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> dept_name<span class=\"string\">&#x27;部门&#x27;</span>,<span class=\"built_in\">avg</span>(salary)<span class=\"string\">&#x27;平均薪资&#x27;</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> dept_name <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> dept_name;</span><br><span class=\"line\"></span><br><span class=\"line\">#<span class=\"number\">4</span> 查询平均薪资大于<span class=\"number\">6000</span>的部门</span><br><span class=\"line\"><span class=\"comment\">-- 先对源数据where过滤掉部门为null的数据，接着按部门分组聚合统计各部门的平均薪资，最后再通过having过滤出平均薪资大于6000的部门。</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\tdept_name <span class=\"string\">&#x27;部门&#x27;</span>,</span><br><span class=\"line\">\t<span class=\"built_in\">avg</span>( salary ) <span class=\"string\">&#x27;平均薪资&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\temp </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">\tdept_name <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">\tdept_name </span><br><span class=\"line\"><span class=\"keyword\">HAVING</span></span><br><span class=\"line\">\t<span class=\"built_in\">avg</span>( salary ) <span class=\"operator\">&gt;</span> <span class=\"number\">6000</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>where和having的区别</strong></p>\n<ul>\n<li>where 进行分组前的过滤，where 后面不能写聚合函数</li>\n<li>having 是分组后的过滤，having 后面可以写聚合函数</li>\n</ul>\n<h3 id=\"limit\"><a href=\"#limit\" class=\"headerlink\" title=\"limit\"></a>limit</h3><p>limit是限制的意思,用于限制返回的查询结果的行数 (可以通过limit指定查询多少行数据)</p>\n<p>limit 语法是 MySql的方言,用来完成分页</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 字段<span class=\"number\">1</span>,字段<span class=\"number\">2.</span>.. <span class=\"keyword\">FROM</span> 表名 LIMIT <span class=\"keyword\">offset</span> , length;</span><br></pre></td></tr></table></figure>\n\n<p>offset 起始行数，从0开始记数， 如果省略 则默认为 0。<br>length 返回的行数。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询emp表中的前<span class=\"number\">5</span>条数据</span><br><span class=\"line\"><span class=\"comment\">-- 参数1:起始值,默认是0; 参数2:要查询的条数 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">0</span> , <span class=\"number\">5</span>;</span><br><span class=\"line\"># 查询emp表中 从第<span class=\"number\">4</span>条开始,查询<span class=\"number\">6</span>条 <span class=\"comment\">-- 起始值默认是从0开始的.</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">3</span> , <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>分页</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 分页操作 每页显示3条数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">0</span>,<span class=\"number\">3</span>; <span class=\"comment\">-- 第1页 </span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">3</span>,<span class=\"number\">3</span>; <span class=\"comment\">-- 第2页</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> emp LIMIT <span class=\"number\">6</span>,<span class=\"number\">3</span>; <span class=\"comment\">-- 第3页</span></span><br><span class=\"line\"><span class=\"comment\">-- 分页公式 起始索引 =(当前页 -1)* 每页条数 </span></span><br><span class=\"line\"><span class=\"comment\">-- limit是MySql中的方言</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">分页，每页显示3条</span></span><br><span class=\"line\"><span class=\"comment\">第1页，1，2，3</span></span><br><span class=\"line\"><span class=\"comment\">第2页，4，5，6</span></span><br><span class=\"line\"><span class=\"comment\">第3页，7，8，9</span></span><br><span class=\"line\"><span class=\"comment\">第1页，第1条开始，相对第1条偏移0条，显示3条</span></span><br><span class=\"line\"><span class=\"comment\">第2页，第4条开始，相对第1条偏移3条，显示3条</span></span><br><span class=\"line\"><span class=\"comment\">第3页，第7条开始，相对第1条偏移6条，显示3条</span></span><br><span class=\"line\"><span class=\"comment\">当前页偏移量=当前页之前所有页的显示条数总和</span></span><br><span class=\"line\"><span class=\"comment\">当前页偏移量计算公式：（页数-1）*每页显示条数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"SQL约束\"><a href=\"#SQL约束\" class=\"headerlink\" title=\"SQL约束\"></a>SQL约束</h2><p>约束，就是对数据进一步限制，从而保证数据的有效性、正确性、完整性。违反约束的数据将无法插入到数据表中。</p>\n<p>约束是针对字段的。</p>\n<p>常见约束：</p>\n<ul>\n<li>主键（primary key）</li>\n<li>唯一（unique）</li>\n<li>非空（not null）</li>\n<li>外键（foreign key）</li>\n<li>默认值（default）</li>\n</ul>\n<h3 id=\"主键\"><a href=\"#主键\" class=\"headerlink\" title=\"主键\"></a>主键</h3><p>作用：用来唯一标识数据表中的每一条记录。</p>\n<p>特点：不可重复，唯一，非空。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字段名 字段类型 primary key</span><br><span class=\"line\">primary key(字段名)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 方式<span class=\"number\">1</span> 创建一个带主键的表 </span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY, ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"># 方式<span class=\"number\">2</span> 创建一个带主键的表 </span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(eid <span class=\"type\">INT</span>, ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>), <span class=\"keyword\">PRIMARY</span> KEY(eid));</span><br><span class=\"line\"></span><br><span class=\"line\"># 方式<span class=\"number\">3</span> 向已经创建的表添加主键</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> emp2 <span class=\"keyword\">ADD</span> <span class=\"keyword\">PRIMARY</span> KEY(eid);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表中的主键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> emp2 <span class=\"keyword\">DROP</span> <span class=\"keyword\">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"主键自增\"><a href=\"#主键自增\" class=\"headerlink\" title=\"主键自增\"></a>主键自增</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">关键字:</span><br><span class=\"line\">AUTO_INCREMENT 表示自动增长(字段类型必须是整数类型)</span><br></pre></td></tr></table></figure>\n\n<p>数据库在插入数据时，如果主键自增字段不填写数据，数据库会以自增的形式自动生成主键字段的值。默认从1或者上一条记录的主键字段值开始自增，也可以指定起始值。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建主键自增的表 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(</span><br><span class=\"line\">  <span class=\"comment\">-- 关键字 AUTO_INCREMENT,主键类型必须是整数类型 </span></span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  sex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建主键自增的表,自定义自增起始值 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  sex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">)AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>delete</strong>删除数据不会影响自增，自增会接着删除前的数据自增。</p>\n<p><strong>truncate</strong>删除数据再自增会从1开始，因为truncate是将表删除再复制一个表结构相同的新表。</p>\n<h3 id=\"非空\"><a href=\"#非空\" class=\"headerlink\" title=\"非空\"></a>非空</h3><p>特点：该列不允许为null</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字段名 字段类型 not null</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 非空约束</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp2(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"comment\">-- 添加非空约束, ename字段不能为空 </span></span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  sex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><strong>空字符串(‘’)不等于null，可以插入</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 插入<span class=\"string\">&#x27;&#x27;</span>成功</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> emp2 (ename,sex) <span class=\"keyword\">values</span>(<span class=\"string\">&#x27;&#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>);\t<span class=\"comment\">-- OK, Time: 0.000000s</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"唯一\"><a href=\"#唯一\" class=\"headerlink\" title=\"唯一\"></a>唯一</h3><p>特点：该列的值不能重复（对null会忽略不做判断）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字段名 字段值 unique</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#创建emp3表 为ename 字段添加唯一约束 </span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp3(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>) <span class=\"keyword\">UNIQUE</span>,</span><br><span class=\"line\">  sex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>主键约束和唯一约束的区别：</p>\n<ul>\n<li>主键约束，唯一且不能够为空(主键约束=非空约束+唯一约束)。</li>\n<li>唯一约束，唯一 但是可以为空。</li>\n<li>一个表中只能有一个主键，但是可以有多个唯一约束。</li>\n</ul>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p>作用：用来指定该列的默认值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字段名 字段类型 DEFAULT 默认值</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建带有默认值的表 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> emp4(</span><br><span class=\"line\">\teid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT, </span><br><span class=\"line\">\tename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  <span class=\"comment\">-- 为sex字段添加默认值</span></span><br><span class=\"line\">\tsex <span class=\"type\">CHAR</span>(<span class=\"number\">1</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;女&#x27;</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加数据 使用默认值</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> emp4(ename,sex) <span class=\"keyword\">VALUES</span>(<span class=\"string\">&#x27;张三&#x27;</span>,<span class=\"keyword\">DEFAULT</span>); </span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> emp4(ename) <span class=\"keyword\">VALUES</span>(<span class=\"string\">&#x27;李四&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外键约束\"><a href=\"#外键约束\" class=\"headerlink\" title=\"外键约束\"></a>外键约束</h3><p>数据表A中某一个字段，指向数据表B中的主键，那么数据表A中的这一字段就是外键。</p>\n<p>在这种关系场景中，外键所在的表叫做从表，外键所指向表叫做主表。</p>\n<p>作用：使两张数据表产生对应关系。</p>\n<p>特点：</p>\n<ul>\n<li><p>从表插入数据时，外键字段的值必须在主表主键字段中存在，外键字段类型必须和主表主键字段类型保持一致。</p>\n</li>\n<li><p>一张表可以有多个外键。表明该表与多个表有关联。</p>\n</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 新建表时添加外键</span></span><br><span class=\"line\">[<span class=\"keyword\">CONSTRAINT</span>] [外键约束名称] <span class=\"keyword\">FOREIGN</span> KEY(外键字段名) <span class=\"keyword\">REFERENCES</span> 主表名(主键字段名);</span><br><span class=\"line\"><span class=\"comment\">-- 已有表添加外键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 从表名 <span class=\"keyword\">ADD</span> [<span class=\"keyword\">CONSTRAINT</span>] [外键约束名称] <span class=\"keyword\">FOREIGN</span> KEY (外键字段名) <span class=\"keyword\">REFERENCES</span> 主表(主键字段名);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除外键</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> 从表名 <span class=\"keyword\">drop</span> <span class=\"keyword\">foreign</span> key 外键约束名称</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加外键</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 从表 <span class=\"keyword\">ADD</span> [<span class=\"keyword\">CONSTRAINT</span>] [外键约束名称] <span class=\"keyword\">FOREIGN</span> KEY (外键字段名) <span class=\"keyword\">REFERENCES</span> 主表(主 键字段名);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 添加外键约束，创建employee表</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> employee(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  age <span class=\"type\">INT</span>,</span><br><span class=\"line\">  dept_id <span class=\"type\">INT</span>, <span class=\"comment\">-- 外键字段类型要和主表的主键字段类型保持一致 </span></span><br><span class=\"line\">  <span class=\"comment\">-- 添加外键约束</span></span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> emp_dept_fk <span class=\"keyword\">FOREIGN</span> KEY(dept_id) <span class=\"keyword\">REFERENCES</span> department(id)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加数据 (从表外键对应主表主键)</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;张百万&#x27;</span>, <span class=\"number\">20</span>, <span class=\"number\">1</span>); </span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;赵四&#x27;</span>, <span class=\"number\">21</span>, <span class=\"number\">1</span>); </span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;广坤&#x27;</span>, <span class=\"number\">20</span>, <span class=\"number\">2</span>); </span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小斌&#x27;</span>, <span class=\"number\">20</span>, <span class=\"number\">2</span>); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入一条有问题的数据 (部门id在主表主键中不存在)</span></span><br><span class=\"line\"><span class=\"comment\">-- Cannot add or update a child row: a foreign key constraint fails </span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> employee (ename, age, dept_id) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;错误&#x27;</span>, <span class=\"number\">18</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除employee 表中的外键约束,外键约束名 emp_dept_fk </span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> employee <span class=\"keyword\">DROP</span> <span class=\"keyword\">FOREIGN</span> KEY emp_dept_fk;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 可以省略外键名称, 系统会自动生成一个</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> employee <span class=\"keyword\">ADD</span> <span class=\"keyword\">FOREIGN</span> KEY (dept_id) <span class=\"keyword\">REFERENCES</span> department (id);</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意事项</strong></p>\n<ul>\n<li>添加数据时, 应该先添加主表中的数据。</li>\n<li>删除数据时,应该先删除从表中的数据。</li>\n<li>从表外键类型必须与主表主键类型一致 否则创建失败。</li>\n</ul>\n<h4 id=\"级联删除\"><a href=\"#级联删除\" class=\"headerlink\" title=\"级联删除\"></a>级联删除</h4><p>删除主表数据的同时，自动删除掉从表数据</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">级联删除</span><br><span class=\"line\">ON DELETE CASCADE</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 重新创建添加级联操作 </span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> employee(</span><br><span class=\"line\">  eid <span class=\"type\">INT</span> <span class=\"keyword\">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class=\"line\">  ename <span class=\"type\">VARCHAR</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">  age <span class=\"type\">INT</span>,</span><br><span class=\"line\">  dept_id <span class=\"type\">INT</span>,</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> emp_dept_fk <span class=\"keyword\">FOREIGN</span> KEY(dept_id) <span class=\"keyword\">REFERENCES</span> department(id) <span class=\"comment\">-- 添加级联删除</span></span><br><span class=\"line\">  <span class=\"keyword\">ON</span> <span class=\"keyword\">DELETE</span> CASCADE</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"多表查询\"><a href=\"#多表查询\" class=\"headerlink\" title=\"多表查询\"></a>多表查询</h2><p>查询多张表(至少涉及2张表),获取到需要的数据。</p>\n<h3 id=\"交叉连接查询\"><a href=\"#交叉连接查询\" class=\"headerlink\" title=\"交叉连接查询\"></a>交叉连接查询</h3><p>直接使用select语句查询两张表。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 表1, 表2;</span><br></pre></td></tr></table></figure>\n\n<p>交叉连接查询会产生笛卡尔积，查询结果有误</p>\n<h4 id=\"笛卡尔积\"><a href=\"#笛卡尔积\" class=\"headerlink\" title=\"笛卡尔积\"></a>笛卡尔积</h4><p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-05_19-44-43.jpg\" alt=\"img\"></p>\n<h3 id=\"内连接查询\"><a href=\"#内连接查询\" class=\"headerlink\" title=\"内连接查询\"></a>内连接查询</h3><h4 id=\"隐式内连接\"><a href=\"#隐式内连接\" class=\"headerlink\" title=\"隐式内连接\"></a>隐式内连接</h4><p>交叉连接查询+where条件过滤</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 左表, 右表 WHERE 连接条件;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 隐式内连接</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products,category <span class=\"keyword\">WHERE</span> category_id <span class=\"operator\">=</span> cid;</span><br><span class=\"line\"></span><br><span class=\"line\">#查询 格力空调是属于哪一分类下的商品</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> </span><br><span class=\"line\">p.pname, c.cname</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> </span><br><span class=\"line\">products p , category c </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> </span><br><span class=\"line\">p.category_id <span class=\"operator\">=</span> c.cid </span><br><span class=\"line\"><span class=\"keyword\">AND</span> p.pname <span class=\"operator\">=</span> <span class=\"string\">&#x27;格力空调&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"显示内连接\"><a href=\"#显示内连接\" class=\"headerlink\" title=\"显示内连接\"></a>显示内连接</h4><p>使用**[inner] join … on …关键字**。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 左表 [INNER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]] -- inner 可以省略</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 显式内连接查询</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> products p <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> category c <span class=\"keyword\">ON</span> p.category_id <span class=\"operator\">=</span> c.cid;</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询鞋服分类下,价格大于<span class=\"number\">500</span>的商品名称和价格</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> </span><br><span class=\"line\">p.pname,p.price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products p <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> category c </span><br><span class=\"line\"><span class=\"keyword\">ON</span> p.category_id <span class=\"operator\">=</span> c.cid </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> p.price <span class=\"operator\">&gt;</span> <span class=\"number\">500</span> <span class=\"keyword\">AND</span> cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;鞋服&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"外连接查询\"><a href=\"#外连接查询\" class=\"headerlink\" title=\"外连接查询\"></a>外连接查询</h3><h4 id=\"左外连接\"><a href=\"#左外连接\" class=\"headerlink\" title=\"左外连接\"></a>左外连接</h4><p>使用left [outer] join … on …关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 左表 LEFT [OUTER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]]</span><br></pre></td></tr></table></figure>\n\n<p>特点：</p>\n<ul>\n<li>左表为基准, 右表去查询左表</li>\n<li>返回结果时，左表数据正常展示，右表在左表中查询得到的数据正常展示，查询不到的展示为Null</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 左外连接查询</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> category c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> products p <span class=\"keyword\">on</span> c.cid <span class=\"operator\">=</span> p.category_id;</span><br><span class=\"line\"></span><br><span class=\"line\"># 分类表中有汽车类目，商品表中并并没有该类目的商品</span><br><span class=\"line\">c001\t家电\tp001\t小 米 电 视 机 \t<span class=\"number\">5000</span>\t<span class=\"number\">1</span>\tc001</span><br><span class=\"line\">c001\t家电\tp002\t格 力 空 调 \t<span class=\"number\">3000</span>\t<span class=\"number\">1</span>\tc001</span><br><span class=\"line\">c001\t家电\tp003\t美 的 冰 箱 \t<span class=\"number\">4500</span>\t<span class=\"number\">1</span>\tc001</span><br><span class=\"line\">c002\t鞋服\tp004\t篮 球 鞋 \t<span class=\"number\">800</span>\t<span class=\"number\">1</span>\tc002</span><br><span class=\"line\">c002\t鞋服\tp005\t运 动 裤 \t<span class=\"number\">200</span>\t<span class=\"number\">1</span>\tc002</span><br><span class=\"line\">c002\t鞋服\tp006\tT 恤 \t<span class=\"number\">300</span>\t<span class=\"number\">1</span>\tc002</span><br><span class=\"line\">c002\t鞋服\tp007\t冲 锋 衣 \t<span class=\"number\">2000</span>\t<span class=\"number\">1</span>\tc002</span><br><span class=\"line\">c003\t化妆品\tp008\t神 仙 水 \t<span class=\"number\">800</span>\t<span class=\"number\">1</span>\tc003</span><br><span class=\"line\">c003\t化妆品\tp009\t大 宝 \t<span class=\"number\">200</span>\t<span class=\"number\">1</span>\tc003</span><br><span class=\"line\">c004\t汽车\t</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询每个分类下的商品个数</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">c.cname, <span class=\"built_in\">count</span>(p.pid) </span><br><span class=\"line\"><span class=\"keyword\">from</span> </span><br><span class=\"line\">category c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> products p </span><br><span class=\"line\"><span class=\"keyword\">on</span> c.cid <span class=\"operator\">=</span> p.category_id </span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> c.cname;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"右外连接\"><a href=\"#右外连接\" class=\"headerlink\" title=\"右外连接\"></a>右外连接</h4><p>使用 right [outer] join … on … 关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 字段名 FROM 左表 RIGHT [OUTER] JOIN 右表 ON 条件 [and 条件2] [where 条件 [and 条件2]]</span><br></pre></td></tr></table></figure>\n\n<p>特点：和左外连接一样，只是以右表为基准。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-05_21-50-07.jpg\" alt=\"img\"></p>\n<p>2个以上表如何多表查询，思路是先选2个进行查询，将查询结果当作一个新的表，再和下一个表进行多表查询，以此类推。</p>\n<h3 id=\"join-on-and-和-join-on-where-and\"><a href=\"#join-on-and-和-join-on-where-and\" class=\"headerlink\" title=\"join on and 和 join on where and\"></a>join on and 和 join on where and</h3><p>在使用left join时，on和where条件的区别如下：  </p>\n<p>1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。（实际上左连接中如果and语句是对左表进行过滤的，那么不管真假都不起任何作用。如果是对右表过滤的，那么左表所有记录都返回，右表筛选以后再与左表连接返回） </p>\n<p>2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉，on后的条件用来生成左右表关联的临时表，where后的条件对临时表中的记录进行过滤。</p>\n<p> 在使用inner join时，不管是对左表还是右表进行筛选，on and和on where都会对生成的临时表进行过滤。</p>\n<p>————————————————<br>版权声明：本文为CSDN博主「行者摩罗」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/xingzhemoluo/article/details/39677891\">https://blog.csdn.net/xingzhemoluo/article/details/39677891</a></p>\n<h2 id=\"合并查询\"><a href=\"#合并查询\" class=\"headerlink\" title=\"合并查询\"></a>合并查询</h2><p>union和union all</p>\n<p>union/union all操作符用来合并多个select语句的结果集（就是查询结果）。</p>\n<p>union 和 union all 都要满足以下条件才能合并：</p>\n<ul>\n<li>要合并的结果集，列数必须相同，列的顺序必须一致，列的字段类型也必须相似。</li>\n</ul>\n<p>union 和 union all 的区别：</p>\n<ul>\n<li>union：消除重复行，重复检查期间，null值会被算在内。</li>\n<li>union all：不消除重复行，只是将结果集合并后就返回。</li>\n<li>执行效率上，union all 要比 union 快很多。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column1 [, column2 ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">[<span class=\"keyword\">WHERE</span> <span class=\"keyword\">condition</span>]</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> <span class=\"operator\">/</span> <span class=\"keyword\">UNION</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> column1 [, column2 ]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table1 [, table2 ]</span><br><span class=\"line\">[<span class=\"keyword\">WHERE</span> <span class=\"keyword\">condition</span>]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h2><p>子查询概念：一条select 查询语句的结果, 作为另一条 select 语句的一部分。</p>\n<p>特点：</p>\n<ul>\n<li>子查询必须放在小括号中</li>\n<li>整个sql至少会有两个select关键字</li>\n</ul>\n<p>子查询常见分类</p>\n<ul>\n<li><strong>where型子查询</strong>：将子查询的结果, 作为父查询的比较条件</li>\n<li>**from型子查询 **：将子查询的结果, 作为 一张表,提供给父层查询使用</li>\n<li><strong>exists型子查询</strong>：子查询的结果是单列多行, 类似一个数组, 父层查询使用 IN 函数 ,包含子查询的结果</li>\n</ul>\n<h3 id=\"where型子查询\"><a href=\"#where型子查询\" class=\"headerlink\" title=\"where型子查询\"></a>where型子查询</h3><p>当子查询的结果是一个值时（单行单列）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 查询字段 FROM 表 WHERE 字段 &#x3D; (子查询);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 子查询的方式, 查询价格最高的商品信息</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> products <span class=\"keyword\">where</span> price <span class=\"operator\">=</span> (<span class=\"keyword\">select</span> <span class=\"built_in\">max</span>(price) <span class=\"keyword\">from</span> products);</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询化妆品分类下的 商品名称 商品价格</span><br><span class=\"line\"><span class=\"comment\">-- 子查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> p.pname, p.price <span class=\"keyword\">from</span> products p <span class=\"keyword\">where</span> p.category_id <span class=\"operator\">=</span> (<span class=\"keyword\">select</span> cid <span class=\"keyword\">from</span> category <span class=\"keyword\">where</span> cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;化妆品&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 内连接查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span>  p.pname,p.price <span class=\"keyword\">from</span> products p <span class=\"keyword\">join</span> category c <span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid <span class=\"keyword\">where</span> c.cname <span class=\"operator\">=</span> <span class=\"string\">&#x27;化妆品&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"exists型子查询\"><a href=\"#exists型子查询\" class=\"headerlink\" title=\"exists型子查询\"></a>exists型子查询</h3><p>当子查询的结果是一个集合时（多行单列），需要用where … in (子查询)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 查询字段 FROM 表 WHERE 字段 in (子查询);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询价格小于两千的商品,来自于哪些分类(名称)</span><br><span class=\"line\"><span class=\"keyword\">select</span> cname <span class=\"keyword\">from</span> category <span class=\"keyword\">where</span> cid <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> category_id <span class=\"keyword\">from</span> products <span class=\"keyword\">where</span> price <span class=\"operator\">&lt;</span> <span class=\"number\">2000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"># 查询家电类 与 鞋服类下面的全部商品信息</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> products <span class=\"keyword\">where</span> category_id <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> cid <span class=\"keyword\">from</span> category <span class=\"keyword\">where</span> cname <span class=\"keyword\">in</span>(<span class=\"string\">&#x27;家电&#x27;</span>,<span class=\"string\">&#x27;鞋服&#x27;</span>));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"from型子查询\"><a href=\"#from型子查询\" class=\"headerlink\" title=\"from型子查询\"></a>from型子查询</h3><p>当子查询的结果是一个表（多列多行）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT 查询字段 FROM (子查询)表别名 WHERE 条件;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询商品中,价格大于<span class=\"number\">500</span>的商品信息,包括 商品名称 商品价格 商品所属分类名称</span><br><span class=\"line\"><span class=\"comment\">-- 子查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> p.pname,p.price,c.cname <span class=\"keyword\">from</span> (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> products <span class=\"keyword\">where</span> price <span class=\"operator\">&gt;</span> <span class=\"number\">500</span>) p <span class=\"keyword\">join</span> category c <span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid;</span><br><span class=\"line\"><span class=\"comment\">-- 内连接查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> p.pname,p.price,c.cname <span class=\"keyword\">from</span> products p  <span class=\"keyword\">join</span> category c <span class=\"keyword\">on</span> p.category_id <span class=\"operator\">=</span> c.cid <span class=\"keyword\">where</span> p.price <span class=\"operator\">&gt;</span> <span class=\"number\">500</span>;</span><br></pre></td></tr></table></figure>\n\n<p><strong>当子查询作为一张表的时候，需要起别名，否则无法访问表中的字段。</strong></p>\n<h1 id=\"SQL语句执行顺序\"><a href=\"#SQL语句执行顺序\" class=\"headerlink\" title=\"SQL语句执行顺序\"></a>SQL语句执行顺序</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. from </span><br><span class=\"line\">2. join </span><br><span class=\"line\">3. on </span><br><span class=\"line\">4. where </span><br><span class=\"line\">5. group by(开始使用select中的别名，后面的语句中都可以使用)</span><br><span class=\"line\">6.  avg,sum.... </span><br><span class=\"line\">7. having </span><br><span class=\"line\">8. select </span><br><span class=\"line\">9. distinct </span><br><span class=\"line\">10. order by</span><br><span class=\"line\">11. limit </span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、FROM  table1 left join table2 on 将table1和table2中的数据产生笛卡尔积，生成Temp1</span><br><span class=\"line\"></span><br><span class=\"line\">2、JOIN table2  所以先是确定表，再确定关联条件</span><br><span class=\"line\"></span><br><span class=\"line\">3、ON table1.column &#x3D; table2.columu 确定表的绑定条件 由Temp1产生中间表Temp2</span><br><span class=\"line\"></span><br><span class=\"line\">4、WHERE  对中间表Temp2产生的结果进行过滤  产生中间表Temp3</span><br><span class=\"line\"></span><br><span class=\"line\">5、GROUP BY 对中间表Temp3进行分组，产生中间表Temp4</span><br><span class=\"line\"></span><br><span class=\"line\">6、HAVING  对分组后的记录进行聚合 产生中间表Temp5</span><br><span class=\"line\"></span><br><span class=\"line\">7、SELECT  对中间表Temp5进行列筛选，产生中间表 Temp6</span><br><span class=\"line\"></span><br><span class=\"line\">8、DISTINCT 对中间表 Temp6进行去重，产生中间表 Temp7</span><br><span class=\"line\"></span><br><span class=\"line\">9、ORDER BY 对Temp7中的数据进行排序，产生中间表Temp8</span><br><span class=\"line\"></span><br><span class=\"line\">10、LIMIT 对中间表Temp8进行分页，产生中间表Temp9</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"案例1\"><a href=\"#案例1\" class=\"headerlink\" title=\"案例1\"></a>案例1</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询线索(二级渠道jdsc)后续转化成交车型详情。</span><br><span class=\"line\"><span class=\"comment\">-- 在二级渠道jdsc下，成交的线索，的车型详情</span></span><br><span class=\"line\"><span class=\"comment\">-- 线索表中二级渠道下的线索 和 订单表中的线索 的 交集。所以使用内连接查询。</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> clue_day c, order_day o <span class=\"keyword\">where</span> c.clue_id <span class=\"operator\">=</span> o.clue_id <span class=\"keyword\">and</span> c.ca_n <span class=\"operator\">=</span> <span class=\"string\">&#x27;jdsc&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">join</span> order_day o <span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id <span class=\"keyword\">where</span> c.ca_n <span class=\"operator\">=</span> <span class=\"string\">&#x27;jdsc&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"案例2\"><a href=\"#案例2\" class=\"headerlink\" title=\"案例2\"></a>案例2</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 统计所有渠道(按照二级渠道)的转化率</span><br><span class=\"line\"><span class=\"comment\">-- 转化率 = 该渠道下订单数/该渠道下线索数。订单数是线索数的子集，所以使用外连接查询。</span></span><br><span class=\"line\"><span class=\"comment\">-- 统计每一个二级渠道的转化率：按二级渠道分组聚合统计</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> c.ca_n, <span class=\"built_in\">count</span>(o.order_id)<span class=\"operator\">/</span><span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\"><span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o </span><br><span class=\"line\"><span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id </span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> c.ca_n;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"案例3\"><a href=\"#案例3\" class=\"headerlink\" title=\"案例3\"></a>案例3</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询各城市线索数并计算所有城市线索总数</span><br><span class=\"line\"><span class=\"comment\">-- 各城市线索数只需要用到clue表一张表，因此不需要多表查询</span></span><br><span class=\"line\"><span class=\"comment\">-- 各城市线索数，需要按城市分组求和</span></span><br><span class=\"line\"><span class=\"comment\">-- 各城市线索数，加起来就是所有城市线索总数，因此是子查询❌</span></span><br><span class=\"line\"><span class=\"comment\">-- 错误原因：子查询无法将两个结果展示在一张表中</span></span><br><span class=\"line\"><span class=\"comment\">-- 使用合并查询，将两个结果拼在一张表中。</span></span><br><span class=\"line\"><span class=\"comment\">-- 所有城市线索总数，也不需要先计算各城市线索数再求和，直接对clue表的线索求和即可。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> c.city_id,<span class=\"built_in\">count</span>(c.clue_id)clue_num <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> c.city_id</span><br><span class=\"line\"><span class=\"keyword\">union</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"string\">&#x27;总计&#x27;</span>,<span class=\"built_in\">count</span>(c.clue_id) <span class=\"keyword\">from</span> clue_day c;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"案例4\"><a href=\"#案例4\" class=\"headerlink\" title=\"案例4\"></a>案例4</h1><p>日期直接相减做了一个隐式转换操作，将时间转换为整数，但并不是用unix_timestamp转换，而是直接把年月日时分秒拼起来，如2013-04-21 16:59:33 直接转换为20130421165933，所以得到的结果是错误的。</p>\n<p>Unix_timestamp([日期])函数：返回自’1970-01-01 00:00:00’的到当前日期[指定日期]的秒数差。</p>\n<p>Datediff(d1,d2)函数：返回d1-d2的天数差</p>\n<p>Ceil()函数：向上取整</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 找出优质渠道，做重点投入</span></span><br><span class=\"line\"><span class=\"comment\">-- 我们对于优质渠道(以二级渠道来说)的定义: </span></span><br><span class=\"line\"><span class=\"comment\">-- 该二级渠道内平均转化周期&lt; 整体平均转化周期</span></span><br><span class=\"line\"><span class=\"comment\">-- 该二级渠道的线索量 &gt; 各二级渠道平均线索量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">\t针对《二级渠道内平均转化周期》和《二级渠道的线索量》的分析</span></span><br><span class=\"line\"><span class=\"comment\">\t转化周期:成单日期 — 线索创建日期 平均:avg</span></span><br><span class=\"line\"><span class=\"comment\">\t渠道线索量:分组 count统计</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">-- 这里需要注意：二级渠道线索量是所有二级渠道的，其中包括未成单的二级渠道。</span></span><br><span class=\"line\"><span class=\"comment\">-- 因此这里使用关联查询时，首先排除内连接，因为内连接只能查出成单的二级渠道</span></span><br><span class=\"line\"><span class=\"comment\">-- 其次使用外连接时，clue表应该作为主表将渠道全部展示出来</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\"><span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o <span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\"><span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 二级渠道平均线索量</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">ceil</span>(<span class=\"built_in\">avg</span>(clue_num)) <span class=\"keyword\">from</span> (</span><br><span class=\"line\">  <span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\">  <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o \t<span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\">  <span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">  <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\">)a <span class=\"comment\">-- 子查询作为一张表时，必须有别名才能访问其中的字段</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 整体平均转化周期</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">avg</span>(datediff( created_at, clue_created_at )) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> clue_day c <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> order_day o <span class=\"keyword\">ON</span> c.clue_id <span class=\"operator\">=</span> o.clue_id </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">AND</span> clue_created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询结果</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> ca_n, avg_time, clue_num <span class=\"keyword\">from</span> (</span><br><span class=\"line\">  <span class=\"comment\">-- 《二级渠道内平均转化周期》和《二级渠道的线索量》</span></span><br><span class=\"line\">  <span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\">  <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o <span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\">  <span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">  <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> avg_time <span class=\"operator\">&lt;</span> (</span><br><span class=\"line\">  <span class=\"comment\">-- 整体平均转化周期</span></span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">avg</span>(datediff( created_at, clue_created_at )) </span><br><span class=\"line\">\t<span class=\"keyword\">FROM</span> clue_day c <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> order_day o <span class=\"keyword\">ON</span> c.clue_id <span class=\"operator\">=</span> o.clue_id </span><br><span class=\"line\">\t<span class=\"keyword\">WHERE</span> created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">AND</span> clue_created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\">\t) </span><br><span class=\"line\"><span class=\"keyword\">AND</span> clue_num <span class=\"operator\">&gt;</span> (</span><br><span class=\"line\">  <span class=\"comment\">-- 二级渠道平均线索量</span></span><br><span class=\"line\">  <span class=\"keyword\">select</span> <span class=\"built_in\">ceil</span>(<span class=\"built_in\">avg</span>(clue_num)) <span class=\"keyword\">from</span> (</span><br><span class=\"line\">    <span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\">    <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o \t<span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\">    <span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">    <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\">\t)a </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>一段sql查询多次作为子查询被使用，可以用with 别名 as (子查询) 优化：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 《二级渠道内平均转化周期》和《二级渠道的线索量》</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> ca_value <span class=\"keyword\">as</span> (</span><br><span class=\"line\">  <span class=\"keyword\">select</span> ca_n, <span class=\"built_in\">avg</span>(datediff(created_at,clue_created_at)), <span class=\"built_in\">count</span>(c.clue_id) </span><br><span class=\"line\">  <span class=\"keyword\">from</span> clue_day c <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> order_day o <span class=\"keyword\">on</span> c.clue_id <span class=\"operator\">=</span> o.clue_id</span><br><span class=\"line\">  <span class=\"keyword\">where</span> created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">null</span> <span class=\"keyword\">and</span> clue_created_at <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">NULL</span></span><br><span class=\"line\">  <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> ca_n</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">-- 查询结果</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> ca_n, avg_time, clue_num <span class=\"keyword\">from</span> ca_value</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> avg_time <span class=\"operator\">&lt;</span> (</span><br><span class=\"line\">\t<span class=\"keyword\">SELECT</span> <span class=\"built_in\">avg</span>(datediff( created_at, clue_created_at )) </span><br><span class=\"line\">\t<span class=\"keyword\">FROM</span> clue_day c <span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> order_day o <span class=\"keyword\">ON</span> c.clue_id <span class=\"operator\">=</span> o.clue_id </span><br><span class=\"line\">\t<span class=\"keyword\">WHERE</span> created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">AND</span> clue_created_at <span class=\"keyword\">IS</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> </span><br><span class=\"line\">\t) </span><br><span class=\"line\"><span class=\"keyword\">AND</span> clue_num <span class=\"operator\">&gt;</span> (<span class=\"keyword\">SELECT</span> <span class=\"built_in\">ceil</span>(<span class=\"built_in\">avg</span>( clue_num )) <span class=\"keyword\">FROM</span> ca_value);</span><br></pre></td></tr></table></figure>\n\n<p><strong>⚠️注意</strong>：<a href=\"https://bbs.csdn.net/topics/390280176\">with…as…的用法</a></p>\n<h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">case</span></span><br><span class=\"line\"> <span class=\"keyword\">when</span> 条件<span class=\"number\">1</span> <span class=\"keyword\">then</span> 结果<span class=\"number\">1</span></span><br><span class=\"line\"> <span class=\"keyword\">when</span> 条件<span class=\"number\">2</span> <span class=\"keyword\">then</span> 结果<span class=\"number\">2</span></span><br><span class=\"line\"> ...</span><br><span class=\"line\"> <span class=\"keyword\">else</span> 结果（默认<span class=\"keyword\">null</span>） <span class=\"comment\">-- 上面条件都不满足时，返回else结果；如果不写else，默认也返回null</span></span><br><span class=\"line\"> <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"ES5学习笔记","date":"2017-06-01T04:52:28.000Z","description":"《JavaScript教程-阮一峰》《JavaScript高级程序设计》ES5要点总结","_content":"\n# 语法\n\n## 基本语法\n\n+ 凡是JavaScript语言中预期为值的地方，都可以使用表达式。\n\n+ 使用var重新声明一个已经存在的变量是无效的，但是如果第二次声明的同时还附了值，则会覆盖掉前面的值。\n\n  ```\n  var x = 1;\n  var x;\n  x // 1\n\n  var x = 1;\n  var x = 2;\n  x // 2\n  ```\n\n+ JavaScript引擎的工作方式是，现解析代码，获取所有被声明的变量，然后再一行一行的运行。这造成的结果就是所有的变量声明语句，都会被提升到代码的头部，这就叫做变量提升。\n\n  ```\n  console.log(a);\n  var a = 1;\n  //undefined\n  //等同于\n  var a;\n  console.log(a);\n  a = 1;\n  ```\n\n  变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。\n\n  ```\n  console.log(b);\n  b = 1;\n  //Error:b is not defined\n  ```\n\n+ 中文是合法的标识符，可以用作变量名\n\n  ```\n  var 临时变量 = 1；\n  ```\n\n+ 多个if...else连在一起使用的时候，可以转为使用更方便的switch结构\n\n  ```\n  switch (fruit){\n    case \"banana\":\n    \t//...\n    \tbreak;\n    case \"apple\":\n    \t//...\n    \tbreak;\n    default:\n    \t//...\n  }\n  ```\n\n  每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。\n\n  switch语句部分和case语句部分，都可以使用表达式\n\n  switch语句后面的表达式与case语句后面的表达式，在比较运算结果时，采用严格相等===，而不是相等运算==，意味着比较时不会发生类型转换\n\n  ```\n  var x = 1;\n  switch(x){\n    case true:\n    \tconsole.log('x发生类型转换‘);\n    default:\n    \tconsole.log('x没有发生类型转换‘);\n  }\n  // x没有发生类型转换\n  ```\n\n+ while循环、for循环可以使用break语句跳出循环\n\n+ continue用语立即终止本轮循环，返回循环结构头部，开始下一轮循环\n\n+ 如果存在多重循环，不带参数的break和continue语句都只针对最内层循环\n\n+ 标签（label）：JS允许语句的前面有标签，相当于定位赋，用于跳转到程序的任意位置，格式如下：\n\n  ```\n  label:\n  \tstatement\n  ```\n\n  标签可以时任意的标识符，但不能是保留字\n\n  标签通常和break、continue语句配合使用，跳出特定的循环：\n\n  ```\n  top:\n  \tfor(var i = 0; i < 3; i++){\n        for(var j = 0; j < 3; j++){\n          if(i ===1 && j === 1){\n            break top;\n          }\n        }\n  \t}\n  ```\n\n  上面的双重循环中，break后面跟了top标签（top不用加引号），满足条件时，直接跳出双层循环。如果不加标签，则只跳出内层循环，进入下一次外层循环。\n\n  continue一样\n\n## 数据类型\n\n+ 6中数据类型（es6又新增了第七中Symbol类型），数值、字符串、布尔值称为原始类型，对象称为合成类型，null、undefined特殊值\n\n+ JS的所有数据，都可视为广义的对象，数组、函数，原始类型的数据\n\n+ 对象又分成3个子类：狭义的对象（object），数组（array），函数（function）\n\n+ JS把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，体现了JS作为“函数式语言”的本质\n\n+ JS有三种方法确定一个值的类型：\n\n  typeof运算符\n\n  instanceof运算符\n\n  Object.prototype.toString方法\n\n+ typeof null返回object，并不是说null的数据类型就是对象，本质上null是一个类似于undefined的特殊值。null表示空值，即该处的值为空；undefined表示“为定义”\n\n+ 空数组 []，空对象 {}对应的布尔值都是true\n\n### 数值\n\n+ NaN是number类型的一种特殊值，表示“非数字”（Not a Number)\n\n+ isNaN方法判断一个值是否为NaN，空数组和只有一个数值成员的数组，is NaN返回false，原因是这些数组能被Number函数转成数值。\n\n  ```\n  isNan([]) //false\n  isNaN([123]) //false\n  isNaN(['123']) //false\n  ```\n\n+ parseInt()方法用于将字符串转为整数\t。\n\n  字符串转为整数是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分\n\n  ```\n  parseInt('12.34') //12\n  ```\n\n  如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN：\n\n  ```\n  parseInt('abc') //NaN\n  parseInt('+') //NaN\n  parseInt('+1') //1\n  ```\n\n  parseInt()方法还可以接受第二个参数（2到36之间），表示被解析到值的进制，返回该值对应的十进制数。第二个参数默认是10。\n\n+ parseFloat()方法用于将一个字符串转为浮点数\n\n  如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分\n\n  如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN\n\n### 字符串\n\n+ 如果要在单引号（或双引号）字符串的内部，使用单引号（或双引号），就必须在内部的单引号（或双引号）前面加上反斜杠，用来转义：\n\n  ```\n  'Did she say \\'Hello\\'?'\n  // \"Did she say 'Hello'?\"\n  ```\n\n+ 字符串默认只能写在一行内，分成多行将会报错\n\n+ 字符串可以被视为字符数组，可以使用数组的方括号运算符返回某个位置的字符，但仅此而已，无法修改和增删，只有将字符串显式转为数组后才能使用\n\n+ Base64转码：\n\n  btoa()：字符串或二进制值转为Base64编码\n\n  atob()：Base64编码转为原来的编码\n\n### 对象\n\n+ 对象三种声明方法：\n\n  1. 直接使用大括号{ }生成`var o1 = {};`\n  2. 用new命令生成一个Object对象的实例`var o2 = new Object();`\n  3. 用Object.create方法生成`Object.create(Object.prototype);`\n\n  对象采用大括号表示导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？\n\n  为避免歧义，JS规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），不许在大括号前加上圆括号\n\n  ```\n  ({foo:123})\n  ```\n\n\n+ 对象的所有键名都是字符串，加不加引号都可以，非字符串的键名会被转为字符串。但是如果键名不符合标识名的条件，也不是数字，则必须加上引号，否则报错。\n\n+ JS的保留字可以不加引号当作键名\n\n+ 对象的每一个“键名”又称为“属性”，它的“键值“可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为”方法“，它可以像函数那样调用：\n\n  ```\n  var o = {\n    p: function (x){\n      return 2 * x;\n    }\n  };\n  o.p(1) // 2\n  ```\n\n+ **不同的变量名指向同一个对象**，他们都是这个对象的引用，也就是说指向同一个内存地址，修改其中的一个变量，会影响到其他所有变量：\n\n  ```\n  var o1 = {};\n  var o2 = o1;\n\n  o1.a = 1;\n  o2.a // 1\n\n  o2.b = 2;\n  o1.b // 2\n  ```\n\n  如果取消某一个变量对原对象的引用，不会影响到另一个变量：\n\n  ```\n  var o1 = {};\n  var o2 = o1;\n\n  o1 = 1;\n  o2 // {}\n  ```\n\n  这种引用只局限于对象，对原始类型的数据则是传值引用，都是值的拷贝\n\n  ```\n  var x = 1;\n  var y = x;\n\n  x = 2;\n  y // 1\n  // 当x的值发生变化后，y的值并未改变，表示y和x并不是指向同一个内存地址\n  ```\n\n+ **读取对象属性**有两种方法，使用点运算符，使用方括号运算符\n\n  使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理\n\n  数值键名不能使用点运算符，因为会被当成小数点，只能使用方括号运算符，且不用加引号\n\n  方括号运算符内部可以使用表达式\n\n  ```\n  o['hello'+'world']\n  o[3+3]\n  ```\n\n+ 点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值\n\n  ```\n  o.p = 'abc';\n  p['p'] = 'abc';\n  ```\n\n+ Object.keys方法查看一个对象本身的所有属性：\n\n  ```\n  var o = {\n    key1: 1,\n    key2: 2\n  }\n  Object.keys(o);\n  // ['key1','key2']\n  ```\n\n+ delete命令用于删除对象的属性，删除成功后返回true\n\n  ```\n  delete o.p\n  ```\n\n  delete命令删除一个不存在的属性，不会报错，而且返回true\n\n  delete删除存在且不得删除的属性，返回false\n\n  delete职能删除对象本身的属性，无法删除继承的属性\n\n+ **in运算符**用于检查对象是否包含某个属性（检查的是键名，不是键值），包含返回true，否则返回false：\n\n  ```\n  var o = { p:1 };\n  'p' in o //true\n  ```\n\n  JS中，所有全局变量都是顶层对象（浏览器的顶层对象就是window对象）的属性，因此可以用in运算符判断一个全局变量是否存在\n\n  in运算符不能识别对象继承的属性\n\n+ **for…in循环**用来遍历一个对象所有可便利（enumerable）的属性，会跳过不可遍历的属性\n\n  它不仅遍历对象自身的属性，还遍历继承的属性\n\n### 数组\n\n+ 只要是数组，就一定有length属性。\n\n  length属性是可写的\n\n  如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值，其余的被自动删除\n\n  如果人为设置length大雨当前元素个数，则数组成员数量会增加到这个值，新增的位置都是空位，读取新增的位置会返回undefined\n\n+ 由于数组本质上是对象，所以我们可以为数组添加属性，这不影响length属性的值\n\n+ 类似数组的对象（array-like object）：一个对象的所有键名都是正整数或零，并且有length属性\n\n  “类似数组的对象”并不是数组，它不具备数组特有的方法，比如push方法\n\n  ”类似数组的对象“的根本特征，就是具有length属性，但这种length属性不是动态值，不会随着成员变化而变化\n\n  典型的”类似数组的对象“是函数的arguments对象，大多数DOM元素集，还有字符串\n\n+ **in运算符**同样适用于数组，如果数组某个位置是空位，in运算符返回false\n\n+ **for…in循环**遍历的是对象的所有属性，数组是对象的一种，因此for...in循环也可以遍历数组的所有属性，包括数组的所有数字键和其他属性，因此不推荐用for...in遍历数组\n\n+ **数组的空位**：当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位。数组的空位不影响length属性：\n\n  ```\n  var a = [1, ,1];\n  a.length // 3\n  ```\n\n  数组的空位可读取，返回undefined\n\n  使用delete命令删除一个数组成员，会形成空位，并且不影响length属性：\n\n  ```\n  var a = [1,2,3];\n  delete a[1];\n\n  a[1] //undefined\n  a.length // 3\n  ```\n\n+ 数组的某个位置是空位，和某个位置是undefined是不一样的。\n\n  如果是空位，使用数组的forEach方法、for...in循环、Object.keys方法进行遍历，空位都会被跳过；\n\n  如果是undefined，遍历不会被跳过。\n\n  空位就是数组没有这个元素，所以不会被遍历到，而undefined表示数组有这个元素，值时undefined。\n\n### 函数\n\n+ **函数的三种声明方法**：\n\n  1. function命令声明的代码区块，就是一个函数：\n\n     ```\n     function print(s){\n       console.log(s);\n     }\n     ```\n\n  2. 函数表达式：除了用function命令声明，还可以采用变量赋值的写法\n\n     ```\n     var print = function(s){\n       console.log(s);\n     }\n     ```\n\n     这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式，因为赋值语句的等号右侧只能放表达式\n\n     采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效\n\n     ```\n     var print = function x(){\n       console.log(typeof x);\n     };\n     x // Error\n     print() //function\n     ```\n\n     需要注意，函数表达式需要在语句的结尾加上“；”，表示语句结束。\n\n  这两种声明函数的方式，差别很细微，这里可以近似认为是等价的\n\n  3. Function构造函数\n\n     ```\n     var add = new Function(\n     \t'x',\n     \t'y',\n     \t'return x + y'\n     );\n     // 等同于\n     function add(x,y){\n       return x + y;\n     }\n     ```\n\n     Function构造函数接受任意数量的参数，只有最后一个参数会被当作函数体，其他参数都是函数的参数；如果只有一个参数，该参数就是函数体\n\n     这种声明函数的方式非常不直观，几乎无人使用\n\n  + 如果同一个函数被多次声明，后面的声明会覆盖前面的声明\n\n    ```\n    function f(){\n      console.log(1);\n    }\n    f() // 2\n    function f(){\n      console.log(2);\n    }\n    f() // 2\n    ```\n\n+ 调用函数时，使用圆括号运算符\n\n  函数体内部的return语句表示返回。JS引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。\n\n  函数可以调用自身，这就是递归。\n\n+ **第一等公民**：JS语言将函数看作一种值，与其他值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。\n\n  由于函数与其他数据类型地位平等，所以在JS中又称函数为第一等公民。\n\n  ```\n  function add(x,y){\n    return x + y;\n  }\n\n  // 将函数赋值给一个变量\n  var operator = add;\n\n  // 将函数作为参数和返回值\n  function a(op){\n    return op;\n  }\n  a(add)(1,1)\n  // 2\n  ```\n\n+ **函数名的提升**：JS引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部：\n\n  ```\n  f();\n\n  function f(){}\n  ```\n\n  但是，如果采用赋值语句定义函数，JS就会报错：\n\n  ```\n  f();\n  var f = function (){};\n  // Error!\n  ```\n\n  等同于：\n\n  ```\n  var f;\n  f();\n  f = function () {};\n  ```\n\n  上面代码第二行，调用f时，f只是被声明了，还没有被赋值，等于undefined，所以会报错。\n\n+ **不能再条件语句中声明函数**：根据ES规范，不得在非函数的代码块中声明函数，最常见的就是if和try语句\n\n+ **函数的属性和方法**：\n\n  + *name属性*，返回紧跟在function关键字之后的那个函数名：\n\n    ```\n    function f1(){}\n    f1.name // 'f1'\n\n    var f2 = function (){};\n    f2.name // ''\n\n    var f3 = function myName(){};\n    f3.name // 'myName'\n    ```\n\n    匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）\n\n  + *length属性*，返回函数预期传入的参数个数，即函数定义之中的参数个数。不管调用时输入了多少个参数，只返回定义时的参数个数。\n\n  + *toString()方法*，返回函数的源码。\n\n+ **函数作用域**\n\n  作用域（scope）指的是变量存在的范围\n\n  JS只有两种作用域：一种是全剧作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。\n\n  在函数外部声明的变量就是**全局变量**，它可以在函数内部读取。\n\n  在函数内部定义的变量就是**局部变量**，外部无法读取。\n\n  + **函数内部定义的变量，会在该作用域内覆盖同名全局变量**：\n\n  ```\n  var v = 1;\n\n  function f(){\n    var v = 2;\n    console.log(v);\n  }\n\n  f() // 2\n  v // 1\n  ```\n\n  + **函数内部的变量提升**：\n\n    与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。\n\n  + **函数本身的作用域**：\n\n    函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。\n\n    ```\n    var a = 1;\n    var x = function (){\n      console.log(a);\n    }\n\n    function f() {\n      var a = 2;\n      x();\n    }\n\n    f() // 1\n    ```\n\n    函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。\n\n    很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量：\n\n    ```\n    var x = function (){\n      console.log(a);\n    };\n\n    function y(f) {\n      var a = 2;\n      f();\n    }\n\n    y(x)\n    // Error: a is not defined\n    ```\n\n    同样的，函数体内部声明的函数，作用域绑定函数体内部：\n\n    ```\n    function foo(){\n      var x = 1;\n      function bar(){\n        console.log(x);\n      }\n      return bar;\n    }\n\n    var x = 2;\n    var f = foo();\n    f() // 1\n    ```\n\n    这种机制构成了**闭包**。\n\n+ **参数**：ES5中，函数参数不是必需的，JS允许省略参数。\n\n  + ```\n    function f(a){\n      a = a || 1;\n      return a;\n    }\n    // ||表示“或运算”，赋值语句的等号右边，预期是一个值，凡是预期为值的地方，都可以用表达式\n    ```\n\n  + **传递方式**：\n\n    + 函数参数如果是**原始类型**的值（数值、字符串、布尔值），传递方式是**传值传递**。意味着，在函数体内修改参数值，不会影响到函数外部\n\n      ```\n      var p = 2;\n      function f(p){\n        p = 3;\n      }\n      f(p);\n\n      p // 2\n      ```\n\n      变量p是一个原始类型的值，传入函数f的方式是传值传递。因此在函数内部，p的值时原始值的拷贝，无论怎么修改，都不会影响到原始值。\n\n    + 如果函数参数是**复合类型**的值（数组、对象、其他函数），传递方式是**传址传递**。意味着，在函数内部修改参数，将会影响到原始值。\n\n      ```\n      var obj = {p: 1};\n      function f(o){\n        o.p = 2;\n      }\n      f(obj);\n\n      obj.p // 2\n      ```\n\n      上面代码中，传入函数f的是对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。\n\n      **注意**：如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值：\n\n      ```\n      var obj = [1,2,3];\n      function f(o){\n        0 = [2,3,4];\n      }\n      f(obj);\n\n      obj // [1,2,3]\n      ```\n\n      这是因为，形式参数（o）与实际参数obj存在一个赋值关系\n\n      ```\n      // 函数f内部\n      o = obj;\n      ```\n\n      上面代码中，对o的修改都会反映在obj身上。但是，如果对o赋予一个新的值，就等于切断了o与obj的联系，导致此后的修改都不会影响到obj。\n\n  + 某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性：\n\n    ```\n    var a = 1;\n    function f(p){\n      window[p] = 2;\n    }\n    f('a');\n\n    a // 2\n    ```\n\n  + **同名参数**：\n\n    如果有同名的参数，则取最后出现的那个值，即使最后的参数没有值或被省略，也是以其为准：\n\n    ```\n    function f(a,a){\n      console.log(a);\n    }\n    f(1,2) // 2\n    f(1) // undefined\n    ```\n\n  + **arguments对象**：\n\n    arguments对象包含了函数运行时的所有参数，arguments[0是第一个参数，arguments[1]就是第二个，以此类推。这个对象只有在函数体内部可以使用。\n\n    **正常模式下**，arguments对象可以在运行时修改：\n\n    ```\n    var f = function (a,b){\n      arguments[0] = 3;\n      arguments[1] = 2;\n      return a + b;\n    }\n    f(1,1) //5\n    ```\n\n    **严格模式下**，arguments对象是一个只读对象，修改它是无效的，但不会报错\n\n    ```\n    var f = function (a,b){\n      'use strict';\n      arguments[0] = 3; // 无效\n      arguments[1] = 2; // 无效\n      return a + b;\n    }\n    f(1,1) // 2\n    ```\n\n    介绍数组时说过，arguments虽然很像数组，但是它时一个对象，是一个“类似数组的对象”。数组专有的方法，不能在arguments对象上直接使用。\n\n+ **闭包**：\n\n  JS的作用域机制，使得函数外部无法获取函数内部声明的变量。\n\n  但出于某种原因，需要得到函数内部的局部变量。正常情况下是办不到的，只有通过变通方法实现，就是在函数内部，再定义一个函数。\n\n  ```\n  function f1(){\n    var n = 999;\n    function f2(){\n      console.log(n); // 999\n    }\n  }\n  ```\n\n  函数f2声明在函数f1的内部，f1内部的所有局部变量，对f2可见。反之则不行。这是JS语言特有的“链式作用域”结构（chain scope），子对象会一级一级的向上寻找所有父对象的变量。\n\n  既然f2可以读取f1的局部变量，那么只要把f2作为返回值，就可以在f1外部读取他的内部变量了\n\n  ```\n  function f1(){\n    var n = 999;\n    function f2(){\n      console.log(n);\n    }\n    return f2;\n  }\n  var result = f1();\n  result(); // 999\n  ```\n\n  函数f1点返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1点内部变量了。\n\n  **闭包**就是函数f2，即能够读取其他函数内部变量的函数。\n\n  JS语言中，只有函数内部的字函数才能读取内部变量，因此可以把闭包加单理解成**“定义在一个函数内部的函数”**。在本质上，闭包就是将函数内部和函数外部链接起来的一座桥梁。\n\n  **闭包的最大用处有两个**：1. 读取函数内部的变量。2. 让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在：\n\n  ```\n  function createIncrmenentor(start){\n    return function (){\n      return start++;\n    };\n  }\n  var inc = createIncrementor(5);\n\n  inc() // 5\n  inc() // 6\n  inc() // 7\n  ```\n\n  *上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境一直存在。所以，闭包可以看作是函数内部作用域的一个接口。*\n\n  *为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也是种在内存中，不会再调用结束后，被垃圾回收机制回收。*\n\n  **闭包的另一个用处，是封装对象的私有属性和私有方法。**\n\n  ```\n  function Person(name) {\n    var _age;\n    function setAge(n) {\n      _age = n;\n    }\n    function getAge() {\n      return _age;\n    }\n\n    return {\n      name: name,\n      getAge: getAge,\n      setAge: setAge\n    };\n  }\n\n  var p1 = Person('张三');\n  p1.setAge(25);\n  p1.getAge() // 25\n  ```\n\n  **注意**，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。\n\n+ **立即调用的函数表达式**\n\n  在JS中，一对圆括号（）是一种运算符，跟在函数名之后，表示调用该函数。比如，print（）就表示调用print函数。\n\n  有时，我们需要在定义函数之后，立即调用该函数。这时，闭不能在函数的定义之后加上圆括号，会产生语法错误：\n\n  ```\n  function () { /* code */}();\n  // SyntaxError: Unexpected token (\n  ```\n\n  产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。同行首是一个对象的大括号，到底是表达式还是语句同理。\n\n  ```\n  // 语句\n  function f() {}\n  // 表达式\n  var f = function f() {}\n  ```\n\n  为避免解析上的歧义，JS引擎规定，如果function关键字出现在行首，一律解释称语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。\n\n  解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。\n\n  ```\n  (function (){ /* code */ }());\n  // 或者\n  (function (){ /* code */ })();\n  ```\n\n  以圆括号开头，引擎就会认为这个一个表达式，而不是函数定义语句，就避免了错误。这就叫做“立即调用的函数表达式”。\n\n  这两种写法最后的分号都是必须的。如果省略分号，遇到连着两个立即调用的函数表达式，可能就会报错。\n\n## 运算符\n\n+ 加号运算符，拼接字符串和加法运算\n\n  ```\n  1 + 1 // '2'\n  '1' + 1 // '11'\n  1 + '1' // '11'\n\n  1+1+1+1 // '4'\n  '1'+1+1+1 // '1111'\n  1+'1'+1+1 // '1111'\n  1+1+'1'+1 // '211'\n  1+1+1+'1' // '31'\n  ```\n\n  从左往右，能加法运算就加法运算，直到遇到字符，把之前的运算结果和字符拼接，字符之后全部为拼接。\n\n  利用空字符串，将值转为字符串类型\n\n  ```\n  x + ''\n  ```\n\n+ 余数运算符（%）\n\n  ```\n  12 % 5 // 2\n  ```\n\n  余数运算的运算结果的正负由第一个运算子的正负决定：\n\n  ```\n  -1 % 2 // -1\n  1 % -2 // 1\n  ```\n\n+ 自增运算符（++）、自减运算符（—)\n\n  自增／自减操作会修改原始变量\n\n  放在变量前，先自增／自减，再返回操作后的值；\n\n  放在变量后，先返回变量的值，再自增／自减\n\n  ```\n  var x = 1;\n  var y = 1;\n  x++ // 1;\n  ++y // 2\n  ```\n\n+ 数值运算符（+）同样使用加号，但它是一元运算符（只需要一个操作数）。\n\n  数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）\n\n  ```\n  +true // 1\n  +[] // 0\n  +{} // NaN\n  ```\n\n+ 赋值运算符，除了最常见的等号（=），还有以下：\n\n  ```\n  x += y // 等同于 x = x + y\n  x -= y // 等同于 x = x - y\n  x *= y // 等同于 x = x * y\n  x /= y // 等同于 x = x / y\n  x %= y // 等同于 x = x % y\n  x >>= y // 等同于 x = x >> y\n  x <<= y // 等同于 x = x << y\n  x >>>= y // 等同于 x = x >>> y\n  x &= y // 等同于 x = x & y\n  x |= y // 等同于 x = x | y\n  x ^= y // 等同于 x = x ^ y\n  ```\n\n+ 比较运算符\n\n  如果两个运算子都是字符串，则按照字典顺序比较（实际上是比较Unicode码点）\n\n  否则，将两个运算子都转成数值，再进行比较（等同于先调用Number函数）\n\n+ ==和===的区别\n\n  相等运算符==比较两个值是否相等，严格相等运算符===比较它们是否为“同一个值”。\n\n  如果两个值不是同一类型，严格相等运算符===直接返回 false，而相等运算符==会将它们转化成同一类型，再用严格相等运算符进行比较\n\n+ ===严格相等运算符\n\n  + 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，不同就返回false。\n\n    ```\n    1 === 0x1 // true\n    NaN === NaN // false NaN与任何值都不相等，包括自己\n    ```\n\n  + 同一类型的复合类型的值（对象、数组、函数）比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象\n\n    ```\n    {} === {} // false\n    [] === [] // false\n    (function(){} === function(){}) // false\n    ```\n\n    上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是`false`。\n\n    如果两个变量引用同一个对象，则它们相等。\n\n    ```\n    var v1 = {};\n    var v2 = v1;\n    v1 === v2 // true\n    ```\n\n    注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。\n\n+ ==相等运算符\n\n  + 比较相同类型的数据时，与严格相等运算符完全一样\n\n  + 比较不同类型的数据时，相等运算符会先讲数据进行类型转换，然后再用严格相等运算符比较，转换规则如下：\n    + 比较原始类型的数据时，会将数据转换成数值类型再进行比较\n\n    + 复合类型（对象、数组、函数）和原始类型的值比较时，复合类型转化成原始类型，再进行比较\n\n      ```\n      [1] == 1 // true\n      // 等同于 Number([1]) == 1\n\n      [1] == '1' // true\n      // 等同于 String([1]) == Number('1')\n\n      [1] == true // true\n      // 等同于 Number([1]) == Number(true)\n      ```\n\n+ 且运算符&&\n\n  运算规则：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值：\n\n  ```\n  't' && '' // \"\"\n  't' && 'f' // \"f\"\n  't' && (1 + 2) // 3\n  '' && 'f' // \"\"\n  '' && '' // \"\"\n\n  var x = 1;\n  (1 - 1) && ( x += 1) // 0\n  x // 1\n  ```\n\n  if语句中经常这样写：\n\n  ```\n  if(x && y){\n    /* code */\n  }\n  ```\n\n  x && y并不直接返回布尔值，而是if命令后面的判断条件预期应该是一个布尔值，JS会自动将其转为布尔值。\n\n+ 或运算符||\n\n  运算规则：如果第一个运算子的布尔值为`true`，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为`false`，则返回第二个运算子的值。\n\n+ void运算符\n\n  void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。\n\n  ```\n  void 0 // undefined\n  void(0) // undefined\n  ```\n\n  void运算符的主要作用是用于在超链接中插入代码，防止网页跳转。\n\n  ```\n  // 点击链接，但不跳转页面\n  <a href=\"javascript:void\"></a>\n\n  // 新建窗口打开链接\n  <a href=\"javascript:void window.open('http://example.com')\"></a>\n\n  // 提交表单，但不会跳转页面\n  <a href=\"javascript:void(document.form.submit())\"></a>\n  ```\n\n## 数据类型转换\n\nJS是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。\n\n虽然变量没有类型，但是数据本身和各种运算符是有类型的。如果运算符发现，数据的类型与预期不符，就会自动转换类型。\n\n### 强制转换\n\n强制转换主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或布尔值。\n\n+ Number()函数，可以将任意类型的值转化成数值\n\n  1. 原始类型值（字符串，布尔值、undefined、null）\n\n     Number函数将字符串转为数值要比parseInt函数严格很多。只有有一个字符无法转成数值，整个字符串就会被转为NaN。而parseInt是逐个转换字符。\n\n     ```\n     // 数值：转换后还是原来的值\n     Number(324) // 324\n\n     // 字符串：如果可以被解析为数值，则转换为相应的数值\n     Number('324') // 324\n\n     // 字符串：如果不可以被解析为数值，返回NaN\n     Number('324abc') // NaN\n\n     // 空字符串转为0\n     Number('') // 0\n\n     // 布尔值：true 转成1，false 转成0\n     Number(true) // 1\n     Number(false) // 0\n\n     // undefined：转成 NaN\n     Number(undefined) // NaN\n\n     // null：转成0\n     Number(null) // 0\n     ```\n\n  2. 复合类型值（对象、数组、函数）\n\n     简单的规则是，`Number`方法的参数是对象时，将返回`NaN`，**除非是包含单个数值的数组**。\n\n     ```\n     Number({a: 1}) // NaN\n     Number([1, 2, 3]) // NaN\n     Number([5]) // 5\n     ```\n\n+ String()函数，可以将任意类型的值转化成字符串。转换规则如下：\n\n  1. 原始类型值的转换规则\n\n     ```\n     数值：转为相应的字符串。\n     字符串：转换后还是原来的值。\n     布尔值：true转为\"true\"，false转为\"false\"。\n     undefined：转为\"undefined\"。\n     null：转为\"null\"。\n\n     String(123) // \"123\"\n     String('abc') // \"abc\"\n     String(true) // \"true\"\n     String(undefined) // \"undefined\"\n     String(null) // \"null\"\n     ```\n\n  2. 对象的转换规则\n\n     `String`方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\n\n     ```\n     String({a: 1}) // \"[object Object]\"\n     String([1, 2, 3]) // \"1,2,3\"\n     ```\n\n+ Boolean()函数，可以将任意类型的变量转为布尔值，除了以下六个值的转换结果为false，其他值全部是true\n\n  ```\n  undefined\n  null\n  -0\n  0或+0\n  NaN\n  ''（空字符串）\n  ```\n\n### 自动转换\n\n以下三种情况，JS会自动转换数据类型，转换时自动完成的，对用户不可见\n\n```\n// 1. 不同类型的数据互相运算\n123 + 'abc' // \"123abc\"\n\n// 2. 对非布尔值类型的数据求布尔值\nif ('abc') {\n  console.log('hello')\n}  // \"hello\"\n\n// 3. 对非数值类型的数据使用一元运算符（即“+”和“-”）\n+ {foo: 'bar'} // NaN\n- [1, 2, 3] // NaN\n```\n\n自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用`String`函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。\n\n## 错误处理机制\n\n### Error对象\n\nJavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript原生提供一个`Error`构造函数，所有抛出的错误都是这个构造函数的实例。\n\n```\nvar err = new Error('出错了');\nerr.message // \"出错了\"\n```\n\nError构造函数接受一个参数，表示错误提示，可以从实例等message属性读到这个参数。\n\nError对象的实例必须有message属性。大多数JS引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但她们是非标准的，不是每种实现都有\n\n### JS的原声错误类型\n\nError对象时最易班的错误类型。在它的基础上，JS还定义了其他6种错误：\n\n1. SyntaxError是解析代码时发生的语法错误\n2. ReferenceError是引用一个不存在的变量时发生的错误或将一个值分配给无法分配的对象\n3. RangeError\n4. TypeError\n5. URIError\n6. EvalError\n\n### 自定义错误\n\n除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。\n\n```\nfunction UserError(message) {\n   this.message = message || \"默认信息\";\n   this.name = \"UserError\";\n}\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n```\n\n上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义的错误了。\n\n```\nnew UserError(\"这是自定义的错误！\");\n```\n\n### throw语句\n\nthrow语句的作用是中断程序执行，抛出一个意外或错误。它接受一个表达式作为参数们可以抛出各种值。\n\nJS引擎一旦遇到throw语句，就会停止执行后面的语句，并将throw语句的参数值，返回给用户。\n\n```\nthrow new Error('出错了！');\n```\n\n### try…catch结构\n\ntry…catch结构对错误进行处理\n\n```\ntru{\n  throw new Error('出错了！');\n}catch(e){\n  console.log(e.name + \":\" + e.message);\n  console.log(e.stack)\n}\n```\n\ntry代码块一抛出错误（上例用的是throw语句），js引擎就立即把代码的执行，转到catch代码块。catch接受一个参数，表示try代码块抛出的值。\n\ncatch代码块中，还可以再抛出错误，甚至使用嵌套的try...catch结构。\n\n# 面向对象编程\n\n面向对象编程（Object Oriented Programming，OOP）是目前主流的编程范式。\n\n对象是一个容器，封装了属性（property）和方法（method）。\n\n## 构造函数\n\n典型的面向对象编程语言（C++，Java），存在“类”（class）的概念。所谓“类”就是对象的模版，对象就是“类”的实例。JS语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。\n\nJS语言使用构造函数作为对象的模版。所谓“构造函数”，就是专门用来生成对象的函数。它提供模版，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。\n\n构造函数的写法就是一个普通的函数，但是有自己的特征和用法。为了和普通函数区别，构造函数名字的第一个字母通常大写：\n\n```\nvar Vehicle = function () {\n  this.price = 1000;\n};\n```\n\n1. 函数体内部使用了this关键字，代表了所要生成的对象实例。\n2. 生成对象的时候，必需用new命令。\n\n## new命令\n\nnew命令的作用是，执行构造函数，返回一个对象实例。\n\n```\nvar Vehicle = function () {\n  this.price = 1000;\n};\nvar v = new Vehicle();\nv.price // 1000\n```\n\nnew命令执行时，构造函数内部的this，就代表了新生成的实例对象。\n\n使用new命令时，根据需要，构造函数也可以接受参数：\n\n```\nvar Vehicle = function (p) {\n  this.price = p;\n};\nvar v = new Vehicle(500);\n```\n\nnew命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号：\n\n```\nvar v = new Vehicle();\nvar v = new Vehicle;\n```\n\n### new命令的原理\n\n使用new命令时，她后面的函数调用就不是正常的调用，而是依次执行下面的步骤：\n\n1. 创建一个空对象，作为将要返回的对象实例\n2. 将这个空对象的原型，指向构造函数的prototype属性\n3. 将这个空对象赋值给函数内部的this关键字\n4. 开始执行构造函数内部的代码\n\n构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造“为需要的样子。\n\n如果构造函数内部有return语句，而且return后面跟一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。\n\n```\nvar Vehicle = function () {\n  this.price = 1000;\n  return 1000;\n};\n\n(new Vehicle()) === 1000\n// false\n\nvar Vehicle = function (){\n  this.price = 1000;\n  return { price: 2000 };\n};\n\n(new Vehicle()).price\n// 2000\n```\n\n如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。\n\n### 直接调用构造函数会发生什么？\n\n如果忘了使用new命令，直接调用构造函数会发生什么？\n\n这种情况下，构造函数就编程了普通函数，并不会生成实例对象。而且this这时代表全局对象，将造成一些意想不到的后果。\n\n```\nvar Vehicle = function () {\n  this.price = 1000;\n}\n\nvar v = Vehicle();\nv.price\n// Uncaught TypeError: Cannot read property 'price' of undefined\n\nprice\n// 1000\n```\n\n不使用new命令调用Vehicle构造函数时，price属性变成了全局变量，变量v变成了undefined。\n\n### new.target\n\n函数内部可以使用new.target属性。如当前函数是new命令调用，new.target指向当前函数，否则为undefined。\n\n## 使用Object.create()创建实例对象\n\n构造函数作为模版，可以生成实例对象。但是，有时只能拿到实例对象，而该对象根本就不是由构造函数生成的。这时可以使用Object.create()方法，直接以某个实例对象作为模版，生成一个新的实例对象。\n\n```\nvar person1 = {\n  name: '张三',\n  age: 38,\n  greeting: function() {\n    console.log('Hi! I\\'m ' + this.name + '.');\n  }\n};\n\nvar person2 = Object.create(person1);\n\nperson2.name // 张三\nperson2.greeting() // Hi! I'm 张三.\n```\n\n上面代码中，对象person1是person2的模版，后者继承了前者的属性和方法。\n\n## this关键字\n\nthis总是返回一个对象，简单说就是返回属性或方法“当前”所在的对象:\n\n```\nvar person = {\n  name : 'Ethan',\n  describe: function () {\n    return '姓名:'+this.name;\n  }\n};\nperson.describe()\n// “姓名：Ethan”\n```\n\nthis.name表示describe方法所在的当前对象的name属性。调用person.describe方法时，describe方法所在的当前对象是person，所以就是调用person.name。\n\n**由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。**\n\n```\nfunction f() {\n  return '姓名：'+ this.name;\n}\n\nvar A = {\n  name: '张三',\n  describe: f\n};\n\nvar B = {\n  name: '李四',\n  describe: f\n};\n\nA.describe() // \"姓名：张三\"\nB.describe() // \"姓名：李四\"\n```\n\n只要函数被赋给另一个变量，this的指向就会变：\n\n```\nvar A = {\n  name: '张三',\n  describe: function () {\n    return '姓名：'+ this.name;\n  }\n};\n\nvar name = '李四';\nvar f = A.describe;\nf() // \"姓名：李四\"\n```\n\nA.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。\n\n```\n<input type=\"text\" name=\"age\" size=3 onChange=\"validate(this, 18, 99);\">\n\n<script>\nfunction validate(obj, lowval, hival){\n  if ((obj.value < lowval) || (obj.value > hival))\n    console.log('Invalid Value!');\n}\n</script>\n```\n\n上面代码是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数。回调函数传入this，就代表传入当前对象（即文本框），然后就可以从this.value上面独到用户的输入值。\n\nJS语言中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是这个对象（环境）。\n\n如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。\n\n```\nfunction f(){\n  return this;\n}\nf() === window // true\n```\n\n可以近似地认为，this是所有函数运行时的一个隐藏参数，指向函数的运行环境。 \n\n### 使用场合\n\nthis的使用可以分成以下几个场合。\n\n1. **全局环境**使用this，它指的就是顶层对象window。\n\n   ```\n   this === window // true\n\n   function f(){\n     soncole.log(this === window); // true\n   }\n   ```\n\n   不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。\n\n2. **构造函数**中的this，指的是实例对象。\n\n3. **对象的方法**\n\n   当A对象的方法被赋予B对象，该方法中的this就是从指向A对象变成了指向B对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。\n\n   ```\n   var obj = {\n     foo: function(){\n       console.log(this);\n     }\n   };\n   obj.foo() // obj\n   ```\n\n   obj.foo方法执行时，它内部的this指向obj。\n\n   但是，只有这一种用法（直接在obj对象上调用foo方法），this指向obj；其他用法时，this都指向代码块当前所在对象（浏览器为window对象）。\n\n   ```\n   // 情况一\n   (obj.foo = obj.foo)() // window\n\n   // 情况二\n   (false || obj.foo)() // window\n\n   // 情况三\n   (1, obj.foo)() // window\n   ```\n\n   上面代码中，obj.foo先运算在执行，即使值根本没有变化，this也不再指向obj了。这时因为这时它就脱离了运行环境obj，而是在全局环境执行。\n\n   可以这样理解，在JS引擎内部，obj和obj.foo储存在两个内存地址，假设时M1和M2。只有obj.foo（）这样调用时，是从M1调用M2，因此this指向obj。但是，上面三种情况，都是直接取出M2进行运算，然后在全局环境执行运算结果（还是M2），因此this指向全局环境。\n\n   **如果某个方法位于多层对象的内部，这时this只是指向当前一层的对象，而不会继承更上面的层**：\n\n   ```\n   var a = {\n     p: 'Hello',\n     b: {\n       m: function(){\n         console.log(this.p);\n       }\n     }\n   };\n\n   a.b.m() // undefined\n   ```\n\n   上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是直系那个a.b。\n\n### 使用注意\n\n1. 避免多层this\n\n   ```\n   var o = {\n     f1:function(){\n       console.log(this);\n       var f2 = function (){\n         console.log(this);\n       }();\n     }\n   }\n\n   o.f1()\n   // Object\n   // Window\n   ```\n\n   第一层指向该对象，第二层指向全局对象\n\n   [**为什么第二层this指向全局对象window？**](http://blog.csdn.net/u011457225/article/details/73882551?utm_source=itdadao&utm_medium=referral)\n\n   o.f1()表示调用o对象的f1方法，所以f1方法中的this指向o对象；而f1方法中的闭包（即f2函数）不属于任何对象，它不是一个对象的方法。非严格模式下，如果没有指定属于哪个对象，那么它就属于window对象。\n\n### 绑定this的方法\n\nJS提供了call、apply、bind三种方法，来切换／固定this 的指向。\n\n1. **function.prototype.call()**\n\n   作用：指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。\n\n   call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。如果参数是一个原始值，那么这个原始值回自动转成对应的包装对象，然后传入call方法。\n\n   ```\n   var n = 123;\n   var obj = { n: 456};\n\n   function a(){\n     console.log(this.n);\n   }\n\n   a.call() // 123\n   a.call(null) // 123\n   a.call(undefined) // 123\n   a.call(window) // 123\n   a.call(obj) // 456\n   ```\n\n   call方法还可以接受多个参数，第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。\n\n   ```\n   func.call(thisValue,arg1,arg2,...)\n   ```\n\n   ```\n   function add(a,b){\n     return a + b;\n   }\n\n   add.call(this,1,2) // 3\n   ```\n\n2. **function.prototype.apply()**\n\n   apply方法等作用域call方法类似，也是改变this指向，然后在调用该函数。唯一的区别就是，他接受一个数组作为函数执行时的参数：\n\n   ```\n   func.apply(thisValue,[arg1,arg2,...])\n   ```\n\n   ```\n   function f(x,y){\n     console.log(x+y);\n   }\n   f.call(null,1,1) // 2\n   f.apply(null,[1,1]) // 2\n   ```\n\n3. **function.prototype.bind()**\n\n   apply／call方法不仅绑定函数执行时所在的对象，还会立即执行函数。\n\n   bind方法只用于将函数体内的this绑定到某个对象，然后返回一个新函数。\n\n## prototype 对象\n\n### 原型对象\n\n通过同一个构造函数创建的实例对象之间，无法共享属性，对系统资源造成浪费。\n\n**JS的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。null除外。**\n\n原型对象上的所有属性和方法，都能派生对象共享。这就是JS继承机制的基本设计。\n\n通过构造函数生成实例对象时，会自动为实例对象分配原型对象。**每一个构造函数都有一个prototype属性**，这个属性就是实例对象的原型对象。\n\n```\nfunction Animal (name){\n  this.name = name;\n}\n\nAnimal.prototype.color = 'white';\n\nvar cat1 = new Animal('大毛');\nvar cat2 = new Animal('二毛');\n\ncat1.color // 'white'\ncat2.color // 'white'\n```\n\n构造函数Animal的prototype对象，就是实例对象cat1和cat2的原型对象。在原型对象上添加一个color属性。实例对象都能读取该属性。\n\n+ 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。\n\n\n+ 当实例对象本身没有某个属性或方法等时候，它会去原型对象寻找并读取这个属性火方法。\n+ 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。\n\n**原型对象的作用，就是定义所有实例对象共享的属性和方法。**\n\n### 原型链\n\n原型对象本身也是对象，又有自己的原型，所以形成一条原型链。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。\n\n如果一层层地上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即Object构造函数的prototype属性指向的那个对象。`Object.prototype`对象的原型是没有任何属性和方法等`null`对象，而`null`对象没有自己的原型。\n\n+ 原型链的作用是：读取对象的某个属性时，JS引擎线寻找对象本身的属性，如果找不到，就到它的原型去找，如果还找不到，就到原型的原型去找。如果知道最顶层的`Object.prototype`还是找不到，则返回undefined。\n\n在原型链一级级向上寻找某个属性，对性能有影响。属性越在山层影响越大。如果寻找某个不存在的属性，会遍历整个原型链。\n\n```\nvar MyArray = function (){};\n\nMyArray.prototype = new Array();\nMyArray.prototype.constructor = MyArray;\n\nvar mine = new MyArray();\nmine.push(1,2,3);\n\nmine.length // 3\nmine instanceof Array // true\n```\n\ninstanceof运算符用来比较一个对象是否为某个构造函数的实例。\n\n### constructor属性\n\nprototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。\n\n```\nfunction P (){}\n\nP.prototype.constructor === p // true\n```\n\n由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承：\n\n```\nfunction P () {}\nvar p = new P();\n\np.constructor\n// function P() {}\n\np.constructor === P.prototype.constructor\n// true\n\np.hasOwnProperty('constructor')\n//false\n```\n\n+ **constructor属性的作用，是分辨原型对象到底属于哪个构造函数**\n\n+ 通过constructor属性，从实例新建另一个实例：\n\n  ```\n  function Constr() {}\n  var x = new Constr();\n\n  var y = new x.constructor();\n  y instanceof Constr // true\n  ```\n\n  这使得在实例方法中，调用自身的构造函数成为可能：\n\n  ```\n  Constr.prototype.createCopy = function (){\n    return new this.constructor();\n  }\n  ```\n\n+ 通过name属性，可以从实例得到构造函数的名称：\n\n  ```\n  function Foo () {}\n  var f = new Foo();\n  f.constructor.name // \"Foo\"\n  ```\n\n+ 修改原型对象时，一般要同时校正constructor属性的指向，否则会导致instanceof运算符失真。\n\n### instanceof运算符\n\ninstanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。\n\n```\nvar n = new Vehicle();\nv instanceof Vehicle // true\n```\n\ninstanceof运算符左边时实例对象，右边是构造函数。它会检查右边构造函数的原型对象，是否在左边对象的原型链上。\n\ninstanceof运算符只能用于对象，不适用原始类型的值。\n\n### Object.getPrototypeOf()\n\n`Object.getPrototypeOf`方法返回一个对象的原型。这时获取原型对象的标准方法。\n\n```\n// 空对象的原型是Object.prototype\nObject.getPrototypeOf({}) === Object.prototype\n// true\n\n// 函数的原型是Function.prototype\nfunction f() {}\nObject.getPrototypeOf(f) === Function.prototype\n// true\n\n// f 为 F 的实例对象，则 f 的原型是 F.prototype\nvar f = new F();\nObject.getPrototypeOf(f) === F.prototype\n// true\n```\n\n### Object.setPrototypeOf()\n\n`Object.setPrototypeOf`方法可以为现有对象设置原型，返回一个新对象。\n\n`Object.setPrototypeOf`方法接受两个参数，第一个是现有对象，第二个是原型对象。\n\n`new`命令通过构造函数新建实例对象，实质就是将实例对象的原型，指向构造函数的`prototype`属性，然后在实例对象上执行构造函数。\n\n```\nvar F = function () {\n  this.foo = 'bar';\n};\n\nvar f = new F();\n\n// 等同于\nvar f = Object.setPrototypeOf({}, F.prototype);\nF.call(f);\nf.foo // \"bar\"\n```\n\n### Object.create()\n\n`Object.create`方法是为了满足只能通过实例对象生成另一个实例对象的需求。\n\n`Object.create`方法接受一个对象作为**第一个参数**，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。\n\n老式浏览器如果不支持Object.create方法，可以用下面代码部署：\n\n```\nif (typeof Object.create !== 'function'){\n  Object.create = function (obj){\n    function F(){}\n    F.prototype = obj;\n    return new F()\n  };\n}\n```\n\n+ Object.create方法参数不能为空，或者不是对象，否则会报错。\n\n+ 如果想生成一个不继承任何属性的对象，可以将Object.create的参数设为null。\n\n+ Object.create方法生成的新对象，动态继承原型。在原型上添加或修改任何方法，会立刻反应在新对象之上。\n\n+ Object.create方法还接受**第二个参数**。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性\n\n  ```\n  var obj = Object.create({}, {\n    p1: {\n      value: 123,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    },\n    p2: {\n      value: 'abc',\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    }\n  });\n\n  // 等同于\n  var obj = Object.create({});\n  obj.p1 = 123;\n  obj.p2 = 'abc';\n  ```\n\n+ Object.create方法生成的对象，继承了它原型对象的构造函数。\n\n### Object.prototype.isPrototypeOf()\n\n对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。\n\n```\nvar o1 = {};\nvar o2 = Object.create(o1);\nvar o3 = Object.create(o2);\n\no2.isPrototypeOf(o3); // true\no1.isPrototypeOf(o3); // true\n```\n\n**只要某个对象处在原型链上，isPrototypeOf都返回true。**\n\n### Object.prototype.\\_\\_proto\\_\\_\n\n\\_\\_proto\\_\\_属性（前后各两个下划线）可以改写某个对象的原型对象。\n\n```\nvar obj = {};\nvar p = {};\n\nobj.__proto__ = p;\nObject.getPrototypeOf(obj) === p // true\n```\n\n### 获取原型对象方法等比较\n\n\\_\\_proto\\_\\_属性指向当前对象的原型对象，即构造函数的prototype属性：\n\n```\nvar obj = new Object();\n\nobj.__proto__ === Object.prototype\n//true\nobj.__proto__ === obj.constructor.prototype\n//true\n```\n\n因此，获取实例对象obj的原型对象，有三种方法：\n\n+ obj.\\_\\_proto\\_\\_\n+ obj.constructor.prototype\n+ Object.getPrototypeOf(obj)\n\n前两种方法都不可靠，推荐第三种。\n\n## Object对象与继承\n\n通过原型链，对象的属性分成两种：自身的属性和继承的属性。\n\n### Object.getOwnPropertyNames()\n\n`Object.getOwnPropertyNames`方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。\n\n对象本身的属性之中，有的是可以枚举的，有的不可枚举。`Object.getOwnPropertyNames`方法返回包括不可枚举的所有键名。如果只获取可枚举属性，请使用`Object.keys`方法。\n\n### Obejct.prototype.hasOnwProperty()\n\n对象实例的`hasOwnProperty`方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上：\n\n```\nDate.hasOwnProperty('length')\n// true\n\nDate.hasOwnProperty('toString')\n// false\n```\n\nhasOwnProperty方法是JS中唯一一个处理对象属性时，不会遍历原型链的方法。\n\n### in运算符和for...in循环\n\n+ in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。\n+ 获得对象的所有可枚举属性（不管是自身的还是继承的），可以使用for...in循环。\n\n### 对象的拷贝\n\n如果要拷贝一个对象，需要做到下面两件事情。\n\n+ 确保拷贝后的对象，与原对象具有同样的prototype原型对象。\n+ 确保拷贝后的对象，与原对象具有同样的属性。\n\n# 标准库\n\n## Object对象\n\nJS原生提供Object对象（起首的O大写），所有其他对象都继承自这个对象。\n\nObject本身也是一个构造函数，可以直接通过它来生成新对象。\n\nObject作为构造函数使用时，可以接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。\n\n## Array对象\n\nArray是JS的内置对象，同时也是一个构造函数，可以用它生成新的数组。\n\n## 包装对象\n\n所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。\n\n```\nvar v1 = new Number(123);\nvar v2 = new String('abc');\nvar v3 = new Boolean(true);\n```\n\nNumber、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。\n\n```\nNumber(123) // 123\nString('abc') // \"abc\"\nBoolean(true) // true\n```\n\n总之，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。\n\n## Math对象\n\nMath是JS的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。\n\n## Date对象\n\nDate对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。\n\nDate对象也可以作为构造函数使用。使用new命令，会返回一个Date对象的实例。如果不加参数，生成的就是代表当前时间的对象。\n\n## 属性描述对象\n\nJS提供了一个内部数据结构，用来描述一个对象的属性的行为，控制它的行为。这被称为“属性描述对象“（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。\n\n下面是属性描述对象的一个实例。\n\n```\n{\n  value:123,\n  writable:false,\n  enumerable:true,\n  configurable:false,\n  get:undefined,\n  set:undefined\n}\n```\n\n属性描述对象提供6个元属性：\n\n1. value\n\n   value存放该属性的属性值，默认为undefined。\n\n2. writable\n\n   writable存放一个布尔值，表示属性值（value）是否可改变，默认为true。\n\n3. enumerable\n\n   enumerable存放一个布尔值，表示该属性是否可枚举，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。\n\n4. configurable\n\n   configurable存放一个布尔值，表示“可配置性”，默认为true。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。\n\n5. get\n\n   get存放一个函数，表示该属性的取值函数（getter），默认undefined。\n\n6. set\n\n   set存放一个函数，表示该属性的存值函数（setter），默认为undefined。\n\n### Object.getOwnPropertyDescriptor()\n\n`Object.getOwnPropertyDescriptor`方法可以读出对象自身属性的属性描述对象。\n\n```\nvar o = { p : 'a' };\n\nObject.getOwnPropertyDescriptor(o,'p')\n// Object { value: \"a\",\n//   writable: true,\n//   enumerable: true,\n//   configurable: true\n// }\n```\n\n### Object.defineProperty(),Object.defineProperties()\n\n`Object.defineProperty()`方法允许通过定义属性描述对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下：\n\n```\nObject.defineProperty(object,propertyName,attributesObject)\n```\n\n`Object.defineProperty`方法接受三个参数，第一个是属性所在的对象，第二个是属性名（它应该是一个字符串），第三个是属性的描述对象。比如新建一个o对象，并定义它的p属性，写法如下：\n\n```\nvar o = Object.defineProperty({},'p',{\n  value:123,\n  writable:false,\n  enumerable:true,\n  configurable:false\n})\no.p\n// 123\no.p = 246;\no.p\n// 123\n// 因为writable为false，所以无法改变该属性的值。\n```\n\n如果属性已经存在，`Object.defineProperty`方法相当于更新该属性的属性描述对象。\n\n需要注意的是，Object.defineProperty方法和后面的Object.defineProperties方法，都有性能损耗，会拖慢执行速度，不宜大量使用。\n\n如果一次性定义或修改多个属性，可以使用`Object.defineProperties`方法：\n\n```\nvar o = Object.defineProperties({},{\n  p1: { value: 123, enumerable: true },\n  p2: { value: 'abc', enumerable: true },\n  p3: { get: function(){ return this.p1 + this.p2 },\n  \tenumerable:true,\n  \tconfigurable:true\n  }\n});\n\no.p1 // 123\no.p2 // \"abc\"\no.p3 // \"123abc\"\n```\n\n上面代码的p3属性，定义了取值函数get。**这时需要注意的是，一旦定义了取值函数get（或存值函数set），就不能将writable设为true，或者同时定义value属性，会报错。**\n\n```\nvar o = {};\n\nObject.defineProperty(o,'p',{\n  value:123,\n  get: function (){ return 456; }\n});\n// TypeError: Invalid property.\n// A property cannot both have accessors and be writable or have a value,\n```\n\n### 元属性\n\n#### 可枚举性（enumerable）\n\n只有可枚举的属性，才会被for...in循环遍历，同时还规定原生继承的属性都是不可枚举的。\n\n可枚举性涌来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会渠道该属性。\n\n+ for…in循环\n+ Object.keys方法\n+ JSON.stringify方法\n\n基本上，JS原生提供的属性都是不可枚举的，用户自定义的属性都是可枚举的。\n\n#### 可配置性（configurable）\n\n可配置性决定了是否可以修改属性描述对象。也就是说，当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。\n\n需要注意的是，writable只有在从false改为true会报错，从true改为false则是允许的。\n\n```\nvar o = Object.defineProperty({},'p',{\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(o,'p',{writable: false})\n// 修改成功\n```\n\n至于value，只要writable和configurable有一个为true，就允许改动。\n\n```\nvar o1 = Object.defineProperty({}, 'p', {\n  value: 1,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(o1,'p', {value: 2})\n// 修改成功\n\nvar o2 = Object.defineProperty({}, 'p', {\n  value: 1,\n  writable: false,\n  configurable: true\n});\n\nObject.defineProperty(o2,'p', {value: 2})\n// 修改成功\n```\n\nconfigurable为false时，直接对该属性赋值，不报错，但不会成功。\n\n```\nvar o = Object.defineProperty({},'p',{\n  value: 1,\n  configurable: false\n});\n\no.p = 2;\no.p // 1\n```\n\n上面代码中，o对象的p属性是不可配置的，对他赋值是不会生效的。\n\n可配置性决定了一个变量是否可以被删除。\n\n```\nvar o = Object.definePropertyies({},{\n  p1: { value: 1, configurable: true },\n  p2: { value: 2, configurable: false}\n});\n\ndelete o.p1 // true\ndelete o.p2 // false\n\no.p1 // undefined\no.p2 // 2\n```\n\n#### 可写性（writable）\n\n可写性决定了属性的值是否可以被改变。\n\n```\nvar o = {};\nObject.defineProperty(o,'a',{\n  value: 37,\n  writable:false\n});\n\no.a // 37\no.a = 25;\no.a // 37\n```\n\n正常模式下，对可写性为false的属性赋值不会报错，只会默默失败。但是严格模式下会报错。\n\n关于可写性，还有一种特殊情况。就是如果原型对象的某个属性的可写性为false，那么派生对象将无法自定义这个属性。\n\n```\nvar proto = Object.defineProperty({},'foo',{\n  value: 'a',\n  writable: false\n});\n\nvar o = Object.create(proto);\n\no.foo = 'b';\no.foo // 'a'\n```\n\n规避这个情况的方法，就是通过覆盖属性描述对象，绕过这个限制，原因是这种情况下，原型链会被完全忽视。\n\n```\nObject.defineProperty(o,'foo',{\n  value:'b'\n});\no.foo // 'b'\n```\n\n### 存取器（accessor）\n\n除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用set命令；取值函数称为getter，使用get命令。\n\n存取器提供的是虚拟属性，即该属性的值不失时机存在的，而是每次读取时计算生成的。\n\n```\nvar o = {\n  get p(){\n    return 'getter';\n  },\n  set p(value){\n    console.log('setter:' + value);\n  }\n};\n\no.p // \"getter\"\no.p = 123 // \"setter: 123\"\n```\n\n上面代码中，o对象内部的get和set命令，分别定义了p属性的取值函数和存值函数。定义了这两个函数之后，对p属性取值时，取值函数会自动调用；对p属性赋值时，存值函数会自动调用。\n\n取值函数getter不能接受参数，存值函数setter只能接受一个参数（即属性的值）。\n\n对象也不能有和与之函数同名的属性。\n\n存取器也可以通过Object.defineProperty定义：\n\n```\nvar d = new Date();\nObject.definedProperty(d,'month',{\n  get: function (){\n    return d.getMonth();\n  },\n  set: function (v){\n    d.setMonth(v);\n  }\n});\n```\n\n**利用存取器，可以实现数据对象与DOM对象的双向绑定。**\n\n```\nObject.defineProperty(user,'name',{\n  get: function(){\n    return document.getElementById('foo').value\n  },\n  set: function(newValue){\n    document.getElementById('foo').value = newValue\n  },\n  configurable: true\n})\n```\n\n上面代码，将DOM对象foo与数据对象user的name属性，实现了绑定。两者之中只要有一个对象发生变化，就能在另一个对象上实时反映出来。\n\n# 语法专题\n\n## 单线程模型\n\n### 含义\n\n单线程模型指的是，JS值在一个线程上运行。也就是说，JS同时只能执行一个任务，其他任务都必须在后面排队等待。\n\nJS只在一个线程上运行，不代表JS引擎只有一个线程。JS有多个线程。\n\n### 消息队列\n\nJS运行时，除了一个运行线程，JS还提供一个消息队列，里面是各种需要当前程序处理的消息。新的消息进入队列时，会自动排在队列尾端。\n\n运行线程只要发现消息队列不为空，就会取出排在第一位的消息，执行它对应的回调函数。等执行完，再取出排在第二位的消息，不断循环，直到消息队列变空为止。\n\n进入消息队列的消息，必须有对应的回调函数。否则这个消息就会遗失。\n\nsetTimeout会在指定时间向消息队列添加一条消息。如果消息队列之中，此时没有其他消息，这条消息会立即得到处理；否则，这条消息会不得不等到其他消息处理完，才会得到处理。因此，`setTimeout`指定的执行时间，只是一个最早可能发生的时间，并不能保证一定会在那个时间发生。\n\n### Event Loop\n\n用来一轮又一轮的处理消息队列之中的消息，即执行对应的回调函数的内部循环机制。\n\n常见的JS任务：\n\n+ 执行JS代码\n+ 对用户的输入（鼠标点击、键盘输入等等）做出反应\n+ 处理异步网络请求\n\n所有任务可以分成两种，一种是同步任务，另一种是异步任务。\n\n同步任务指的是，在JavaScript执行进程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入JavaScript执行进程、而进入“任务队列”（task queue）的任务，只有“任务队列”通知主进程，某个异步任务可以执行了，该任务（采用回调函数的形式）才会进入JavaScript进程执行。\n\n以Ajax操作为例，它可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着Ajax操作返回结果，再往下执行；如果是异步任务，该任务直接进入“任务队列”，JavaScript进程跳过Ajax操作，直接往下执行，等到Ajax操作有了结果，JavaScript进程再执行对应的回调函数。\n\n## 定时器\n\nJS提供定时执行代码的功能，叫做定时器（timer），主要由`setTimeout()`和`setInterval()`这两个函数来完成。它们向任务队列添加定时任务。\n\n### setTimeout()\n\n用来指定某个函数或某段代码，在多少毫秒之后执行。\n\nsetTimeout函数接受两个参数，第一个参数`fund|code`是将要推迟执行的函数名或者一段代码，第二个参数`delay`是推迟执行的毫秒数。\n\n```\nconsole.log(1);\nsetTimeout('console.log(2)',1000);\nconsole.log(3);\n```\n\n**注意**，推迟执行的代码必须以字符串的形式放入setTimeout，因为引擎内部使用eval函数，将字符串转为代码。如果推迟执行的是函数，则可以直接将函数名放入setTimeout。\n\n一方面eval函数有安全顾虑，另一方面为了便于引擎优化代码，setTimeout方法一般总是采用匿名函数的形式：\n\n```\nfunction f(){\n  console.log(2);\n}\n\nsetTimeout(f,1000);\n\n// 或者\n\nsetTimeout(function () {\n  console.log(2)\n},1000)\n```\n\n### setInterval()\n\nsetInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。\n\n### clearTimeout()，clearInterval()\n\nsetTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数值传入clearTimeout和clearInterval函数，就可以取消对应的定时器。\n\n```\nvar id1 = setTimeout(f,1000);\nvar id2 = setInterval(f,1000);\n\nclearTimeout(id1);\nclearInterval(id2);\n```\n\n### 运行机制\n\n`setTimeout`和`setInterval`的运行机制是，将指定的代码移出本次执行，等到下一轮 Event Loop 时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮 Event Loop 时重新判断。\n\n## Promise对象\n\n### JS的异步执行\n\n#### 回调函数\n\n回调函数是异步编程最基本的方法。\n\n假定有两个函数f1和f2，后者必须等到前者执行完成才能执行。这时可以考虑改写f1，把f2写成f1的回调函数。\n\n```\nfunction f1(callback){\n  // f1 的代码\n  \n  // f1 执行完成后，调用回调函数\n  callback();\n}\n\nf1(f2);\n```\n\n回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个人物只能指定一个回调函数。\n\n#### Promise对象\n\nPromise对象是CommonJS工作组提出的一种规范，目的是为异步操作提供统一接口。\n\n它是一个对象。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。\n\n它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以蚕蛹同步操作的流程。这个Promise对象有一个then方法，允许指定回调函数，在异步任务完成后调用。\n\n比如，异步操作f1返回一个Promise对象，它的回调函数f2写法如下：\n\n```\n(new Promise(f1)).then(f2);\n```\n\n#### Promise接口\n\nPromise接口的基本思想是，异步任务返回一个Promise对象。\n\nPromise对象只三种状态：\n\n+ 异步操作“未完成”（pending）\n+ 异步操作“已完成”（resolved）\n+ 异步操作“失败”（rejected）\n\n三种状态只有两种变化方式：\n\n+ 异步操作从“未完成”到“已完成”\n+ 异步操作从“未完成”到“失败”\n\n因此，Promise对象的最终结果只有两种：\n\n+ 异步操作成功，Promise对象传回一个值，状态变为resolved。\n+ 异步操作失败，Promise对象抛出一个错误，状态变为rejected。\n\nPromise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时的回调函数，第二个时异步操作失败时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。\n\n```\n// po是一个Promise对象\npo.then(\n\tconsole.log,\n\tconsole.error\n)\n```\n\nthen方法可以链式使用：\n\n```\npo\n\t.then(step1)\n\t.then(step2)\n\t.then(step3)\n\t.then(\n\t\tconsole.log,\n\t\tconsole.error\n\t);\n```\n\n上面代码中，po的状态一旦变为resolved，就一次调用后面每一个then指定的回调函数，每一步都必须等到前一步完成，才会执行。\n\nPromise对象的错误有传递性。\n\n#### Promise对象的生成\n\nES6提供了原生的Promise构造函数，用来生成Promise实例。\n\n```\nvar promise = new Promise(function(resolve,reject){\n  // 异步操作的代码\n  \n  if(/* 异步操作成功 */){\n    resolve(value);\n  }else{\n    reject(error);\n  }\n});\n```\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们时两个函数，由JS引擎提供，不用自己部署。\n\n## 严格模式\n\n进入“严格模式”的标志，是一行字符串`use strict`。\n\n1. 针对整个脚本文件\n\n   将`use strict`放在脚本文件第一行，整个脚本都将以“严格模式”运行。\n\n2. 针对单个函数\n\n   `use strict`放在函数体的第一行，整个函数以“严格模式”运行。\n\n3. 脚本文件的变通写法\n\n   两个不同模式的脚本合并成一个文件，如果严格模式的脚本在前，则合并后的脚本都是“严格模式”；如果正常模式的脚本在前，则合并后的脚本都是“正常模式”。总之，这两种合并后的结果都是不正确的。\n\n   正确的做法是，使用前面第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。\n\n   ```\n   (function(){\n     'use strict';\n     // some code here\n   })();\n   ```\n\n   ​\n\n# DOM模型\n\nDOM是JS操作网页的接口，它的作用是将网页转为一个JS对象，从而可以用脚本进行各种操作。\n\n## 事件模型\n\n### 事件的传播\n\n#### 传播的三个阶段\n\n当一个事件发生以后，它会在不同的DOM节点之间传播（propagation）。这种传播分成三个阶段：\n\n+ 第一阶段：从window对象传导到目标节点，称为“捕获阶段”。\n+ 第二阶段：从目标节点上触发，称为“目标阶段”。\n+ 第三阶段：从目标节点传导回window对象，称为“冒泡阶段”。\n\n这三种阶段的传播模型，会使得一个事件在多个节点上触发。比如，假设点击`<div>`之中嵌套一个`<p>`节点：\n\n```\n<div>\n\t<p>Click Me</p>\n</div>\n```\n\n如果对这两个节点的click事件都设定监听函数，则click事件会被触发四次：\n\n+ 捕获阶段：事件从`<div>`向`<p>`传播时，触发`<div>`的`click`事件；\n+ 目标阶段：事件从`<div>`到达`<p>`时，触发`<p>`的`click`事件；\n+ 目标阶段：事件离开`<p>`时，触发`<p>`的`click`事件；\n+ 冒泡阶段：事件从`<p>`传回`<div>`时，再次触发`<div>`的`click`事件。\n\n#### 事件的代理\n\n由于事件会在冒泡阶段向上传播的父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。\n\n如果希望事件到某个节点为止，不再传播，可以使用时间对象的`stopPropagation`方法。\n\n`stopPropagation`方法只会阻止当前监听函数的传播，不会阻止节点上的其他click事件的监听函数。如果想要不再触发那些监听函数，可以使用stopImmediatePropagation方法。\n\n### Event对象\n\n事件发生以后，会生成一个事件对象，**作为参数传给监听函数**。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例。\n\n#### event.currentTarget\n\ncurrentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。作为比较，target属性返回事件发生的节点。如果监听函数在捕获阶段和冒泡阶段触发，那么这两个属性返回的值是不一样的。\n\n#### event.target\n\ntarget属性返回触发事件的那个节点，即事件最初发生的节点。如果监听函数不在该即诶单触发，那么它与currentTarget属性返回的值是不一样的。\n\n```\nfunction hide(e){\n  console.log(this === e.target);\n  e.target.style.visibility = \"hidden\";\n}\n\n// HTML代码为\n// <p id=\"para\">Hello <em>World</em></p>\npara.addEventListener('click',hide,false);\n```\n\n上面代码中，如果在para节点的em子节点上面点击，则e.target指向em子节点，导致em子节点（即World部分）会不可见，且输出false。\n\n**事件的触发，和事件的监听不是一个概念**，比如上面代码中，点击em节点，click事件是在em节点触发的，然后按照事件传播模型从顶层window节点开始向下捕获，然后再从目标节点em节点向上冒泡，在冒泡阶段，p节点上监听了click事件，那么会执行p节点的监听函数，但此时event.target指向的是触发click事件的em节点，虽然监听函数是在p节点上执行的。\n\n#### event.preventDefault()\n\npreventDefault方法取消浏览器对当前事件的默认行为。该方法生效的前提是，事件的cancelable属性为true。\n\n该方法不会阻止事件的进一步传播。只要在事件的传播过程中（捕获阶段、目标阶段、冒泡阶段皆可），使用了preventDefault方法，该事件的默认方法就不会执行。\n\n#### event.stopPropagation()\n\nstopPropagation方法阻止事件在DOM中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上新定义的事件监听函数。\n\n**stopPropagation既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止事件目标阶段。**\n\n#### event.stopImmediatePropagation()\n\nstopImmediatePropagation方法阻止同一个事件的其他监听函数被调用。\n\n如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序一次调用。只要其中一个监听函数调用了stopImmediatePropagation方法，其他监听函数就不会再执行了。\n\n# 浏览器环境\n\n## 概述\n\n### JS代码嵌入网页的方法\n\n#### script标签：代码嵌入网页\n\n#### script标签：加载外部脚本\n\n#### 事件属性\n\n某些HTML元素的事件属性（比如onclic和onmouseover），可以写入JS代码。当指定事件发生时，就会调用这些代码。\n\n```\n<div onclick=\"alert('Hello')\"></div>\n```\n\n上面的事件属性代码只有一个语句。如果有多个语句，用分号分隔即可。\n\n#### URL协议\n\nURL支持`javascript:`协议，调用这个URL时，就会执行JS代码。\n\n```\n<a href=\"javascript:alert('Hello')\"></a>\n```\n\n### script标签\n\n#### 工作原理\n\n正常的网页加载流程是这样的：\n\n+ 浏览器一边下载HTML网页，一边开始解析\n+ 解析过程中，发现`<script>`标签\n+ 暂停解析，网页渲染的控制权转交给JavaScript引擎\n+ 如果`<script>`标签引用了外部脚本，就下载该脚本，否则就直接执行\n+ 执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页\n\n### 浏览器的组成\n\n浏览器的核心是两部分：渲染引擎和JavaScript解释器（又称JavaScript引擎）。\n\n#### 渲染引擎\n\n渲染引擎处理网页，通常分成四个阶段：\n\n+ 解析代码：HTML代码解析为DOM，CSS代码解析为CSSOM（CSS Object Model）\n+ 对象合成：将DOM和CSSOM合成一个渲染树\n+ 布局：计算出渲染树的布局（layout）\n+ 绘制：将渲染树绘制到屏幕\n\n以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。\n\n#### JavaScript引擎\n\nJS引擎的主要作用是，读取网页中的JS代码，对其处理后运行。\n\n## window对象\n\n### window对象\n\n在浏览器中，window对象指当前的浏览器窗口。它也是所有对象的顶层对象。\n\nJS规定，浏览器环境的所有全局变量，都是window对象的属性。\n\n### history对象\n\n浏览器窗口有一个history对象，用来保存浏览历史。\n\n### Cookie\n\nCookie时服务器保存在浏览器的一小段文本信息，每个Cookie的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。\n\n### Web Storage：浏览器端数据储存机制\n\n这个API的作用是，使得网页可以在浏览器端储存数据。它分成两类：sessionStorage和localStorage。\n\nsessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；localStorage保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。\n\n每个域名的存储上限视浏览器而定。Chrome是2.5MB，Firefox和Opera是5MB，IE是10MB。\n\n另外，与Cookie一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取。\n\n#### 存入／读取数据\n\n存入数据使用setItem方法：\n\n```\nsessionStorage.setItem(\"key\",\"value\");\nlocalStorage.setItem(\"key\",\"value\");\n```\n\n读取数据使用getItem方法：\n\n```\nvar valueSession = sessionStorage.getItem(\"key\");\nvar valueLocal = localStorage.getItem(\"key\");\n```\n\n#### 清除数据\n\nremoveItem方法用于清除某个键名对应的数据。\n\n```\nsessionStorage.removeItem('key');\nlocalStorage.removeItem('key');\n```\n\nclear方法用于清除所有保存的数据。\n\n```\nsessionStorage.clear();\nlocalStorage.clear();\n```\n\n## 同源政策\n\n### 含义\n\n1995年，同源政策由Netscape公司引入浏览器。\n\n最初，它的含义是指，A网页设置的Cookie，B网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。\n\n+ 协议相同\n+ 域名相同\n+ 端口相同\n\n## AJAX\n\n浏览器与服务器之间，采用HTTP协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会想服务器发出HTTP请求。\n\nAJAX包括以下几个步骤：\n\n1. 创建AJAX对象\n2. 发出HTTP请求\n3. 接受服务器传回的数据\n4. 更新网页数据\n\n概括起来就是一句话，AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。\n\n```\nvar xhr = new XMLHttpRequest();\n\n// 指定通信过程中状态改变时的回调函数\nxhr.onreadtstatechange = function(){\n\t// 通信成功时，状态值为4\n  if(xhr.readyState === 4){\n    if(xhr.status === 200){\n      console.log(xhr.resonseText);\n    }else{\n      console.log(xhr.statusText);\n    }\n  }\n}\n\nxhr.onerror = function (e){\n  console.log(xhr.statusText);\n}\n\n// open方式用于指定HTTP动词、请求的网址、是否异步\nxhr.open('GET','/endpoint',true);\n\n// 发送HTTP请求\nxhr.send(null);\n```\n\n","source":"_posts/ES5学习笔记.md","raw":"---\ntitle: ES5学习笔记\ndate: 2017-06-01 12:52:28\ntags:\n- javaScript\n- ES5\ncategories:\n- 学习笔记\ndescription: 《JavaScript教程-阮一峰》《JavaScript高级程序设计》ES5要点总结\n---\n\n# 语法\n\n## 基本语法\n\n+ 凡是JavaScript语言中预期为值的地方，都可以使用表达式。\n\n+ 使用var重新声明一个已经存在的变量是无效的，但是如果第二次声明的同时还附了值，则会覆盖掉前面的值。\n\n  ```\n  var x = 1;\n  var x;\n  x // 1\n\n  var x = 1;\n  var x = 2;\n  x // 2\n  ```\n\n+ JavaScript引擎的工作方式是，现解析代码，获取所有被声明的变量，然后再一行一行的运行。这造成的结果就是所有的变量声明语句，都会被提升到代码的头部，这就叫做变量提升。\n\n  ```\n  console.log(a);\n  var a = 1;\n  //undefined\n  //等同于\n  var a;\n  console.log(a);\n  a = 1;\n  ```\n\n  变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。\n\n  ```\n  console.log(b);\n  b = 1;\n  //Error:b is not defined\n  ```\n\n+ 中文是合法的标识符，可以用作变量名\n\n  ```\n  var 临时变量 = 1；\n  ```\n\n+ 多个if...else连在一起使用的时候，可以转为使用更方便的switch结构\n\n  ```\n  switch (fruit){\n    case \"banana\":\n    \t//...\n    \tbreak;\n    case \"apple\":\n    \t//...\n    \tbreak;\n    default:\n    \t//...\n  }\n  ```\n\n  每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。\n\n  switch语句部分和case语句部分，都可以使用表达式\n\n  switch语句后面的表达式与case语句后面的表达式，在比较运算结果时，采用严格相等===，而不是相等运算==，意味着比较时不会发生类型转换\n\n  ```\n  var x = 1;\n  switch(x){\n    case true:\n    \tconsole.log('x发生类型转换‘);\n    default:\n    \tconsole.log('x没有发生类型转换‘);\n  }\n  // x没有发生类型转换\n  ```\n\n+ while循环、for循环可以使用break语句跳出循环\n\n+ continue用语立即终止本轮循环，返回循环结构头部，开始下一轮循环\n\n+ 如果存在多重循环，不带参数的break和continue语句都只针对最内层循环\n\n+ 标签（label）：JS允许语句的前面有标签，相当于定位赋，用于跳转到程序的任意位置，格式如下：\n\n  ```\n  label:\n  \tstatement\n  ```\n\n  标签可以时任意的标识符，但不能是保留字\n\n  标签通常和break、continue语句配合使用，跳出特定的循环：\n\n  ```\n  top:\n  \tfor(var i = 0; i < 3; i++){\n        for(var j = 0; j < 3; j++){\n          if(i ===1 && j === 1){\n            break top;\n          }\n        }\n  \t}\n  ```\n\n  上面的双重循环中，break后面跟了top标签（top不用加引号），满足条件时，直接跳出双层循环。如果不加标签，则只跳出内层循环，进入下一次外层循环。\n\n  continue一样\n\n## 数据类型\n\n+ 6中数据类型（es6又新增了第七中Symbol类型），数值、字符串、布尔值称为原始类型，对象称为合成类型，null、undefined特殊值\n\n+ JS的所有数据，都可视为广义的对象，数组、函数，原始类型的数据\n\n+ 对象又分成3个子类：狭义的对象（object），数组（array），函数（function）\n\n+ JS把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，体现了JS作为“函数式语言”的本质\n\n+ JS有三种方法确定一个值的类型：\n\n  typeof运算符\n\n  instanceof运算符\n\n  Object.prototype.toString方法\n\n+ typeof null返回object，并不是说null的数据类型就是对象，本质上null是一个类似于undefined的特殊值。null表示空值，即该处的值为空；undefined表示“为定义”\n\n+ 空数组 []，空对象 {}对应的布尔值都是true\n\n### 数值\n\n+ NaN是number类型的一种特殊值，表示“非数字”（Not a Number)\n\n+ isNaN方法判断一个值是否为NaN，空数组和只有一个数值成员的数组，is NaN返回false，原因是这些数组能被Number函数转成数值。\n\n  ```\n  isNan([]) //false\n  isNaN([123]) //false\n  isNaN(['123']) //false\n  ```\n\n+ parseInt()方法用于将字符串转为整数\t。\n\n  字符串转为整数是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分\n\n  ```\n  parseInt('12.34') //12\n  ```\n\n  如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN：\n\n  ```\n  parseInt('abc') //NaN\n  parseInt('+') //NaN\n  parseInt('+1') //1\n  ```\n\n  parseInt()方法还可以接受第二个参数（2到36之间），表示被解析到值的进制，返回该值对应的十进制数。第二个参数默认是10。\n\n+ parseFloat()方法用于将一个字符串转为浮点数\n\n  如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分\n\n  如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN\n\n### 字符串\n\n+ 如果要在单引号（或双引号）字符串的内部，使用单引号（或双引号），就必须在内部的单引号（或双引号）前面加上反斜杠，用来转义：\n\n  ```\n  'Did she say \\'Hello\\'?'\n  // \"Did she say 'Hello'?\"\n  ```\n\n+ 字符串默认只能写在一行内，分成多行将会报错\n\n+ 字符串可以被视为字符数组，可以使用数组的方括号运算符返回某个位置的字符，但仅此而已，无法修改和增删，只有将字符串显式转为数组后才能使用\n\n+ Base64转码：\n\n  btoa()：字符串或二进制值转为Base64编码\n\n  atob()：Base64编码转为原来的编码\n\n### 对象\n\n+ 对象三种声明方法：\n\n  1. 直接使用大括号{ }生成`var o1 = {};`\n  2. 用new命令生成一个Object对象的实例`var o2 = new Object();`\n  3. 用Object.create方法生成`Object.create(Object.prototype);`\n\n  对象采用大括号表示导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？\n\n  为避免歧义，JS规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），不许在大括号前加上圆括号\n\n  ```\n  ({foo:123})\n  ```\n\n\n+ 对象的所有键名都是字符串，加不加引号都可以，非字符串的键名会被转为字符串。但是如果键名不符合标识名的条件，也不是数字，则必须加上引号，否则报错。\n\n+ JS的保留字可以不加引号当作键名\n\n+ 对象的每一个“键名”又称为“属性”，它的“键值“可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为”方法“，它可以像函数那样调用：\n\n  ```\n  var o = {\n    p: function (x){\n      return 2 * x;\n    }\n  };\n  o.p(1) // 2\n  ```\n\n+ **不同的变量名指向同一个对象**，他们都是这个对象的引用，也就是说指向同一个内存地址，修改其中的一个变量，会影响到其他所有变量：\n\n  ```\n  var o1 = {};\n  var o2 = o1;\n\n  o1.a = 1;\n  o2.a // 1\n\n  o2.b = 2;\n  o1.b // 2\n  ```\n\n  如果取消某一个变量对原对象的引用，不会影响到另一个变量：\n\n  ```\n  var o1 = {};\n  var o2 = o1;\n\n  o1 = 1;\n  o2 // {}\n  ```\n\n  这种引用只局限于对象，对原始类型的数据则是传值引用，都是值的拷贝\n\n  ```\n  var x = 1;\n  var y = x;\n\n  x = 2;\n  y // 1\n  // 当x的值发生变化后，y的值并未改变，表示y和x并不是指向同一个内存地址\n  ```\n\n+ **读取对象属性**有两种方法，使用点运算符，使用方括号运算符\n\n  使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理\n\n  数值键名不能使用点运算符，因为会被当成小数点，只能使用方括号运算符，且不用加引号\n\n  方括号运算符内部可以使用表达式\n\n  ```\n  o['hello'+'world']\n  o[3+3]\n  ```\n\n+ 点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值\n\n  ```\n  o.p = 'abc';\n  p['p'] = 'abc';\n  ```\n\n+ Object.keys方法查看一个对象本身的所有属性：\n\n  ```\n  var o = {\n    key1: 1,\n    key2: 2\n  }\n  Object.keys(o);\n  // ['key1','key2']\n  ```\n\n+ delete命令用于删除对象的属性，删除成功后返回true\n\n  ```\n  delete o.p\n  ```\n\n  delete命令删除一个不存在的属性，不会报错，而且返回true\n\n  delete删除存在且不得删除的属性，返回false\n\n  delete职能删除对象本身的属性，无法删除继承的属性\n\n+ **in运算符**用于检查对象是否包含某个属性（检查的是键名，不是键值），包含返回true，否则返回false：\n\n  ```\n  var o = { p:1 };\n  'p' in o //true\n  ```\n\n  JS中，所有全局变量都是顶层对象（浏览器的顶层对象就是window对象）的属性，因此可以用in运算符判断一个全局变量是否存在\n\n  in运算符不能识别对象继承的属性\n\n+ **for…in循环**用来遍历一个对象所有可便利（enumerable）的属性，会跳过不可遍历的属性\n\n  它不仅遍历对象自身的属性，还遍历继承的属性\n\n### 数组\n\n+ 只要是数组，就一定有length属性。\n\n  length属性是可写的\n\n  如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值，其余的被自动删除\n\n  如果人为设置length大雨当前元素个数，则数组成员数量会增加到这个值，新增的位置都是空位，读取新增的位置会返回undefined\n\n+ 由于数组本质上是对象，所以我们可以为数组添加属性，这不影响length属性的值\n\n+ 类似数组的对象（array-like object）：一个对象的所有键名都是正整数或零，并且有length属性\n\n  “类似数组的对象”并不是数组，它不具备数组特有的方法，比如push方法\n\n  ”类似数组的对象“的根本特征，就是具有length属性，但这种length属性不是动态值，不会随着成员变化而变化\n\n  典型的”类似数组的对象“是函数的arguments对象，大多数DOM元素集，还有字符串\n\n+ **in运算符**同样适用于数组，如果数组某个位置是空位，in运算符返回false\n\n+ **for…in循环**遍历的是对象的所有属性，数组是对象的一种，因此for...in循环也可以遍历数组的所有属性，包括数组的所有数字键和其他属性，因此不推荐用for...in遍历数组\n\n+ **数组的空位**：当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位。数组的空位不影响length属性：\n\n  ```\n  var a = [1, ,1];\n  a.length // 3\n  ```\n\n  数组的空位可读取，返回undefined\n\n  使用delete命令删除一个数组成员，会形成空位，并且不影响length属性：\n\n  ```\n  var a = [1,2,3];\n  delete a[1];\n\n  a[1] //undefined\n  a.length // 3\n  ```\n\n+ 数组的某个位置是空位，和某个位置是undefined是不一样的。\n\n  如果是空位，使用数组的forEach方法、for...in循环、Object.keys方法进行遍历，空位都会被跳过；\n\n  如果是undefined，遍历不会被跳过。\n\n  空位就是数组没有这个元素，所以不会被遍历到，而undefined表示数组有这个元素，值时undefined。\n\n### 函数\n\n+ **函数的三种声明方法**：\n\n  1. function命令声明的代码区块，就是一个函数：\n\n     ```\n     function print(s){\n       console.log(s);\n     }\n     ```\n\n  2. 函数表达式：除了用function命令声明，还可以采用变量赋值的写法\n\n     ```\n     var print = function(s){\n       console.log(s);\n     }\n     ```\n\n     这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式，因为赋值语句的等号右侧只能放表达式\n\n     采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效\n\n     ```\n     var print = function x(){\n       console.log(typeof x);\n     };\n     x // Error\n     print() //function\n     ```\n\n     需要注意，函数表达式需要在语句的结尾加上“；”，表示语句结束。\n\n  这两种声明函数的方式，差别很细微，这里可以近似认为是等价的\n\n  3. Function构造函数\n\n     ```\n     var add = new Function(\n     \t'x',\n     \t'y',\n     \t'return x + y'\n     );\n     // 等同于\n     function add(x,y){\n       return x + y;\n     }\n     ```\n\n     Function构造函数接受任意数量的参数，只有最后一个参数会被当作函数体，其他参数都是函数的参数；如果只有一个参数，该参数就是函数体\n\n     这种声明函数的方式非常不直观，几乎无人使用\n\n  + 如果同一个函数被多次声明，后面的声明会覆盖前面的声明\n\n    ```\n    function f(){\n      console.log(1);\n    }\n    f() // 2\n    function f(){\n      console.log(2);\n    }\n    f() // 2\n    ```\n\n+ 调用函数时，使用圆括号运算符\n\n  函数体内部的return语句表示返回。JS引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。\n\n  函数可以调用自身，这就是递归。\n\n+ **第一等公民**：JS语言将函数看作一种值，与其他值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。\n\n  由于函数与其他数据类型地位平等，所以在JS中又称函数为第一等公民。\n\n  ```\n  function add(x,y){\n    return x + y;\n  }\n\n  // 将函数赋值给一个变量\n  var operator = add;\n\n  // 将函数作为参数和返回值\n  function a(op){\n    return op;\n  }\n  a(add)(1,1)\n  // 2\n  ```\n\n+ **函数名的提升**：JS引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部：\n\n  ```\n  f();\n\n  function f(){}\n  ```\n\n  但是，如果采用赋值语句定义函数，JS就会报错：\n\n  ```\n  f();\n  var f = function (){};\n  // Error!\n  ```\n\n  等同于：\n\n  ```\n  var f;\n  f();\n  f = function () {};\n  ```\n\n  上面代码第二行，调用f时，f只是被声明了，还没有被赋值，等于undefined，所以会报错。\n\n+ **不能再条件语句中声明函数**：根据ES规范，不得在非函数的代码块中声明函数，最常见的就是if和try语句\n\n+ **函数的属性和方法**：\n\n  + *name属性*，返回紧跟在function关键字之后的那个函数名：\n\n    ```\n    function f1(){}\n    f1.name // 'f1'\n\n    var f2 = function (){};\n    f2.name // ''\n\n    var f3 = function myName(){};\n    f3.name // 'myName'\n    ```\n\n    匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）\n\n  + *length属性*，返回函数预期传入的参数个数，即函数定义之中的参数个数。不管调用时输入了多少个参数，只返回定义时的参数个数。\n\n  + *toString()方法*，返回函数的源码。\n\n+ **函数作用域**\n\n  作用域（scope）指的是变量存在的范围\n\n  JS只有两种作用域：一种是全剧作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。\n\n  在函数外部声明的变量就是**全局变量**，它可以在函数内部读取。\n\n  在函数内部定义的变量就是**局部变量**，外部无法读取。\n\n  + **函数内部定义的变量，会在该作用域内覆盖同名全局变量**：\n\n  ```\n  var v = 1;\n\n  function f(){\n    var v = 2;\n    console.log(v);\n  }\n\n  f() // 2\n  v // 1\n  ```\n\n  + **函数内部的变量提升**：\n\n    与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。\n\n  + **函数本身的作用域**：\n\n    函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。\n\n    ```\n    var a = 1;\n    var x = function (){\n      console.log(a);\n    }\n\n    function f() {\n      var a = 2;\n      x();\n    }\n\n    f() // 1\n    ```\n\n    函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。\n\n    很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量：\n\n    ```\n    var x = function (){\n      console.log(a);\n    };\n\n    function y(f) {\n      var a = 2;\n      f();\n    }\n\n    y(x)\n    // Error: a is not defined\n    ```\n\n    同样的，函数体内部声明的函数，作用域绑定函数体内部：\n\n    ```\n    function foo(){\n      var x = 1;\n      function bar(){\n        console.log(x);\n      }\n      return bar;\n    }\n\n    var x = 2;\n    var f = foo();\n    f() // 1\n    ```\n\n    这种机制构成了**闭包**。\n\n+ **参数**：ES5中，函数参数不是必需的，JS允许省略参数。\n\n  + ```\n    function f(a){\n      a = a || 1;\n      return a;\n    }\n    // ||表示“或运算”，赋值语句的等号右边，预期是一个值，凡是预期为值的地方，都可以用表达式\n    ```\n\n  + **传递方式**：\n\n    + 函数参数如果是**原始类型**的值（数值、字符串、布尔值），传递方式是**传值传递**。意味着，在函数体内修改参数值，不会影响到函数外部\n\n      ```\n      var p = 2;\n      function f(p){\n        p = 3;\n      }\n      f(p);\n\n      p // 2\n      ```\n\n      变量p是一个原始类型的值，传入函数f的方式是传值传递。因此在函数内部，p的值时原始值的拷贝，无论怎么修改，都不会影响到原始值。\n\n    + 如果函数参数是**复合类型**的值（数组、对象、其他函数），传递方式是**传址传递**。意味着，在函数内部修改参数，将会影响到原始值。\n\n      ```\n      var obj = {p: 1};\n      function f(o){\n        o.p = 2;\n      }\n      f(obj);\n\n      obj.p // 2\n      ```\n\n      上面代码中，传入函数f的是对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。\n\n      **注意**：如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值：\n\n      ```\n      var obj = [1,2,3];\n      function f(o){\n        0 = [2,3,4];\n      }\n      f(obj);\n\n      obj // [1,2,3]\n      ```\n\n      这是因为，形式参数（o）与实际参数obj存在一个赋值关系\n\n      ```\n      // 函数f内部\n      o = obj;\n      ```\n\n      上面代码中，对o的修改都会反映在obj身上。但是，如果对o赋予一个新的值，就等于切断了o与obj的联系，导致此后的修改都不会影响到obj。\n\n  + 某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性：\n\n    ```\n    var a = 1;\n    function f(p){\n      window[p] = 2;\n    }\n    f('a');\n\n    a // 2\n    ```\n\n  + **同名参数**：\n\n    如果有同名的参数，则取最后出现的那个值，即使最后的参数没有值或被省略，也是以其为准：\n\n    ```\n    function f(a,a){\n      console.log(a);\n    }\n    f(1,2) // 2\n    f(1) // undefined\n    ```\n\n  + **arguments对象**：\n\n    arguments对象包含了函数运行时的所有参数，arguments[0是第一个参数，arguments[1]就是第二个，以此类推。这个对象只有在函数体内部可以使用。\n\n    **正常模式下**，arguments对象可以在运行时修改：\n\n    ```\n    var f = function (a,b){\n      arguments[0] = 3;\n      arguments[1] = 2;\n      return a + b;\n    }\n    f(1,1) //5\n    ```\n\n    **严格模式下**，arguments对象是一个只读对象，修改它是无效的，但不会报错\n\n    ```\n    var f = function (a,b){\n      'use strict';\n      arguments[0] = 3; // 无效\n      arguments[1] = 2; // 无效\n      return a + b;\n    }\n    f(1,1) // 2\n    ```\n\n    介绍数组时说过，arguments虽然很像数组，但是它时一个对象，是一个“类似数组的对象”。数组专有的方法，不能在arguments对象上直接使用。\n\n+ **闭包**：\n\n  JS的作用域机制，使得函数外部无法获取函数内部声明的变量。\n\n  但出于某种原因，需要得到函数内部的局部变量。正常情况下是办不到的，只有通过变通方法实现，就是在函数内部，再定义一个函数。\n\n  ```\n  function f1(){\n    var n = 999;\n    function f2(){\n      console.log(n); // 999\n    }\n  }\n  ```\n\n  函数f2声明在函数f1的内部，f1内部的所有局部变量，对f2可见。反之则不行。这是JS语言特有的“链式作用域”结构（chain scope），子对象会一级一级的向上寻找所有父对象的变量。\n\n  既然f2可以读取f1的局部变量，那么只要把f2作为返回值，就可以在f1外部读取他的内部变量了\n\n  ```\n  function f1(){\n    var n = 999;\n    function f2(){\n      console.log(n);\n    }\n    return f2;\n  }\n  var result = f1();\n  result(); // 999\n  ```\n\n  函数f1点返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1点内部变量了。\n\n  **闭包**就是函数f2，即能够读取其他函数内部变量的函数。\n\n  JS语言中，只有函数内部的字函数才能读取内部变量，因此可以把闭包加单理解成**“定义在一个函数内部的函数”**。在本质上，闭包就是将函数内部和函数外部链接起来的一座桥梁。\n\n  **闭包的最大用处有两个**：1. 读取函数内部的变量。2. 让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在：\n\n  ```\n  function createIncrmenentor(start){\n    return function (){\n      return start++;\n    };\n  }\n  var inc = createIncrementor(5);\n\n  inc() // 5\n  inc() // 6\n  inc() // 7\n  ```\n\n  *上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境一直存在。所以，闭包可以看作是函数内部作用域的一个接口。*\n\n  *为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也是种在内存中，不会再调用结束后，被垃圾回收机制回收。*\n\n  **闭包的另一个用处，是封装对象的私有属性和私有方法。**\n\n  ```\n  function Person(name) {\n    var _age;\n    function setAge(n) {\n      _age = n;\n    }\n    function getAge() {\n      return _age;\n    }\n\n    return {\n      name: name,\n      getAge: getAge,\n      setAge: setAge\n    };\n  }\n\n  var p1 = Person('张三');\n  p1.setAge(25);\n  p1.getAge() // 25\n  ```\n\n  **注意**，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。\n\n+ **立即调用的函数表达式**\n\n  在JS中，一对圆括号（）是一种运算符，跟在函数名之后，表示调用该函数。比如，print（）就表示调用print函数。\n\n  有时，我们需要在定义函数之后，立即调用该函数。这时，闭不能在函数的定义之后加上圆括号，会产生语法错误：\n\n  ```\n  function () { /* code */}();\n  // SyntaxError: Unexpected token (\n  ```\n\n  产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。同行首是一个对象的大括号，到底是表达式还是语句同理。\n\n  ```\n  // 语句\n  function f() {}\n  // 表达式\n  var f = function f() {}\n  ```\n\n  为避免解析上的歧义，JS引擎规定，如果function关键字出现在行首，一律解释称语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。\n\n  解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。\n\n  ```\n  (function (){ /* code */ }());\n  // 或者\n  (function (){ /* code */ })();\n  ```\n\n  以圆括号开头，引擎就会认为这个一个表达式，而不是函数定义语句，就避免了错误。这就叫做“立即调用的函数表达式”。\n\n  这两种写法最后的分号都是必须的。如果省略分号，遇到连着两个立即调用的函数表达式，可能就会报错。\n\n## 运算符\n\n+ 加号运算符，拼接字符串和加法运算\n\n  ```\n  1 + 1 // '2'\n  '1' + 1 // '11'\n  1 + '1' // '11'\n\n  1+1+1+1 // '4'\n  '1'+1+1+1 // '1111'\n  1+'1'+1+1 // '1111'\n  1+1+'1'+1 // '211'\n  1+1+1+'1' // '31'\n  ```\n\n  从左往右，能加法运算就加法运算，直到遇到字符，把之前的运算结果和字符拼接，字符之后全部为拼接。\n\n  利用空字符串，将值转为字符串类型\n\n  ```\n  x + ''\n  ```\n\n+ 余数运算符（%）\n\n  ```\n  12 % 5 // 2\n  ```\n\n  余数运算的运算结果的正负由第一个运算子的正负决定：\n\n  ```\n  -1 % 2 // -1\n  1 % -2 // 1\n  ```\n\n+ 自增运算符（++）、自减运算符（—)\n\n  自增／自减操作会修改原始变量\n\n  放在变量前，先自增／自减，再返回操作后的值；\n\n  放在变量后，先返回变量的值，再自增／自减\n\n  ```\n  var x = 1;\n  var y = 1;\n  x++ // 1;\n  ++y // 2\n  ```\n\n+ 数值运算符（+）同样使用加号，但它是一元运算符（只需要一个操作数）。\n\n  数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）\n\n  ```\n  +true // 1\n  +[] // 0\n  +{} // NaN\n  ```\n\n+ 赋值运算符，除了最常见的等号（=），还有以下：\n\n  ```\n  x += y // 等同于 x = x + y\n  x -= y // 等同于 x = x - y\n  x *= y // 等同于 x = x * y\n  x /= y // 等同于 x = x / y\n  x %= y // 等同于 x = x % y\n  x >>= y // 等同于 x = x >> y\n  x <<= y // 等同于 x = x << y\n  x >>>= y // 等同于 x = x >>> y\n  x &= y // 等同于 x = x & y\n  x |= y // 等同于 x = x | y\n  x ^= y // 等同于 x = x ^ y\n  ```\n\n+ 比较运算符\n\n  如果两个运算子都是字符串，则按照字典顺序比较（实际上是比较Unicode码点）\n\n  否则，将两个运算子都转成数值，再进行比较（等同于先调用Number函数）\n\n+ ==和===的区别\n\n  相等运算符==比较两个值是否相等，严格相等运算符===比较它们是否为“同一个值”。\n\n  如果两个值不是同一类型，严格相等运算符===直接返回 false，而相等运算符==会将它们转化成同一类型，再用严格相等运算符进行比较\n\n+ ===严格相等运算符\n\n  + 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，不同就返回false。\n\n    ```\n    1 === 0x1 // true\n    NaN === NaN // false NaN与任何值都不相等，包括自己\n    ```\n\n  + 同一类型的复合类型的值（对象、数组、函数）比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象\n\n    ```\n    {} === {} // false\n    [] === [] // false\n    (function(){} === function(){}) // false\n    ```\n\n    上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是`false`。\n\n    如果两个变量引用同一个对象，则它们相等。\n\n    ```\n    var v1 = {};\n    var v2 = v1;\n    v1 === v2 // true\n    ```\n\n    注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。\n\n+ ==相等运算符\n\n  + 比较相同类型的数据时，与严格相等运算符完全一样\n\n  + 比较不同类型的数据时，相等运算符会先讲数据进行类型转换，然后再用严格相等运算符比较，转换规则如下：\n    + 比较原始类型的数据时，会将数据转换成数值类型再进行比较\n\n    + 复合类型（对象、数组、函数）和原始类型的值比较时，复合类型转化成原始类型，再进行比较\n\n      ```\n      [1] == 1 // true\n      // 等同于 Number([1]) == 1\n\n      [1] == '1' // true\n      // 等同于 String([1]) == Number('1')\n\n      [1] == true // true\n      // 等同于 Number([1]) == Number(true)\n      ```\n\n+ 且运算符&&\n\n  运算规则：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值：\n\n  ```\n  't' && '' // \"\"\n  't' && 'f' // \"f\"\n  't' && (1 + 2) // 3\n  '' && 'f' // \"\"\n  '' && '' // \"\"\n\n  var x = 1;\n  (1 - 1) && ( x += 1) // 0\n  x // 1\n  ```\n\n  if语句中经常这样写：\n\n  ```\n  if(x && y){\n    /* code */\n  }\n  ```\n\n  x && y并不直接返回布尔值，而是if命令后面的判断条件预期应该是一个布尔值，JS会自动将其转为布尔值。\n\n+ 或运算符||\n\n  运算规则：如果第一个运算子的布尔值为`true`，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为`false`，则返回第二个运算子的值。\n\n+ void运算符\n\n  void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。\n\n  ```\n  void 0 // undefined\n  void(0) // undefined\n  ```\n\n  void运算符的主要作用是用于在超链接中插入代码，防止网页跳转。\n\n  ```\n  // 点击链接，但不跳转页面\n  <a href=\"javascript:void\"></a>\n\n  // 新建窗口打开链接\n  <a href=\"javascript:void window.open('http://example.com')\"></a>\n\n  // 提交表单，但不会跳转页面\n  <a href=\"javascript:void(document.form.submit())\"></a>\n  ```\n\n## 数据类型转换\n\nJS是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。\n\n虽然变量没有类型，但是数据本身和各种运算符是有类型的。如果运算符发现，数据的类型与预期不符，就会自动转换类型。\n\n### 强制转换\n\n强制转换主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或布尔值。\n\n+ Number()函数，可以将任意类型的值转化成数值\n\n  1. 原始类型值（字符串，布尔值、undefined、null）\n\n     Number函数将字符串转为数值要比parseInt函数严格很多。只有有一个字符无法转成数值，整个字符串就会被转为NaN。而parseInt是逐个转换字符。\n\n     ```\n     // 数值：转换后还是原来的值\n     Number(324) // 324\n\n     // 字符串：如果可以被解析为数值，则转换为相应的数值\n     Number('324') // 324\n\n     // 字符串：如果不可以被解析为数值，返回NaN\n     Number('324abc') // NaN\n\n     // 空字符串转为0\n     Number('') // 0\n\n     // 布尔值：true 转成1，false 转成0\n     Number(true) // 1\n     Number(false) // 0\n\n     // undefined：转成 NaN\n     Number(undefined) // NaN\n\n     // null：转成0\n     Number(null) // 0\n     ```\n\n  2. 复合类型值（对象、数组、函数）\n\n     简单的规则是，`Number`方法的参数是对象时，将返回`NaN`，**除非是包含单个数值的数组**。\n\n     ```\n     Number({a: 1}) // NaN\n     Number([1, 2, 3]) // NaN\n     Number([5]) // 5\n     ```\n\n+ String()函数，可以将任意类型的值转化成字符串。转换规则如下：\n\n  1. 原始类型值的转换规则\n\n     ```\n     数值：转为相应的字符串。\n     字符串：转换后还是原来的值。\n     布尔值：true转为\"true\"，false转为\"false\"。\n     undefined：转为\"undefined\"。\n     null：转为\"null\"。\n\n     String(123) // \"123\"\n     String('abc') // \"abc\"\n     String(true) // \"true\"\n     String(undefined) // \"undefined\"\n     String(null) // \"null\"\n     ```\n\n  2. 对象的转换规则\n\n     `String`方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\n\n     ```\n     String({a: 1}) // \"[object Object]\"\n     String([1, 2, 3]) // \"1,2,3\"\n     ```\n\n+ Boolean()函数，可以将任意类型的变量转为布尔值，除了以下六个值的转换结果为false，其他值全部是true\n\n  ```\n  undefined\n  null\n  -0\n  0或+0\n  NaN\n  ''（空字符串）\n  ```\n\n### 自动转换\n\n以下三种情况，JS会自动转换数据类型，转换时自动完成的，对用户不可见\n\n```\n// 1. 不同类型的数据互相运算\n123 + 'abc' // \"123abc\"\n\n// 2. 对非布尔值类型的数据求布尔值\nif ('abc') {\n  console.log('hello')\n}  // \"hello\"\n\n// 3. 对非数值类型的数据使用一元运算符（即“+”和“-”）\n+ {foo: 'bar'} // NaN\n- [1, 2, 3] // NaN\n```\n\n自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用`String`函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。\n\n## 错误处理机制\n\n### Error对象\n\nJavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript原生提供一个`Error`构造函数，所有抛出的错误都是这个构造函数的实例。\n\n```\nvar err = new Error('出错了');\nerr.message // \"出错了\"\n```\n\nError构造函数接受一个参数，表示错误提示，可以从实例等message属性读到这个参数。\n\nError对象的实例必须有message属性。大多数JS引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但她们是非标准的，不是每种实现都有\n\n### JS的原声错误类型\n\nError对象时最易班的错误类型。在它的基础上，JS还定义了其他6种错误：\n\n1. SyntaxError是解析代码时发生的语法错误\n2. ReferenceError是引用一个不存在的变量时发生的错误或将一个值分配给无法分配的对象\n3. RangeError\n4. TypeError\n5. URIError\n6. EvalError\n\n### 自定义错误\n\n除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。\n\n```\nfunction UserError(message) {\n   this.message = message || \"默认信息\";\n   this.name = \"UserError\";\n}\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n```\n\n上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义的错误了。\n\n```\nnew UserError(\"这是自定义的错误！\");\n```\n\n### throw语句\n\nthrow语句的作用是中断程序执行，抛出一个意外或错误。它接受一个表达式作为参数们可以抛出各种值。\n\nJS引擎一旦遇到throw语句，就会停止执行后面的语句，并将throw语句的参数值，返回给用户。\n\n```\nthrow new Error('出错了！');\n```\n\n### try…catch结构\n\ntry…catch结构对错误进行处理\n\n```\ntru{\n  throw new Error('出错了！');\n}catch(e){\n  console.log(e.name + \":\" + e.message);\n  console.log(e.stack)\n}\n```\n\ntry代码块一抛出错误（上例用的是throw语句），js引擎就立即把代码的执行，转到catch代码块。catch接受一个参数，表示try代码块抛出的值。\n\ncatch代码块中，还可以再抛出错误，甚至使用嵌套的try...catch结构。\n\n# 面向对象编程\n\n面向对象编程（Object Oriented Programming，OOP）是目前主流的编程范式。\n\n对象是一个容器，封装了属性（property）和方法（method）。\n\n## 构造函数\n\n典型的面向对象编程语言（C++，Java），存在“类”（class）的概念。所谓“类”就是对象的模版，对象就是“类”的实例。JS语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。\n\nJS语言使用构造函数作为对象的模版。所谓“构造函数”，就是专门用来生成对象的函数。它提供模版，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。\n\n构造函数的写法就是一个普通的函数，但是有自己的特征和用法。为了和普通函数区别，构造函数名字的第一个字母通常大写：\n\n```\nvar Vehicle = function () {\n  this.price = 1000;\n};\n```\n\n1. 函数体内部使用了this关键字，代表了所要生成的对象实例。\n2. 生成对象的时候，必需用new命令。\n\n## new命令\n\nnew命令的作用是，执行构造函数，返回一个对象实例。\n\n```\nvar Vehicle = function () {\n  this.price = 1000;\n};\nvar v = new Vehicle();\nv.price // 1000\n```\n\nnew命令执行时，构造函数内部的this，就代表了新生成的实例对象。\n\n使用new命令时，根据需要，构造函数也可以接受参数：\n\n```\nvar Vehicle = function (p) {\n  this.price = p;\n};\nvar v = new Vehicle(500);\n```\n\nnew命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号：\n\n```\nvar v = new Vehicle();\nvar v = new Vehicle;\n```\n\n### new命令的原理\n\n使用new命令时，她后面的函数调用就不是正常的调用，而是依次执行下面的步骤：\n\n1. 创建一个空对象，作为将要返回的对象实例\n2. 将这个空对象的原型，指向构造函数的prototype属性\n3. 将这个空对象赋值给函数内部的this关键字\n4. 开始执行构造函数内部的代码\n\n构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造“为需要的样子。\n\n如果构造函数内部有return语句，而且return后面跟一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。\n\n```\nvar Vehicle = function () {\n  this.price = 1000;\n  return 1000;\n};\n\n(new Vehicle()) === 1000\n// false\n\nvar Vehicle = function (){\n  this.price = 1000;\n  return { price: 2000 };\n};\n\n(new Vehicle()).price\n// 2000\n```\n\n如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。\n\n### 直接调用构造函数会发生什么？\n\n如果忘了使用new命令，直接调用构造函数会发生什么？\n\n这种情况下，构造函数就编程了普通函数，并不会生成实例对象。而且this这时代表全局对象，将造成一些意想不到的后果。\n\n```\nvar Vehicle = function () {\n  this.price = 1000;\n}\n\nvar v = Vehicle();\nv.price\n// Uncaught TypeError: Cannot read property 'price' of undefined\n\nprice\n// 1000\n```\n\n不使用new命令调用Vehicle构造函数时，price属性变成了全局变量，变量v变成了undefined。\n\n### new.target\n\n函数内部可以使用new.target属性。如当前函数是new命令调用，new.target指向当前函数，否则为undefined。\n\n## 使用Object.create()创建实例对象\n\n构造函数作为模版，可以生成实例对象。但是，有时只能拿到实例对象，而该对象根本就不是由构造函数生成的。这时可以使用Object.create()方法，直接以某个实例对象作为模版，生成一个新的实例对象。\n\n```\nvar person1 = {\n  name: '张三',\n  age: 38,\n  greeting: function() {\n    console.log('Hi! I\\'m ' + this.name + '.');\n  }\n};\n\nvar person2 = Object.create(person1);\n\nperson2.name // 张三\nperson2.greeting() // Hi! I'm 张三.\n```\n\n上面代码中，对象person1是person2的模版，后者继承了前者的属性和方法。\n\n## this关键字\n\nthis总是返回一个对象，简单说就是返回属性或方法“当前”所在的对象:\n\n```\nvar person = {\n  name : 'Ethan',\n  describe: function () {\n    return '姓名:'+this.name;\n  }\n};\nperson.describe()\n// “姓名：Ethan”\n```\n\nthis.name表示describe方法所在的当前对象的name属性。调用person.describe方法时，describe方法所在的当前对象是person，所以就是调用person.name。\n\n**由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。**\n\n```\nfunction f() {\n  return '姓名：'+ this.name;\n}\n\nvar A = {\n  name: '张三',\n  describe: f\n};\n\nvar B = {\n  name: '李四',\n  describe: f\n};\n\nA.describe() // \"姓名：张三\"\nB.describe() // \"姓名：李四\"\n```\n\n只要函数被赋给另一个变量，this的指向就会变：\n\n```\nvar A = {\n  name: '张三',\n  describe: function () {\n    return '姓名：'+ this.name;\n  }\n};\n\nvar name = '李四';\nvar f = A.describe;\nf() // \"姓名：李四\"\n```\n\nA.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。\n\n```\n<input type=\"text\" name=\"age\" size=3 onChange=\"validate(this, 18, 99);\">\n\n<script>\nfunction validate(obj, lowval, hival){\n  if ((obj.value < lowval) || (obj.value > hival))\n    console.log('Invalid Value!');\n}\n</script>\n```\n\n上面代码是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数。回调函数传入this，就代表传入当前对象（即文本框），然后就可以从this.value上面独到用户的输入值。\n\nJS语言中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是这个对象（环境）。\n\n如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。\n\n```\nfunction f(){\n  return this;\n}\nf() === window // true\n```\n\n可以近似地认为，this是所有函数运行时的一个隐藏参数，指向函数的运行环境。 \n\n### 使用场合\n\nthis的使用可以分成以下几个场合。\n\n1. **全局环境**使用this，它指的就是顶层对象window。\n\n   ```\n   this === window // true\n\n   function f(){\n     soncole.log(this === window); // true\n   }\n   ```\n\n   不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。\n\n2. **构造函数**中的this，指的是实例对象。\n\n3. **对象的方法**\n\n   当A对象的方法被赋予B对象，该方法中的this就是从指向A对象变成了指向B对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。\n\n   ```\n   var obj = {\n     foo: function(){\n       console.log(this);\n     }\n   };\n   obj.foo() // obj\n   ```\n\n   obj.foo方法执行时，它内部的this指向obj。\n\n   但是，只有这一种用法（直接在obj对象上调用foo方法），this指向obj；其他用法时，this都指向代码块当前所在对象（浏览器为window对象）。\n\n   ```\n   // 情况一\n   (obj.foo = obj.foo)() // window\n\n   // 情况二\n   (false || obj.foo)() // window\n\n   // 情况三\n   (1, obj.foo)() // window\n   ```\n\n   上面代码中，obj.foo先运算在执行，即使值根本没有变化，this也不再指向obj了。这时因为这时它就脱离了运行环境obj，而是在全局环境执行。\n\n   可以这样理解，在JS引擎内部，obj和obj.foo储存在两个内存地址，假设时M1和M2。只有obj.foo（）这样调用时，是从M1调用M2，因此this指向obj。但是，上面三种情况，都是直接取出M2进行运算，然后在全局环境执行运算结果（还是M2），因此this指向全局环境。\n\n   **如果某个方法位于多层对象的内部，这时this只是指向当前一层的对象，而不会继承更上面的层**：\n\n   ```\n   var a = {\n     p: 'Hello',\n     b: {\n       m: function(){\n         console.log(this.p);\n       }\n     }\n   };\n\n   a.b.m() // undefined\n   ```\n\n   上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是直系那个a.b。\n\n### 使用注意\n\n1. 避免多层this\n\n   ```\n   var o = {\n     f1:function(){\n       console.log(this);\n       var f2 = function (){\n         console.log(this);\n       }();\n     }\n   }\n\n   o.f1()\n   // Object\n   // Window\n   ```\n\n   第一层指向该对象，第二层指向全局对象\n\n   [**为什么第二层this指向全局对象window？**](http://blog.csdn.net/u011457225/article/details/73882551?utm_source=itdadao&utm_medium=referral)\n\n   o.f1()表示调用o对象的f1方法，所以f1方法中的this指向o对象；而f1方法中的闭包（即f2函数）不属于任何对象，它不是一个对象的方法。非严格模式下，如果没有指定属于哪个对象，那么它就属于window对象。\n\n### 绑定this的方法\n\nJS提供了call、apply、bind三种方法，来切换／固定this 的指向。\n\n1. **function.prototype.call()**\n\n   作用：指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。\n\n   call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。如果参数是一个原始值，那么这个原始值回自动转成对应的包装对象，然后传入call方法。\n\n   ```\n   var n = 123;\n   var obj = { n: 456};\n\n   function a(){\n     console.log(this.n);\n   }\n\n   a.call() // 123\n   a.call(null) // 123\n   a.call(undefined) // 123\n   a.call(window) // 123\n   a.call(obj) // 456\n   ```\n\n   call方法还可以接受多个参数，第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。\n\n   ```\n   func.call(thisValue,arg1,arg2,...)\n   ```\n\n   ```\n   function add(a,b){\n     return a + b;\n   }\n\n   add.call(this,1,2) // 3\n   ```\n\n2. **function.prototype.apply()**\n\n   apply方法等作用域call方法类似，也是改变this指向，然后在调用该函数。唯一的区别就是，他接受一个数组作为函数执行时的参数：\n\n   ```\n   func.apply(thisValue,[arg1,arg2,...])\n   ```\n\n   ```\n   function f(x,y){\n     console.log(x+y);\n   }\n   f.call(null,1,1) // 2\n   f.apply(null,[1,1]) // 2\n   ```\n\n3. **function.prototype.bind()**\n\n   apply／call方法不仅绑定函数执行时所在的对象，还会立即执行函数。\n\n   bind方法只用于将函数体内的this绑定到某个对象，然后返回一个新函数。\n\n## prototype 对象\n\n### 原型对象\n\n通过同一个构造函数创建的实例对象之间，无法共享属性，对系统资源造成浪费。\n\n**JS的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。null除外。**\n\n原型对象上的所有属性和方法，都能派生对象共享。这就是JS继承机制的基本设计。\n\n通过构造函数生成实例对象时，会自动为实例对象分配原型对象。**每一个构造函数都有一个prototype属性**，这个属性就是实例对象的原型对象。\n\n```\nfunction Animal (name){\n  this.name = name;\n}\n\nAnimal.prototype.color = 'white';\n\nvar cat1 = new Animal('大毛');\nvar cat2 = new Animal('二毛');\n\ncat1.color // 'white'\ncat2.color // 'white'\n```\n\n构造函数Animal的prototype对象，就是实例对象cat1和cat2的原型对象。在原型对象上添加一个color属性。实例对象都能读取该属性。\n\n+ 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。\n\n\n+ 当实例对象本身没有某个属性或方法等时候，它会去原型对象寻找并读取这个属性火方法。\n+ 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。\n\n**原型对象的作用，就是定义所有实例对象共享的属性和方法。**\n\n### 原型链\n\n原型对象本身也是对象，又有自己的原型，所以形成一条原型链。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。\n\n如果一层层地上溯，所有对象的原型最终都可以上溯到`Object.prototype`，即Object构造函数的prototype属性指向的那个对象。`Object.prototype`对象的原型是没有任何属性和方法等`null`对象，而`null`对象没有自己的原型。\n\n+ 原型链的作用是：读取对象的某个属性时，JS引擎线寻找对象本身的属性，如果找不到，就到它的原型去找，如果还找不到，就到原型的原型去找。如果知道最顶层的`Object.prototype`还是找不到，则返回undefined。\n\n在原型链一级级向上寻找某个属性，对性能有影响。属性越在山层影响越大。如果寻找某个不存在的属性，会遍历整个原型链。\n\n```\nvar MyArray = function (){};\n\nMyArray.prototype = new Array();\nMyArray.prototype.constructor = MyArray;\n\nvar mine = new MyArray();\nmine.push(1,2,3);\n\nmine.length // 3\nmine instanceof Array // true\n```\n\ninstanceof运算符用来比较一个对象是否为某个构造函数的实例。\n\n### constructor属性\n\nprototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。\n\n```\nfunction P (){}\n\nP.prototype.constructor === p // true\n```\n\n由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承：\n\n```\nfunction P () {}\nvar p = new P();\n\np.constructor\n// function P() {}\n\np.constructor === P.prototype.constructor\n// true\n\np.hasOwnProperty('constructor')\n//false\n```\n\n+ **constructor属性的作用，是分辨原型对象到底属于哪个构造函数**\n\n+ 通过constructor属性，从实例新建另一个实例：\n\n  ```\n  function Constr() {}\n  var x = new Constr();\n\n  var y = new x.constructor();\n  y instanceof Constr // true\n  ```\n\n  这使得在实例方法中，调用自身的构造函数成为可能：\n\n  ```\n  Constr.prototype.createCopy = function (){\n    return new this.constructor();\n  }\n  ```\n\n+ 通过name属性，可以从实例得到构造函数的名称：\n\n  ```\n  function Foo () {}\n  var f = new Foo();\n  f.constructor.name // \"Foo\"\n  ```\n\n+ 修改原型对象时，一般要同时校正constructor属性的指向，否则会导致instanceof运算符失真。\n\n### instanceof运算符\n\ninstanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。\n\n```\nvar n = new Vehicle();\nv instanceof Vehicle // true\n```\n\ninstanceof运算符左边时实例对象，右边是构造函数。它会检查右边构造函数的原型对象，是否在左边对象的原型链上。\n\ninstanceof运算符只能用于对象，不适用原始类型的值。\n\n### Object.getPrototypeOf()\n\n`Object.getPrototypeOf`方法返回一个对象的原型。这时获取原型对象的标准方法。\n\n```\n// 空对象的原型是Object.prototype\nObject.getPrototypeOf({}) === Object.prototype\n// true\n\n// 函数的原型是Function.prototype\nfunction f() {}\nObject.getPrototypeOf(f) === Function.prototype\n// true\n\n// f 为 F 的实例对象，则 f 的原型是 F.prototype\nvar f = new F();\nObject.getPrototypeOf(f) === F.prototype\n// true\n```\n\n### Object.setPrototypeOf()\n\n`Object.setPrototypeOf`方法可以为现有对象设置原型，返回一个新对象。\n\n`Object.setPrototypeOf`方法接受两个参数，第一个是现有对象，第二个是原型对象。\n\n`new`命令通过构造函数新建实例对象，实质就是将实例对象的原型，指向构造函数的`prototype`属性，然后在实例对象上执行构造函数。\n\n```\nvar F = function () {\n  this.foo = 'bar';\n};\n\nvar f = new F();\n\n// 等同于\nvar f = Object.setPrototypeOf({}, F.prototype);\nF.call(f);\nf.foo // \"bar\"\n```\n\n### Object.create()\n\n`Object.create`方法是为了满足只能通过实例对象生成另一个实例对象的需求。\n\n`Object.create`方法接受一个对象作为**第一个参数**，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。\n\n老式浏览器如果不支持Object.create方法，可以用下面代码部署：\n\n```\nif (typeof Object.create !== 'function'){\n  Object.create = function (obj){\n    function F(){}\n    F.prototype = obj;\n    return new F()\n  };\n}\n```\n\n+ Object.create方法参数不能为空，或者不是对象，否则会报错。\n\n+ 如果想生成一个不继承任何属性的对象，可以将Object.create的参数设为null。\n\n+ Object.create方法生成的新对象，动态继承原型。在原型上添加或修改任何方法，会立刻反应在新对象之上。\n\n+ Object.create方法还接受**第二个参数**。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性\n\n  ```\n  var obj = Object.create({}, {\n    p1: {\n      value: 123,\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    },\n    p2: {\n      value: 'abc',\n      enumerable: true,\n      configurable: true,\n      writable: true,\n    }\n  });\n\n  // 等同于\n  var obj = Object.create({});\n  obj.p1 = 123;\n  obj.p2 = 'abc';\n  ```\n\n+ Object.create方法生成的对象，继承了它原型对象的构造函数。\n\n### Object.prototype.isPrototypeOf()\n\n对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。\n\n```\nvar o1 = {};\nvar o2 = Object.create(o1);\nvar o3 = Object.create(o2);\n\no2.isPrototypeOf(o3); // true\no1.isPrototypeOf(o3); // true\n```\n\n**只要某个对象处在原型链上，isPrototypeOf都返回true。**\n\n### Object.prototype.\\_\\_proto\\_\\_\n\n\\_\\_proto\\_\\_属性（前后各两个下划线）可以改写某个对象的原型对象。\n\n```\nvar obj = {};\nvar p = {};\n\nobj.__proto__ = p;\nObject.getPrototypeOf(obj) === p // true\n```\n\n### 获取原型对象方法等比较\n\n\\_\\_proto\\_\\_属性指向当前对象的原型对象，即构造函数的prototype属性：\n\n```\nvar obj = new Object();\n\nobj.__proto__ === Object.prototype\n//true\nobj.__proto__ === obj.constructor.prototype\n//true\n```\n\n因此，获取实例对象obj的原型对象，有三种方法：\n\n+ obj.\\_\\_proto\\_\\_\n+ obj.constructor.prototype\n+ Object.getPrototypeOf(obj)\n\n前两种方法都不可靠，推荐第三种。\n\n## Object对象与继承\n\n通过原型链，对象的属性分成两种：自身的属性和继承的属性。\n\n### Object.getOwnPropertyNames()\n\n`Object.getOwnPropertyNames`方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。\n\n对象本身的属性之中，有的是可以枚举的，有的不可枚举。`Object.getOwnPropertyNames`方法返回包括不可枚举的所有键名。如果只获取可枚举属性，请使用`Object.keys`方法。\n\n### Obejct.prototype.hasOnwProperty()\n\n对象实例的`hasOwnProperty`方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上：\n\n```\nDate.hasOwnProperty('length')\n// true\n\nDate.hasOwnProperty('toString')\n// false\n```\n\nhasOwnProperty方法是JS中唯一一个处理对象属性时，不会遍历原型链的方法。\n\n### in运算符和for...in循环\n\n+ in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。\n+ 获得对象的所有可枚举属性（不管是自身的还是继承的），可以使用for...in循环。\n\n### 对象的拷贝\n\n如果要拷贝一个对象，需要做到下面两件事情。\n\n+ 确保拷贝后的对象，与原对象具有同样的prototype原型对象。\n+ 确保拷贝后的对象，与原对象具有同样的属性。\n\n# 标准库\n\n## Object对象\n\nJS原生提供Object对象（起首的O大写），所有其他对象都继承自这个对象。\n\nObject本身也是一个构造函数，可以直接通过它来生成新对象。\n\nObject作为构造函数使用时，可以接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。\n\n## Array对象\n\nArray是JS的内置对象，同时也是一个构造函数，可以用它生成新的数组。\n\n## 包装对象\n\n所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。\n\n```\nvar v1 = new Number(123);\nvar v2 = new String('abc');\nvar v3 = new Boolean(true);\n```\n\nNumber、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。\n\n```\nNumber(123) // 123\nString('abc') // \"abc\"\nBoolean(true) // true\n```\n\n总之，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。\n\n## Math对象\n\nMath是JS的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。\n\n## Date对象\n\nDate对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。\n\nDate对象也可以作为构造函数使用。使用new命令，会返回一个Date对象的实例。如果不加参数，生成的就是代表当前时间的对象。\n\n## 属性描述对象\n\nJS提供了一个内部数据结构，用来描述一个对象的属性的行为，控制它的行为。这被称为“属性描述对象“（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。\n\n下面是属性描述对象的一个实例。\n\n```\n{\n  value:123,\n  writable:false,\n  enumerable:true,\n  configurable:false,\n  get:undefined,\n  set:undefined\n}\n```\n\n属性描述对象提供6个元属性：\n\n1. value\n\n   value存放该属性的属性值，默认为undefined。\n\n2. writable\n\n   writable存放一个布尔值，表示属性值（value）是否可改变，默认为true。\n\n3. enumerable\n\n   enumerable存放一个布尔值，表示该属性是否可枚举，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。\n\n4. configurable\n\n   configurable存放一个布尔值，表示“可配置性”，默认为true。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。\n\n5. get\n\n   get存放一个函数，表示该属性的取值函数（getter），默认undefined。\n\n6. set\n\n   set存放一个函数，表示该属性的存值函数（setter），默认为undefined。\n\n### Object.getOwnPropertyDescriptor()\n\n`Object.getOwnPropertyDescriptor`方法可以读出对象自身属性的属性描述对象。\n\n```\nvar o = { p : 'a' };\n\nObject.getOwnPropertyDescriptor(o,'p')\n// Object { value: \"a\",\n//   writable: true,\n//   enumerable: true,\n//   configurable: true\n// }\n```\n\n### Object.defineProperty(),Object.defineProperties()\n\n`Object.defineProperty()`方法允许通过定义属性描述对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下：\n\n```\nObject.defineProperty(object,propertyName,attributesObject)\n```\n\n`Object.defineProperty`方法接受三个参数，第一个是属性所在的对象，第二个是属性名（它应该是一个字符串），第三个是属性的描述对象。比如新建一个o对象，并定义它的p属性，写法如下：\n\n```\nvar o = Object.defineProperty({},'p',{\n  value:123,\n  writable:false,\n  enumerable:true,\n  configurable:false\n})\no.p\n// 123\no.p = 246;\no.p\n// 123\n// 因为writable为false，所以无法改变该属性的值。\n```\n\n如果属性已经存在，`Object.defineProperty`方法相当于更新该属性的属性描述对象。\n\n需要注意的是，Object.defineProperty方法和后面的Object.defineProperties方法，都有性能损耗，会拖慢执行速度，不宜大量使用。\n\n如果一次性定义或修改多个属性，可以使用`Object.defineProperties`方法：\n\n```\nvar o = Object.defineProperties({},{\n  p1: { value: 123, enumerable: true },\n  p2: { value: 'abc', enumerable: true },\n  p3: { get: function(){ return this.p1 + this.p2 },\n  \tenumerable:true,\n  \tconfigurable:true\n  }\n});\n\no.p1 // 123\no.p2 // \"abc\"\no.p3 // \"123abc\"\n```\n\n上面代码的p3属性，定义了取值函数get。**这时需要注意的是，一旦定义了取值函数get（或存值函数set），就不能将writable设为true，或者同时定义value属性，会报错。**\n\n```\nvar o = {};\n\nObject.defineProperty(o,'p',{\n  value:123,\n  get: function (){ return 456; }\n});\n// TypeError: Invalid property.\n// A property cannot both have accessors and be writable or have a value,\n```\n\n### 元属性\n\n#### 可枚举性（enumerable）\n\n只有可枚举的属性，才会被for...in循环遍历，同时还规定原生继承的属性都是不可枚举的。\n\n可枚举性涌来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会渠道该属性。\n\n+ for…in循环\n+ Object.keys方法\n+ JSON.stringify方法\n\n基本上，JS原生提供的属性都是不可枚举的，用户自定义的属性都是可枚举的。\n\n#### 可配置性（configurable）\n\n可配置性决定了是否可以修改属性描述对象。也就是说，当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。\n\n需要注意的是，writable只有在从false改为true会报错，从true改为false则是允许的。\n\n```\nvar o = Object.defineProperty({},'p',{\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(o,'p',{writable: false})\n// 修改成功\n```\n\n至于value，只要writable和configurable有一个为true，就允许改动。\n\n```\nvar o1 = Object.defineProperty({}, 'p', {\n  value: 1,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(o1,'p', {value: 2})\n// 修改成功\n\nvar o2 = Object.defineProperty({}, 'p', {\n  value: 1,\n  writable: false,\n  configurable: true\n});\n\nObject.defineProperty(o2,'p', {value: 2})\n// 修改成功\n```\n\nconfigurable为false时，直接对该属性赋值，不报错，但不会成功。\n\n```\nvar o = Object.defineProperty({},'p',{\n  value: 1,\n  configurable: false\n});\n\no.p = 2;\no.p // 1\n```\n\n上面代码中，o对象的p属性是不可配置的，对他赋值是不会生效的。\n\n可配置性决定了一个变量是否可以被删除。\n\n```\nvar o = Object.definePropertyies({},{\n  p1: { value: 1, configurable: true },\n  p2: { value: 2, configurable: false}\n});\n\ndelete o.p1 // true\ndelete o.p2 // false\n\no.p1 // undefined\no.p2 // 2\n```\n\n#### 可写性（writable）\n\n可写性决定了属性的值是否可以被改变。\n\n```\nvar o = {};\nObject.defineProperty(o,'a',{\n  value: 37,\n  writable:false\n});\n\no.a // 37\no.a = 25;\no.a // 37\n```\n\n正常模式下，对可写性为false的属性赋值不会报错，只会默默失败。但是严格模式下会报错。\n\n关于可写性，还有一种特殊情况。就是如果原型对象的某个属性的可写性为false，那么派生对象将无法自定义这个属性。\n\n```\nvar proto = Object.defineProperty({},'foo',{\n  value: 'a',\n  writable: false\n});\n\nvar o = Object.create(proto);\n\no.foo = 'b';\no.foo // 'a'\n```\n\n规避这个情况的方法，就是通过覆盖属性描述对象，绕过这个限制，原因是这种情况下，原型链会被完全忽视。\n\n```\nObject.defineProperty(o,'foo',{\n  value:'b'\n});\no.foo // 'b'\n```\n\n### 存取器（accessor）\n\n除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用set命令；取值函数称为getter，使用get命令。\n\n存取器提供的是虚拟属性，即该属性的值不失时机存在的，而是每次读取时计算生成的。\n\n```\nvar o = {\n  get p(){\n    return 'getter';\n  },\n  set p(value){\n    console.log('setter:' + value);\n  }\n};\n\no.p // \"getter\"\no.p = 123 // \"setter: 123\"\n```\n\n上面代码中，o对象内部的get和set命令，分别定义了p属性的取值函数和存值函数。定义了这两个函数之后，对p属性取值时，取值函数会自动调用；对p属性赋值时，存值函数会自动调用。\n\n取值函数getter不能接受参数，存值函数setter只能接受一个参数（即属性的值）。\n\n对象也不能有和与之函数同名的属性。\n\n存取器也可以通过Object.defineProperty定义：\n\n```\nvar d = new Date();\nObject.definedProperty(d,'month',{\n  get: function (){\n    return d.getMonth();\n  },\n  set: function (v){\n    d.setMonth(v);\n  }\n});\n```\n\n**利用存取器，可以实现数据对象与DOM对象的双向绑定。**\n\n```\nObject.defineProperty(user,'name',{\n  get: function(){\n    return document.getElementById('foo').value\n  },\n  set: function(newValue){\n    document.getElementById('foo').value = newValue\n  },\n  configurable: true\n})\n```\n\n上面代码，将DOM对象foo与数据对象user的name属性，实现了绑定。两者之中只要有一个对象发生变化，就能在另一个对象上实时反映出来。\n\n# 语法专题\n\n## 单线程模型\n\n### 含义\n\n单线程模型指的是，JS值在一个线程上运行。也就是说，JS同时只能执行一个任务，其他任务都必须在后面排队等待。\n\nJS只在一个线程上运行，不代表JS引擎只有一个线程。JS有多个线程。\n\n### 消息队列\n\nJS运行时，除了一个运行线程，JS还提供一个消息队列，里面是各种需要当前程序处理的消息。新的消息进入队列时，会自动排在队列尾端。\n\n运行线程只要发现消息队列不为空，就会取出排在第一位的消息，执行它对应的回调函数。等执行完，再取出排在第二位的消息，不断循环，直到消息队列变空为止。\n\n进入消息队列的消息，必须有对应的回调函数。否则这个消息就会遗失。\n\nsetTimeout会在指定时间向消息队列添加一条消息。如果消息队列之中，此时没有其他消息，这条消息会立即得到处理；否则，这条消息会不得不等到其他消息处理完，才会得到处理。因此，`setTimeout`指定的执行时间，只是一个最早可能发生的时间，并不能保证一定会在那个时间发生。\n\n### Event Loop\n\n用来一轮又一轮的处理消息队列之中的消息，即执行对应的回调函数的内部循环机制。\n\n常见的JS任务：\n\n+ 执行JS代码\n+ 对用户的输入（鼠标点击、键盘输入等等）做出反应\n+ 处理异步网络请求\n\n所有任务可以分成两种，一种是同步任务，另一种是异步任务。\n\n同步任务指的是，在JavaScript执行进程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入JavaScript执行进程、而进入“任务队列”（task queue）的任务，只有“任务队列”通知主进程，某个异步任务可以执行了，该任务（采用回调函数的形式）才会进入JavaScript进程执行。\n\n以Ajax操作为例，它可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着Ajax操作返回结果，再往下执行；如果是异步任务，该任务直接进入“任务队列”，JavaScript进程跳过Ajax操作，直接往下执行，等到Ajax操作有了结果，JavaScript进程再执行对应的回调函数。\n\n## 定时器\n\nJS提供定时执行代码的功能，叫做定时器（timer），主要由`setTimeout()`和`setInterval()`这两个函数来完成。它们向任务队列添加定时任务。\n\n### setTimeout()\n\n用来指定某个函数或某段代码，在多少毫秒之后执行。\n\nsetTimeout函数接受两个参数，第一个参数`fund|code`是将要推迟执行的函数名或者一段代码，第二个参数`delay`是推迟执行的毫秒数。\n\n```\nconsole.log(1);\nsetTimeout('console.log(2)',1000);\nconsole.log(3);\n```\n\n**注意**，推迟执行的代码必须以字符串的形式放入setTimeout，因为引擎内部使用eval函数，将字符串转为代码。如果推迟执行的是函数，则可以直接将函数名放入setTimeout。\n\n一方面eval函数有安全顾虑，另一方面为了便于引擎优化代码，setTimeout方法一般总是采用匿名函数的形式：\n\n```\nfunction f(){\n  console.log(2);\n}\n\nsetTimeout(f,1000);\n\n// 或者\n\nsetTimeout(function () {\n  console.log(2)\n},1000)\n```\n\n### setInterval()\n\nsetInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。\n\n### clearTimeout()，clearInterval()\n\nsetTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数值传入clearTimeout和clearInterval函数，就可以取消对应的定时器。\n\n```\nvar id1 = setTimeout(f,1000);\nvar id2 = setInterval(f,1000);\n\nclearTimeout(id1);\nclearInterval(id2);\n```\n\n### 运行机制\n\n`setTimeout`和`setInterval`的运行机制是，将指定的代码移出本次执行，等到下一轮 Event Loop 时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮 Event Loop 时重新判断。\n\n## Promise对象\n\n### JS的异步执行\n\n#### 回调函数\n\n回调函数是异步编程最基本的方法。\n\n假定有两个函数f1和f2，后者必须等到前者执行完成才能执行。这时可以考虑改写f1，把f2写成f1的回调函数。\n\n```\nfunction f1(callback){\n  // f1 的代码\n  \n  // f1 执行完成后，调用回调函数\n  callback();\n}\n\nf1(f2);\n```\n\n回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个人物只能指定一个回调函数。\n\n#### Promise对象\n\nPromise对象是CommonJS工作组提出的一种规范，目的是为异步操作提供统一接口。\n\n它是一个对象。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。\n\n它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以蚕蛹同步操作的流程。这个Promise对象有一个then方法，允许指定回调函数，在异步任务完成后调用。\n\n比如，异步操作f1返回一个Promise对象，它的回调函数f2写法如下：\n\n```\n(new Promise(f1)).then(f2);\n```\n\n#### Promise接口\n\nPromise接口的基本思想是，异步任务返回一个Promise对象。\n\nPromise对象只三种状态：\n\n+ 异步操作“未完成”（pending）\n+ 异步操作“已完成”（resolved）\n+ 异步操作“失败”（rejected）\n\n三种状态只有两种变化方式：\n\n+ 异步操作从“未完成”到“已完成”\n+ 异步操作从“未完成”到“失败”\n\n因此，Promise对象的最终结果只有两种：\n\n+ 异步操作成功，Promise对象传回一个值，状态变为resolved。\n+ 异步操作失败，Promise对象抛出一个错误，状态变为rejected。\n\nPromise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时的回调函数，第二个时异步操作失败时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。\n\n```\n// po是一个Promise对象\npo.then(\n\tconsole.log,\n\tconsole.error\n)\n```\n\nthen方法可以链式使用：\n\n```\npo\n\t.then(step1)\n\t.then(step2)\n\t.then(step3)\n\t.then(\n\t\tconsole.log,\n\t\tconsole.error\n\t);\n```\n\n上面代码中，po的状态一旦变为resolved，就一次调用后面每一个then指定的回调函数，每一步都必须等到前一步完成，才会执行。\n\nPromise对象的错误有传递性。\n\n#### Promise对象的生成\n\nES6提供了原生的Promise构造函数，用来生成Promise实例。\n\n```\nvar promise = new Promise(function(resolve,reject){\n  // 异步操作的代码\n  \n  if(/* 异步操作成功 */){\n    resolve(value);\n  }else{\n    reject(error);\n  }\n});\n```\n\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们时两个函数，由JS引擎提供，不用自己部署。\n\n## 严格模式\n\n进入“严格模式”的标志，是一行字符串`use strict`。\n\n1. 针对整个脚本文件\n\n   将`use strict`放在脚本文件第一行，整个脚本都将以“严格模式”运行。\n\n2. 针对单个函数\n\n   `use strict`放在函数体的第一行，整个函数以“严格模式”运行。\n\n3. 脚本文件的变通写法\n\n   两个不同模式的脚本合并成一个文件，如果严格模式的脚本在前，则合并后的脚本都是“严格模式”；如果正常模式的脚本在前，则合并后的脚本都是“正常模式”。总之，这两种合并后的结果都是不正确的。\n\n   正确的做法是，使用前面第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。\n\n   ```\n   (function(){\n     'use strict';\n     // some code here\n   })();\n   ```\n\n   ​\n\n# DOM模型\n\nDOM是JS操作网页的接口，它的作用是将网页转为一个JS对象，从而可以用脚本进行各种操作。\n\n## 事件模型\n\n### 事件的传播\n\n#### 传播的三个阶段\n\n当一个事件发生以后，它会在不同的DOM节点之间传播（propagation）。这种传播分成三个阶段：\n\n+ 第一阶段：从window对象传导到目标节点，称为“捕获阶段”。\n+ 第二阶段：从目标节点上触发，称为“目标阶段”。\n+ 第三阶段：从目标节点传导回window对象，称为“冒泡阶段”。\n\n这三种阶段的传播模型，会使得一个事件在多个节点上触发。比如，假设点击`<div>`之中嵌套一个`<p>`节点：\n\n```\n<div>\n\t<p>Click Me</p>\n</div>\n```\n\n如果对这两个节点的click事件都设定监听函数，则click事件会被触发四次：\n\n+ 捕获阶段：事件从`<div>`向`<p>`传播时，触发`<div>`的`click`事件；\n+ 目标阶段：事件从`<div>`到达`<p>`时，触发`<p>`的`click`事件；\n+ 目标阶段：事件离开`<p>`时，触发`<p>`的`click`事件；\n+ 冒泡阶段：事件从`<p>`传回`<div>`时，再次触发`<div>`的`click`事件。\n\n#### 事件的代理\n\n由于事件会在冒泡阶段向上传播的父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。\n\n如果希望事件到某个节点为止，不再传播，可以使用时间对象的`stopPropagation`方法。\n\n`stopPropagation`方法只会阻止当前监听函数的传播，不会阻止节点上的其他click事件的监听函数。如果想要不再触发那些监听函数，可以使用stopImmediatePropagation方法。\n\n### Event对象\n\n事件发生以后，会生成一个事件对象，**作为参数传给监听函数**。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例。\n\n#### event.currentTarget\n\ncurrentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。作为比较，target属性返回事件发生的节点。如果监听函数在捕获阶段和冒泡阶段触发，那么这两个属性返回的值是不一样的。\n\n#### event.target\n\ntarget属性返回触发事件的那个节点，即事件最初发生的节点。如果监听函数不在该即诶单触发，那么它与currentTarget属性返回的值是不一样的。\n\n```\nfunction hide(e){\n  console.log(this === e.target);\n  e.target.style.visibility = \"hidden\";\n}\n\n// HTML代码为\n// <p id=\"para\">Hello <em>World</em></p>\npara.addEventListener('click',hide,false);\n```\n\n上面代码中，如果在para节点的em子节点上面点击，则e.target指向em子节点，导致em子节点（即World部分）会不可见，且输出false。\n\n**事件的触发，和事件的监听不是一个概念**，比如上面代码中，点击em节点，click事件是在em节点触发的，然后按照事件传播模型从顶层window节点开始向下捕获，然后再从目标节点em节点向上冒泡，在冒泡阶段，p节点上监听了click事件，那么会执行p节点的监听函数，但此时event.target指向的是触发click事件的em节点，虽然监听函数是在p节点上执行的。\n\n#### event.preventDefault()\n\npreventDefault方法取消浏览器对当前事件的默认行为。该方法生效的前提是，事件的cancelable属性为true。\n\n该方法不会阻止事件的进一步传播。只要在事件的传播过程中（捕获阶段、目标阶段、冒泡阶段皆可），使用了preventDefault方法，该事件的默认方法就不会执行。\n\n#### event.stopPropagation()\n\nstopPropagation方法阻止事件在DOM中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上新定义的事件监听函数。\n\n**stopPropagation既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止事件目标阶段。**\n\n#### event.stopImmediatePropagation()\n\nstopImmediatePropagation方法阻止同一个事件的其他监听函数被调用。\n\n如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序一次调用。只要其中一个监听函数调用了stopImmediatePropagation方法，其他监听函数就不会再执行了。\n\n# 浏览器环境\n\n## 概述\n\n### JS代码嵌入网页的方法\n\n#### script标签：代码嵌入网页\n\n#### script标签：加载外部脚本\n\n#### 事件属性\n\n某些HTML元素的事件属性（比如onclic和onmouseover），可以写入JS代码。当指定事件发生时，就会调用这些代码。\n\n```\n<div onclick=\"alert('Hello')\"></div>\n```\n\n上面的事件属性代码只有一个语句。如果有多个语句，用分号分隔即可。\n\n#### URL协议\n\nURL支持`javascript:`协议，调用这个URL时，就会执行JS代码。\n\n```\n<a href=\"javascript:alert('Hello')\"></a>\n```\n\n### script标签\n\n#### 工作原理\n\n正常的网页加载流程是这样的：\n\n+ 浏览器一边下载HTML网页，一边开始解析\n+ 解析过程中，发现`<script>`标签\n+ 暂停解析，网页渲染的控制权转交给JavaScript引擎\n+ 如果`<script>`标签引用了外部脚本，就下载该脚本，否则就直接执行\n+ 执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页\n\n### 浏览器的组成\n\n浏览器的核心是两部分：渲染引擎和JavaScript解释器（又称JavaScript引擎）。\n\n#### 渲染引擎\n\n渲染引擎处理网页，通常分成四个阶段：\n\n+ 解析代码：HTML代码解析为DOM，CSS代码解析为CSSOM（CSS Object Model）\n+ 对象合成：将DOM和CSSOM合成一个渲染树\n+ 布局：计算出渲染树的布局（layout）\n+ 绘制：将渲染树绘制到屏幕\n\n以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。\n\n#### JavaScript引擎\n\nJS引擎的主要作用是，读取网页中的JS代码，对其处理后运行。\n\n## window对象\n\n### window对象\n\n在浏览器中，window对象指当前的浏览器窗口。它也是所有对象的顶层对象。\n\nJS规定，浏览器环境的所有全局变量，都是window对象的属性。\n\n### history对象\n\n浏览器窗口有一个history对象，用来保存浏览历史。\n\n### Cookie\n\nCookie时服务器保存在浏览器的一小段文本信息，每个Cookie的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。\n\n### Web Storage：浏览器端数据储存机制\n\n这个API的作用是，使得网页可以在浏览器端储存数据。它分成两类：sessionStorage和localStorage。\n\nsessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；localStorage保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。\n\n每个域名的存储上限视浏览器而定。Chrome是2.5MB，Firefox和Opera是5MB，IE是10MB。\n\n另外，与Cookie一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取。\n\n#### 存入／读取数据\n\n存入数据使用setItem方法：\n\n```\nsessionStorage.setItem(\"key\",\"value\");\nlocalStorage.setItem(\"key\",\"value\");\n```\n\n读取数据使用getItem方法：\n\n```\nvar valueSession = sessionStorage.getItem(\"key\");\nvar valueLocal = localStorage.getItem(\"key\");\n```\n\n#### 清除数据\n\nremoveItem方法用于清除某个键名对应的数据。\n\n```\nsessionStorage.removeItem('key');\nlocalStorage.removeItem('key');\n```\n\nclear方法用于清除所有保存的数据。\n\n```\nsessionStorage.clear();\nlocalStorage.clear();\n```\n\n## 同源政策\n\n### 含义\n\n1995年，同源政策由Netscape公司引入浏览器。\n\n最初，它的含义是指，A网页设置的Cookie，B网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。\n\n+ 协议相同\n+ 域名相同\n+ 端口相同\n\n## AJAX\n\n浏览器与服务器之间，采用HTTP协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会想服务器发出HTTP请求。\n\nAJAX包括以下几个步骤：\n\n1. 创建AJAX对象\n2. 发出HTTP请求\n3. 接受服务器传回的数据\n4. 更新网页数据\n\n概括起来就是一句话，AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。\n\n```\nvar xhr = new XMLHttpRequest();\n\n// 指定通信过程中状态改变时的回调函数\nxhr.onreadtstatechange = function(){\n\t// 通信成功时，状态值为4\n  if(xhr.readyState === 4){\n    if(xhr.status === 200){\n      console.log(xhr.resonseText);\n    }else{\n      console.log(xhr.statusText);\n    }\n  }\n}\n\nxhr.onerror = function (e){\n  console.log(xhr.statusText);\n}\n\n// open方式用于指定HTTP动词、请求的网址、是否异步\nxhr.open('GET','/endpoint',true);\n\n// 发送HTTP请求\nxhr.send(null);\n```\n\n","slug":"ES5学习笔记","published":1,"updated":"2021-05-08T15:06:15.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckohezbrh002iwct46vzibe8b","content":"<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><ul>\n<li><p>凡是JavaScript语言中预期为值的地方，都可以使用表达式。</p>\n</li>\n<li><p>使用var重新声明一个已经存在的变量是无效的，但是如果第二次声明的同时还附了值，则会覆盖掉前面的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">var x;</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\"></span><br><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">var x &#x3D; 2;</span><br><span class=\"line\">x &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li>\n<li><p>JavaScript引擎的工作方式是，现解析代码，获取所有被声明的变量，然后再一行一行的运行。这造成的结果就是所有的变量声明语句，都会被提升到代码的头部，这就叫做变量提升。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a);</span><br><span class=\"line\">var a &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F;undefined</span><br><span class=\"line\">&#x2F;&#x2F;等同于</span><br><span class=\"line\">var a;</span><br><span class=\"line\">console.log(a);</span><br><span class=\"line\">a &#x3D; 1;</span><br></pre></td></tr></table></figure>\n\n<p>变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(b);</span><br><span class=\"line\">b &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F;Error:b is not defined</span><br></pre></td></tr></table></figure></li>\n<li><p>中文是合法的标识符，可以用作变量名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var 临时变量 &#x3D; 1；</span><br></pre></td></tr></table></figure></li>\n<li><p>多个if…else连在一起使用的时候，可以转为使用更方便的switch结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch (fruit)&#123;</span><br><span class=\"line\">  case &quot;banana&quot;:</span><br><span class=\"line\">  \t&#x2F;&#x2F;...</span><br><span class=\"line\">  \tbreak;</span><br><span class=\"line\">  case &quot;apple&quot;:</span><br><span class=\"line\">  \t&#x2F;&#x2F;...</span><br><span class=\"line\">  \tbreak;</span><br><span class=\"line\">  default:</span><br><span class=\"line\">  \t&#x2F;&#x2F;...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。</p>\n<p>switch语句部分和case语句部分，都可以使用表达式</p>\n<p>switch语句后面的表达式与case语句后面的表达式，在比较运算结果时，采用严格相等===，而不是相等运算==，意味着比较时不会发生类型转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">switch(x)&#123;</span><br><span class=\"line\">  case true:</span><br><span class=\"line\">  \tconsole.log(&#39;x发生类型转换‘);</span><br><span class=\"line\">  default:</span><br><span class=\"line\">  \tconsole.log(&#39;x没有发生类型转换‘);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; x没有发生类型转换</span><br></pre></td></tr></table></figure></li>\n<li><p>while循环、for循环可以使用break语句跳出循环</p>\n</li>\n<li><p>continue用语立即终止本轮循环，返回循环结构头部，开始下一轮循环</p>\n</li>\n<li><p>如果存在多重循环，不带参数的break和continue语句都只针对最内层循环</p>\n</li>\n<li><p>标签（label）：JS允许语句的前面有标签，相当于定位赋，用于跳转到程序的任意位置，格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label:</span><br><span class=\"line\">\tstatement</span><br></pre></td></tr></table></figure>\n\n<p>标签可以时任意的标识符，但不能是保留字</p>\n<p>标签通常和break、continue语句配合使用，跳出特定的循环：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top:</span><br><span class=\"line\">\tfor(var i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class=\"line\">      for(var j &#x3D; 0; j &lt; 3; j++)&#123;</span><br><span class=\"line\">        if(i &#x3D;&#x3D;&#x3D;1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">          break top;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的双重循环中，break后面跟了top标签（top不用加引号），满足条件时，直接跳出双层循环。如果不加标签，则只跳出内层循环，进入下一次外层循环。</p>\n<p>continue一样</p>\n</li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ul>\n<li><p>6中数据类型（es6又新增了第七中Symbol类型），数值、字符串、布尔值称为原始类型，对象称为合成类型，null、undefined特殊值</p>\n</li>\n<li><p>JS的所有数据，都可视为广义的对象，数组、函数，原始类型的数据</p>\n</li>\n<li><p>对象又分成3个子类：狭义的对象（object），数组（array），函数（function）</p>\n</li>\n<li><p>JS把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，体现了JS作为“函数式语言”的本质</p>\n</li>\n<li><p>JS有三种方法确定一个值的类型：</p>\n<p>typeof运算符</p>\n<p>instanceof运算符</p>\n<p>Object.prototype.toString方法</p>\n</li>\n<li><p>typeof null返回object，并不是说null的数据类型就是对象，本质上null是一个类似于undefined的特殊值。null表示空值，即该处的值为空；undefined表示“为定义”</p>\n</li>\n<li><p>空数组 []，空对象 {}对应的布尔值都是true</p>\n</li>\n</ul>\n<h3 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h3><ul>\n<li><p>NaN是number类型的一种特殊值，表示“非数字”（Not a Number)</p>\n</li>\n<li><p>isNaN方法判断一个值是否为NaN，空数组和只有一个数值成员的数组，is NaN返回false，原因是这些数组能被Number函数转成数值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNan([]) &#x2F;&#x2F;false</span><br><span class=\"line\">isNaN([123]) &#x2F;&#x2F;false</span><br><span class=\"line\">isNaN([&#39;123&#39;]) &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure></li>\n<li><p>parseInt()方法用于将字符串转为整数    。</p>\n<p>字符串转为整数是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&#39;12.34&#39;) &#x2F;&#x2F;12</span><br></pre></td></tr></table></figure>\n\n<p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&#39;abc&#39;) &#x2F;&#x2F;NaN</span><br><span class=\"line\">parseInt(&#39;+&#39;) &#x2F;&#x2F;NaN</span><br><span class=\"line\">parseInt(&#39;+1&#39;) &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<p>parseInt()方法还可以接受第二个参数（2到36之间），表示被解析到值的进制，返回该值对应的十进制数。第二个参数默认是10。</p>\n</li>\n<li><p>parseFloat()方法用于将一个字符串转为浮点数</p>\n<p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分</p>\n<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN</p>\n</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><ul>\n<li><p>如果要在单引号（或双引号）字符串的内部，使用单引号（或双引号），就必须在内部的单引号（或双引号）前面加上反斜杠，用来转义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;Did she say \\&#39;Hello\\&#39;?&#39;</span><br><span class=\"line\">&#x2F;&#x2F; &quot;Did she say &#39;Hello&#39;?&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>字符串默认只能写在一行内，分成多行将会报错</p>\n</li>\n<li><p>字符串可以被视为字符数组，可以使用数组的方括号运算符返回某个位置的字符，但仅此而已，无法修改和增删，只有将字符串显式转为数组后才能使用</p>\n</li>\n<li><p>Base64转码：</p>\n<p>btoa()：字符串或二进制值转为Base64编码</p>\n<p>atob()：Base64编码转为原来的编码</p>\n</li>\n</ul>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><ul>\n<li><p>对象三种声明方法：</p>\n<ol>\n<li>直接使用大括号{ }生成<code>var o1 = &#123;&#125;;</code></li>\n<li>用new命令生成一个Object对象的实例<code>var o2 = new Object();</code></li>\n<li>用Object.create方法生成<code>Object.create(Object.prototype);</code></li>\n</ol>\n<p>对象采用大括号表示导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>\n<p>为避免歧义，JS规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），不许在大括号前加上圆括号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123;foo:123&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><p>对象的所有键名都是字符串，加不加引号都可以，非字符串的键名会被转为字符串。但是如果键名不符合标识名的条件，也不是数字，则必须加上引号，否则报错。</p>\n</li>\n<li><p>JS的保留字可以不加引号当作键名</p>\n</li>\n<li><p>对象的每一个“键名”又称为“属性”，它的“键值“可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为”方法“，它可以像函数那样调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o &#x3D; &#123;</span><br><span class=\"line\">  p: function (x)&#123;</span><br><span class=\"line\">    return 2 * x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">o.p(1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>不同的变量名指向同一个对象</strong>，他们都是这个对象的引用，也就是说指向同一个内存地址，修改其中的一个变量，会影响到其他所有变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 &#x3D; &#123;&#125;;</span><br><span class=\"line\">var o2 &#x3D; o1;</span><br><span class=\"line\"></span><br><span class=\"line\">o1.a &#x3D; 1;</span><br><span class=\"line\">o2.a &#x2F;&#x2F; 1</span><br><span class=\"line\"></span><br><span class=\"line\">o2.b &#x3D; 2;</span><br><span class=\"line\">o1.b &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<p>如果取消某一个变量对原对象的引用，不会影响到另一个变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 &#x3D; &#123;&#125;;</span><br><span class=\"line\">var o2 &#x3D; o1;</span><br><span class=\"line\"></span><br><span class=\"line\">o1 &#x3D; 1;</span><br><span class=\"line\">o2 &#x2F;&#x2F; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种引用只局限于对象，对原始类型的数据则是传值引用，都是值的拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">var y &#x3D; x;</span><br><span class=\"line\"></span><br><span class=\"line\">x &#x3D; 2;</span><br><span class=\"line\">y &#x2F;&#x2F; 1</span><br><span class=\"line\">&#x2F;&#x2F; 当x的值发生变化后，y的值并未改变，表示y和x并不是指向同一个内存地址</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>读取对象属性</strong>有两种方法，使用点运算符，使用方括号运算符</p>\n<p>使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理</p>\n<p>数值键名不能使用点运算符，因为会被当成小数点，只能使用方括号运算符，且不用加引号</p>\n<p>方括号运算符内部可以使用表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o[&#39;hello&#39;+&#39;world&#39;]</span><br><span class=\"line\">o[3+3]</span><br></pre></td></tr></table></figure></li>\n<li><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o.p &#x3D; &#39;abc&#39;;</span><br><span class=\"line\">p[&#39;p&#39;] &#x3D; &#39;abc&#39;;</span><br></pre></td></tr></table></figure></li>\n<li><p>Object.keys方法查看一个对象本身的所有属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o &#x3D; &#123;</span><br><span class=\"line\">  key1: 1,</span><br><span class=\"line\">  key2: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.keys(o);</span><br><span class=\"line\">&#x2F;&#x2F; [&#39;key1&#39;,&#39;key2&#39;]</span><br></pre></td></tr></table></figure></li>\n<li><p>delete命令用于删除对象的属性，删除成功后返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete o.p</span><br></pre></td></tr></table></figure>\n\n<p>delete命令删除一个不存在的属性，不会报错，而且返回true</p>\n<p>delete删除存在且不得删除的属性，返回false</p>\n<p>delete职能删除对象本身的属性，无法删除继承的属性</p>\n</li>\n<li><p><strong>in运算符</strong>用于检查对象是否包含某个属性（检查的是键名，不是键值），包含返回true，否则返回false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o &#x3D; &#123; p:1 &#125;;</span><br><span class=\"line\">&#39;p&#39; in o &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<p>JS中，所有全局变量都是顶层对象（浏览器的顶层对象就是window对象）的属性，因此可以用in运算符判断一个全局变量是否存在</p>\n<p>in运算符不能识别对象继承的属性</p>\n</li>\n<li><p><strong>for…in循环</strong>用来遍历一个对象所有可便利（enumerable）的属性，会跳过不可遍历的属性</p>\n<p>它不仅遍历对象自身的属性，还遍历继承的属性</p>\n</li>\n</ul>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ul>\n<li><p>只要是数组，就一定有length属性。</p>\n<p>length属性是可写的</p>\n<p>如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值，其余的被自动删除</p>\n<p>如果人为设置length大雨当前元素个数，则数组成员数量会增加到这个值，新增的位置都是空位，读取新增的位置会返回undefined</p>\n</li>\n<li><p>由于数组本质上是对象，所以我们可以为数组添加属性，这不影响length属性的值</p>\n</li>\n<li><p>类似数组的对象（array-like object）：一个对象的所有键名都是正整数或零，并且有length属性</p>\n<p>“类似数组的对象”并不是数组，它不具备数组特有的方法，比如push方法</p>\n<p>”类似数组的对象“的根本特征，就是具有length属性，但这种length属性不是动态值，不会随着成员变化而变化</p>\n<p>典型的”类似数组的对象“是函数的arguments对象，大多数DOM元素集，还有字符串</p>\n</li>\n<li><p><strong>in运算符</strong>同样适用于数组，如果数组某个位置是空位，in运算符返回false</p>\n</li>\n<li><p><strong>for…in循环</strong>遍历的是对象的所有属性，数组是对象的一种，因此for…in循环也可以遍历数组的所有属性，包括数组的所有数字键和其他属性，因此不推荐用for…in遍历数组</p>\n</li>\n<li><p><strong>数组的空位</strong>：当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位。数组的空位不影响length属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, ,1];</span><br><span class=\"line\">a.length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>\n\n<p>数组的空位可读取，返回undefined</p>\n<p>使用delete命令删除一个数组成员，会形成空位，并且不影响length属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1,2,3];</span><br><span class=\"line\">delete a[1];</span><br><span class=\"line\"></span><br><span class=\"line\">a[1] &#x2F;&#x2F;undefined</span><br><span class=\"line\">a.length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure></li>\n<li><p>数组的某个位置是空位，和某个位置是undefined是不一样的。</p>\n<p>如果是空位，使用数组的forEach方法、for…in循环、Object.keys方法进行遍历，空位都会被跳过；</p>\n<p>如果是undefined，遍历不会被跳过。</p>\n<p>空位就是数组没有这个元素，所以不会被遍历到，而undefined表示数组有这个元素，值时undefined。</p>\n</li>\n</ul>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><ul>\n<li><p><strong>函数的三种声明方法</strong>：</p>\n<ol>\n<li><p>function命令声明的代码区块，就是一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function print(s)&#123;</span><br><span class=\"line\">  console.log(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>函数表达式：除了用function命令声明，还可以采用变量赋值的写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var print &#x3D; function(s)&#123;</span><br><span class=\"line\">  console.log(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式，因为赋值语句的等号右侧只能放表达式</p>\n<p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var print &#x3D; function x()&#123;</span><br><span class=\"line\">  console.log(typeof x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; Error</span><br><span class=\"line\">print() &#x2F;&#x2F;function</span><br></pre></td></tr></table></figure>\n\n<p>需要注意，函数表达式需要在语句的结尾加上“；”，表示语句结束。</p>\n</li>\n</ol>\n<p>这两种声明函数的方式，差别很细微，这里可以近似认为是等价的</p>\n<ol start=\"3\">\n<li><p>Function构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add &#x3D; new Function(</span><br><span class=\"line\">\t&#39;x&#39;,</span><br><span class=\"line\">\t&#39;y&#39;,</span><br><span class=\"line\">\t&#39;return x + y&#39;</span><br><span class=\"line\">);</span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">function add(x,y)&#123;</span><br><span class=\"line\">  return x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Function构造函数接受任意数量的参数，只有最后一个参数会被当作函数体，其他参数都是函数的参数；如果只有一个参数，该参数就是函数体</p>\n<p>这种声明函数的方式非常不直观，几乎无人使用</p>\n</li>\n</ol>\n<ul>\n<li><p>如果同一个函数被多次声明，后面的声明会覆盖前面的声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f()&#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() &#x2F;&#x2F; 2</span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>调用函数时，使用圆括号运算符</p>\n<p>函数体内部的return语句表示返回。JS引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。</p>\n<p>函数可以调用自身，这就是递归。</p>\n</li>\n<li><p><strong>第一等公民</strong>：JS语言将函数看作一种值，与其他值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。</p>\n<p>由于函数与其他数据类型地位平等，所以在JS中又称函数为第一等公民。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(x,y)&#123;</span><br><span class=\"line\">  return x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将函数赋值给一个变量</span><br><span class=\"line\">var operator &#x3D; add;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将函数作为参数和返回值</span><br><span class=\"line\">function a(op)&#123;</span><br><span class=\"line\">  return op;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(add)(1,1)</span><br><span class=\"line\">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>函数名的提升</strong>：JS引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">function f()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果采用赋值语句定义函数，JS就会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f();</span><br><span class=\"line\">var f &#x3D; function ()&#123;&#125;;</span><br><span class=\"line\">&#x2F;&#x2F; Error!</span><br></pre></td></tr></table></figure>\n\n<p>等同于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f;</span><br><span class=\"line\">f();</span><br><span class=\"line\">f &#x3D; function () &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码第二行，调用f时，f只是被声明了，还没有被赋值，等于undefined，所以会报错。</p>\n</li>\n<li><p><strong>不能再条件语句中声明函数</strong>：根据ES规范，不得在非函数的代码块中声明函数，最常见的就是if和try语句</p>\n</li>\n<li><p><strong>函数的属性和方法</strong>：</p>\n<ul>\n<li><p><em>name属性</em>，返回紧跟在function关键字之后的那个函数名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1()&#123;&#125;</span><br><span class=\"line\">f1.name &#x2F;&#x2F; &#39;f1&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">var f2 &#x3D; function ()&#123;&#125;;</span><br><span class=\"line\">f2.name &#x2F;&#x2F; &#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">var f3 &#x3D; function myName()&#123;&#125;;</span><br><span class=\"line\">f3.name &#x2F;&#x2F; &#39;myName&#39;</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）</p>\n</li>\n<li><p><em>length属性</em>，返回函数预期传入的参数个数，即函数定义之中的参数个数。不管调用时输入了多少个参数，只返回定义时的参数个数。</p>\n</li>\n<li><p><em>toString()方法</em>，返回函数的源码。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>函数作用域</strong></p>\n<p>作用域（scope）指的是变量存在的范围</p>\n<p>JS只有两种作用域：一种是全剧作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。</p>\n<p>在函数外部声明的变量就是<strong>全局变量</strong>，它可以在函数内部读取。</p>\n<p>在函数内部定义的变量就是<strong>局部变量</strong>，外部无法读取。</p>\n<ul>\n<li><strong>函数内部定义的变量，会在该作用域内覆盖同名全局变量</strong>：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">  var v &#x3D; 2;</span><br><span class=\"line\">  console.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; 2</span><br><span class=\"line\">v &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>函数内部的变量提升</strong>：</p>\n<p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>\n</li>\n<li><p><strong>函数本身的作用域</strong>：</p>\n<p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 1;</span><br><span class=\"line\">var x &#x3D; function ()&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  var a &#x3D; 2;</span><br><span class=\"line\">  x();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>\n\n<p>函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>\n<p>很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; function ()&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function y(f) &#123;</span><br><span class=\"line\">  var a &#x3D; 2;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">y(x)</span><br><span class=\"line\">&#x2F;&#x2F; Error: a is not defined</span><br></pre></td></tr></table></figure>\n\n<p>同样的，函数体内部声明的函数，作用域绑定函数体内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">  var x &#x3D; 1;</span><br><span class=\"line\">  function bar()&#123;</span><br><span class=\"line\">    console.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var x &#x3D; 2;</span><br><span class=\"line\">var f &#x3D; foo();</span><br><span class=\"line\">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>\n\n<p>这种机制构成了<strong>闭包</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>参数</strong>：ES5中，函数参数不是必需的，JS允许省略参数。</p>\n<ul>\n<li><p>```<br>function f(a){<br>  a = a || 1;<br>  return a;<br>}<br>// ||表示“或运算”，赋值语句的等号右边，预期是一个值，凡是预期为值的地方，都可以用表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ **传递方式**：</span><br><span class=\"line\"></span><br><span class=\"line\">  + 函数参数如果是**原始类型**的值（数值、字符串、布尔值），传递方式是**传值传递**。意味着，在函数体内修改参数值，不会影响到函数外部</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var p = 2;<br>  function f(p){</p>\n<pre><code>p = 3;\n</code></pre>\n<p>  }<br>  f(p);</p>\n<p>  p // 2</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  变量p是一个原始类型的值，传入函数f的方式是传值传递。因此在函数内部，p的值时原始值的拷贝，无论怎么修改，都不会影响到原始值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 如果函数参数是**复合类型**的值（数组、对象、其他函数），传递方式是**传址传递**。意味着，在函数内部修改参数，将会影响到原始值。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var obj = {p: 1};<br>  function f(o){</p>\n<pre><code>o.p = 2;\n</code></pre>\n<p>  }<br>  f(obj);</p>\n<p>  obj.p // 2</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，传入函数f的是对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。</span><br><span class=\"line\"></span><br><span class=\"line\">**注意**：如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var obj = [1,2,3];<br>  function f(o){</p>\n<pre><code>0 = [2,3,4];\n</code></pre>\n<p>  }<br>  f(obj);</p>\n<p>  obj // [1,2,3]</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这是因为，形式参数（o）与实际参数obj存在一个赋值关系</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  // 函数f内部<br>  o = obj;</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    上面代码中，对o的修改都会反映在obj身上。但是，如果对o赋予一个新的值，就等于切断了o与obj的联系，导致此后的修改都不会影响到obj。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var a = 1;<br>function f(p){<br>  window[p] = 2;<br>}<br>f(‘a’);</p>\n<p>a // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ **同名参数**：</span><br><span class=\"line\"></span><br><span class=\"line\">  如果有同名的参数，则取最后出现的那个值，即使最后的参数没有值或被省略，也是以其为准：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f(a,a){<br>  console.log(a);<br>}<br>f(1,2) // 2<br>f(1) // undefined</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ **arguments对象**：</span><br><span class=\"line\"></span><br><span class=\"line\">  arguments对象包含了函数运行时的所有参数，arguments[0是第一个参数，arguments[1]就是第二个，以此类推。这个对象只有在函数体内部可以使用。</span><br><span class=\"line\"></span><br><span class=\"line\">  **正常模式下**，arguments对象可以在运行时修改：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var f = function (a,b){<br>  arguments[0] = 3;<br>  arguments[1] = 2;<br>  return a + b;<br>}<br>f(1,1) //5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**严格模式下**，arguments对象是一个只读对象，修改它是无效的，但不会报错</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var f = function (a,b){<br>  ‘use strict’;<br>  arguments[0] = 3; // 无效<br>  arguments[1] = 2; // 无效<br>  return a + b;<br>}<br>f(1,1) // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    介绍数组时说过，arguments虽然很像数组，但是它时一个对象，是一个“类似数组的对象”。数组专有的方法，不能在arguments对象上直接使用。</span><br><span class=\"line\"></span><br><span class=\"line\">+ **闭包**：</span><br><span class=\"line\"></span><br><span class=\"line\">  JS的作用域机制，使得函数外部无法获取函数内部声明的变量。</span><br><span class=\"line\"></span><br><span class=\"line\">  但出于某种原因，需要得到函数内部的局部变量。正常情况下是办不到的，只有通过变通方法实现，就是在函数内部，再定义一个函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f1(){<br>var n = 999;<br>function f2(){<br>  console.log(n); // 999<br>}<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">函数f2声明在函数f1的内部，f1内部的所有局部变量，对f2可见。反之则不行。这是JS语言特有的“链式作用域”结构（chain scope），子对象会一级一级的向上寻找所有父对象的变量。</span><br><span class=\"line\"></span><br><span class=\"line\">既然f2可以读取f1的局部变量，那么只要把f2作为返回值，就可以在f1外部读取他的内部变量了</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f1(){<br>var n = 999;<br>function f2(){<br>  console.log(n);<br>}<br>return f2;<br>}<br>var result = f1();<br>result(); // 999</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">函数f1点返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1点内部变量了。</span><br><span class=\"line\"></span><br><span class=\"line\">**闭包**就是函数f2，即能够读取其他函数内部变量的函数。</span><br><span class=\"line\"></span><br><span class=\"line\">JS语言中，只有函数内部的字函数才能读取内部变量，因此可以把闭包加单理解成**“定义在一个函数内部的函数”**。在本质上，闭包就是将函数内部和函数外部链接起来的一座桥梁。</span><br><span class=\"line\"></span><br><span class=\"line\">**闭包的最大用处有两个**：1. 读取函数内部的变量。2. 让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function createIncrmenentor(start){<br>return function (){<br>  return start++;<br>};<br>}<br>var inc = createIncrementor(5);</p>\n</li>\n</ul>\n<p>inc() // 5<br>inc() // 6<br>inc() // 7</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">*上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境一直存在。所以，闭包可以看作是函数内部作用域的一个接口。*</span><br><span class=\"line\"></span><br><span class=\"line\">*为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也是种在内存中，不会再调用结束后，被垃圾回收机制回收。*</span><br><span class=\"line\"></span><br><span class=\"line\">**闭包的另一个用处，是封装对象的私有属性和私有方法。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function Person(name) {<br>  var _age;<br>  function setAge(n) {</p>\n<pre><code>_age = n;\n</code></pre>\n<p>  }<br>  function getAge() {</p>\n<pre><code>return _age;\n</code></pre>\n<p>  }</p>\n<p>  return {</p>\n<pre><code>name: name,\ngetAge: getAge,\nsetAge: setAge\n</code></pre>\n<p>  };<br>}</p>\n<p>var p1 = Person(‘张三’);<br>p1.setAge(25);<br>p1.getAge() // 25</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  **注意**，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</span><br><span class=\"line\"></span><br><span class=\"line\">+ **立即调用的函数表达式**</span><br><span class=\"line\"></span><br><span class=\"line\">  在JS中，一对圆括号（）是一种运算符，跟在函数名之后，表示调用该函数。比如，print（）就表示调用print函数。</span><br><span class=\"line\"></span><br><span class=\"line\">  有时，我们需要在定义函数之后，立即调用该函数。这时，闭不能在函数的定义之后加上圆括号，会产生语法错误：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function () { /* code */}();<br>// SyntaxError: Unexpected token (</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。同行首是一个对象的大括号，到底是表达式还是语句同理。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 语句<br>function f() {}<br>// 表达式<br>var f = function f() {}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">为避免解析上的歧义，JS引擎规定，如果function关键字出现在行首，一律解释称语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>(function (){ /* code <em>/ }());<br>// 或者<br>(function (){ /</em> code */ })();</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  以圆括号开头，引擎就会认为这个一个表达式，而不是函数定义语句，就避免了错误。这就叫做“立即调用的函数表达式”。</span><br><span class=\"line\"></span><br><span class=\"line\">  这两种写法最后的分号都是必须的。如果省略分号，遇到连着两个立即调用的函数表达式，可能就会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">## 运算符</span><br><span class=\"line\"></span><br><span class=\"line\">+ 加号运算符，拼接字符串和加法运算</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>1 + 1 // ‘2’<br>‘1’ + 1 // ‘11’<br>1 + ‘1’ // ‘11’</p>\n<p>1+1+1+1 // ‘4’<br>‘1’+1+1+1 // ‘1111’<br>1+’1’+1+1 // ‘1111’<br>1+1+’1’+1 // ‘211’<br>1+1+1+’1’ // ‘31’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">从左往右，能加法运算就加法运算，直到遇到字符，把之前的运算结果和字符拼接，字符之后全部为拼接。</span><br><span class=\"line\"></span><br><span class=\"line\">利用空字符串，将值转为字符串类型</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>x + ‘’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 余数运算符（%）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>12 % 5 // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">余数运算的运算结果的正负由第一个运算子的正负决定：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>-1 % 2 // -1<br>1 % -2 // 1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 自增运算符（++）、自减运算符（—)</span><br><span class=\"line\"></span><br><span class=\"line\">  自增／自减操作会修改原始变量</span><br><span class=\"line\"></span><br><span class=\"line\">  放在变量前，先自增／自减，再返回操作后的值；</span><br><span class=\"line\"></span><br><span class=\"line\">  放在变量后，先返回变量的值，再自增／自减</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var x = 1;<br>var y = 1;<br>x++ // 1;<br>++y // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 数值运算符（+）同样使用加号，但它是一元运算符（只需要一个操作数）。</span><br><span class=\"line\"></span><br><span class=\"line\">  数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>+true // 1<br>+[] // 0<br>+{} // NaN</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 赋值运算符，除了最常见的等号（&#x3D;），还有以下：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>x += y // 等同于 x = x + y<br>x -= y // 等同于 x = x - y<br>x *= y // 等同于 x = x * y<br>x /= y // 等同于 x = x / y<br>x %= y // 等同于 x = x % y<br>x &gt;&gt;= y // 等同于 x = x &gt;&gt; y<br>x &lt;&lt;= y // 等同于 x = x &lt;&lt; y<br>x &gt;&gt;&gt;= y // 等同于 x = x &gt;&gt;&gt; y<br>x &amp;= y // 等同于 x = x &amp; y<br>x |= y // 等同于 x = x | y<br>x ^= y // 等同于 x = x ^ y</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 比较运算符</span><br><span class=\"line\"></span><br><span class=\"line\">  如果两个运算子都是字符串，则按照字典顺序比较（实际上是比较Unicode码点）</span><br><span class=\"line\"></span><br><span class=\"line\">  否则，将两个运算子都转成数值，再进行比较（等同于先调用Number函数）</span><br><span class=\"line\"></span><br><span class=\"line\">+ &#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</span><br><span class=\"line\"></span><br><span class=\"line\">  相等运算符&#x3D;&#x3D;比较两个值是否相等，严格相等运算符&#x3D;&#x3D;&#x3D;比较它们是否为“同一个值”。</span><br><span class=\"line\"></span><br><span class=\"line\">  如果两个值不是同一类型，严格相等运算符&#x3D;&#x3D;&#x3D;直接返回 false，而相等运算符&#x3D;&#x3D;会将它们转化成同一类型，再用严格相等运算符进行比较</span><br><span class=\"line\"></span><br><span class=\"line\">+ &#x3D;&#x3D;&#x3D;严格相等运算符</span><br><span class=\"line\"></span><br><span class=\"line\">  + 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，不同就返回false。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  1 === 0x1 // true<br>  NaN === NaN // false NaN与任何值都不相等，包括自己</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 同一类型的复合类型的值（对象、数组、函数）比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  {} === {} // false<br>  [] === [] // false<br>  (function(){} === function(){}) // false</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是&#96;false&#96;。</span><br><span class=\"line\"></span><br><span class=\"line\">如果两个变量引用同一个对象，则它们相等。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var v1 = {};<br>  var v2 = v1;<br>  v1 === v2 // true</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ &#x3D;&#x3D;相等运算符</span><br><span class=\"line\"></span><br><span class=\"line\">  + 比较相同类型的数据时，与严格相等运算符完全一样</span><br><span class=\"line\"></span><br><span class=\"line\">  + 比较不同类型的数据时，相等运算符会先讲数据进行类型转换，然后再用严格相等运算符比较，转换规则如下：</span><br><span class=\"line\">    + 比较原始类型的数据时，会将数据转换成数值类型再进行比较</span><br><span class=\"line\"></span><br><span class=\"line\">    + 复合类型（对象、数组、函数）和原始类型的值比较时，复合类型转化成原始类型，再进行比较</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<pre><code>[1] == 1 // true\n// 等同于 Number([1]) == 1\n\n[1] == &#39;1&#39; // true\n// 等同于 String([1]) == Number(&#39;1&#39;)\n\n[1] == true // true\n// 等同于 Number([1]) == Number(true)\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 且运算符&amp;&amp;</span><br><span class=\"line\"></span><br><span class=\"line\">  运算规则：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>‘t’ &amp;&amp; ‘’ // “”<br>‘t’ &amp;&amp; ‘f’ // “f”<br>‘t’ &amp;&amp; (1 + 2) // 3<br>‘’ &amp;&amp; ‘f’ // “”<br>‘’ &amp;&amp; ‘’ // “”</p>\n<p>var x = 1;<br>(1 - 1) &amp;&amp; ( x += 1) // 0<br>x // 1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if语句中经常这样写：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>if(x &amp;&amp; y){<br>  /* code */<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  x &amp;&amp; y并不直接返回布尔值，而是if命令后面的判断条件预期应该是一个布尔值，JS会自动将其转为布尔值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 或运算符||</span><br><span class=\"line\"></span><br><span class=\"line\">  运算规则：如果第一个运算子的布尔值为&#96;true&#96;，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为&#96;false&#96;，则返回第二个运算子的值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ void运算符</span><br><span class=\"line\"></span><br><span class=\"line\">  void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>void 0 // undefined<br>void(0) // undefined</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">void运算符的主要作用是用于在超链接中插入代码，防止网页跳转。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 点击链接，但不跳转页面<br><a href=\"javascript:void\"></a></p>\n<p>// 新建窗口打开链接<br><a href=\"javascript:void window.open('http://example.com')\"></a></p>\n<p>// 提交表单，但不会跳转页面<br><a href=\"javascript:void(document.form.submit())\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 数据类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">JS是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</span><br><span class=\"line\"></span><br><span class=\"line\">虽然变量没有类型，但是数据本身和各种运算符是有类型的。如果运算符发现，数据的类型与预期不符，就会自动转换类型。</span><br><span class=\"line\"></span><br><span class=\"line\">### 强制转换</span><br><span class=\"line\"></span><br><span class=\"line\">强制转换主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或布尔值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ Number()函数，可以将任意类型的值转化成数值</span><br><span class=\"line\"></span><br><span class=\"line\">  1. 原始类型值（字符串，布尔值、undefined、null）</span><br><span class=\"line\"></span><br><span class=\"line\">     Number函数将字符串转为数值要比parseInt函数严格很多。只有有一个字符无法转成数值，整个字符串就会被转为NaN。而parseInt是逐个转换字符。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   // 数值：转换后还是原来的值<br>   Number(324) // 324</p>\n<p>   // 字符串：如果可以被解析为数值，则转换为相应的数值<br>   Number(‘324’) // 324</p>\n<p>   // 字符串：如果不可以被解析为数值，返回NaN<br>   Number(‘324abc’) // NaN</p>\n<p>   // 空字符串转为0<br>   Number(‘’) // 0</p>\n<p>   // 布尔值：true 转成1，false 转成0<br>   Number(true) // 1<br>   Number(false) // 0</p>\n<p>   // undefined：转成 NaN<br>   Number(undefined) // NaN</p>\n<p>   // null：转成0<br>   Number(null) // 0</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 复合类型值（对象、数组、函数）</span><br><span class=\"line\"></span><br><span class=\"line\">   简单的规则是，&#96;Number&#96;方法的参数是对象时，将返回&#96;NaN&#96;，**除非是包含单个数值的数组**。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   Number({a: 1}) // NaN<br>   Number([1, 2, 3]) // NaN<br>   Number([5]) // 5</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ String()函数，可以将任意类型的值转化成字符串。转换规则如下：</span><br><span class=\"line\"></span><br><span class=\"line\">  1. 原始类型值的转换规则</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   数值：转为相应的字符串。<br>   字符串：转换后还是原来的值。<br>   布尔值：true转为”true”，false转为”false”。<br>   undefined：转为”undefined”。<br>   null：转为”null”。</p>\n<p>   String(123) // “123”<br>   String(‘abc’) // “abc”<br>   String(true) // “true”<br>   String(undefined) // “undefined”<br>   String(null) // “null”</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 对象的转换规则</span><br><span class=\"line\"></span><br><span class=\"line\">   &#96;String&#96;方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   String({a: 1}) // “[object Object]”<br>   String([1, 2, 3]) // “1,2,3”</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ Boolean()函数，可以将任意类型的变量转为布尔值，除了以下六个值的转换结果为false，其他值全部是true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>undefined<br>null<br>-0<br>0或+0<br>NaN<br>‘’（空字符串）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 自动转换</span><br><span class=\"line\"></span><br><span class=\"line\">以下三种情况，JS会自动转换数据类型，转换时自动完成的，对用户不可见</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 1. 不同类型的数据互相运算<br>123 + ‘abc’ // “123abc”</p>\n</li>\n</ul>\n<p>// 2. 对非布尔值类型的数据求布尔值<br>if (‘abc’) {<br>  console.log(‘hello’)<br>}  // “hello”</p>\n<p>// 3. 对非数值类型的数据使用一元运算符（即“+”和“-”）</p>\n<ul>\n<li>{foo: ‘bar’} // NaN</li>\n</ul>\n<ul>\n<li>[1, 2, 3] // NaN<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用&#96;String&#96;函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。</span><br><span class=\"line\"></span><br><span class=\"line\">## 错误处理机制</span><br><span class=\"line\"></span><br><span class=\"line\">### Error对象</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript原生提供一个&#96;Error&#96;构造函数，所有抛出的错误都是这个构造函数的实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nvar err = new Error(‘出错了’);<br>err.message // “出错了”<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Error构造函数接受一个参数，表示错误提示，可以从实例等message属性读到这个参数。</span><br><span class=\"line\"></span><br><span class=\"line\">Error对象的实例必须有message属性。大多数JS引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但她们是非标准的，不是每种实现都有</span><br><span class=\"line\"></span><br><span class=\"line\">### JS的原声错误类型</span><br><span class=\"line\"></span><br><span class=\"line\">Error对象时最易班的错误类型。在它的基础上，JS还定义了其他6种错误：</span><br><span class=\"line\"></span><br><span class=\"line\">1. SyntaxError是解析代码时发生的语法错误</span><br><span class=\"line\">2. ReferenceError是引用一个不存在的变量时发生的错误或将一个值分配给无法分配的对象</span><br><span class=\"line\">3. RangeError</span><br><span class=\"line\">4. TypeError</span><br><span class=\"line\">5. URIError</span><br><span class=\"line\">6. EvalError</span><br><span class=\"line\"></span><br><span class=\"line\">### 自定义错误</span><br><span class=\"line\"></span><br><span class=\"line\">除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nfunction UserError(message) {<br> this.message = message || “默认信息”;<br> this.name = “UserError”;<br>}</li>\n</ul>\n<p>UserError.prototype = new Error();<br>UserError.prototype.constructor = UserError;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义的错误了。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>new UserError(“这是自定义的错误！”);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### throw语句</span><br><span class=\"line\"></span><br><span class=\"line\">throw语句的作用是中断程序执行，抛出一个意外或错误。它接受一个表达式作为参数们可以抛出各种值。</span><br><span class=\"line\"></span><br><span class=\"line\">JS引擎一旦遇到throw语句，就会停止执行后面的语句，并将throw语句的参数值，返回给用户。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>throw new Error(‘出错了！’);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### try…catch结构</span><br><span class=\"line\"></span><br><span class=\"line\">try…catch结构对错误进行处理</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>tru{<br>  throw new Error(‘出错了！’);<br>}catch(e){<br>  console.log(e.name + “:” + e.message);<br>  console.log(e.stack)<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">try代码块一抛出错误（上例用的是throw语句），js引擎就立即把代码的执行，转到catch代码块。catch接受一个参数，表示try代码块抛出的值。</span><br><span class=\"line\"></span><br><span class=\"line\">catch代码块中，还可以再抛出错误，甚至使用嵌套的try...catch结构。</span><br><span class=\"line\"></span><br><span class=\"line\"># 面向对象编程</span><br><span class=\"line\"></span><br><span class=\"line\">面向对象编程（Object Oriented Programming，OOP）是目前主流的编程范式。</span><br><span class=\"line\"></span><br><span class=\"line\">对象是一个容器，封装了属性（property）和方法（method）。</span><br><span class=\"line\"></span><br><span class=\"line\">## 构造函数</span><br><span class=\"line\"></span><br><span class=\"line\">典型的面向对象编程语言（C++，Java），存在“类”（class）的概念。所谓“类”就是对象的模版，对象就是“类”的实例。JS语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</span><br><span class=\"line\"></span><br><span class=\"line\">JS语言使用构造函数作为对象的模版。所谓“构造函数”，就是专门用来生成对象的函数。它提供模版，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。</span><br><span class=\"line\"></span><br><span class=\"line\">构造函数的写法就是一个普通的函数，但是有自己的特征和用法。为了和普通函数区别，构造函数名字的第一个字母通常大写：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function () {<br>  this.price = 1000;<br>};</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1. 函数体内部使用了this关键字，代表了所要生成的对象实例。</span><br><span class=\"line\">2. 生成对象的时候，必需用new命令。</span><br><span class=\"line\"></span><br><span class=\"line\">## new命令</span><br><span class=\"line\"></span><br><span class=\"line\">new命令的作用是，执行构造函数，返回一个对象实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function () {<br>  this.price = 1000;<br>};<br>var v = new Vehicle();<br>v.price // 1000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">new命令执行时，构造函数内部的this，就代表了新生成的实例对象。</span><br><span class=\"line\"></span><br><span class=\"line\">使用new命令时，根据需要，构造函数也可以接受参数：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function (p) {<br>  this.price = p;<br>};<br>var v = new Vehicle(500);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var v = new Vehicle();<br>var v = new Vehicle;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### new命令的原理</span><br><span class=\"line\"></span><br><span class=\"line\">使用new命令时，她后面的函数调用就不是正常的调用，而是依次执行下面的步骤：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 创建一个空对象，作为将要返回的对象实例</span><br><span class=\"line\">2. 将这个空对象的原型，指向构造函数的prototype属性</span><br><span class=\"line\">3. 将这个空对象赋值给函数内部的this关键字</span><br><span class=\"line\">4. 开始执行构造函数内部的代码</span><br><span class=\"line\"></span><br><span class=\"line\">构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造“为需要的样子。</span><br><span class=\"line\"></span><br><span class=\"line\">如果构造函数内部有return语句，而且return后面跟一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function () {<br>  this.price = 1000;<br>  return 1000;<br>};</p>\n<p>(new Vehicle()) === 1000<br>// false</p>\n<p>var Vehicle = function (){<br>  this.price = 1000;<br>  return { price: 2000 };<br>};</p>\n<p>(new Vehicle()).price<br>// 2000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。</span><br><span class=\"line\"></span><br><span class=\"line\">### 直接调用构造函数会发生什么？</span><br><span class=\"line\"></span><br><span class=\"line\">如果忘了使用new命令，直接调用构造函数会发生什么？</span><br><span class=\"line\"></span><br><span class=\"line\">这种情况下，构造函数就编程了普通函数，并不会生成实例对象。而且this这时代表全局对象，将造成一些意想不到的后果。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function () {<br>  this.price = 1000;<br>}</p>\n<p>var v = Vehicle();<br>v.price<br>// Uncaught TypeError: Cannot read property ‘price’ of undefined</p>\n<p>price<br>// 1000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">不使用new命令调用Vehicle构造函数时，price属性变成了全局变量，变量v变成了undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">### new.target</span><br><span class=\"line\"></span><br><span class=\"line\">函数内部可以使用new.target属性。如当前函数是new命令调用，new.target指向当前函数，否则为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用Object.create()创建实例对象</span><br><span class=\"line\"></span><br><span class=\"line\">构造函数作为模版，可以生成实例对象。但是，有时只能拿到实例对象，而该对象根本就不是由构造函数生成的。这时可以使用Object.create()方法，直接以某个实例对象作为模版，生成一个新的实例对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var person1 = {<br>  name: ‘张三’,<br>  age: 38,<br>  greeting: function() {<br>    console.log(‘Hi! I&#39;m ‘ + this.name + ‘.’);<br>  }<br>};</p>\n<p>var person2 = Object.create(person1);</p>\n<p>person2.name // 张三<br>person2.greeting() // Hi! I’m 张三.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，对象person1是person2的模版，后者继承了前者的属性和方法。</span><br><span class=\"line\"></span><br><span class=\"line\">## this关键字</span><br><span class=\"line\"></span><br><span class=\"line\">this总是返回一个对象，简单说就是返回属性或方法“当前”所在的对象:</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var person = {<br>  name : ‘Ethan’,<br>  describe: function () {<br>    return ‘姓名:’+this.name;<br>  }<br>};<br>person.describe()<br>// “姓名：Ethan”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">this.name表示describe方法所在的当前对象的name属性。调用person.describe方法时，describe方法所在的当前对象是person，所以就是调用person.name。</span><br><span class=\"line\"></span><br><span class=\"line\">**由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f() {<br>  return ‘姓名：’+ this.name;<br>}</p>\n<p>var A = {<br>  name: ‘张三’,<br>  describe: f<br>};</p>\n<p>var B = {<br>  name: ‘李四’,<br>  describe: f<br>};</p>\n<p>A.describe() // “姓名：张三”<br>B.describe() // “姓名：李四”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">只要函数被赋给另一个变量，this的指向就会变：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var A = {<br>  name: ‘张三’,<br>  describe: function () {<br>    return ‘姓名：’+ this.name;<br>  }<br>};</p>\n<p>var name = ‘李四’;<br>var f = A.describe;<br>f() // “姓名：李四”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<input type=\"text\" name=\"age\" size=3 onChange=\"validate(this, 18, 99);\">\n\n<script>\nfunction validate(obj, lowval, hival){\n  if ((obj.value < lowval) || (obj.value > hival))\n    console.log('Invalid Value!');\n}\n</script>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数。回调函数传入this，就代表传入当前对象（即文本框），然后就可以从this.value上面独到用户的输入值。</span><br><span class=\"line\"></span><br><span class=\"line\">JS语言中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是这个对象（环境）。</span><br><span class=\"line\"></span><br><span class=\"line\">如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f(){<br>  return this;<br>}<br>f() === window // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">可以近似地认为，this是所有函数运行时的一个隐藏参数，指向函数的运行环境。 </span><br><span class=\"line\"></span><br><span class=\"line\">### 使用场合</span><br><span class=\"line\"></span><br><span class=\"line\">this的使用可以分成以下几个场合。</span><br><span class=\"line\"></span><br><span class=\"line\">1. **全局环境**使用this，它指的就是顶层对象window。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   this === window // true</p>\n<p>   function f(){<br>     soncole.log(this === window); // true<br>   }<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。</span><br><span class=\"line\"></span><br><span class=\"line\">2. **构造函数**中的this，指的是实例对象。</span><br><span class=\"line\"></span><br><span class=\"line\">3. **对象的方法**</span><br><span class=\"line\"></span><br><span class=\"line\">   当A对象的方法被赋予B对象，该方法中的this就是从指向A对象变成了指向B对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   var obj = {<br>     foo: function(){<br>       console.log(this);<br>     }<br>   };<br>   obj.foo() // obj<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">obj.foo方法执行时，它内部的this指向obj。</span><br><span class=\"line\"></span><br><span class=\"line\">但是，只有这一种用法（直接在obj对象上调用foo方法），this指向obj；其他用法时，this都指向代码块当前所在对象（浏览器为window对象）。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   // 情况一<br>   (obj.foo = obj.foo)() // window</p>\n<p>   // 情况二<br>   (false || obj.foo)() // window</p>\n<p>   // 情况三<br>   (1, obj.foo)() // window<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，obj.foo先运算在执行，即使值根本没有变化，this也不再指向obj了。这时因为这时它就脱离了运行环境obj，而是在全局环境执行。</span><br><span class=\"line\"></span><br><span class=\"line\">可以这样理解，在JS引擎内部，obj和obj.foo储存在两个内存地址，假设时M1和M2。只有obj.foo（）这样调用时，是从M1调用M2，因此this指向obj。但是，上面三种情况，都是直接取出M2进行运算，然后在全局环境执行运算结果（还是M2），因此this指向全局环境。</span><br><span class=\"line\"></span><br><span class=\"line\">**如果某个方法位于多层对象的内部，这时this只是指向当前一层的对象，而不会继承更上面的层**：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   var a = {<br>     p: ‘Hello’,<br>     b: {<br>       m: function(){<br>         console.log(this.p);<br>       }<br>     }<br>   };</p>\n<p>   a.b.m() // undefined<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是直系那个a.b。</span><br><span class=\"line\"></span><br><span class=\"line\">### 使用注意</span><br><span class=\"line\"></span><br><span class=\"line\">1. 避免多层this</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   var o = {<br>     f1:function(){<br>       console.log(this);<br>       var f2 = function (){<br>         console.log(this);<br>       }();<br>     }<br>   }</p>\n<p>   o.f1()<br>   // Object<br>   // Window<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   第一层指向该对象，第二层指向全局对象</span><br><span class=\"line\"></span><br><span class=\"line\">   [**为什么第二层this指向全局对象window？**](http:&#x2F;&#x2F;blog.csdn.net&#x2F;u011457225&#x2F;article&#x2F;details&#x2F;73882551?utm_source&#x3D;itdadao&amp;utm_medium&#x3D;referral)</span><br><span class=\"line\"></span><br><span class=\"line\">   o.f1()表示调用o对象的f1方法，所以f1方法中的this指向o对象；而f1方法中的闭包（即f2函数）不属于任何对象，它不是一个对象的方法。非严格模式下，如果没有指定属于哪个对象，那么它就属于window对象。</span><br><span class=\"line\"></span><br><span class=\"line\">### 绑定this的方法</span><br><span class=\"line\"></span><br><span class=\"line\">JS提供了call、apply、bind三种方法，来切换／固定this 的指向。</span><br><span class=\"line\"></span><br><span class=\"line\">1. **function.prototype.call()**</span><br><span class=\"line\"></span><br><span class=\"line\">   作用：指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</span><br><span class=\"line\"></span><br><span class=\"line\">   call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。如果参数是一个原始值，那么这个原始值回自动转成对应的包装对象，然后传入call方法。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   var n = 123;<br>   var obj = { n: 456};</p>\n<p>   function a(){<br>     console.log(this.n);<br>   }</p>\n<p>   a.call() // 123<br>   a.call(null) // 123<br>   a.call(undefined) // 123<br>   a.call(window) // 123<br>   a.call(obj) // 456<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">call方法还可以接受多个参数，第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   func.call(thisValue,arg1,arg2,…)<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   function add(a,b){<br>     return a + b;<br>   }</p>\n<p>   add.call(this,1,2) // 3<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. **function.prototype.apply()**</span><br><span class=\"line\"></span><br><span class=\"line\">   apply方法等作用域call方法类似，也是改变this指向，然后在调用该函数。唯一的区别就是，他接受一个数组作为函数执行时的参数：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   func.apply(thisValue,[arg1,arg2,…])<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   function f(x,y){<br>     console.log(x+y);<br>   }<br>   f.call(null,1,1) // 2<br>   f.apply(null,[1,1]) // 2<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. **function.prototype.bind()**</span><br><span class=\"line\"></span><br><span class=\"line\">   apply／call方法不仅绑定函数执行时所在的对象，还会立即执行函数。</span><br><span class=\"line\"></span><br><span class=\"line\">   bind方法只用于将函数体内的this绑定到某个对象，然后返回一个新函数。</span><br><span class=\"line\"></span><br><span class=\"line\">## prototype 对象</span><br><span class=\"line\"></span><br><span class=\"line\">### 原型对象</span><br><span class=\"line\"></span><br><span class=\"line\">通过同一个构造函数创建的实例对象之间，无法共享属性，对系统资源造成浪费。</span><br><span class=\"line\"></span><br><span class=\"line\">**JS的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。null除外。**</span><br><span class=\"line\"></span><br><span class=\"line\">原型对象上的所有属性和方法，都能派生对象共享。这就是JS继承机制的基本设计。</span><br><span class=\"line\"></span><br><span class=\"line\">通过构造函数生成实例对象时，会自动为实例对象分配原型对象。**每一个构造函数都有一个prototype属性**，这个属性就是实例对象的原型对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>function Animal (name){<br>  this.name = name;<br>}</p>\n<p>Animal.prototype.color = ‘white’;</p>\n<p>var cat1 = new Animal(‘大毛’);<br>var cat2 = new Animal(‘二毛’);</p>\n<p>cat1.color // ‘white’<br>cat2.color // ‘white’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">构造函数Animal的prototype对象，就是实例对象cat1和cat2的原型对象。在原型对象上添加一个color属性。实例对象都能读取该属性。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+ 当实例对象本身没有某个属性或方法等时候，它会去原型对象寻找并读取这个属性火方法。</span><br><span class=\"line\">+ 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</span><br><span class=\"line\"></span><br><span class=\"line\">**原型对象的作用，就是定义所有实例对象共享的属性和方法。**</span><br><span class=\"line\"></span><br><span class=\"line\">### 原型链</span><br><span class=\"line\"></span><br><span class=\"line\">原型对象本身也是对象，又有自己的原型，所以形成一条原型链。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。</span><br><span class=\"line\"></span><br><span class=\"line\">如果一层层地上溯，所有对象的原型最终都可以上溯到&#96;Object.prototype&#96;，即Object构造函数的prototype属性指向的那个对象。&#96;Object.prototype&#96;对象的原型是没有任何属性和方法等&#96;null&#96;对象，而&#96;null&#96;对象没有自己的原型。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 原型链的作用是：读取对象的某个属性时，JS引擎线寻找对象本身的属性，如果找不到，就到它的原型去找，如果还找不到，就到原型的原型去找。如果知道最顶层的&#96;Object.prototype&#96;还是找不到，则返回undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">在原型链一级级向上寻找某个属性，对性能有影响。属性越在山层影响越大。如果寻找某个不存在的属性，会遍历整个原型链。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var MyArray = function (){};</p>\n<p>MyArray.prototype = new Array();<br>MyArray.prototype.constructor = MyArray;</p>\n<p>var mine = new MyArray();<br>mine.push(1,2,3);</p>\n<p>mine.length // 3<br>mine instanceof Array // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">instanceof运算符用来比较一个对象是否为某个构造函数的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">### constructor属性</span><br><span class=\"line\"></span><br><span class=\"line\">prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function P (){}</p>\n<p>P.prototype.constructor === p // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function P () {}<br>var p = new P();</p>\n<p>p.constructor<br>// function P() {}</p>\n<p>p.constructor === P.prototype.constructor<br>// true</p>\n<p>p.hasOwnProperty(‘constructor’)<br>//false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ **constructor属性的作用，是分辨原型对象到底属于哪个构造函数**</span><br><span class=\"line\"></span><br><span class=\"line\">+ 通过constructor属性，从实例新建另一个实例：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  function Constr() {}<br>  var x = new Constr();</p>\n<p>  var y = new x.constructor();<br>  y instanceof Constr // true<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这使得在实例方法中，调用自身的构造函数成为可能：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>  Constr.prototype.createCopy = function (){<br>    return new this.constructor();<br>  }<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 通过name属性，可以从实例得到构造函数的名称：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>  function Foo () {}<br>  var f = new Foo();<br>  f.constructor.name // “Foo”<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 修改原型对象时，一般要同时校正constructor属性的指向，否则会导致instanceof运算符失真。</span><br><span class=\"line\"></span><br><span class=\"line\">### instanceof运算符</span><br><span class=\"line\"></span><br><span class=\"line\">instanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>var n = new Vehicle();<br>v instanceof Vehicle // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">instanceof运算符左边时实例对象，右边是构造函数。它会检查右边构造函数的原型对象，是否在左边对象的原型链上。</span><br><span class=\"line\"></span><br><span class=\"line\">instanceof运算符只能用于对象，不适用原始类型的值。</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.getPrototypeOf()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.getPrototypeOf&#96;方法返回一个对象的原型。这时获取原型对象的标准方法。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 空对象的原型是Object.prototype<br>Object.getPrototypeOf({}) === Object.prototype<br>// true</p>\n<p>// 函数的原型是Function.prototype<br>function f() {}<br>Object.getPrototypeOf(f) === Function.prototype<br>// true</p>\n<p>// f 为 F 的实例对象，则 f 的原型是 F.prototype<br>var f = new F();<br>Object.getPrototypeOf(f) === F.prototype<br>// true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### Object.setPrototypeOf()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.setPrototypeOf&#96;方法可以为现有对象设置原型，返回一个新对象。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.setPrototypeOf&#96;方法接受两个参数，第一个是现有对象，第二个是原型对象。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;new&#96;命令通过构造函数新建实例对象，实质就是将实例对象的原型，指向构造函数的&#96;prototype&#96;属性，然后在实例对象上执行构造函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var F = function () {<br>  this.foo = ‘bar’;<br>};</p>\n<p>var f = new F();</p>\n<p>// 等同于<br>var f = Object.setPrototypeOf({}, F.prototype);<br>F.call(f);<br>f.foo // “bar”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### Object.create()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.create&#96;方法是为了满足只能通过实例对象生成另一个实例对象的需求。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.create&#96;方法接受一个对象作为**第一个参数**，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">老式浏览器如果不支持Object.create方法，可以用下面代码部署：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>if (typeof Object.create !== ‘function’){<br>  Object.create = function (obj){<br>    function F(){}<br>    F.prototype = obj;<br>    return new F()<br>  };<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ Object.create方法参数不能为空，或者不是对象，否则会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 如果想生成一个不继承任何属性的对象，可以将Object.create的参数设为null。</span><br><span class=\"line\"></span><br><span class=\"line\">+ Object.create方法生成的新对象，动态继承原型。在原型上添加或修改任何方法，会立刻反应在新对象之上。</span><br><span class=\"line\"></span><br><span class=\"line\">+ Object.create方法还接受**第二个参数**。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var obj = Object.create({}, {<br>    p1: {<br>      value: 123,<br>      enumerable: true,<br>      configurable: true,<br>      writable: true,<br>    },<br>    p2: {<br>      value: ‘abc’,<br>      enumerable: true,<br>      configurable: true,<br>      writable: true,<br>    }<br>  });</p>\n<p>  // 等同于<br>  var obj = Object.create({});<br>  obj.p1 = 123;<br>  obj.p2 = ‘abc’;<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ Object.create方法生成的对象，继承了它原型对象的构造函数。</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.prototype.isPrototypeOf()</span><br><span class=\"line\"></span><br><span class=\"line\">对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>var o1 = {};<br>var o2 = Object.create(o1);<br>var o3 = Object.create(o2);</p>\n<p>o2.isPrototypeOf(o3); // true<br>o1.isPrototypeOf(o3); // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**只要某个对象处在原型链上，isPrototypeOf都返回true。**</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.prototype.\\_\\_proto\\_\\_</span><br><span class=\"line\"></span><br><span class=\"line\">\\_\\_proto\\_\\_属性（前后各两个下划线）可以改写某个对象的原型对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var obj = {};<br>var p = {};</p>\n<p>obj.<strong>proto</strong> = p;<br>Object.getPrototypeOf(obj) === p // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 获取原型对象方法等比较</span><br><span class=\"line\"></span><br><span class=\"line\">\\_\\_proto\\_\\_属性指向当前对象的原型对象，即构造函数的prototype属性：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var obj = new Object();</p>\n<p>obj.<strong>proto</strong> === Object.prototype<br>//true<br>obj.<strong>proto</strong> === obj.constructor.prototype<br>//true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">因此，获取实例对象obj的原型对象，有三种方法：</span><br><span class=\"line\"></span><br><span class=\"line\">+ obj.\\_\\_proto\\_\\_</span><br><span class=\"line\">+ obj.constructor.prototype</span><br><span class=\"line\">+ Object.getPrototypeOf(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">前两种方法都不可靠，推荐第三种。</span><br><span class=\"line\"></span><br><span class=\"line\">## Object对象与继承</span><br><span class=\"line\"></span><br><span class=\"line\">通过原型链，对象的属性分成两种：自身的属性和继承的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.getOwnPropertyNames()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.getOwnPropertyNames&#96;方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。</span><br><span class=\"line\"></span><br><span class=\"line\">对象本身的属性之中，有的是可以枚举的，有的不可枚举。&#96;Object.getOwnPropertyNames&#96;方法返回包括不可枚举的所有键名。如果只获取可枚举属性，请使用&#96;Object.keys&#96;方法。</span><br><span class=\"line\"></span><br><span class=\"line\">### Obejct.prototype.hasOnwProperty()</span><br><span class=\"line\"></span><br><span class=\"line\">对象实例的&#96;hasOwnProperty&#96;方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Date.hasOwnProperty(‘length’)<br>// true</p>\n<p>Date.hasOwnProperty(‘toString’)<br>// false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">hasOwnProperty方法是JS中唯一一个处理对象属性时，不会遍历原型链的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">### in运算符和for...in循环</span><br><span class=\"line\"></span><br><span class=\"line\">+ in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</span><br><span class=\"line\">+ 获得对象的所有可枚举属性（不管是自身的还是继承的），可以使用for...in循环。</span><br><span class=\"line\"></span><br><span class=\"line\">### 对象的拷贝</span><br><span class=\"line\"></span><br><span class=\"line\">如果要拷贝一个对象，需要做到下面两件事情。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 确保拷贝后的对象，与原对象具有同样的prototype原型对象。</span><br><span class=\"line\">+ 确保拷贝后的对象，与原对象具有同样的属性。</span><br><span class=\"line\"></span><br><span class=\"line\"># 标准库</span><br><span class=\"line\"></span><br><span class=\"line\">## Object对象</span><br><span class=\"line\"></span><br><span class=\"line\">JS原生提供Object对象（起首的O大写），所有其他对象都继承自这个对象。</span><br><span class=\"line\"></span><br><span class=\"line\">Object本身也是一个构造函数，可以直接通过它来生成新对象。</span><br><span class=\"line\"></span><br><span class=\"line\">Object作为构造函数使用时，可以接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。</span><br><span class=\"line\"></span><br><span class=\"line\">## Array对象</span><br><span class=\"line\"></span><br><span class=\"line\">Array是JS的内置对象，同时也是一个构造函数，可以用它生成新的数组。</span><br><span class=\"line\"></span><br><span class=\"line\">## 包装对象</span><br><span class=\"line\"></span><br><span class=\"line\">所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var v1 = new Number(123);<br>var v2 = new String(‘abc’);<br>var v3 = new Boolean(true);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Number(123) // 123<br>String(‘abc’) // “abc”<br>Boolean(true) // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">总之，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。</span><br><span class=\"line\"></span><br><span class=\"line\">## Math对象</span><br><span class=\"line\"></span><br><span class=\"line\">Math是JS的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。</span><br><span class=\"line\"></span><br><span class=\"line\">## Date对象</span><br><span class=\"line\"></span><br><span class=\"line\">Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。</span><br><span class=\"line\"></span><br><span class=\"line\">Date对象也可以作为构造函数使用。使用new命令，会返回一个Date对象的实例。如果不加参数，生成的就是代表当前时间的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性描述对象</span><br><span class=\"line\"></span><br><span class=\"line\">JS提供了一个内部数据结构，用来描述一个对象的属性的行为，控制它的行为。这被称为“属性描述对象“（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</span><br><span class=\"line\"></span><br><span class=\"line\">下面是属性描述对象的一个实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>{<br>  value:123,<br>  writable:false,<br>  enumerable:true,<br>  configurable:false,<br>  get:undefined,<br>  set:undefined<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">属性描述对象提供6个元属性：</span><br><span class=\"line\"></span><br><span class=\"line\">1. value</span><br><span class=\"line\"></span><br><span class=\"line\">   value存放该属性的属性值，默认为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">2. writable</span><br><span class=\"line\"></span><br><span class=\"line\">   writable存放一个布尔值，表示属性值（value）是否可改变，默认为true。</span><br><span class=\"line\"></span><br><span class=\"line\">3. enumerable</span><br><span class=\"line\"></span><br><span class=\"line\">   enumerable存放一个布尔值，表示该属性是否可枚举，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。</span><br><span class=\"line\"></span><br><span class=\"line\">4. configurable</span><br><span class=\"line\"></span><br><span class=\"line\">   configurable存放一个布尔值，表示“可配置性”，默认为true。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。</span><br><span class=\"line\"></span><br><span class=\"line\">5. get</span><br><span class=\"line\"></span><br><span class=\"line\">   get存放一个函数，表示该属性的取值函数（getter），默认undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">6. set</span><br><span class=\"line\"></span><br><span class=\"line\">   set存放一个函数，表示该属性的存值函数（setter），默认为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.getOwnPropertyDescriptor()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.getOwnPropertyDescriptor&#96;方法可以读出对象自身属性的属性描述对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = { p : ‘a’ };</p>\n<p>Object.getOwnPropertyDescriptor(o,’p’)<br>// Object { value: “a”,<br>//   writable: true,<br>//   enumerable: true,<br>//   configurable: true<br>// }</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### Object.defineProperty(),Object.defineProperties()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.defineProperty()&#96;方法允许通过定义属性描述对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Object.defineProperty(object,propertyName,attributesObject)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#96;Object.defineProperty&#96;方法接受三个参数，第一个是属性所在的对象，第二个是属性名（它应该是一个字符串），第三个是属性的描述对象。比如新建一个o对象，并定义它的p属性，写法如下：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.defineProperty({},’p’,{<br>  value:123,<br>  writable:false,<br>  enumerable:true,<br>  configurable:false<br>})<br>o.p<br>// 123<br>o.p = 246;<br>o.p<br>// 123<br>// 因为writable为false，所以无法改变该属性的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果属性已经存在，&#96;Object.defineProperty&#96;方法相当于更新该属性的属性描述对象。</span><br><span class=\"line\"></span><br><span class=\"line\">需要注意的是，Object.defineProperty方法和后面的Object.defineProperties方法，都有性能损耗，会拖慢执行速度，不宜大量使用。</span><br><span class=\"line\"></span><br><span class=\"line\">如果一次性定义或修改多个属性，可以使用&#96;Object.defineProperties&#96;方法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.defineProperties({},{<br>  p1: { value: 123, enumerable: true },<br>  p2: { value: ‘abc’, enumerable: true },<br>  p3: { get: function(){ return this.p1 + this.p2 },<br>      enumerable:true,<br>      configurable:true<br>  }<br>});</p>\n<p>o.p1 // 123<br>o.p2 // “abc”<br>o.p3 // “123abc”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码的p3属性，定义了取值函数get。**这时需要注意的是，一旦定义了取值函数get（或存值函数set），就不能将writable设为true，或者同时定义value属性，会报错。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = {};</p>\n<p>Object.defineProperty(o,’p’,{<br>  value:123,<br>  get: function (){ return 456; }<br>});<br>// TypeError: Invalid property.<br>// A property cannot both have accessors and be writable or have a value,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 元属性</span><br><span class=\"line\"></span><br><span class=\"line\">#### 可枚举性（enumerable）</span><br><span class=\"line\"></span><br><span class=\"line\">只有可枚举的属性，才会被for...in循环遍历，同时还规定原生继承的属性都是不可枚举的。</span><br><span class=\"line\"></span><br><span class=\"line\">可枚举性涌来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会渠道该属性。</span><br><span class=\"line\"></span><br><span class=\"line\">+ for…in循环</span><br><span class=\"line\">+ Object.keys方法</span><br><span class=\"line\">+ JSON.stringify方法</span><br><span class=\"line\"></span><br><span class=\"line\">基本上，JS原生提供的属性都是不可枚举的，用户自定义的属性都是可枚举的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 可配置性（configurable）</span><br><span class=\"line\"></span><br><span class=\"line\">可配置性决定了是否可以修改属性描述对象。也就是说，当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。</span><br><span class=\"line\"></span><br><span class=\"line\">需要注意的是，writable只有在从false改为true会报错，从true改为false则是允许的。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.defineProperty({},’p’,{<br>  writable: true,<br>  configurable: false<br>});</p>\n<p>Object.defineProperty(o,’p’,{writable: false})<br>// 修改成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">至于value，只要writable和configurable有一个为true，就允许改动。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o1 = Object.defineProperty({}, ‘p’, {<br>  value: 1,<br>  writable: true,<br>  configurable: false<br>});</p>\n<p>Object.defineProperty(o1,’p’, {value: 2})<br>// 修改成功</p>\n<p>var o2 = Object.defineProperty({}, ‘p’, {<br>  value: 1,<br>  writable: false,<br>  configurable: true<br>});</p>\n<p>Object.defineProperty(o2,’p’, {value: 2})<br>// 修改成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">configurable为false时，直接对该属性赋值，不报错，但不会成功。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.defineProperty({},’p’,{<br>  value: 1,<br>  configurable: false<br>});</p>\n<p>o.p = 2;<br>o.p // 1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，o对象的p属性是不可配置的，对他赋值是不会生效的。</span><br><span class=\"line\"></span><br><span class=\"line\">可配置性决定了一个变量是否可以被删除。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.definePropertyies({},{<br>  p1: { value: 1, configurable: true },<br>  p2: { value: 2, configurable: false}<br>});</p>\n<p>delete o.p1 // true<br>delete o.p2 // false</p>\n<p>o.p1 // undefined<br>o.p2 // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 可写性（writable）</span><br><span class=\"line\"></span><br><span class=\"line\">可写性决定了属性的值是否可以被改变。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = {};<br>Object.defineProperty(o,’a’,{<br>  value: 37,<br>  writable:false<br>});</p>\n<p>o.a // 37<br>o.a = 25;<br>o.a // 37</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">正常模式下，对可写性为false的属性赋值不会报错，只会默默失败。但是严格模式下会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">关于可写性，还有一种特殊情况。就是如果原型对象的某个属性的可写性为false，那么派生对象将无法自定义这个属性。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var proto = Object.defineProperty({},’foo’,{<br>  value: ‘a’,<br>  writable: false<br>});</p>\n<p>var o = Object.create(proto);</p>\n<p>o.foo = ‘b’;<br>o.foo // ‘a’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">规避这个情况的方法，就是通过覆盖属性描述对象，绕过这个限制，原因是这种情况下，原型链会被完全忽视。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Object.defineProperty(o,’foo’,{<br>  value:’b’<br>});<br>o.foo // ‘b’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 存取器（accessor）</span><br><span class=\"line\"></span><br><span class=\"line\">除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用set命令；取值函数称为getter，使用get命令。</span><br><span class=\"line\"></span><br><span class=\"line\">存取器提供的是虚拟属性，即该属性的值不失时机存在的，而是每次读取时计算生成的。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = {<br>  get p(){<br>    return ‘getter’;<br>  },<br>  set p(value){<br>    console.log(‘setter:’ + value);<br>  }<br>};</p>\n<p>o.p // “getter”<br>o.p = 123 // “setter: 123”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，o对象内部的get和set命令，分别定义了p属性的取值函数和存值函数。定义了这两个函数之后，对p属性取值时，取值函数会自动调用；对p属性赋值时，存值函数会自动调用。</span><br><span class=\"line\"></span><br><span class=\"line\">取值函数getter不能接受参数，存值函数setter只能接受一个参数（即属性的值）。</span><br><span class=\"line\"></span><br><span class=\"line\">对象也不能有和与之函数同名的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">存取器也可以通过Object.defineProperty定义：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var d = new Date();<br>Object.definedProperty(d,’month’,{<br>  get: function (){<br>    return d.getMonth();<br>  },<br>  set: function (v){<br>    d.setMonth(v);<br>  }<br>});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**利用存取器，可以实现数据对象与DOM对象的双向绑定。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Object.defineProperty(user,’name’,{<br>  get: function(){<br>    return document.getElementById(‘foo’).value<br>  },<br>  set: function(newValue){<br>    document.getElementById(‘foo’).value = newValue<br>  },<br>  configurable: true<br>})</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码，将DOM对象foo与数据对象user的name属性，实现了绑定。两者之中只要有一个对象发生变化，就能在另一个对象上实时反映出来。</span><br><span class=\"line\"></span><br><span class=\"line\"># 语法专题</span><br><span class=\"line\"></span><br><span class=\"line\">## 单线程模型</span><br><span class=\"line\"></span><br><span class=\"line\">### 含义</span><br><span class=\"line\"></span><br><span class=\"line\">单线程模型指的是，JS值在一个线程上运行。也就是说，JS同时只能执行一个任务，其他任务都必须在后面排队等待。</span><br><span class=\"line\"></span><br><span class=\"line\">JS只在一个线程上运行，不代表JS引擎只有一个线程。JS有多个线程。</span><br><span class=\"line\"></span><br><span class=\"line\">### 消息队列</span><br><span class=\"line\"></span><br><span class=\"line\">JS运行时，除了一个运行线程，JS还提供一个消息队列，里面是各种需要当前程序处理的消息。新的消息进入队列时，会自动排在队列尾端。</span><br><span class=\"line\"></span><br><span class=\"line\">运行线程只要发现消息队列不为空，就会取出排在第一位的消息，执行它对应的回调函数。等执行完，再取出排在第二位的消息，不断循环，直到消息队列变空为止。</span><br><span class=\"line\"></span><br><span class=\"line\">进入消息队列的消息，必须有对应的回调函数。否则这个消息就会遗失。</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout会在指定时间向消息队列添加一条消息。如果消息队列之中，此时没有其他消息，这条消息会立即得到处理；否则，这条消息会不得不等到其他消息处理完，才会得到处理。因此，&#96;setTimeout&#96;指定的执行时间，只是一个最早可能发生的时间，并不能保证一定会在那个时间发生。</span><br><span class=\"line\"></span><br><span class=\"line\">### Event Loop</span><br><span class=\"line\"></span><br><span class=\"line\">用来一轮又一轮的处理消息队列之中的消息，即执行对应的回调函数的内部循环机制。</span><br><span class=\"line\"></span><br><span class=\"line\">常见的JS任务：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 执行JS代码</span><br><span class=\"line\">+ 对用户的输入（鼠标点击、键盘输入等等）做出反应</span><br><span class=\"line\">+ 处理异步网络请求</span><br><span class=\"line\"></span><br><span class=\"line\">所有任务可以分成两种，一种是同步任务，另一种是异步任务。</span><br><span class=\"line\"></span><br><span class=\"line\">同步任务指的是，在JavaScript执行进程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入JavaScript执行进程、而进入“任务队列”（task queue）的任务，只有“任务队列”通知主进程，某个异步任务可以执行了，该任务（采用回调函数的形式）才会进入JavaScript进程执行。</span><br><span class=\"line\"></span><br><span class=\"line\">以Ajax操作为例，它可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着Ajax操作返回结果，再往下执行；如果是异步任务，该任务直接进入“任务队列”，JavaScript进程跳过Ajax操作，直接往下执行，等到Ajax操作有了结果，JavaScript进程再执行对应的回调函数。</span><br><span class=\"line\"></span><br><span class=\"line\">## 定时器</span><br><span class=\"line\"></span><br><span class=\"line\">JS提供定时执行代码的功能，叫做定时器（timer），主要由&#96;setTimeout()&#96;和&#96;setInterval()&#96;这两个函数来完成。它们向任务队列添加定时任务。</span><br><span class=\"line\"></span><br><span class=\"line\">### setTimeout()</span><br><span class=\"line\"></span><br><span class=\"line\">用来指定某个函数或某段代码，在多少毫秒之后执行。</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout函数接受两个参数，第一个参数&#96;fund|code&#96;是将要推迟执行的函数名或者一段代码，第二个参数&#96;delay&#96;是推迟执行的毫秒数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>console.log(1);<br>setTimeout(‘console.log(2)’,1000);<br>console.log(3);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**注意**，推迟执行的代码必须以字符串的形式放入setTimeout，因为引擎内部使用eval函数，将字符串转为代码。如果推迟执行的是函数，则可以直接将函数名放入setTimeout。</span><br><span class=\"line\"></span><br><span class=\"line\">一方面eval函数有安全顾虑，另一方面为了便于引擎优化代码，setTimeout方法一般总是采用匿名函数的形式：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f(){<br>  console.log(2);<br>}</p>\n<p>setTimeout(f,1000);</p>\n<p>// 或者</p>\n<p>setTimeout(function () {<br>  console.log(2)<br>},1000)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### setInterval()</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</span><br><span class=\"line\"></span><br><span class=\"line\">### clearTimeout()，clearInterval()</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数值传入clearTimeout和clearInterval函数，就可以取消对应的定时器。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var id1 = setTimeout(f,1000);<br>var id2 = setInterval(f,1000);</p>\n<p>clearTimeout(id1);<br>clearInterval(id2);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 运行机制</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;setTimeout&#96;和&#96;setInterval&#96;的运行机制是，将指定的代码移出本次执行，等到下一轮 Event Loop 时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮 Event Loop 时重新判断。</span><br><span class=\"line\"></span><br><span class=\"line\">## Promise对象</span><br><span class=\"line\"></span><br><span class=\"line\">### JS的异步执行</span><br><span class=\"line\"></span><br><span class=\"line\">#### 回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">回调函数是异步编程最基本的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">假定有两个函数f1和f2，后者必须等到前者执行完成才能执行。这时可以考虑改写f1，把f2写成f1的回调函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f1(callback){<br>  // f1 的代码</p>\n<p>  // f1 执行完成后，调用回调函数<br>  callback();<br>}</p>\n<p>f1(f2);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个人物只能指定一个回调函数。</span><br><span class=\"line\"></span><br><span class=\"line\">#### Promise对象</span><br><span class=\"line\"></span><br><span class=\"line\">Promise对象是CommonJS工作组提出的一种规范，目的是为异步操作提供统一接口。</span><br><span class=\"line\"></span><br><span class=\"line\">它是一个对象。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。</span><br><span class=\"line\"></span><br><span class=\"line\">它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以蚕蛹同步操作的流程。这个Promise对象有一个then方法，允许指定回调函数，在异步任务完成后调用。</span><br><span class=\"line\"></span><br><span class=\"line\">比如，异步操作f1返回一个Promise对象，它的回调函数f2写法如下：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>(new Promise(f1)).then(f2);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### Promise接口</span><br><span class=\"line\"></span><br><span class=\"line\">Promise接口的基本思想是，异步任务返回一个Promise对象。</span><br><span class=\"line\"></span><br><span class=\"line\">Promise对象只三种状态：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 异步操作“未完成”（pending）</span><br><span class=\"line\">+ 异步操作“已完成”（resolved）</span><br><span class=\"line\">+ 异步操作“失败”（rejected）</span><br><span class=\"line\"></span><br><span class=\"line\">三种状态只有两种变化方式：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 异步操作从“未完成”到“已完成”</span><br><span class=\"line\">+ 异步操作从“未完成”到“失败”</span><br><span class=\"line\"></span><br><span class=\"line\">因此，Promise对象的最终结果只有两种：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 异步操作成功，Promise对象传回一个值，状态变为resolved。</span><br><span class=\"line\">+ 异步操作失败，Promise对象抛出一个错误，状态变为rejected。</span><br><span class=\"line\"></span><br><span class=\"line\">Promise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时的回调函数，第二个时异步操作失败时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// po是一个Promise对象<br>po.then(<br>    console.log,<br>    console.error<br>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">then方法可以链式使用：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>po<br>    .then(step1)<br>    .then(step2)<br>    .then(step3)<br>    .then(<br>        console.log,<br>        console.error<br>    );</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，po的状态一旦变为resolved，就一次调用后面每一个then指定的回调函数，每一步都必须等到前一步完成，才会执行。</span><br><span class=\"line\"></span><br><span class=\"line\">Promise对象的错误有传递性。</span><br><span class=\"line\"></span><br><span class=\"line\">#### Promise对象的生成</span><br><span class=\"line\"></span><br><span class=\"line\">ES6提供了原生的Promise构造函数，用来生成Promise实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var promise = new Promise(function(resolve,reject){<br>  // 异步操作的代码</p>\n<p>  if(/* 异步操作成功 */){<br>    resolve(value);<br>  }else{<br>    reject(error);<br>  }<br>});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们时两个函数，由JS引擎提供，不用自己部署。</span><br><span class=\"line\"></span><br><span class=\"line\">## 严格模式</span><br><span class=\"line\"></span><br><span class=\"line\">进入“严格模式”的标志，是一行字符串&#96;use strict&#96;。</span><br><span class=\"line\"></span><br><span class=\"line\">1. 针对整个脚本文件</span><br><span class=\"line\"></span><br><span class=\"line\">   将&#96;use strict&#96;放在脚本文件第一行，整个脚本都将以“严格模式”运行。</span><br><span class=\"line\"></span><br><span class=\"line\">2. 针对单个函数</span><br><span class=\"line\"></span><br><span class=\"line\">   &#96;use strict&#96;放在函数体的第一行，整个函数以“严格模式”运行。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 脚本文件的变通写法</span><br><span class=\"line\"></span><br><span class=\"line\">   两个不同模式的脚本合并成一个文件，如果严格模式的脚本在前，则合并后的脚本都是“严格模式”；如果正常模式的脚本在前，则合并后的脚本都是“正常模式”。总之，这两种合并后的结果都是不正确的。</span><br><span class=\"line\"></span><br><span class=\"line\">   正确的做法是，使用前面第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   (function(){<br>     ‘use strict’;<br>     // some code here<br>   })();<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   ​</span><br><span class=\"line\"></span><br><span class=\"line\"># DOM模型</span><br><span class=\"line\"></span><br><span class=\"line\">DOM是JS操作网页的接口，它的作用是将网页转为一个JS对象，从而可以用脚本进行各种操作。</span><br><span class=\"line\"></span><br><span class=\"line\">## 事件模型</span><br><span class=\"line\"></span><br><span class=\"line\">### 事件的传播</span><br><span class=\"line\"></span><br><span class=\"line\">#### 传播的三个阶段</span><br><span class=\"line\"></span><br><span class=\"line\">当一个事件发生以后，它会在不同的DOM节点之间传播（propagation）。这种传播分成三个阶段：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一阶段：从window对象传导到目标节点，称为“捕获阶段”。</span><br><span class=\"line\">+ 第二阶段：从目标节点上触发，称为“目标阶段”。</span><br><span class=\"line\">+ 第三阶段：从目标节点传导回window对象，称为“冒泡阶段”。</span><br><span class=\"line\"></span><br><span class=\"line\">这三种阶段的传播模型，会使得一个事件在多个节点上触发。比如，假设点击&#96;&lt;div&gt;&#96;之中嵌套一个&#96;&lt;p&gt;&#96;节点：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<div>\n    <p>Click Me</p>\n</div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果对这两个节点的click事件都设定监听函数，则click事件会被触发四次：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 捕获阶段：事件从&#96;&lt;div&gt;&#96;向&#96;&lt;p&gt;&#96;传播时，触发&#96;&lt;div&gt;&#96;的&#96;click&#96;事件；</span><br><span class=\"line\">+ 目标阶段：事件从&#96;&lt;div&gt;&#96;到达&#96;&lt;p&gt;&#96;时，触发&#96;&lt;p&gt;&#96;的&#96;click&#96;事件；</span><br><span class=\"line\">+ 目标阶段：事件离开&#96;&lt;p&gt;&#96;时，触发&#96;&lt;p&gt;&#96;的&#96;click&#96;事件；</span><br><span class=\"line\">+ 冒泡阶段：事件从&#96;&lt;p&gt;&#96;传回&#96;&lt;div&gt;&#96;时，再次触发&#96;&lt;div&gt;&#96;的&#96;click&#96;事件。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 事件的代理</span><br><span class=\"line\"></span><br><span class=\"line\">由于事件会在冒泡阶段向上传播的父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。</span><br><span class=\"line\"></span><br><span class=\"line\">如果希望事件到某个节点为止，不再传播，可以使用时间对象的&#96;stopPropagation&#96;方法。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;stopPropagation&#96;方法只会阻止当前监听函数的传播，不会阻止节点上的其他click事件的监听函数。如果想要不再触发那些监听函数，可以使用stopImmediatePropagation方法。</span><br><span class=\"line\"></span><br><span class=\"line\">### Event对象</span><br><span class=\"line\"></span><br><span class=\"line\">事件发生以后，会生成一个事件对象，**作为参数传给监听函数**。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.currentTarget</span><br><span class=\"line\"></span><br><span class=\"line\">currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。作为比较，target属性返回事件发生的节点。如果监听函数在捕获阶段和冒泡阶段触发，那么这两个属性返回的值是不一样的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.target</span><br><span class=\"line\"></span><br><span class=\"line\">target属性返回触发事件的那个节点，即事件最初发生的节点。如果监听函数不在该即诶单触发，那么它与currentTarget属性返回的值是不一样的。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nfunction hide(e){\n  console.log(this === e.target);\n  e.target.style.visibility = \"hidden\";\n}\n\n<p>// HTML代码为<br>// <p id=\"para\">Hello <em>World</em></p><br>para.addEventListener(‘click’,hide,false);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，如果在para节点的em子节点上面点击，则e.target指向em子节点，导致em子节点（即World部分）会不可见，且输出false。</span><br><span class=\"line\"></span><br><span class=\"line\">**事件的触发，和事件的监听不是一个概念**，比如上面代码中，点击em节点，click事件是在em节点触发的，然后按照事件传播模型从顶层window节点开始向下捕获，然后再从目标节点em节点向上冒泡，在冒泡阶段，p节点上监听了click事件，那么会执行p节点的监听函数，但此时event.target指向的是触发click事件的em节点，虽然监听函数是在p节点上执行的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.preventDefault()</span><br><span class=\"line\"></span><br><span class=\"line\">preventDefault方法取消浏览器对当前事件的默认行为。该方法生效的前提是，事件的cancelable属性为true。</span><br><span class=\"line\"></span><br><span class=\"line\">该方法不会阻止事件的进一步传播。只要在事件的传播过程中（捕获阶段、目标阶段、冒泡阶段皆可），使用了preventDefault方法，该事件的默认方法就不会执行。</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.stopPropagation()</span><br><span class=\"line\"></span><br><span class=\"line\">stopPropagation方法阻止事件在DOM中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上新定义的事件监听函数。</span><br><span class=\"line\"></span><br><span class=\"line\">**stopPropagation既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止事件目标阶段。**</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.stopImmediatePropagation()</span><br><span class=\"line\"></span><br><span class=\"line\">stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用。</span><br><span class=\"line\"></span><br><span class=\"line\">如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序一次调用。只要其中一个监听函数调用了stopImmediatePropagation方法，其他监听函数就不会再执行了。</span><br><span class=\"line\"></span><br><span class=\"line\"># 浏览器环境</span><br><span class=\"line\"></span><br><span class=\"line\">## 概述</span><br><span class=\"line\"></span><br><span class=\"line\">### JS代码嵌入网页的方法</span><br><span class=\"line\"></span><br><span class=\"line\">#### script标签：代码嵌入网页</span><br><span class=\"line\"></span><br><span class=\"line\">#### script标签：加载外部脚本</span><br><span class=\"line\"></span><br><span class=\"line\">#### 事件属性</span><br><span class=\"line\"></span><br><span class=\"line\">某些HTML元素的事件属性（比如onclic和onmouseover），可以写入JS代码。当指定事件发生时，就会调用这些代码。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div onclick=\"alert('Hello')\"></div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的事件属性代码只有一个语句。如果有多个语句，用分号分隔即可。</span><br><span class=\"line\"></span><br><span class=\"line\">#### URL协议</span><br><span class=\"line\"></span><br><span class=\"line\">URL支持&#96;javascript:&#96;协议，调用这个URL时，就会执行JS代码。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a href=\"javascript:alert('Hello')\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### script标签</span><br><span class=\"line\"></span><br><span class=\"line\">#### 工作原理</span><br><span class=\"line\"></span><br><span class=\"line\">正常的网页加载流程是这样的：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 浏览器一边下载HTML网页，一边开始解析</span><br><span class=\"line\">+ 解析过程中，发现&#96;&lt;script&gt;&#96;标签</span><br><span class=\"line\">+ 暂停解析，网页渲染的控制权转交给JavaScript引擎</span><br><span class=\"line\">+ 如果&#96;&lt;script&gt;&#96;标签引用了外部脚本，就下载该脚本，否则就直接执行</span><br><span class=\"line\">+ 执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页</span><br><span class=\"line\"></span><br><span class=\"line\">### 浏览器的组成</span><br><span class=\"line\"></span><br><span class=\"line\">浏览器的核心是两部分：渲染引擎和JavaScript解释器（又称JavaScript引擎）。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 渲染引擎</span><br><span class=\"line\"></span><br><span class=\"line\">渲染引擎处理网页，通常分成四个阶段：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 解析代码：HTML代码解析为DOM，CSS代码解析为CSSOM（CSS Object Model）</span><br><span class=\"line\">+ 对象合成：将DOM和CSSOM合成一个渲染树</span><br><span class=\"line\">+ 布局：计算出渲染树的布局（layout）</span><br><span class=\"line\">+ 绘制：将渲染树绘制到屏幕</span><br><span class=\"line\"></span><br><span class=\"line\">以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。</span><br><span class=\"line\"></span><br><span class=\"line\">#### JavaScript引擎</span><br><span class=\"line\"></span><br><span class=\"line\">JS引擎的主要作用是，读取网页中的JS代码，对其处理后运行。</span><br><span class=\"line\"></span><br><span class=\"line\">## window对象</span><br><span class=\"line\"></span><br><span class=\"line\">### window对象</span><br><span class=\"line\"></span><br><span class=\"line\">在浏览器中，window对象指当前的浏览器窗口。它也是所有对象的顶层对象。</span><br><span class=\"line\"></span><br><span class=\"line\">JS规定，浏览器环境的所有全局变量，都是window对象的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">### history对象</span><br><span class=\"line\"></span><br><span class=\"line\">浏览器窗口有一个history对象，用来保存浏览历史。</span><br><span class=\"line\"></span><br><span class=\"line\">### Cookie</span><br><span class=\"line\"></span><br><span class=\"line\">Cookie时服务器保存在浏览器的一小段文本信息，每个Cookie的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。</span><br><span class=\"line\"></span><br><span class=\"line\">### Web Storage：浏览器端数据储存机制</span><br><span class=\"line\"></span><br><span class=\"line\">这个API的作用是，使得网页可以在浏览器端储存数据。它分成两类：sessionStorage和localStorage。</span><br><span class=\"line\"></span><br><span class=\"line\">sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；localStorage保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">每个域名的存储上限视浏览器而定。Chrome是2.5MB，Firefox和Opera是5MB，IE是10MB。</span><br><span class=\"line\"></span><br><span class=\"line\">另外，与Cookie一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 存入／读取数据</span><br><span class=\"line\"></span><br><span class=\"line\">存入数据使用setItem方法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nsessionStorage.setItem(\"key\",\"value\");\nlocalStorage.setItem(\"key\",\"value\");\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">读取数据使用getItem方法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nvar valueSession = sessionStorage.getItem(\"key\");\nvar valueLocal = localStorage.getItem(\"key\");\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 清除数据</span><br><span class=\"line\"></span><br><span class=\"line\">removeItem方法用于清除某个键名对应的数据。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nsessionStorage.removeItem('key');\nlocalStorage.removeItem('key');\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">clear方法用于清除所有保存的数据。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nsessionStorage.clear();\nlocalStorage.clear();\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 同源政策</span><br><span class=\"line\"></span><br><span class=\"line\">### 含义</span><br><span class=\"line\"></span><br><span class=\"line\">1995年，同源政策由Netscape公司引入浏览器。</span><br><span class=\"line\"></span><br><span class=\"line\">最初，它的含义是指，A网页设置的Cookie，B网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 协议相同</span><br><span class=\"line\">+ 域名相同</span><br><span class=\"line\">+ 端口相同</span><br><span class=\"line\"></span><br><span class=\"line\">## AJAX</span><br><span class=\"line\"></span><br><span class=\"line\">浏览器与服务器之间，采用HTTP协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会想服务器发出HTTP请求。</span><br><span class=\"line\"></span><br><span class=\"line\">AJAX包括以下几个步骤：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 创建AJAX对象</span><br><span class=\"line\">2. 发出HTTP请求</span><br><span class=\"line\">3. 接受服务器传回的数据</span><br><span class=\"line\">4. 更新网页数据</span><br><span class=\"line\"></span><br><span class=\"line\">概括起来就是一句话，AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nvar xhr = new XMLHttpRequest();\n\n<p>// 指定通信过程中状态改变时的回调函数<br>xhr.onreadtstatechange = function(){<br>    // 通信成功时，状态值为4<br>  if(xhr.readyState === 4){<br>    if(xhr.status === 200){<br>      console.log(xhr.resonseText);<br>    }else{<br>      console.log(xhr.statusText);<br>    }<br>  }<br>}</p>\n<p>xhr.onerror = function (e){<br>  console.log(xhr.statusText);<br>}</p>\n<p>// open方式用于指定HTTP动词、请求的网址、是否异步<br>xhr.open(‘GET’,’/endpoint’,true);</p>\n<p>// 发送HTTP请求<br>xhr.send(null);</p>\n<pre><code>\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h1><h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><ul>\n<li><p>凡是JavaScript语言中预期为值的地方，都可以使用表达式。</p>\n</li>\n<li><p>使用var重新声明一个已经存在的变量是无效的，但是如果第二次声明的同时还附了值，则会覆盖掉前面的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">var x;</span><br><span class=\"line\">x &#x2F;&#x2F; 1</span><br><span class=\"line\"></span><br><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">var x &#x3D; 2;</span><br><span class=\"line\">x &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li>\n<li><p>JavaScript引擎的工作方式是，现解析代码，获取所有被声明的变量，然后再一行一行的运行。这造成的结果就是所有的变量声明语句，都会被提升到代码的头部，这就叫做变量提升。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a);</span><br><span class=\"line\">var a &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F;undefined</span><br><span class=\"line\">&#x2F;&#x2F;等同于</span><br><span class=\"line\">var a;</span><br><span class=\"line\">console.log(a);</span><br><span class=\"line\">a &#x3D; 1;</span><br></pre></td></tr></table></figure>\n\n<p>变量提升只对var命令声明的变量有效，如果一个变量不是用var命令声明的，就不会发生变量提升。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(b);</span><br><span class=\"line\">b &#x3D; 1;</span><br><span class=\"line\">&#x2F;&#x2F;Error:b is not defined</span><br></pre></td></tr></table></figure></li>\n<li><p>中文是合法的标识符，可以用作变量名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var 临时变量 &#x3D; 1；</span><br></pre></td></tr></table></figure></li>\n<li><p>多个if…else连在一起使用的时候，可以转为使用更方便的switch结构</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">switch (fruit)&#123;</span><br><span class=\"line\">  case &quot;banana&quot;:</span><br><span class=\"line\">  \t&#x2F;&#x2F;...</span><br><span class=\"line\">  \tbreak;</span><br><span class=\"line\">  case &quot;apple&quot;:</span><br><span class=\"line\">  \t&#x2F;&#x2F;...</span><br><span class=\"line\">  \tbreak;</span><br><span class=\"line\">  default:</span><br><span class=\"line\">  \t&#x2F;&#x2F;...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个case代码块内部的break语句不能少，否则会接下去执行下一个case代码块，而不是跳出switch结构。</p>\n<p>switch语句部分和case语句部分，都可以使用表达式</p>\n<p>switch语句后面的表达式与case语句后面的表达式，在比较运算结果时，采用严格相等===，而不是相等运算==，意味着比较时不会发生类型转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">switch(x)&#123;</span><br><span class=\"line\">  case true:</span><br><span class=\"line\">  \tconsole.log(&#39;x发生类型转换‘);</span><br><span class=\"line\">  default:</span><br><span class=\"line\">  \tconsole.log(&#39;x没有发生类型转换‘);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; x没有发生类型转换</span><br></pre></td></tr></table></figure></li>\n<li><p>while循环、for循环可以使用break语句跳出循环</p>\n</li>\n<li><p>continue用语立即终止本轮循环，返回循环结构头部，开始下一轮循环</p>\n</li>\n<li><p>如果存在多重循环，不带参数的break和continue语句都只针对最内层循环</p>\n</li>\n<li><p>标签（label）：JS允许语句的前面有标签，相当于定位赋，用于跳转到程序的任意位置，格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label:</span><br><span class=\"line\">\tstatement</span><br></pre></td></tr></table></figure>\n\n<p>标签可以时任意的标识符，但不能是保留字</p>\n<p>标签通常和break、continue语句配合使用，跳出特定的循环：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top:</span><br><span class=\"line\">\tfor(var i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class=\"line\">      for(var j &#x3D; 0; j &lt; 3; j++)&#123;</span><br><span class=\"line\">        if(i &#x3D;&#x3D;&#x3D;1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">          break top;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的双重循环中，break后面跟了top标签（top不用加引号），满足条件时，直接跳出双层循环。如果不加标签，则只跳出内层循环，进入下一次外层循环。</p>\n<p>continue一样</p>\n</li>\n</ul>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><ul>\n<li><p>6中数据类型（es6又新增了第七中Symbol类型），数值、字符串、布尔值称为原始类型，对象称为合成类型，null、undefined特殊值</p>\n</li>\n<li><p>JS的所有数据，都可视为广义的对象，数组、函数，原始类型的数据</p>\n</li>\n<li><p>对象又分成3个子类：狭义的对象（object），数组（array），函数（function）</p>\n</li>\n<li><p>JS把函数当成一种数据类型，可以像其他类型的数据一样，进行赋值和传递，体现了JS作为“函数式语言”的本质</p>\n</li>\n<li><p>JS有三种方法确定一个值的类型：</p>\n<p>typeof运算符</p>\n<p>instanceof运算符</p>\n<p>Object.prototype.toString方法</p>\n</li>\n<li><p>typeof null返回object，并不是说null的数据类型就是对象，本质上null是一个类似于undefined的特殊值。null表示空值，即该处的值为空；undefined表示“为定义”</p>\n</li>\n<li><p>空数组 []，空对象 {}对应的布尔值都是true</p>\n</li>\n</ul>\n<h3 id=\"数值\"><a href=\"#数值\" class=\"headerlink\" title=\"数值\"></a>数值</h3><ul>\n<li><p>NaN是number类型的一种特殊值，表示“非数字”（Not a Number)</p>\n</li>\n<li><p>isNaN方法判断一个值是否为NaN，空数组和只有一个数值成员的数组，is NaN返回false，原因是这些数组能被Number函数转成数值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isNan([]) &#x2F;&#x2F;false</span><br><span class=\"line\">isNaN([123]) &#x2F;&#x2F;false</span><br><span class=\"line\">isNaN([&#39;123&#39;]) &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure></li>\n<li><p>parseInt()方法用于将字符串转为整数    。</p>\n<p>字符串转为整数是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&#39;12.34&#39;) &#x2F;&#x2F;12</span><br></pre></td></tr></table></figure>\n\n<p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parseInt(&#39;abc&#39;) &#x2F;&#x2F;NaN</span><br><span class=\"line\">parseInt(&#39;+&#39;) &#x2F;&#x2F;NaN</span><br><span class=\"line\">parseInt(&#39;+1&#39;) &#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<p>parseInt()方法还可以接受第二个参数（2到36之间），表示被解析到值的进制，返回该值对应的十进制数。第二个参数默认是10。</p>\n</li>\n<li><p>parseFloat()方法用于将一个字符串转为浮点数</p>\n<p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分</p>\n<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回NaN</p>\n</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><ul>\n<li><p>如果要在单引号（或双引号）字符串的内部，使用单引号（或双引号），就必须在内部的单引号（或双引号）前面加上反斜杠，用来转义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;Did she say \\&#39;Hello\\&#39;?&#39;</span><br><span class=\"line\">&#x2F;&#x2F; &quot;Did she say &#39;Hello&#39;?&quot;</span><br></pre></td></tr></table></figure></li>\n<li><p>字符串默认只能写在一行内，分成多行将会报错</p>\n</li>\n<li><p>字符串可以被视为字符数组，可以使用数组的方括号运算符返回某个位置的字符，但仅此而已，无法修改和增删，只有将字符串显式转为数组后才能使用</p>\n</li>\n<li><p>Base64转码：</p>\n<p>btoa()：字符串或二进制值转为Base64编码</p>\n<p>atob()：Base64编码转为原来的编码</p>\n</li>\n</ul>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><ul>\n<li><p>对象三种声明方法：</p>\n<ol>\n<li>直接使用大括号{ }生成<code>var o1 = &#123;&#125;;</code></li>\n<li>用new命令生成一个Object对象的实例<code>var o2 = new Object();</code></li>\n<li>用Object.create方法生成<code>Object.create(Object.prototype);</code></li>\n</ol>\n<p>对象采用大括号表示导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>\n<p>为避免歧义，JS规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），不许在大括号前加上圆括号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&#123;foo:123&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<ul>\n<li><p>对象的所有键名都是字符串，加不加引号都可以，非字符串的键名会被转为字符串。但是如果键名不符合标识名的条件，也不是数字，则必须加上引号，否则报错。</p>\n</li>\n<li><p>JS的保留字可以不加引号当作键名</p>\n</li>\n<li><p>对象的每一个“键名”又称为“属性”，它的“键值“可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为”方法“，它可以像函数那样调用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o &#x3D; &#123;</span><br><span class=\"line\">  p: function (x)&#123;</span><br><span class=\"line\">    return 2 * x;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">o.p(1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>不同的变量名指向同一个对象</strong>，他们都是这个对象的引用，也就是说指向同一个内存地址，修改其中的一个变量，会影响到其他所有变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 &#x3D; &#123;&#125;;</span><br><span class=\"line\">var o2 &#x3D; o1;</span><br><span class=\"line\"></span><br><span class=\"line\">o1.a &#x3D; 1;</span><br><span class=\"line\">o2.a &#x2F;&#x2F; 1</span><br><span class=\"line\"></span><br><span class=\"line\">o2.b &#x3D; 2;</span><br><span class=\"line\">o1.b &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>\n\n<p>如果取消某一个变量对原对象的引用，不会影响到另一个变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 &#x3D; &#123;&#125;;</span><br><span class=\"line\">var o2 &#x3D; o1;</span><br><span class=\"line\"></span><br><span class=\"line\">o1 &#x3D; 1;</span><br><span class=\"line\">o2 &#x2F;&#x2F; &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种引用只局限于对象，对原始类型的数据则是传值引用，都是值的拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; 1;</span><br><span class=\"line\">var y &#x3D; x;</span><br><span class=\"line\"></span><br><span class=\"line\">x &#x3D; 2;</span><br><span class=\"line\">y &#x2F;&#x2F; 1</span><br><span class=\"line\">&#x2F;&#x2F; 当x的值发生变化后，y的值并未改变，表示y和x并不是指向同一个内存地址</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>读取对象属性</strong>有两种方法，使用点运算符，使用方括号运算符</p>\n<p>使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理</p>\n<p>数值键名不能使用点运算符，因为会被当成小数点，只能使用方括号运算符，且不用加引号</p>\n<p>方括号运算符内部可以使用表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o[&#39;hello&#39;+&#39;world&#39;]</span><br><span class=\"line\">o[3+3]</span><br></pre></td></tr></table></figure></li>\n<li><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o.p &#x3D; &#39;abc&#39;;</span><br><span class=\"line\">p[&#39;p&#39;] &#x3D; &#39;abc&#39;;</span><br></pre></td></tr></table></figure></li>\n<li><p>Object.keys方法查看一个对象本身的所有属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o &#x3D; &#123;</span><br><span class=\"line\">  key1: 1,</span><br><span class=\"line\">  key2: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Object.keys(o);</span><br><span class=\"line\">&#x2F;&#x2F; [&#39;key1&#39;,&#39;key2&#39;]</span><br></pre></td></tr></table></figure></li>\n<li><p>delete命令用于删除对象的属性，删除成功后返回true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">delete o.p</span><br></pre></td></tr></table></figure>\n\n<p>delete命令删除一个不存在的属性，不会报错，而且返回true</p>\n<p>delete删除存在且不得删除的属性，返回false</p>\n<p>delete职能删除对象本身的属性，无法删除继承的属性</p>\n</li>\n<li><p><strong>in运算符</strong>用于检查对象是否包含某个属性（检查的是键名，不是键值），包含返回true，否则返回false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o &#x3D; &#123; p:1 &#125;;</span><br><span class=\"line\">&#39;p&#39; in o &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<p>JS中，所有全局变量都是顶层对象（浏览器的顶层对象就是window对象）的属性，因此可以用in运算符判断一个全局变量是否存在</p>\n<p>in运算符不能识别对象继承的属性</p>\n</li>\n<li><p><strong>for…in循环</strong>用来遍历一个对象所有可便利（enumerable）的属性，会跳过不可遍历的属性</p>\n<p>它不仅遍历对象自身的属性，还遍历继承的属性</p>\n</li>\n</ul>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ul>\n<li><p>只要是数组，就一定有length属性。</p>\n<p>length属性是可写的</p>\n<p>如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值，其余的被自动删除</p>\n<p>如果人为设置length大雨当前元素个数，则数组成员数量会增加到这个值，新增的位置都是空位，读取新增的位置会返回undefined</p>\n</li>\n<li><p>由于数组本质上是对象，所以我们可以为数组添加属性，这不影响length属性的值</p>\n</li>\n<li><p>类似数组的对象（array-like object）：一个对象的所有键名都是正整数或零，并且有length属性</p>\n<p>“类似数组的对象”并不是数组，它不具备数组特有的方法，比如push方法</p>\n<p>”类似数组的对象“的根本特征，就是具有length属性，但这种length属性不是动态值，不会随着成员变化而变化</p>\n<p>典型的”类似数组的对象“是函数的arguments对象，大多数DOM元素集，还有字符串</p>\n</li>\n<li><p><strong>in运算符</strong>同样适用于数组，如果数组某个位置是空位，in运算符返回false</p>\n</li>\n<li><p><strong>for…in循环</strong>遍历的是对象的所有属性，数组是对象的一种，因此for…in循环也可以遍历数组的所有属性，包括数组的所有数字键和其他属性，因此不推荐用for…in遍历数组</p>\n</li>\n<li><p><strong>数组的空位</strong>：当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位。数组的空位不影响length属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1, ,1];</span><br><span class=\"line\">a.length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>\n\n<p>数组的空位可读取，返回undefined</p>\n<p>使用delete命令删除一个数组成员，会形成空位，并且不影响length属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; [1,2,3];</span><br><span class=\"line\">delete a[1];</span><br><span class=\"line\"></span><br><span class=\"line\">a[1] &#x2F;&#x2F;undefined</span><br><span class=\"line\">a.length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure></li>\n<li><p>数组的某个位置是空位，和某个位置是undefined是不一样的。</p>\n<p>如果是空位，使用数组的forEach方法、for…in循环、Object.keys方法进行遍历，空位都会被跳过；</p>\n<p>如果是undefined，遍历不会被跳过。</p>\n<p>空位就是数组没有这个元素，所以不会被遍历到，而undefined表示数组有这个元素，值时undefined。</p>\n</li>\n</ul>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><ul>\n<li><p><strong>函数的三种声明方法</strong>：</p>\n<ol>\n<li><p>function命令声明的代码区块，就是一个函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function print(s)&#123;</span><br><span class=\"line\">  console.log(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>函数表达式：除了用function命令声明，还可以采用变量赋值的写法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var print &#x3D; function(s)&#123;</span><br><span class=\"line\">  console.log(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式，因为赋值语句的等号右侧只能放表达式</p>\n<p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var print &#x3D; function x()&#123;</span><br><span class=\"line\">  console.log(typeof x);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">x &#x2F;&#x2F; Error</span><br><span class=\"line\">print() &#x2F;&#x2F;function</span><br></pre></td></tr></table></figure>\n\n<p>需要注意，函数表达式需要在语句的结尾加上“；”，表示语句结束。</p>\n</li>\n</ol>\n<p>这两种声明函数的方式，差别很细微，这里可以近似认为是等价的</p>\n<ol start=\"3\">\n<li><p>Function构造函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var add &#x3D; new Function(</span><br><span class=\"line\">\t&#39;x&#39;,</span><br><span class=\"line\">\t&#39;y&#39;,</span><br><span class=\"line\">\t&#39;return x + y&#39;</span><br><span class=\"line\">);</span><br><span class=\"line\">&#x2F;&#x2F; 等同于</span><br><span class=\"line\">function add(x,y)&#123;</span><br><span class=\"line\">  return x + y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Function构造函数接受任意数量的参数，只有最后一个参数会被当作函数体，其他参数都是函数的参数；如果只有一个参数，该参数就是函数体</p>\n<p>这种声明函数的方式非常不直观，几乎无人使用</p>\n</li>\n</ol>\n<ul>\n<li><p>如果同一个函数被多次声明，后面的声明会覆盖前面的声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f()&#123;</span><br><span class=\"line\">  console.log(1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() &#x2F;&#x2F; 2</span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">  console.log(2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>调用函数时，使用圆括号运算符</p>\n<p>函数体内部的return语句表示返回。JS引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。return语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回undefined。</p>\n<p>函数可以调用自身，这就是递归。</p>\n</li>\n<li><p><strong>第一等公民</strong>：JS语言将函数看作一种值，与其他值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。</p>\n<p>由于函数与其他数据类型地位平等，所以在JS中又称函数为第一等公民。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(x,y)&#123;</span><br><span class=\"line\">  return x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将函数赋值给一个变量</span><br><span class=\"line\">var operator &#x3D; add;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将函数作为参数和返回值</span><br><span class=\"line\">function a(op)&#123;</span><br><span class=\"line\">  return op;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(add)(1,1)</span><br><span class=\"line\">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>函数名的提升</strong>：JS引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f();</span><br><span class=\"line\"></span><br><span class=\"line\">function f()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果采用赋值语句定义函数，JS就会报错：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f();</span><br><span class=\"line\">var f &#x3D; function ()&#123;&#125;;</span><br><span class=\"line\">&#x2F;&#x2F; Error!</span><br></pre></td></tr></table></figure>\n\n<p>等同于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var f;</span><br><span class=\"line\">f();</span><br><span class=\"line\">f &#x3D; function () &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码第二行，调用f时，f只是被声明了，还没有被赋值，等于undefined，所以会报错。</p>\n</li>\n<li><p><strong>不能再条件语句中声明函数</strong>：根据ES规范，不得在非函数的代码块中声明函数，最常见的就是if和try语句</p>\n</li>\n<li><p><strong>函数的属性和方法</strong>：</p>\n<ul>\n<li><p><em>name属性</em>，返回紧跟在function关键字之后的那个函数名：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1()&#123;&#125;</span><br><span class=\"line\">f1.name &#x2F;&#x2F; &#39;f1&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">var f2 &#x3D; function ()&#123;&#125;;</span><br><span class=\"line\">f2.name &#x2F;&#x2F; &#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">var f3 &#x3D; function myName()&#123;&#125;;</span><br><span class=\"line\">f3.name &#x2F;&#x2F; &#39;myName&#39;</span><br></pre></td></tr></table></figure>\n\n<p>匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）</p>\n</li>\n<li><p><em>length属性</em>，返回函数预期传入的参数个数，即函数定义之中的参数个数。不管调用时输入了多少个参数，只返回定义时的参数个数。</p>\n</li>\n<li><p><em>toString()方法</em>，返回函数的源码。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>函数作用域</strong></p>\n<p>作用域（scope）指的是变量存在的范围</p>\n<p>JS只有两种作用域：一种是全剧作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。</p>\n<p>在函数外部声明的变量就是<strong>全局变量</strong>，它可以在函数内部读取。</p>\n<p>在函数内部定义的变量就是<strong>局部变量</strong>，外部无法读取。</p>\n<ul>\n<li><strong>函数内部定义的变量，会在该作用域内覆盖同名全局变量</strong>：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v &#x3D; 1;</span><br><span class=\"line\"></span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">  var v &#x3D; 2;</span><br><span class=\"line\">  console.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; 2</span><br><span class=\"line\">v &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>函数内部的变量提升</strong>：</p>\n<p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>\n</li>\n<li><p><strong>函数本身的作用域</strong>：</p>\n<p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 1;</span><br><span class=\"line\">var x &#x3D; function ()&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  var a &#x3D; 2;</span><br><span class=\"line\">  x();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>\n\n<p>函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>\n<p>很容易犯错的一点是，如果函数A调用函数B，却没考虑到函数B不会引用函数A的内部变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var x &#x3D; function ()&#123;</span><br><span class=\"line\">  console.log(a);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">function y(f) &#123;</span><br><span class=\"line\">  var a &#x3D; 2;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">y(x)</span><br><span class=\"line\">&#x2F;&#x2F; Error: a is not defined</span><br></pre></td></tr></table></figure>\n\n<p>同样的，函数体内部声明的函数，作用域绑定函数体内部：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo()&#123;</span><br><span class=\"line\">  var x &#x3D; 1;</span><br><span class=\"line\">  function bar()&#123;</span><br><span class=\"line\">    console.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var x &#x3D; 2;</span><br><span class=\"line\">var f &#x3D; foo();</span><br><span class=\"line\">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>\n\n<p>这种机制构成了<strong>闭包</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>参数</strong>：ES5中，函数参数不是必需的，JS允许省略参数。</p>\n<ul>\n<li><p>```<br>function f(a){<br>  a = a || 1;<br>  return a;<br>}<br>// ||表示“或运算”，赋值语句的等号右边，预期是一个值，凡是预期为值的地方，都可以用表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ **传递方式**：</span><br><span class=\"line\"></span><br><span class=\"line\">  + 函数参数如果是**原始类型**的值（数值、字符串、布尔值），传递方式是**传值传递**。意味着，在函数体内修改参数值，不会影响到函数外部</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var p = 2;<br>  function f(p){</p>\n<pre><code>p = 3;\n</code></pre>\n<p>  }<br>  f(p);</p>\n<p>  p // 2</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  变量p是一个原始类型的值，传入函数f的方式是传值传递。因此在函数内部，p的值时原始值的拷贝，无论怎么修改，都不会影响到原始值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 如果函数参数是**复合类型**的值（数组、对象、其他函数），传递方式是**传址传递**。意味着，在函数内部修改参数，将会影响到原始值。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var obj = {p: 1};<br>  function f(o){</p>\n<pre><code>o.p = 2;\n</code></pre>\n<p>  }<br>  f(obj);</p>\n<p>  obj.p // 2</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，传入函数f的是对象obj的地址。因此，在函数内部修改obj的属性p，会影响到原始值。</span><br><span class=\"line\"></span><br><span class=\"line\">**注意**：如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var obj = [1,2,3];<br>  function f(o){</p>\n<pre><code>0 = [2,3,4];\n</code></pre>\n<p>  }<br>  f(obj);</p>\n<p>  obj // [1,2,3]</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这是因为，形式参数（o）与实际参数obj存在一个赋值关系</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  // 函数f内部<br>  o = obj;</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    上面代码中，对o的修改都会反映在obj身上。但是，如果对o赋予一个新的值，就等于切断了o与obj的联系，导致此后的修改都不会影响到obj。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var a = 1;<br>function f(p){<br>  window[p] = 2;<br>}<br>f(‘a’);</p>\n<p>a // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ **同名参数**：</span><br><span class=\"line\"></span><br><span class=\"line\">  如果有同名的参数，则取最后出现的那个值，即使最后的参数没有值或被省略，也是以其为准：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f(a,a){<br>  console.log(a);<br>}<br>f(1,2) // 2<br>f(1) // undefined</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ **arguments对象**：</span><br><span class=\"line\"></span><br><span class=\"line\">  arguments对象包含了函数运行时的所有参数，arguments[0是第一个参数，arguments[1]就是第二个，以此类推。这个对象只有在函数体内部可以使用。</span><br><span class=\"line\"></span><br><span class=\"line\">  **正常模式下**，arguments对象可以在运行时修改：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var f = function (a,b){<br>  arguments[0] = 3;<br>  arguments[1] = 2;<br>  return a + b;<br>}<br>f(1,1) //5</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**严格模式下**，arguments对象是一个只读对象，修改它是无效的，但不会报错</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var f = function (a,b){<br>  ‘use strict’;<br>  arguments[0] = 3; // 无效<br>  arguments[1] = 2; // 无效<br>  return a + b;<br>}<br>f(1,1) // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    介绍数组时说过，arguments虽然很像数组，但是它时一个对象，是一个“类似数组的对象”。数组专有的方法，不能在arguments对象上直接使用。</span><br><span class=\"line\"></span><br><span class=\"line\">+ **闭包**：</span><br><span class=\"line\"></span><br><span class=\"line\">  JS的作用域机制，使得函数外部无法获取函数内部声明的变量。</span><br><span class=\"line\"></span><br><span class=\"line\">  但出于某种原因，需要得到函数内部的局部变量。正常情况下是办不到的，只有通过变通方法实现，就是在函数内部，再定义一个函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f1(){<br>var n = 999;<br>function f2(){<br>  console.log(n); // 999<br>}<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">函数f2声明在函数f1的内部，f1内部的所有局部变量，对f2可见。反之则不行。这是JS语言特有的“链式作用域”结构（chain scope），子对象会一级一级的向上寻找所有父对象的变量。</span><br><span class=\"line\"></span><br><span class=\"line\">既然f2可以读取f1的局部变量，那么只要把f2作为返回值，就可以在f1外部读取他的内部变量了</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f1(){<br>var n = 999;<br>function f2(){<br>  console.log(n);<br>}<br>return f2;<br>}<br>var result = f1();<br>result(); // 999</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">函数f1点返回值就是函数f2，由于f2可以读取f1的内部变量，所以就可以在外部获得f1点内部变量了。</span><br><span class=\"line\"></span><br><span class=\"line\">**闭包**就是函数f2，即能够读取其他函数内部变量的函数。</span><br><span class=\"line\"></span><br><span class=\"line\">JS语言中，只有函数内部的字函数才能读取内部变量，因此可以把闭包加单理解成**“定义在一个函数内部的函数”**。在本质上，闭包就是将函数内部和函数外部链接起来的一座桥梁。</span><br><span class=\"line\"></span><br><span class=\"line\">**闭包的最大用处有两个**：1. 读取函数内部的变量。2. 让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function createIncrmenentor(start){<br>return function (){<br>  return start++;<br>};<br>}<br>var inc = createIncrementor(5);</p>\n</li>\n</ul>\n<p>inc() // 5<br>inc() // 6<br>inc() // 7</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">*上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境一直存在。所以，闭包可以看作是函数内部作用域的一个接口。*</span><br><span class=\"line\"></span><br><span class=\"line\">*为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也是种在内存中，不会再调用结束后，被垃圾回收机制回收。*</span><br><span class=\"line\"></span><br><span class=\"line\">**闭包的另一个用处，是封装对象的私有属性和私有方法。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function Person(name) {<br>  var _age;<br>  function setAge(n) {</p>\n<pre><code>_age = n;\n</code></pre>\n<p>  }<br>  function getAge() {</p>\n<pre><code>return _age;\n</code></pre>\n<p>  }</p>\n<p>  return {</p>\n<pre><code>name: name,\ngetAge: getAge,\nsetAge: setAge\n</code></pre>\n<p>  };<br>}</p>\n<p>var p1 = Person(‘张三’);<br>p1.setAge(25);<br>p1.getAge() // 25</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  **注意**，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</span><br><span class=\"line\"></span><br><span class=\"line\">+ **立即调用的函数表达式**</span><br><span class=\"line\"></span><br><span class=\"line\">  在JS中，一对圆括号（）是一种运算符，跟在函数名之后，表示调用该函数。比如，print（）就表示调用print函数。</span><br><span class=\"line\"></span><br><span class=\"line\">  有时，我们需要在定义函数之后，立即调用该函数。这时，闭不能在函数的定义之后加上圆括号，会产生语法错误：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function () { /* code */}();<br>// SyntaxError: Unexpected token (</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。同行首是一个对象的大括号，到底是表达式还是语句同理。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 语句<br>function f() {}<br>// 表达式<br>var f = function f() {}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">为避免解析上的歧义，JS引擎规定，如果function关键字出现在行首，一律解释称语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</span><br><span class=\"line\"></span><br><span class=\"line\">解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>(function (){ /* code <em>/ }());<br>// 或者<br>(function (){ /</em> code */ })();</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  以圆括号开头，引擎就会认为这个一个表达式，而不是函数定义语句，就避免了错误。这就叫做“立即调用的函数表达式”。</span><br><span class=\"line\"></span><br><span class=\"line\">  这两种写法最后的分号都是必须的。如果省略分号，遇到连着两个立即调用的函数表达式，可能就会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">## 运算符</span><br><span class=\"line\"></span><br><span class=\"line\">+ 加号运算符，拼接字符串和加法运算</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>1 + 1 // ‘2’<br>‘1’ + 1 // ‘11’<br>1 + ‘1’ // ‘11’</p>\n<p>1+1+1+1 // ‘4’<br>‘1’+1+1+1 // ‘1111’<br>1+’1’+1+1 // ‘1111’<br>1+1+’1’+1 // ‘211’<br>1+1+1+’1’ // ‘31’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">从左往右，能加法运算就加法运算，直到遇到字符，把之前的运算结果和字符拼接，字符之后全部为拼接。</span><br><span class=\"line\"></span><br><span class=\"line\">利用空字符串，将值转为字符串类型</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>x + ‘’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 余数运算符（%）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>12 % 5 // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">余数运算的运算结果的正负由第一个运算子的正负决定：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>-1 % 2 // -1<br>1 % -2 // 1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 自增运算符（++）、自减运算符（—)</span><br><span class=\"line\"></span><br><span class=\"line\">  自增／自减操作会修改原始变量</span><br><span class=\"line\"></span><br><span class=\"line\">  放在变量前，先自增／自减，再返回操作后的值；</span><br><span class=\"line\"></span><br><span class=\"line\">  放在变量后，先返回变量的值，再自增／自减</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var x = 1;<br>var y = 1;<br>x++ // 1;<br>++y // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 数值运算符（+）同样使用加号，但它是一元运算符（只需要一个操作数）。</span><br><span class=\"line\"></span><br><span class=\"line\">  数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>+true // 1<br>+[] // 0<br>+{} // NaN</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 赋值运算符，除了最常见的等号（&#x3D;），还有以下：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>x += y // 等同于 x = x + y<br>x -= y // 等同于 x = x - y<br>x *= y // 等同于 x = x * y<br>x /= y // 等同于 x = x / y<br>x %= y // 等同于 x = x % y<br>x &gt;&gt;= y // 等同于 x = x &gt;&gt; y<br>x &lt;&lt;= y // 等同于 x = x &lt;&lt; y<br>x &gt;&gt;&gt;= y // 等同于 x = x &gt;&gt;&gt; y<br>x &amp;= y // 等同于 x = x &amp; y<br>x |= y // 等同于 x = x | y<br>x ^= y // 等同于 x = x ^ y</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 比较运算符</span><br><span class=\"line\"></span><br><span class=\"line\">  如果两个运算子都是字符串，则按照字典顺序比较（实际上是比较Unicode码点）</span><br><span class=\"line\"></span><br><span class=\"line\">  否则，将两个运算子都转成数值，再进行比较（等同于先调用Number函数）</span><br><span class=\"line\"></span><br><span class=\"line\">+ &#x3D;&#x3D;和&#x3D;&#x3D;&#x3D;的区别</span><br><span class=\"line\"></span><br><span class=\"line\">  相等运算符&#x3D;&#x3D;比较两个值是否相等，严格相等运算符&#x3D;&#x3D;&#x3D;比较它们是否为“同一个值”。</span><br><span class=\"line\"></span><br><span class=\"line\">  如果两个值不是同一类型，严格相等运算符&#x3D;&#x3D;&#x3D;直接返回 false，而相等运算符&#x3D;&#x3D;会将它们转化成同一类型，再用严格相等运算符进行比较</span><br><span class=\"line\"></span><br><span class=\"line\">+ &#x3D;&#x3D;&#x3D;严格相等运算符</span><br><span class=\"line\"></span><br><span class=\"line\">  + 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，不同就返回false。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  1 === 0x1 // true<br>  NaN === NaN // false NaN与任何值都不相等，包括自己</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 同一类型的复合类型的值（对象、数组、函数）比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  {} === {} // false<br>  [] === [] // false<br>  (function(){} === function(){}) // false</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等。原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是&#96;false&#96;。</span><br><span class=\"line\"></span><br><span class=\"line\">如果两个变量引用同一个对象，则它们相等。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var v1 = {};<br>  var v2 = v1;<br>  v1 === v2 // true</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">    注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ &#x3D;&#x3D;相等运算符</span><br><span class=\"line\"></span><br><span class=\"line\">  + 比较相同类型的数据时，与严格相等运算符完全一样</span><br><span class=\"line\"></span><br><span class=\"line\">  + 比较不同类型的数据时，相等运算符会先讲数据进行类型转换，然后再用严格相等运算符比较，转换规则如下：</span><br><span class=\"line\">    + 比较原始类型的数据时，会将数据转换成数值类型再进行比较</span><br><span class=\"line\"></span><br><span class=\"line\">    + 复合类型（对象、数组、函数）和原始类型的值比较时，复合类型转化成原始类型，再进行比较</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<pre><code>[1] == 1 // true\n// 等同于 Number([1]) == 1\n\n[1] == &#39;1&#39; // true\n// 等同于 String([1]) == Number(&#39;1&#39;)\n\n[1] == true // true\n// 等同于 Number([1]) == Number(true)\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 且运算符&amp;&amp;</span><br><span class=\"line\"></span><br><span class=\"line\">  运算规则：如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</code></pre>\n<p>‘t’ &amp;&amp; ‘’ // “”<br>‘t’ &amp;&amp; ‘f’ // “f”<br>‘t’ &amp;&amp; (1 + 2) // 3<br>‘’ &amp;&amp; ‘f’ // “”<br>‘’ &amp;&amp; ‘’ // “”</p>\n<p>var x = 1;<br>(1 - 1) &amp;&amp; ( x += 1) // 0<br>x // 1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if语句中经常这样写：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>if(x &amp;&amp; y){<br>  /* code */<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  x &amp;&amp; y并不直接返回布尔值，而是if命令后面的判断条件预期应该是一个布尔值，JS会自动将其转为布尔值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 或运算符||</span><br><span class=\"line\"></span><br><span class=\"line\">  运算规则：如果第一个运算子的布尔值为&#96;true&#96;，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为&#96;false&#96;，则返回第二个运算子的值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ void运算符</span><br><span class=\"line\"></span><br><span class=\"line\">  void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>void 0 // undefined<br>void(0) // undefined</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">void运算符的主要作用是用于在超链接中插入代码，防止网页跳转。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 点击链接，但不跳转页面<br><a href=\"javascript:void\"></a></p>\n<p>// 新建窗口打开链接<br><a href=\"javascript:void window.open('http://example.com')\"></a></p>\n<p>// 提交表单，但不会跳转页面<br><a href=\"javascript:void(document.form.submit())\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 数据类型转换</span><br><span class=\"line\"></span><br><span class=\"line\">JS是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</span><br><span class=\"line\"></span><br><span class=\"line\">虽然变量没有类型，但是数据本身和各种运算符是有类型的。如果运算符发现，数据的类型与预期不符，就会自动转换类型。</span><br><span class=\"line\"></span><br><span class=\"line\">### 强制转换</span><br><span class=\"line\"></span><br><span class=\"line\">强制转换主要指使用Number、String和Boolean三个构造函数，手动将各种类型的值，转换成数字、字符串或布尔值。</span><br><span class=\"line\"></span><br><span class=\"line\">+ Number()函数，可以将任意类型的值转化成数值</span><br><span class=\"line\"></span><br><span class=\"line\">  1. 原始类型值（字符串，布尔值、undefined、null）</span><br><span class=\"line\"></span><br><span class=\"line\">     Number函数将字符串转为数值要比parseInt函数严格很多。只有有一个字符无法转成数值，整个字符串就会被转为NaN。而parseInt是逐个转换字符。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   // 数值：转换后还是原来的值<br>   Number(324) // 324</p>\n<p>   // 字符串：如果可以被解析为数值，则转换为相应的数值<br>   Number(‘324’) // 324</p>\n<p>   // 字符串：如果不可以被解析为数值，返回NaN<br>   Number(‘324abc’) // NaN</p>\n<p>   // 空字符串转为0<br>   Number(‘’) // 0</p>\n<p>   // 布尔值：true 转成1，false 转成0<br>   Number(true) // 1<br>   Number(false) // 0</p>\n<p>   // undefined：转成 NaN<br>   Number(undefined) // NaN</p>\n<p>   // null：转成0<br>   Number(null) // 0</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 复合类型值（对象、数组、函数）</span><br><span class=\"line\"></span><br><span class=\"line\">   简单的规则是，&#96;Number&#96;方法的参数是对象时，将返回&#96;NaN&#96;，**除非是包含单个数值的数组**。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   Number({a: 1}) // NaN<br>   Number([1, 2, 3]) // NaN<br>   Number([5]) // 5</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ String()函数，可以将任意类型的值转化成字符串。转换规则如下：</span><br><span class=\"line\"></span><br><span class=\"line\">  1. 原始类型值的转换规则</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   数值：转为相应的字符串。<br>   字符串：转换后还是原来的值。<br>   布尔值：true转为”true”，false转为”false”。<br>   undefined：转为”undefined”。<br>   null：转为”null”。</p>\n<p>   String(123) // “123”<br>   String(‘abc’) // “abc”<br>   String(true) // “true”<br>   String(undefined) // “undefined”<br>   String(null) // “null”</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. 对象的转换规则</span><br><span class=\"line\"></span><br><span class=\"line\">   &#96;String&#96;方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   String({a: 1}) // “[object Object]”<br>   String([1, 2, 3]) // “1,2,3”</p>\n   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ Boolean()函数，可以将任意类型的变量转为布尔值，除了以下六个值的转换结果为false，其他值全部是true</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>undefined<br>null<br>-0<br>0或+0<br>NaN<br>‘’（空字符串）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 自动转换</span><br><span class=\"line\"></span><br><span class=\"line\">以下三种情况，JS会自动转换数据类型，转换时自动完成的，对用户不可见</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 1. 不同类型的数据互相运算<br>123 + ‘abc’ // “123abc”</p>\n</li>\n</ul>\n<p>// 2. 对非布尔值类型的数据求布尔值<br>if (‘abc’) {<br>  console.log(‘hello’)<br>}  // “hello”</p>\n<p>// 3. 对非数值类型的数据使用一元运算符（即“+”和“-”）</p>\n<ul>\n<li>{foo: ‘bar’} // NaN</li>\n</ul>\n<ul>\n<li>[1, 2, 3] // NaN<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用&#96;String&#96;函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。</span><br><span class=\"line\"></span><br><span class=\"line\">## 错误处理机制</span><br><span class=\"line\"></span><br><span class=\"line\">### Error对象</span><br><span class=\"line\"></span><br><span class=\"line\">JavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript原生提供一个&#96;Error&#96;构造函数，所有抛出的错误都是这个构造函数的实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nvar err = new Error(‘出错了’);<br>err.message // “出错了”<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Error构造函数接受一个参数，表示错误提示，可以从实例等message属性读到这个参数。</span><br><span class=\"line\"></span><br><span class=\"line\">Error对象的实例必须有message属性。大多数JS引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但她们是非标准的，不是每种实现都有</span><br><span class=\"line\"></span><br><span class=\"line\">### JS的原声错误类型</span><br><span class=\"line\"></span><br><span class=\"line\">Error对象时最易班的错误类型。在它的基础上，JS还定义了其他6种错误：</span><br><span class=\"line\"></span><br><span class=\"line\">1. SyntaxError是解析代码时发生的语法错误</span><br><span class=\"line\">2. ReferenceError是引用一个不存在的变量时发生的错误或将一个值分配给无法分配的对象</span><br><span class=\"line\">3. RangeError</span><br><span class=\"line\">4. TypeError</span><br><span class=\"line\">5. URIError</span><br><span class=\"line\">6. EvalError</span><br><span class=\"line\"></span><br><span class=\"line\">### 自定义错误</span><br><span class=\"line\"></span><br><span class=\"line\">除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nfunction UserError(message) {<br> this.message = message || “默认信息”;<br> this.name = “UserError”;<br>}</li>\n</ul>\n<p>UserError.prototype = new Error();<br>UserError.prototype.constructor = UserError;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义的错误了。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>new UserError(“这是自定义的错误！”);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### throw语句</span><br><span class=\"line\"></span><br><span class=\"line\">throw语句的作用是中断程序执行，抛出一个意外或错误。它接受一个表达式作为参数们可以抛出各种值。</span><br><span class=\"line\"></span><br><span class=\"line\">JS引擎一旦遇到throw语句，就会停止执行后面的语句，并将throw语句的参数值，返回给用户。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>throw new Error(‘出错了！’);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### try…catch结构</span><br><span class=\"line\"></span><br><span class=\"line\">try…catch结构对错误进行处理</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>tru{<br>  throw new Error(‘出错了！’);<br>}catch(e){<br>  console.log(e.name + “:” + e.message);<br>  console.log(e.stack)<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">try代码块一抛出错误（上例用的是throw语句），js引擎就立即把代码的执行，转到catch代码块。catch接受一个参数，表示try代码块抛出的值。</span><br><span class=\"line\"></span><br><span class=\"line\">catch代码块中，还可以再抛出错误，甚至使用嵌套的try...catch结构。</span><br><span class=\"line\"></span><br><span class=\"line\"># 面向对象编程</span><br><span class=\"line\"></span><br><span class=\"line\">面向对象编程（Object Oriented Programming，OOP）是目前主流的编程范式。</span><br><span class=\"line\"></span><br><span class=\"line\">对象是一个容器，封装了属性（property）和方法（method）。</span><br><span class=\"line\"></span><br><span class=\"line\">## 构造函数</span><br><span class=\"line\"></span><br><span class=\"line\">典型的面向对象编程语言（C++，Java），存在“类”（class）的概念。所谓“类”就是对象的模版，对象就是“类”的实例。JS语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</span><br><span class=\"line\"></span><br><span class=\"line\">JS语言使用构造函数作为对象的模版。所谓“构造函数”，就是专门用来生成对象的函数。它提供模版，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。</span><br><span class=\"line\"></span><br><span class=\"line\">构造函数的写法就是一个普通的函数，但是有自己的特征和用法。为了和普通函数区别，构造函数名字的第一个字母通常大写：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function () {<br>  this.price = 1000;<br>};</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1. 函数体内部使用了this关键字，代表了所要生成的对象实例。</span><br><span class=\"line\">2. 生成对象的时候，必需用new命令。</span><br><span class=\"line\"></span><br><span class=\"line\">## new命令</span><br><span class=\"line\"></span><br><span class=\"line\">new命令的作用是，执行构造函数，返回一个对象实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function () {<br>  this.price = 1000;<br>};<br>var v = new Vehicle();<br>v.price // 1000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">new命令执行时，构造函数内部的this，就代表了新生成的实例对象。</span><br><span class=\"line\"></span><br><span class=\"line\">使用new命令时，根据需要，构造函数也可以接受参数：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function (p) {<br>  this.price = p;<br>};<br>var v = new Vehicle(500);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">new命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var v = new Vehicle();<br>var v = new Vehicle;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### new命令的原理</span><br><span class=\"line\"></span><br><span class=\"line\">使用new命令时，她后面的函数调用就不是正常的调用，而是依次执行下面的步骤：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 创建一个空对象，作为将要返回的对象实例</span><br><span class=\"line\">2. 将这个空对象的原型，指向构造函数的prototype属性</span><br><span class=\"line\">3. 将这个空对象赋值给函数内部的this关键字</span><br><span class=\"line\">4. 开始执行构造函数内部的代码</span><br><span class=\"line\"></span><br><span class=\"line\">构造函数内部，this指的是一个新生成的空对象，所有针对this的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即this对象），将其“构造“为需要的样子。</span><br><span class=\"line\"></span><br><span class=\"line\">如果构造函数内部有return语句，而且return后面跟一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function () {<br>  this.price = 1000;<br>  return 1000;<br>};</p>\n<p>(new Vehicle()) === 1000<br>// false</p>\n<p>var Vehicle = function (){<br>  this.price = 1000;<br>  return { price: 2000 };<br>};</p>\n<p>(new Vehicle()).price<br>// 2000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。</span><br><span class=\"line\"></span><br><span class=\"line\">### 直接调用构造函数会发生什么？</span><br><span class=\"line\"></span><br><span class=\"line\">如果忘了使用new命令，直接调用构造函数会发生什么？</span><br><span class=\"line\"></span><br><span class=\"line\">这种情况下，构造函数就编程了普通函数，并不会生成实例对象。而且this这时代表全局对象，将造成一些意想不到的后果。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var Vehicle = function () {<br>  this.price = 1000;<br>}</p>\n<p>var v = Vehicle();<br>v.price<br>// Uncaught TypeError: Cannot read property ‘price’ of undefined</p>\n<p>price<br>// 1000</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">不使用new命令调用Vehicle构造函数时，price属性变成了全局变量，变量v变成了undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">### new.target</span><br><span class=\"line\"></span><br><span class=\"line\">函数内部可以使用new.target属性。如当前函数是new命令调用，new.target指向当前函数，否则为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">## 使用Object.create()创建实例对象</span><br><span class=\"line\"></span><br><span class=\"line\">构造函数作为模版，可以生成实例对象。但是，有时只能拿到实例对象，而该对象根本就不是由构造函数生成的。这时可以使用Object.create()方法，直接以某个实例对象作为模版，生成一个新的实例对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var person1 = {<br>  name: ‘张三’,<br>  age: 38,<br>  greeting: function() {<br>    console.log(‘Hi! I&#39;m ‘ + this.name + ‘.’);<br>  }<br>};</p>\n<p>var person2 = Object.create(person1);</p>\n<p>person2.name // 张三<br>person2.greeting() // Hi! I’m 张三.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，对象person1是person2的模版，后者继承了前者的属性和方法。</span><br><span class=\"line\"></span><br><span class=\"line\">## this关键字</span><br><span class=\"line\"></span><br><span class=\"line\">this总是返回一个对象，简单说就是返回属性或方法“当前”所在的对象:</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var person = {<br>  name : ‘Ethan’,<br>  describe: function () {<br>    return ‘姓名:’+this.name;<br>  }<br>};<br>person.describe()<br>// “姓名：Ethan”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">this.name表示describe方法所在的当前对象的name属性。调用person.describe方法时，describe方法所在的当前对象是person，所以就是调用person.name。</span><br><span class=\"line\"></span><br><span class=\"line\">**由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f() {<br>  return ‘姓名：’+ this.name;<br>}</p>\n<p>var A = {<br>  name: ‘张三’,<br>  describe: f<br>};</p>\n<p>var B = {<br>  name: ‘李四’,<br>  describe: f<br>};</p>\n<p>A.describe() // “姓名：张三”<br>B.describe() // “姓名：李四”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">只要函数被赋给另一个变量，this的指向就会变：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var A = {<br>  name: ‘张三’,<br>  describe: function () {<br>    return ‘姓名：’+ this.name;<br>  }<br>};</p>\n<p>var name = ‘李四’;<br>var f = A.describe;<br>f() // “姓名：李四”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<input type=\"text\" name=\"age\" size=3 onChange=\"validate(this, 18, 99);\">\n\n<script>\nfunction validate(obj, lowval, hival){\n  if ((obj.value < lowval) || (obj.value > hival))\n    console.log('Invalid Value!');\n}\n</script>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码是一个文本输入框，每当用户输入一个值，就会调用onChange回调函数。回调函数传入this，就代表传入当前对象（即文本框），然后就可以从this.value上面独到用户的输入值。</span><br><span class=\"line\"></span><br><span class=\"line\">JS语言中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，this就是这个对象（环境）。</span><br><span class=\"line\"></span><br><span class=\"line\">如果一个函数在全局环境中运行，那么this就是指顶层对象（浏览器中为window对象）。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f(){<br>  return this;<br>}<br>f() === window // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">可以近似地认为，this是所有函数运行时的一个隐藏参数，指向函数的运行环境。 </span><br><span class=\"line\"></span><br><span class=\"line\">### 使用场合</span><br><span class=\"line\"></span><br><span class=\"line\">this的使用可以分成以下几个场合。</span><br><span class=\"line\"></span><br><span class=\"line\">1. **全局环境**使用this，它指的就是顶层对象window。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   this === window // true</p>\n<p>   function f(){<br>     soncole.log(this === window); // true<br>   }<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   不管是不是在函数内部，只要是在全局环境下运行，this就是指顶层对象window。</span><br><span class=\"line\"></span><br><span class=\"line\">2. **构造函数**中的this，指的是实例对象。</span><br><span class=\"line\"></span><br><span class=\"line\">3. **对象的方法**</span><br><span class=\"line\"></span><br><span class=\"line\">   当A对象的方法被赋予B对象，该方法中的this就是从指向A对象变成了指向B对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   var obj = {<br>     foo: function(){<br>       console.log(this);<br>     }<br>   };<br>   obj.foo() // obj<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">obj.foo方法执行时，它内部的this指向obj。</span><br><span class=\"line\"></span><br><span class=\"line\">但是，只有这一种用法（直接在obj对象上调用foo方法），this指向obj；其他用法时，this都指向代码块当前所在对象（浏览器为window对象）。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   // 情况一<br>   (obj.foo = obj.foo)() // window</p>\n<p>   // 情况二<br>   (false || obj.foo)() // window</p>\n<p>   // 情况三<br>   (1, obj.foo)() // window<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，obj.foo先运算在执行，即使值根本没有变化，this也不再指向obj了。这时因为这时它就脱离了运行环境obj，而是在全局环境执行。</span><br><span class=\"line\"></span><br><span class=\"line\">可以这样理解，在JS引擎内部，obj和obj.foo储存在两个内存地址，假设时M1和M2。只有obj.foo（）这样调用时，是从M1调用M2，因此this指向obj。但是，上面三种情况，都是直接取出M2进行运算，然后在全局环境执行运算结果（还是M2），因此this指向全局环境。</span><br><span class=\"line\"></span><br><span class=\"line\">**如果某个方法位于多层对象的内部，这时this只是指向当前一层的对象，而不会继承更上面的层**：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   var a = {<br>     p: ‘Hello’,<br>     b: {<br>       m: function(){<br>         console.log(this.p);<br>       }<br>     }<br>   };</p>\n<p>   a.b.m() // undefined<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   上面代码中，a.b.m方法在a对象的第二层，该方法内部的this不是指向a，而是直系那个a.b。</span><br><span class=\"line\"></span><br><span class=\"line\">### 使用注意</span><br><span class=\"line\"></span><br><span class=\"line\">1. 避免多层this</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   var o = {<br>     f1:function(){<br>       console.log(this);<br>       var f2 = function (){<br>         console.log(this);<br>       }();<br>     }<br>   }</p>\n<p>   o.f1()<br>   // Object<br>   // Window<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   第一层指向该对象，第二层指向全局对象</span><br><span class=\"line\"></span><br><span class=\"line\">   [**为什么第二层this指向全局对象window？**](http:&#x2F;&#x2F;blog.csdn.net&#x2F;u011457225&#x2F;article&#x2F;details&#x2F;73882551?utm_source&#x3D;itdadao&amp;utm_medium&#x3D;referral)</span><br><span class=\"line\"></span><br><span class=\"line\">   o.f1()表示调用o对象的f1方法，所以f1方法中的this指向o对象；而f1方法中的闭包（即f2函数）不属于任何对象，它不是一个对象的方法。非严格模式下，如果没有指定属于哪个对象，那么它就属于window对象。</span><br><span class=\"line\"></span><br><span class=\"line\">### 绑定this的方法</span><br><span class=\"line\"></span><br><span class=\"line\">JS提供了call、apply、bind三种方法，来切换／固定this 的指向。</span><br><span class=\"line\"></span><br><span class=\"line\">1. **function.prototype.call()**</span><br><span class=\"line\"></span><br><span class=\"line\">   作用：指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</span><br><span class=\"line\"></span><br><span class=\"line\">   call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。如果参数是一个原始值，那么这个原始值回自动转成对应的包装对象，然后传入call方法。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   var n = 123;<br>   var obj = { n: 456};</p>\n<p>   function a(){<br>     console.log(this.n);<br>   }</p>\n<p>   a.call() // 123<br>   a.call(null) // 123<br>   a.call(undefined) // 123<br>   a.call(window) // 123<br>   a.call(obj) // 456<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">call方法还可以接受多个参数，第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   func.call(thisValue,arg1,arg2,…)<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   function add(a,b){<br>     return a + b;<br>   }</p>\n<p>   add.call(this,1,2) // 3<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">2. **function.prototype.apply()**</span><br><span class=\"line\"></span><br><span class=\"line\">   apply方法等作用域call方法类似，也是改变this指向，然后在调用该函数。唯一的区别就是，他接受一个数组作为函数执行时的参数：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   func.apply(thisValue,[arg1,arg2,…])<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure><br>   function f(x,y){<br>     console.log(x+y);<br>   }<br>   f.call(null,1,1) // 2<br>   f.apply(null,[1,1]) // 2<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. **function.prototype.bind()**</span><br><span class=\"line\"></span><br><span class=\"line\">   apply／call方法不仅绑定函数执行时所在的对象，还会立即执行函数。</span><br><span class=\"line\"></span><br><span class=\"line\">   bind方法只用于将函数体内的this绑定到某个对象，然后返回一个新函数。</span><br><span class=\"line\"></span><br><span class=\"line\">## prototype 对象</span><br><span class=\"line\"></span><br><span class=\"line\">### 原型对象</span><br><span class=\"line\"></span><br><span class=\"line\">通过同一个构造函数创建的实例对象之间，无法共享属性，对系统资源造成浪费。</span><br><span class=\"line\"></span><br><span class=\"line\">**JS的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。null除外。**</span><br><span class=\"line\"></span><br><span class=\"line\">原型对象上的所有属性和方法，都能派生对象共享。这就是JS继承机制的基本设计。</span><br><span class=\"line\"></span><br><span class=\"line\">通过构造函数生成实例对象时，会自动为实例对象分配原型对象。**每一个构造函数都有一个prototype属性**，这个属性就是实例对象的原型对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>function Animal (name){<br>  this.name = name;<br>}</p>\n<p>Animal.prototype.color = ‘white’;</p>\n<p>var cat1 = new Animal(‘大毛’);<br>var cat2 = new Animal(‘二毛’);</p>\n<p>cat1.color // ‘white’<br>cat2.color // ‘white’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">构造函数Animal的prototype对象，就是实例对象cat1和cat2的原型对象。在原型对象上添加一个color属性。实例对象都能读取该属性。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">+ 当实例对象本身没有某个属性或方法等时候，它会去原型对象寻找并读取这个属性火方法。</span><br><span class=\"line\">+ 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</span><br><span class=\"line\"></span><br><span class=\"line\">**原型对象的作用，就是定义所有实例对象共享的属性和方法。**</span><br><span class=\"line\"></span><br><span class=\"line\">### 原型链</span><br><span class=\"line\"></span><br><span class=\"line\">原型对象本身也是对象，又有自己的原型，所以形成一条原型链。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推。</span><br><span class=\"line\"></span><br><span class=\"line\">如果一层层地上溯，所有对象的原型最终都可以上溯到&#96;Object.prototype&#96;，即Object构造函数的prototype属性指向的那个对象。&#96;Object.prototype&#96;对象的原型是没有任何属性和方法等&#96;null&#96;对象，而&#96;null&#96;对象没有自己的原型。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 原型链的作用是：读取对象的某个属性时，JS引擎线寻找对象本身的属性，如果找不到，就到它的原型去找，如果还找不到，就到原型的原型去找。如果知道最顶层的&#96;Object.prototype&#96;还是找不到，则返回undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">在原型链一级级向上寻找某个属性，对性能有影响。属性越在山层影响越大。如果寻找某个不存在的属性，会遍历整个原型链。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var MyArray = function (){};</p>\n<p>MyArray.prototype = new Array();<br>MyArray.prototype.constructor = MyArray;</p>\n<p>var mine = new MyArray();<br>mine.push(1,2,3);</p>\n<p>mine.length // 3<br>mine instanceof Array // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">instanceof运算符用来比较一个对象是否为某个构造函数的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">### constructor属性</span><br><span class=\"line\"></span><br><span class=\"line\">prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function P (){}</p>\n<p>P.prototype.constructor === p // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">由于constructor属性定义在prototype对象上面，意味着可以被所有实例对象继承：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function P () {}<br>var p = new P();</p>\n<p>p.constructor<br>// function P() {}</p>\n<p>p.constructor === P.prototype.constructor<br>// true</p>\n<p>p.hasOwnProperty(‘constructor’)<br>//false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ **constructor属性的作用，是分辨原型对象到底属于哪个构造函数**</span><br><span class=\"line\"></span><br><span class=\"line\">+ 通过constructor属性，从实例新建另一个实例：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  function Constr() {}<br>  var x = new Constr();</p>\n<p>  var y = new x.constructor();<br>  y instanceof Constr // true<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">这使得在实例方法中，调用自身的构造函数成为可能：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>  Constr.prototype.createCopy = function (){<br>    return new this.constructor();<br>  }<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 通过name属性，可以从实例得到构造函数的名称：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>  function Foo () {}<br>  var f = new Foo();<br>  f.constructor.name // “Foo”<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ 修改原型对象时，一般要同时校正constructor属性的指向，否则会导致instanceof运算符失真。</span><br><span class=\"line\"></span><br><span class=\"line\">### instanceof运算符</span><br><span class=\"line\"></span><br><span class=\"line\">instanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>var n = new Vehicle();<br>v instanceof Vehicle // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">instanceof运算符左边时实例对象，右边是构造函数。它会检查右边构造函数的原型对象，是否在左边对象的原型链上。</span><br><span class=\"line\"></span><br><span class=\"line\">instanceof运算符只能用于对象，不适用原始类型的值。</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.getPrototypeOf()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.getPrototypeOf&#96;方法返回一个对象的原型。这时获取原型对象的标准方法。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// 空对象的原型是Object.prototype<br>Object.getPrototypeOf({}) === Object.prototype<br>// true</p>\n<p>// 函数的原型是Function.prototype<br>function f() {}<br>Object.getPrototypeOf(f) === Function.prototype<br>// true</p>\n<p>// f 为 F 的实例对象，则 f 的原型是 F.prototype<br>var f = new F();<br>Object.getPrototypeOf(f) === F.prototype<br>// true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### Object.setPrototypeOf()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.setPrototypeOf&#96;方法可以为现有对象设置原型，返回一个新对象。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.setPrototypeOf&#96;方法接受两个参数，第一个是现有对象，第二个是原型对象。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;new&#96;命令通过构造函数新建实例对象，实质就是将实例对象的原型，指向构造函数的&#96;prototype&#96;属性，然后在实例对象上执行构造函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var F = function () {<br>  this.foo = ‘bar’;<br>};</p>\n<p>var f = new F();</p>\n<p>// 等同于<br>var f = Object.setPrototypeOf({}, F.prototype);<br>F.call(f);<br>f.foo // “bar”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### Object.create()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.create&#96;方法是为了满足只能通过实例对象生成另一个实例对象的需求。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.create&#96;方法接受一个对象作为**第一个参数**，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">老式浏览器如果不支持Object.create方法，可以用下面代码部署：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>if (typeof Object.create !== ‘function’){<br>  Object.create = function (obj){<br>    function F(){}<br>    F.prototype = obj;<br>    return new F()<br>  };<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ Object.create方法参数不能为空，或者不是对象，否则会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 如果想生成一个不继承任何属性的对象，可以将Object.create的参数设为null。</span><br><span class=\"line\"></span><br><span class=\"line\">+ Object.create方法生成的新对象，动态继承原型。在原型上添加或修改任何方法，会立刻反应在新对象之上。</span><br><span class=\"line\"></span><br><span class=\"line\">+ Object.create方法还接受**第二个参数**。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>  var obj = Object.create({}, {<br>    p1: {<br>      value: 123,<br>      enumerable: true,<br>      configurable: true,<br>      writable: true,<br>    },<br>    p2: {<br>      value: ‘abc’,<br>      enumerable: true,<br>      configurable: true,<br>      writable: true,<br>    }<br>  });</p>\n<p>  // 等同于<br>  var obj = Object.create({});<br>  obj.p1 = 123;<br>  obj.p2 = ‘abc’;<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">+ Object.create方法生成的对象，继承了它原型对象的构造函数。</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.prototype.isPrototypeOf()</span><br><span class=\"line\"></span><br><span class=\"line\">对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>var o1 = {};<br>var o2 = Object.create(o1);<br>var o3 = Object.create(o2);</p>\n<p>o2.isPrototypeOf(o3); // true<br>o1.isPrototypeOf(o3); // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**只要某个对象处在原型链上，isPrototypeOf都返回true。**</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.prototype.\\_\\_proto\\_\\_</span><br><span class=\"line\"></span><br><span class=\"line\">\\_\\_proto\\_\\_属性（前后各两个下划线）可以改写某个对象的原型对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var obj = {};<br>var p = {};</p>\n<p>obj.<strong>proto</strong> = p;<br>Object.getPrototypeOf(obj) === p // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 获取原型对象方法等比较</span><br><span class=\"line\"></span><br><span class=\"line\">\\_\\_proto\\_\\_属性指向当前对象的原型对象，即构造函数的prototype属性：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var obj = new Object();</p>\n<p>obj.<strong>proto</strong> === Object.prototype<br>//true<br>obj.<strong>proto</strong> === obj.constructor.prototype<br>//true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">因此，获取实例对象obj的原型对象，有三种方法：</span><br><span class=\"line\"></span><br><span class=\"line\">+ obj.\\_\\_proto\\_\\_</span><br><span class=\"line\">+ obj.constructor.prototype</span><br><span class=\"line\">+ Object.getPrototypeOf(obj)</span><br><span class=\"line\"></span><br><span class=\"line\">前两种方法都不可靠，推荐第三种。</span><br><span class=\"line\"></span><br><span class=\"line\">## Object对象与继承</span><br><span class=\"line\"></span><br><span class=\"line\">通过原型链，对象的属性分成两种：自身的属性和继承的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.getOwnPropertyNames()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.getOwnPropertyNames&#96;方法返回一个数组，成员是对象本身的所有属性的键名，不包含继承的属性键名。</span><br><span class=\"line\"></span><br><span class=\"line\">对象本身的属性之中，有的是可以枚举的，有的不可枚举。&#96;Object.getOwnPropertyNames&#96;方法返回包括不可枚举的所有键名。如果只获取可枚举属性，请使用&#96;Object.keys&#96;方法。</span><br><span class=\"line\"></span><br><span class=\"line\">### Obejct.prototype.hasOnwProperty()</span><br><span class=\"line\"></span><br><span class=\"line\">对象实例的&#96;hasOwnProperty&#96;方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Date.hasOwnProperty(‘length’)<br>// true</p>\n<p>Date.hasOwnProperty(‘toString’)<br>// false</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">hasOwnProperty方法是JS中唯一一个处理对象属性时，不会遍历原型链的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">### in运算符和for...in循环</span><br><span class=\"line\"></span><br><span class=\"line\">+ in运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</span><br><span class=\"line\">+ 获得对象的所有可枚举属性（不管是自身的还是继承的），可以使用for...in循环。</span><br><span class=\"line\"></span><br><span class=\"line\">### 对象的拷贝</span><br><span class=\"line\"></span><br><span class=\"line\">如果要拷贝一个对象，需要做到下面两件事情。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 确保拷贝后的对象，与原对象具有同样的prototype原型对象。</span><br><span class=\"line\">+ 确保拷贝后的对象，与原对象具有同样的属性。</span><br><span class=\"line\"></span><br><span class=\"line\"># 标准库</span><br><span class=\"line\"></span><br><span class=\"line\">## Object对象</span><br><span class=\"line\"></span><br><span class=\"line\">JS原生提供Object对象（起首的O大写），所有其他对象都继承自这个对象。</span><br><span class=\"line\"></span><br><span class=\"line\">Object本身也是一个构造函数，可以直接通过它来生成新对象。</span><br><span class=\"line\"></span><br><span class=\"line\">Object作为构造函数使用时，可以接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。</span><br><span class=\"line\"></span><br><span class=\"line\">## Array对象</span><br><span class=\"line\"></span><br><span class=\"line\">Array是JS的内置对象，同时也是一个构造函数，可以用它生成新的数组。</span><br><span class=\"line\"></span><br><span class=\"line\">## 包装对象</span><br><span class=\"line\"></span><br><span class=\"line\">所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var v1 = new Number(123);<br>var v2 = new String(‘abc’);<br>var v3 = new Boolean(true);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Number(123) // 123<br>String(‘abc’) // “abc”<br>Boolean(true) // true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">总之，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。</span><br><span class=\"line\"></span><br><span class=\"line\">## Math对象</span><br><span class=\"line\"></span><br><span class=\"line\">Math是JS的内置对象，提供一系列数学常数和数学方法。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。</span><br><span class=\"line\"></span><br><span class=\"line\">## Date对象</span><br><span class=\"line\"></span><br><span class=\"line\">Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。</span><br><span class=\"line\"></span><br><span class=\"line\">Date对象也可以作为构造函数使用。使用new命令，会返回一个Date对象的实例。如果不加参数，生成的就是代表当前时间的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">## 属性描述对象</span><br><span class=\"line\"></span><br><span class=\"line\">JS提供了一个内部数据结构，用来描述一个对象的属性的行为，控制它的行为。这被称为“属性描述对象“（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</span><br><span class=\"line\"></span><br><span class=\"line\">下面是属性描述对象的一个实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>{<br>  value:123,<br>  writable:false,<br>  enumerable:true,<br>  configurable:false,<br>  get:undefined,<br>  set:undefined<br>}</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">属性描述对象提供6个元属性：</span><br><span class=\"line\"></span><br><span class=\"line\">1. value</span><br><span class=\"line\"></span><br><span class=\"line\">   value存放该属性的属性值，默认为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">2. writable</span><br><span class=\"line\"></span><br><span class=\"line\">   writable存放一个布尔值，表示属性值（value）是否可改变，默认为true。</span><br><span class=\"line\"></span><br><span class=\"line\">3. enumerable</span><br><span class=\"line\"></span><br><span class=\"line\">   enumerable存放一个布尔值，表示该属性是否可枚举，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。</span><br><span class=\"line\"></span><br><span class=\"line\">4. configurable</span><br><span class=\"line\"></span><br><span class=\"line\">   configurable存放一个布尔值，表示“可配置性”，默认为true。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。</span><br><span class=\"line\"></span><br><span class=\"line\">5. get</span><br><span class=\"line\"></span><br><span class=\"line\">   get存放一个函数，表示该属性的取值函数（getter），默认undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">6. set</span><br><span class=\"line\"></span><br><span class=\"line\">   set存放一个函数，表示该属性的存值函数（setter），默认为undefined。</span><br><span class=\"line\"></span><br><span class=\"line\">### Object.getOwnPropertyDescriptor()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.getOwnPropertyDescriptor&#96;方法可以读出对象自身属性的属性描述对象。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = { p : ‘a’ };</p>\n<p>Object.getOwnPropertyDescriptor(o,’p’)<br>// Object { value: “a”,<br>//   writable: true,<br>//   enumerable: true,<br>//   configurable: true<br>// }</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### Object.defineProperty(),Object.defineProperties()</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;Object.defineProperty()&#96;方法允许通过定义属性描述对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Object.defineProperty(object,propertyName,attributesObject)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#96;Object.defineProperty&#96;方法接受三个参数，第一个是属性所在的对象，第二个是属性名（它应该是一个字符串），第三个是属性的描述对象。比如新建一个o对象，并定义它的p属性，写法如下：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.defineProperty({},’p’,{<br>  value:123,<br>  writable:false,<br>  enumerable:true,<br>  configurable:false<br>})<br>o.p<br>// 123<br>o.p = 246;<br>o.p<br>// 123<br>// 因为writable为false，所以无法改变该属性的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果属性已经存在，&#96;Object.defineProperty&#96;方法相当于更新该属性的属性描述对象。</span><br><span class=\"line\"></span><br><span class=\"line\">需要注意的是，Object.defineProperty方法和后面的Object.defineProperties方法，都有性能损耗，会拖慢执行速度，不宜大量使用。</span><br><span class=\"line\"></span><br><span class=\"line\">如果一次性定义或修改多个属性，可以使用&#96;Object.defineProperties&#96;方法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.defineProperties({},{<br>  p1: { value: 123, enumerable: true },<br>  p2: { value: ‘abc’, enumerable: true },<br>  p3: { get: function(){ return this.p1 + this.p2 },<br>      enumerable:true,<br>      configurable:true<br>  }<br>});</p>\n<p>o.p1 // 123<br>o.p2 // “abc”<br>o.p3 // “123abc”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码的p3属性，定义了取值函数get。**这时需要注意的是，一旦定义了取值函数get（或存值函数set），就不能将writable设为true，或者同时定义value属性，会报错。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = {};</p>\n<p>Object.defineProperty(o,’p’,{<br>  value:123,<br>  get: function (){ return 456; }<br>});<br>// TypeError: Invalid property.<br>// A property cannot both have accessors and be writable or have a value,</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 元属性</span><br><span class=\"line\"></span><br><span class=\"line\">#### 可枚举性（enumerable）</span><br><span class=\"line\"></span><br><span class=\"line\">只有可枚举的属性，才会被for...in循环遍历，同时还规定原生继承的属性都是不可枚举的。</span><br><span class=\"line\"></span><br><span class=\"line\">可枚举性涌来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会渠道该属性。</span><br><span class=\"line\"></span><br><span class=\"line\">+ for…in循环</span><br><span class=\"line\">+ Object.keys方法</span><br><span class=\"line\">+ JSON.stringify方法</span><br><span class=\"line\"></span><br><span class=\"line\">基本上，JS原生提供的属性都是不可枚举的，用户自定义的属性都是可枚举的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 可配置性（configurable）</span><br><span class=\"line\"></span><br><span class=\"line\">可配置性决定了是否可以修改属性描述对象。也就是说，当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。</span><br><span class=\"line\"></span><br><span class=\"line\">需要注意的是，writable只有在从false改为true会报错，从true改为false则是允许的。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.defineProperty({},’p’,{<br>  writable: true,<br>  configurable: false<br>});</p>\n<p>Object.defineProperty(o,’p’,{writable: false})<br>// 修改成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">至于value，只要writable和configurable有一个为true，就允许改动。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o1 = Object.defineProperty({}, ‘p’, {<br>  value: 1,<br>  writable: true,<br>  configurable: false<br>});</p>\n<p>Object.defineProperty(o1,’p’, {value: 2})<br>// 修改成功</p>\n<p>var o2 = Object.defineProperty({}, ‘p’, {<br>  value: 1,<br>  writable: false,<br>  configurable: true<br>});</p>\n<p>Object.defineProperty(o2,’p’, {value: 2})<br>// 修改成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">configurable为false时，直接对该属性赋值，不报错，但不会成功。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.defineProperty({},’p’,{<br>  value: 1,<br>  configurable: false<br>});</p>\n<p>o.p = 2;<br>o.p // 1</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，o对象的p属性是不可配置的，对他赋值是不会生效的。</span><br><span class=\"line\"></span><br><span class=\"line\">可配置性决定了一个变量是否可以被删除。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = Object.definePropertyies({},{<br>  p1: { value: 1, configurable: true },<br>  p2: { value: 2, configurable: false}<br>});</p>\n<p>delete o.p1 // true<br>delete o.p2 // false</p>\n<p>o.p1 // undefined<br>o.p2 // 2</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 可写性（writable）</span><br><span class=\"line\"></span><br><span class=\"line\">可写性决定了属性的值是否可以被改变。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = {};<br>Object.defineProperty(o,’a’,{<br>  value: 37,<br>  writable:false<br>});</p>\n<p>o.a // 37<br>o.a = 25;<br>o.a // 37</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">正常模式下，对可写性为false的属性赋值不会报错，只会默默失败。但是严格模式下会报错。</span><br><span class=\"line\"></span><br><span class=\"line\">关于可写性，还有一种特殊情况。就是如果原型对象的某个属性的可写性为false，那么派生对象将无法自定义这个属性。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var proto = Object.defineProperty({},’foo’,{<br>  value: ‘a’,<br>  writable: false<br>});</p>\n<p>var o = Object.create(proto);</p>\n<p>o.foo = ‘b’;<br>o.foo // ‘a’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">规避这个情况的方法，就是通过覆盖属性描述对象，绕过这个限制，原因是这种情况下，原型链会被完全忽视。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Object.defineProperty(o,’foo’,{<br>  value:’b’<br>});<br>o.foo // ‘b’</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 存取器（accessor）</span><br><span class=\"line\"></span><br><span class=\"line\">除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用set命令；取值函数称为getter，使用get命令。</span><br><span class=\"line\"></span><br><span class=\"line\">存取器提供的是虚拟属性，即该属性的值不失时机存在的，而是每次读取时计算生成的。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var o = {<br>  get p(){<br>    return ‘getter’;<br>  },<br>  set p(value){<br>    console.log(‘setter:’ + value);<br>  }<br>};</p>\n<p>o.p // “getter”<br>o.p = 123 // “setter: 123”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，o对象内部的get和set命令，分别定义了p属性的取值函数和存值函数。定义了这两个函数之后，对p属性取值时，取值函数会自动调用；对p属性赋值时，存值函数会自动调用。</span><br><span class=\"line\"></span><br><span class=\"line\">取值函数getter不能接受参数，存值函数setter只能接受一个参数（即属性的值）。</span><br><span class=\"line\"></span><br><span class=\"line\">对象也不能有和与之函数同名的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">存取器也可以通过Object.defineProperty定义：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var d = new Date();<br>Object.definedProperty(d,’month’,{<br>  get: function (){<br>    return d.getMonth();<br>  },<br>  set: function (v){<br>    d.setMonth(v);<br>  }<br>});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**利用存取器，可以实现数据对象与DOM对象的双向绑定。**</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>Object.defineProperty(user,’name’,{<br>  get: function(){<br>    return document.getElementById(‘foo’).value<br>  },<br>  set: function(newValue){<br>    document.getElementById(‘foo’).value = newValue<br>  },<br>  configurable: true<br>})</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码，将DOM对象foo与数据对象user的name属性，实现了绑定。两者之中只要有一个对象发生变化，就能在另一个对象上实时反映出来。</span><br><span class=\"line\"></span><br><span class=\"line\"># 语法专题</span><br><span class=\"line\"></span><br><span class=\"line\">## 单线程模型</span><br><span class=\"line\"></span><br><span class=\"line\">### 含义</span><br><span class=\"line\"></span><br><span class=\"line\">单线程模型指的是，JS值在一个线程上运行。也就是说，JS同时只能执行一个任务，其他任务都必须在后面排队等待。</span><br><span class=\"line\"></span><br><span class=\"line\">JS只在一个线程上运行，不代表JS引擎只有一个线程。JS有多个线程。</span><br><span class=\"line\"></span><br><span class=\"line\">### 消息队列</span><br><span class=\"line\"></span><br><span class=\"line\">JS运行时，除了一个运行线程，JS还提供一个消息队列，里面是各种需要当前程序处理的消息。新的消息进入队列时，会自动排在队列尾端。</span><br><span class=\"line\"></span><br><span class=\"line\">运行线程只要发现消息队列不为空，就会取出排在第一位的消息，执行它对应的回调函数。等执行完，再取出排在第二位的消息，不断循环，直到消息队列变空为止。</span><br><span class=\"line\"></span><br><span class=\"line\">进入消息队列的消息，必须有对应的回调函数。否则这个消息就会遗失。</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout会在指定时间向消息队列添加一条消息。如果消息队列之中，此时没有其他消息，这条消息会立即得到处理；否则，这条消息会不得不等到其他消息处理完，才会得到处理。因此，&#96;setTimeout&#96;指定的执行时间，只是一个最早可能发生的时间，并不能保证一定会在那个时间发生。</span><br><span class=\"line\"></span><br><span class=\"line\">### Event Loop</span><br><span class=\"line\"></span><br><span class=\"line\">用来一轮又一轮的处理消息队列之中的消息，即执行对应的回调函数的内部循环机制。</span><br><span class=\"line\"></span><br><span class=\"line\">常见的JS任务：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 执行JS代码</span><br><span class=\"line\">+ 对用户的输入（鼠标点击、键盘输入等等）做出反应</span><br><span class=\"line\">+ 处理异步网络请求</span><br><span class=\"line\"></span><br><span class=\"line\">所有任务可以分成两种，一种是同步任务，另一种是异步任务。</span><br><span class=\"line\"></span><br><span class=\"line\">同步任务指的是，在JavaScript执行进程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入JavaScript执行进程、而进入“任务队列”（task queue）的任务，只有“任务队列”通知主进程，某个异步任务可以执行了，该任务（采用回调函数的形式）才会进入JavaScript进程执行。</span><br><span class=\"line\"></span><br><span class=\"line\">以Ajax操作为例，它可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着Ajax操作返回结果，再往下执行；如果是异步任务，该任务直接进入“任务队列”，JavaScript进程跳过Ajax操作，直接往下执行，等到Ajax操作有了结果，JavaScript进程再执行对应的回调函数。</span><br><span class=\"line\"></span><br><span class=\"line\">## 定时器</span><br><span class=\"line\"></span><br><span class=\"line\">JS提供定时执行代码的功能，叫做定时器（timer），主要由&#96;setTimeout()&#96;和&#96;setInterval()&#96;这两个函数来完成。它们向任务队列添加定时任务。</span><br><span class=\"line\"></span><br><span class=\"line\">### setTimeout()</span><br><span class=\"line\"></span><br><span class=\"line\">用来指定某个函数或某段代码，在多少毫秒之后执行。</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout函数接受两个参数，第一个参数&#96;fund|code&#96;是将要推迟执行的函数名或者一段代码，第二个参数&#96;delay&#96;是推迟执行的毫秒数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>console.log(1);<br>setTimeout(‘console.log(2)’,1000);<br>console.log(3);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">**注意**，推迟执行的代码必须以字符串的形式放入setTimeout，因为引擎内部使用eval函数，将字符串转为代码。如果推迟执行的是函数，则可以直接将函数名放入setTimeout。</span><br><span class=\"line\"></span><br><span class=\"line\">一方面eval函数有安全顾虑，另一方面为了便于引擎优化代码，setTimeout方法一般总是采用匿名函数的形式：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f(){<br>  console.log(2);<br>}</p>\n<p>setTimeout(f,1000);</p>\n<p>// 或者</p>\n<p>setTimeout(function () {<br>  console.log(2)<br>},1000)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### setInterval()</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</span><br><span class=\"line\"></span><br><span class=\"line\">### clearTimeout()，clearInterval()</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数值传入clearTimeout和clearInterval函数，就可以取消对应的定时器。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var id1 = setTimeout(f,1000);<br>var id2 = setInterval(f,1000);</p>\n<p>clearTimeout(id1);<br>clearInterval(id2);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 运行机制</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;setTimeout&#96;和&#96;setInterval&#96;的运行机制是，将指定的代码移出本次执行，等到下一轮 Event Loop 时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮 Event Loop 时重新判断。</span><br><span class=\"line\"></span><br><span class=\"line\">## Promise对象</span><br><span class=\"line\"></span><br><span class=\"line\">### JS的异步执行</span><br><span class=\"line\"></span><br><span class=\"line\">#### 回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">回调函数是异步编程最基本的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">假定有两个函数f1和f2，后者必须等到前者执行完成才能执行。这时可以考虑改写f1，把f2写成f1的回调函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>function f1(callback){<br>  // f1 的代码</p>\n<p>  // f1 执行完成后，调用回调函数<br>  callback();<br>}</p>\n<p>f1(f2);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个人物只能指定一个回调函数。</span><br><span class=\"line\"></span><br><span class=\"line\">#### Promise对象</span><br><span class=\"line\"></span><br><span class=\"line\">Promise对象是CommonJS工作组提出的一种规范，目的是为异步操作提供统一接口。</span><br><span class=\"line\"></span><br><span class=\"line\">它是一个对象。它使得异步操作具备同步操作的接口，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。</span><br><span class=\"line\"></span><br><span class=\"line\">它的思想是，每一个异步任务立刻返回一个Promise对象，由于是立刻返回，所以可以蚕蛹同步操作的流程。这个Promise对象有一个then方法，允许指定回调函数，在异步任务完成后调用。</span><br><span class=\"line\"></span><br><span class=\"line\">比如，异步操作f1返回一个Promise对象，它的回调函数f2写法如下：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>(new Promise(f1)).then(f2);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### Promise接口</span><br><span class=\"line\"></span><br><span class=\"line\">Promise接口的基本思想是，异步任务返回一个Promise对象。</span><br><span class=\"line\"></span><br><span class=\"line\">Promise对象只三种状态：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 异步操作“未完成”（pending）</span><br><span class=\"line\">+ 异步操作“已完成”（resolved）</span><br><span class=\"line\">+ 异步操作“失败”（rejected）</span><br><span class=\"line\"></span><br><span class=\"line\">三种状态只有两种变化方式：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 异步操作从“未完成”到“已完成”</span><br><span class=\"line\">+ 异步操作从“未完成”到“失败”</span><br><span class=\"line\"></span><br><span class=\"line\">因此，Promise对象的最终结果只有两种：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 异步操作成功，Promise对象传回一个值，状态变为resolved。</span><br><span class=\"line\">+ 异步操作失败，Promise对象抛出一个错误，状态变为rejected。</span><br><span class=\"line\"></span><br><span class=\"line\">Promise对象使用then方法添加回调函数。then方法可以接受两个回调函数，第一个是异步操作成功时的回调函数，第二个时异步操作失败时的回调函数（可以省略）。一旦状态改变，就调用相应的回调函数。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// po是一个Promise对象<br>po.then(<br>    console.log,<br>    console.error<br>)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">then方法可以链式使用：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>po<br>    .then(step1)<br>    .then(step2)<br>    .then(step3)<br>    .then(<br>        console.log,<br>        console.error<br>    );</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，po的状态一旦变为resolved，就一次调用后面每一个then指定的回调函数，每一步都必须等到前一步完成，才会执行。</span><br><span class=\"line\"></span><br><span class=\"line\">Promise对象的错误有传递性。</span><br><span class=\"line\"></span><br><span class=\"line\">#### Promise对象的生成</span><br><span class=\"line\"></span><br><span class=\"line\">ES6提供了原生的Promise构造函数，用来生成Promise实例。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>var promise = new Promise(function(resolve,reject){<br>  // 异步操作的代码</p>\n<p>  if(/* 异步操作成功 */){<br>    resolve(value);<br>  }else{<br>    reject(error);<br>  }<br>});</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们时两个函数，由JS引擎提供，不用自己部署。</span><br><span class=\"line\"></span><br><span class=\"line\">## 严格模式</span><br><span class=\"line\"></span><br><span class=\"line\">进入“严格模式”的标志，是一行字符串&#96;use strict&#96;。</span><br><span class=\"line\"></span><br><span class=\"line\">1. 针对整个脚本文件</span><br><span class=\"line\"></span><br><span class=\"line\">   将&#96;use strict&#96;放在脚本文件第一行，整个脚本都将以“严格模式”运行。</span><br><span class=\"line\"></span><br><span class=\"line\">2. 针对单个函数</span><br><span class=\"line\"></span><br><span class=\"line\">   &#96;use strict&#96;放在函数体的第一行，整个函数以“严格模式”运行。</span><br><span class=\"line\"></span><br><span class=\"line\">3. 脚本文件的变通写法</span><br><span class=\"line\"></span><br><span class=\"line\">   两个不同模式的脚本合并成一个文件，如果严格模式的脚本在前，则合并后的脚本都是“严格模式”；如果正常模式的脚本在前，则合并后的脚本都是“正常模式”。总之，这两种合并后的结果都是不正确的。</span><br><span class=\"line\"></span><br><span class=\"line\">   正确的做法是，使用前面第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>   (function(){<br>     ‘use strict’;<br>     // some code here<br>   })();<br>   <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   ​</span><br><span class=\"line\"></span><br><span class=\"line\"># DOM模型</span><br><span class=\"line\"></span><br><span class=\"line\">DOM是JS操作网页的接口，它的作用是将网页转为一个JS对象，从而可以用脚本进行各种操作。</span><br><span class=\"line\"></span><br><span class=\"line\">## 事件模型</span><br><span class=\"line\"></span><br><span class=\"line\">### 事件的传播</span><br><span class=\"line\"></span><br><span class=\"line\">#### 传播的三个阶段</span><br><span class=\"line\"></span><br><span class=\"line\">当一个事件发生以后，它会在不同的DOM节点之间传播（propagation）。这种传播分成三个阶段：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 第一阶段：从window对象传导到目标节点，称为“捕获阶段”。</span><br><span class=\"line\">+ 第二阶段：从目标节点上触发，称为“目标阶段”。</span><br><span class=\"line\">+ 第三阶段：从目标节点传导回window对象，称为“冒泡阶段”。</span><br><span class=\"line\"></span><br><span class=\"line\">这三种阶段的传播模型，会使得一个事件在多个节点上触发。比如，假设点击&#96;&lt;div&gt;&#96;之中嵌套一个&#96;&lt;p&gt;&#96;节点：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<div>\n    <p>Click Me</p>\n</div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">如果对这两个节点的click事件都设定监听函数，则click事件会被触发四次：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 捕获阶段：事件从&#96;&lt;div&gt;&#96;向&#96;&lt;p&gt;&#96;传播时，触发&#96;&lt;div&gt;&#96;的&#96;click&#96;事件；</span><br><span class=\"line\">+ 目标阶段：事件从&#96;&lt;div&gt;&#96;到达&#96;&lt;p&gt;&#96;时，触发&#96;&lt;p&gt;&#96;的&#96;click&#96;事件；</span><br><span class=\"line\">+ 目标阶段：事件离开&#96;&lt;p&gt;&#96;时，触发&#96;&lt;p&gt;&#96;的&#96;click&#96;事件；</span><br><span class=\"line\">+ 冒泡阶段：事件从&#96;&lt;p&gt;&#96;传回&#96;&lt;div&gt;&#96;时，再次触发&#96;&lt;div&gt;&#96;的&#96;click&#96;事件。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 事件的代理</span><br><span class=\"line\"></span><br><span class=\"line\">由于事件会在冒泡阶段向上传播的父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理。</span><br><span class=\"line\"></span><br><span class=\"line\">如果希望事件到某个节点为止，不再传播，可以使用时间对象的&#96;stopPropagation&#96;方法。</span><br><span class=\"line\"></span><br><span class=\"line\">&#96;stopPropagation&#96;方法只会阻止当前监听函数的传播，不会阻止节点上的其他click事件的监听函数。如果想要不再触发那些监听函数，可以使用stopImmediatePropagation方法。</span><br><span class=\"line\"></span><br><span class=\"line\">### Event对象</span><br><span class=\"line\"></span><br><span class=\"line\">事件发生以后，会生成一个事件对象，**作为参数传给监听函数**。浏览器原生提供一个Event对象，所有的事件都是这个对象的实例。</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.currentTarget</span><br><span class=\"line\"></span><br><span class=\"line\">currentTarget属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。作为比较，target属性返回事件发生的节点。如果监听函数在捕获阶段和冒泡阶段触发，那么这两个属性返回的值是不一样的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.target</span><br><span class=\"line\"></span><br><span class=\"line\">target属性返回触发事件的那个节点，即事件最初发生的节点。如果监听函数不在该即诶单触发，那么它与currentTarget属性返回的值是不一样的。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nfunction hide(e){\n  console.log(this === e.target);\n  e.target.style.visibility = \"hidden\";\n}\n\n<p>// HTML代码为<br>// <p id=\"para\">Hello <em>World</em></p><br>para.addEventListener(‘click’,hide,false);</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面代码中，如果在para节点的em子节点上面点击，则e.target指向em子节点，导致em子节点（即World部分）会不可见，且输出false。</span><br><span class=\"line\"></span><br><span class=\"line\">**事件的触发，和事件的监听不是一个概念**，比如上面代码中，点击em节点，click事件是在em节点触发的，然后按照事件传播模型从顶层window节点开始向下捕获，然后再从目标节点em节点向上冒泡，在冒泡阶段，p节点上监听了click事件，那么会执行p节点的监听函数，但此时event.target指向的是触发click事件的em节点，虽然监听函数是在p节点上执行的。</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.preventDefault()</span><br><span class=\"line\"></span><br><span class=\"line\">preventDefault方法取消浏览器对当前事件的默认行为。该方法生效的前提是，事件的cancelable属性为true。</span><br><span class=\"line\"></span><br><span class=\"line\">该方法不会阻止事件的进一步传播。只要在事件的传播过程中（捕获阶段、目标阶段、冒泡阶段皆可），使用了preventDefault方法，该事件的默认方法就不会执行。</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.stopPropagation()</span><br><span class=\"line\"></span><br><span class=\"line\">stopPropagation方法阻止事件在DOM中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上新定义的事件监听函数。</span><br><span class=\"line\"></span><br><span class=\"line\">**stopPropagation既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止事件目标阶段。**</span><br><span class=\"line\"></span><br><span class=\"line\">#### event.stopImmediatePropagation()</span><br><span class=\"line\"></span><br><span class=\"line\">stopImmediatePropagation方法阻止同一个事件的其他监听函数被调用。</span><br><span class=\"line\"></span><br><span class=\"line\">如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序一次调用。只要其中一个监听函数调用了stopImmediatePropagation方法，其他监听函数就不会再执行了。</span><br><span class=\"line\"></span><br><span class=\"line\"># 浏览器环境</span><br><span class=\"line\"></span><br><span class=\"line\">## 概述</span><br><span class=\"line\"></span><br><span class=\"line\">### JS代码嵌入网页的方法</span><br><span class=\"line\"></span><br><span class=\"line\">#### script标签：代码嵌入网页</span><br><span class=\"line\"></span><br><span class=\"line\">#### script标签：加载外部脚本</span><br><span class=\"line\"></span><br><span class=\"line\">#### 事件属性</span><br><span class=\"line\"></span><br><span class=\"line\">某些HTML元素的事件属性（比如onclic和onmouseover），可以写入JS代码。当指定事件发生时，就会调用这些代码。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<div onclick=\"alert('Hello')\"></div>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">上面的事件属性代码只有一个语句。如果有多个语句，用分号分隔即可。</span><br><span class=\"line\"></span><br><span class=\"line\">#### URL协议</span><br><span class=\"line\"></span><br><span class=\"line\">URL支持&#96;javascript:&#96;协议，调用这个URL时，就会执行JS代码。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<a href=\"javascript:alert('Hello')\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### script标签</span><br><span class=\"line\"></span><br><span class=\"line\">#### 工作原理</span><br><span class=\"line\"></span><br><span class=\"line\">正常的网页加载流程是这样的：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 浏览器一边下载HTML网页，一边开始解析</span><br><span class=\"line\">+ 解析过程中，发现&#96;&lt;script&gt;&#96;标签</span><br><span class=\"line\">+ 暂停解析，网页渲染的控制权转交给JavaScript引擎</span><br><span class=\"line\">+ 如果&#96;&lt;script&gt;&#96;标签引用了外部脚本，就下载该脚本，否则就直接执行</span><br><span class=\"line\">+ 执行完毕，控制权交还渲染引擎，恢复往下解析HTML网页</span><br><span class=\"line\"></span><br><span class=\"line\">### 浏览器的组成</span><br><span class=\"line\"></span><br><span class=\"line\">浏览器的核心是两部分：渲染引擎和JavaScript解释器（又称JavaScript引擎）。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 渲染引擎</span><br><span class=\"line\"></span><br><span class=\"line\">渲染引擎处理网页，通常分成四个阶段：</span><br><span class=\"line\"></span><br><span class=\"line\">+ 解析代码：HTML代码解析为DOM，CSS代码解析为CSSOM（CSS Object Model）</span><br><span class=\"line\">+ 对象合成：将DOM和CSSOM合成一个渲染树</span><br><span class=\"line\">+ 布局：计算出渲染树的布局（layout）</span><br><span class=\"line\">+ 绘制：将渲染树绘制到屏幕</span><br><span class=\"line\"></span><br><span class=\"line\">以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。</span><br><span class=\"line\"></span><br><span class=\"line\">#### JavaScript引擎</span><br><span class=\"line\"></span><br><span class=\"line\">JS引擎的主要作用是，读取网页中的JS代码，对其处理后运行。</span><br><span class=\"line\"></span><br><span class=\"line\">## window对象</span><br><span class=\"line\"></span><br><span class=\"line\">### window对象</span><br><span class=\"line\"></span><br><span class=\"line\">在浏览器中，window对象指当前的浏览器窗口。它也是所有对象的顶层对象。</span><br><span class=\"line\"></span><br><span class=\"line\">JS规定，浏览器环境的所有全局变量，都是window对象的属性。</span><br><span class=\"line\"></span><br><span class=\"line\">### history对象</span><br><span class=\"line\"></span><br><span class=\"line\">浏览器窗口有一个history对象，用来保存浏览历史。</span><br><span class=\"line\"></span><br><span class=\"line\">### Cookie</span><br><span class=\"line\"></span><br><span class=\"line\">Cookie时服务器保存在浏览器的一小段文本信息，每个Cookie的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。</span><br><span class=\"line\"></span><br><span class=\"line\">### Web Storage：浏览器端数据储存机制</span><br><span class=\"line\"></span><br><span class=\"line\">这个API的作用是，使得网页可以在浏览器端储存数据。它分成两类：sessionStorage和localStorage。</span><br><span class=\"line\"></span><br><span class=\"line\">sessionStorage保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；localStorage保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。</span><br><span class=\"line\"></span><br><span class=\"line\">每个域名的存储上限视浏览器而定。Chrome是2.5MB，Firefox和Opera是5MB，IE是10MB。</span><br><span class=\"line\"></span><br><span class=\"line\">另外，与Cookie一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取。</span><br><span class=\"line\"></span><br><span class=\"line\">#### 存入／读取数据</span><br><span class=\"line\"></span><br><span class=\"line\">存入数据使用setItem方法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nsessionStorage.setItem(\"key\",\"value\");\nlocalStorage.setItem(\"key\",\"value\");\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">读取数据使用getItem方法：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nvar valueSession = sessionStorage.getItem(\"key\");\nvar valueLocal = localStorage.getItem(\"key\");\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 清除数据</span><br><span class=\"line\"></span><br><span class=\"line\">removeItem方法用于清除某个键名对应的数据。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nsessionStorage.removeItem('key');\nlocalStorage.removeItem('key');\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">clear方法用于清除所有保存的数据。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nsessionStorage.clear();\nlocalStorage.clear();\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 同源政策</span><br><span class=\"line\"></span><br><span class=\"line\">### 含义</span><br><span class=\"line\"></span><br><span class=\"line\">1995年，同源政策由Netscape公司引入浏览器。</span><br><span class=\"line\"></span><br><span class=\"line\">最初，它的含义是指，A网页设置的Cookie，B网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。</span><br><span class=\"line\"></span><br><span class=\"line\">+ 协议相同</span><br><span class=\"line\">+ 域名相同</span><br><span class=\"line\">+ 端口相同</span><br><span class=\"line\"></span><br><span class=\"line\">## AJAX</span><br><span class=\"line\"></span><br><span class=\"line\">浏览器与服务器之间，采用HTTP协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会想服务器发出HTTP请求。</span><br><span class=\"line\"></span><br><span class=\"line\">AJAX包括以下几个步骤：</span><br><span class=\"line\"></span><br><span class=\"line\">1. 创建AJAX对象</span><br><span class=\"line\">2. 发出HTTP请求</span><br><span class=\"line\">3. 接受服务器传回的数据</span><br><span class=\"line\">4. 更新网页数据</span><br><span class=\"line\"></span><br><span class=\"line\">概括起来就是一句话，AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\nvar xhr = new XMLHttpRequest();\n\n<p>// 指定通信过程中状态改变时的回调函数<br>xhr.onreadtstatechange = function(){<br>    // 通信成功时，状态值为4<br>  if(xhr.readyState === 4){<br>    if(xhr.status === 200){<br>      console.log(xhr.resonseText);<br>    }else{<br>      console.log(xhr.statusText);<br>    }<br>  }<br>}</p>\n<p>xhr.onerror = function (e){<br>  console.log(xhr.statusText);<br>}</p>\n<p>// open方式用于指定HTTP动词、请求的网址、是否异步<br>xhr.open(‘GET’,’/endpoint’,true);</p>\n<p>// 发送HTTP请求<br>xhr.send(null);</p>\n<pre><code>\n</code></pre>\n"},{"title":"【数据分析】第二阶段：MySQL数据分时实战（三）","date":"2021-05-11T03:14:17.000Z","description":"MySQL项目实战","_content":"\n# 案例一 基于**MySQL**的电商用户、商品、平台价值分析\n\n电商行业，从早年粗放式经营，到现在精细化运营。随平台数据量积累，通过数据分析挖掘消费者潜在需求。\n\n人-货-场 指标体系。人-用户，货-商品，场-平台。\n\n探索用户行为规律，寻找高价值用户（消费频率高，消费金额高）；分析商品特征，寻找高贡献商品（成交量大，利润高）；分析产品功能，优化产品路径。\n\n## 确认问题\n\n通过对用户行为数据进行分析，解决以下问题：\n\n- 基于漏斗模型的用户购买流程各环节分析指标，确定各个环节的转换率，便于找到需要改进的 环节。（优化产品）\n- 找出热销商品，研究热销商品特点。（找到热门产品）\n- 基于RFM模型找出核心付费用户群，对这部分用户进行精准营销。（找到高价值用户）\n\n## 搭建指标\n\n用户-商品-平台\n\n### 用户指标\n\n- 基础指标：uv、pv、dv（浏览深度）、留存率\n- RFM模型\n\n#### UV\n\nunique vistor，一定时间内访问网站的用户数总和。\n\n```sql\nselect \n\tdates,\n\t-- 统计每一天的用户数总和，使用count对user_id计数，其中可能存在一个用户有多次记录，因此去重\n\tcount(distinct user_id) uv,\n\tcount(if(behavior_type = 1, user_id, null)) pv, \n\tcount(if(behavior_type = 1, user_id, null)) / count(distinct user_id) dv\nfrom temp_trade\ngroup by dates -- 案例中要求计算每日pv、uv、dv，因此按日期分组\n```\n\n#### PV\n\npage view，一定时间内所有用户每次访问网站的页数总和。代表网站的用户粘性非常高，PV高网站的跳出率就低，说明网站内容更被用户喜欢。\n\n```sql\nselect \n\tdates,\n\tcount(distinct user_id) uv, \n\t-- 统计每天每个用户浏览网站的页数的总和，同一个用户在一天不同时间段多次浏览网页也被计算在内，因此不需要去重。\n\t-- 本案例中一条behavior_type=1（曝光）的记录视为用户浏览了一个页面，因此对一天中曝光的user_id计数。\n\tcount(if(behavior_type = 1, user_id, null)) pv, \n\tcount(if(behavior_type = 1, user_id, null)) / count(distinct user_id) dv\nfrom temp_trade\ngroup by dates -- 案例中要求计算每日pv、uv、dv，因此按日期分组\n```\n\n#### DV\n\nvisit depth，浏览深度（访问深度）。dv = pv / uv。用户在一次浏览网站的过程中浏览了网站的页数。如果用户一次性的浏览了你的网站的页数越多，那么就基本上可以认定，你的网站有他感兴趣的东西。用户访问网站的深度用数据可以理解为网站平均访问的页面数，就是pv和uv的比值，这个比值越大，用户体验度越好，网站的粘性也越高。\n\n#### 留存、留存率\n\n留存：相对于基准日活跃用户数量，n天后返回的用户数量。\n\n**⚠️注意：留存计算的是n天后返回的用户数量，而不是n天后的用户数量。**\n\n**比如，基准日有10个用户，次日也有10个，但其中8个用户是基准日的，剩下两个2个是新用户。次日留存是8而不是10。**\n\n留存率：n天后返回的用户数/基准日活跃用户数*100%\n\n留存率是用于反映网站、互联网应用或网络游戏的运营情况的统计指标，其具体含义为在统计周期（周/月）内，每日活跃用户数在第N日仍启动该App的用户数占比的平均值。其中N通常取2、3、7、14、30，分别对应次日留存率、三日留存率、周留存率、半月留存率和月留存率。留存率常用于反映用户粘性，当N取值越大、留存率越高时，用户粘性越高。\n\n先计算各日留存，进而就可以求出各日留存率。\n\n**❌错误思路：统计出每日活跃用户数，再按照日期筛选出对应日期的活跃用户数。**\n\n```sql\n-- 先对源数据按日期分组，然后count每日的user_id并去重，得到每日的活跃用户数。\ncreate view wrong1 as\nselect dates, count(distinct user_id) device_v\nfrom temp_trade\ngroup by dates\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_18-47-58.jpg)\n\n```sql\n-- 然后根据需求，筛选出对应日期的活跃用户数即可。\nselect \n\tdates _dates, device_v,\n\t(select device_v from wrong1 where dates = date_add(_dates,interval 1 day)) day_1,\n\t(select device_v from wrong1 where dates = date_add(_dates,interval 2 day)) day_2,\n\t(select device_v from wrong1 where dates = date_add(_dates,interval 3 day)) day_3,\n\t(select device_v from wrong1 where dates = date_add(_dates,interval 7 day)) day_7\nfrom wrong1\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_19-12-56.jpg)\n\n**错误原因：**\n\n> 第一步统计每日活跃用户数看似正确，但这并不能计算出留存。\n>\n> 比如，计算出1号有100个用户，2号有100个用户，那么1号的次日留存就是2号的100吗？并不是。\n>\n> 留存计算的是相对于基准日，n天后返回的用户数。重点在“返回”二字。基准日1号有100个用户，次日2号100个用户中，可能有80个是1号100个用户中的，剩下20个是2号新增的用户。所以1号的次日留存只有80，而不是100。\n>\n> 所以计算留存，并不是简单的统计出每日的活跃用户数，然后按照日期筛选。\n>\n> 而是要统计1号的user_id，在这批user_id中看2号出现了多少个、3号出现了多少个。再统计2号的user_id、3号的user_id...以此类推。\n\n**✅正确思路：统计每个日期有多少user_id，再统计每个日期的所有user_id在之后的2日、3日、...n日中出现的个数。**\n\n1. ```sql\n   select user_id, dates from temp_trade group by user_id,dates\n   -- 按user_id,dates分组，得到全部日期-每个日期的全部活跃用户(无重复) 结果集\n   ```\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_22-42-45.jpg) ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_22-43-07.jpg)\n\n2. ```sql\n   select *\n   from \n   (select user_id, dates from temp_trade group by user_id,dates) a \n   left join \n   (select user_id, dates from temp_trade group by user_id,dates) b \n   on a.user_id = b.user_id\n   -- 1结果集on user_id自关联，得到全部活跃用户-每个用户全部活跃日期-某个用户某一个活跃日期-某个用户全部活跃日期\n   ```\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_22-52-09.jpg)\n\n3. ```sql\n   select *\n   from \n   (select user_id, dates from temp_trade group by user_id,dates) a \n   left join \n   (select user_id, dates from temp_trade group by user_id,dates) b \n   on a.user_id = b.user_id\n   where b.dates >= a.dates\n   -- where过滤，得到全部活跃用户-每个用户全部活跃日期-某个用户某一个活跃日期-某个用户在该日期之后的全部活跃日期\n   ```\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_23-02-23.jpg)\n\n4. ```sql\n   select \n   \ta.dates,\n   \tcount(distinct a.user_id) device_v\n   from \n   (select user_id, dates from temp_trade group by user_id,dates) a\n   left join \n   (select user_id, dates from temp_trade group by user_id,dates) b \n   on a.user_id = b.user_id\n   where b.dates >= a.dates\n   group by a.dates\n   -- 按日期分组，每个分组就是-每个日期全部活跃用户-每个用户大于该日期的全部活跃日期\n   -- count(distinct a.user_id) 统计每个日期的活跃用户数，即基准日活跃用户数\n   ```\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_23-06-28.jpg)\n\n5. ```sql\n   select \n   \ta.dates,\n   \tcount(distinct a.user_id) device_v,\n   \tcount(if(datediff(b.dates,a.dates)=1,a.user_id,null)) remain1\n   from \n   (select user_id, dates from temp_trade group by user_id,dates) a\n   left join \n   (select user_id, dates from temp_trade group by user_id,dates) b \n   on a.user_id = b.user_id\n   where b.dates >= a.dates\n   group by a.dates\n   -- 每个分组-每个日期全部活跃用户-每个用户大于该日期的全部活跃日期-每个用户大于该日期1天的记录-每个日期1天后还有多少用户\n   ```\n\n6. 以此类推\n\n   ```sql\n   create view user_remain_view as\n   select \n   \ta.dates,\n   \tcount(distinct a.user_id) device_v,\n   \tcount(if(datediff(b.dates,a.dates)=1,a.user_id,null)) remain1,\n   \tcount(if(datediff(b.dates,a.dates)=2,a.user_id,null)) remain2,\n   \tcount(if(datediff(b.dates,a.dates)=3,a.user_id,null)) remain3,\n   \tcount(if(datediff(b.dates,a.dates)=4,a.user_id,null)) remain4,\n   \tcount(if(datediff(b.dates,a.dates)=5,a.user_id,null)) remain5,\n   \tcount(if(datediff(b.dates,a.dates)=6,a.user_id,null)) remain6,\n   \tcount(if(datediff(b.dates,a.dates)=7,a.user_id,null)) remain7,\n   \tcount(if(datediff(b.dates,a.dates)=15,a.user_id,null)) remain15,\n   \tcount(if(datediff(b.dates,a.dates)=30,a.user_id,null)) remain30\n   from correct1 a left join correct1 b \n   on a.user_id = b.user_id\n   where b.dates >= a.dates\n   group by a.dates\n   ```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-13_14-28-07.jpg)\n\n留存率\n\n```sql\nselect \n\tdates, \n\tdevice_v,\n\tconcat(cast((remain1/device_v*100) as decimal(10,2)),'%') day_1,\n\tconcat(cast((remain2/device_v*100) as decimal(10,2)),'%') day_2,\n\tconcat(cast((remain3/device_v*100) as decimal(10,2)),'%') day_3,\n\tconcat(cast((remain4/device_v*100) as decimal(10,2)),'%') day_4,\n\tconcat(cast((remain5/device_v*100) as decimal(10,2)),'%') day_5,\n\tconcat(cast((remain6/device_v*100) as decimal(10,2)),'%') day_6,\n\tconcat(cast((remain7/device_v*100) as decimal(10,2)),'%') day_7,\n\tconcat(cast((remain15/device_v*100) as decimal(10,2)),'%') day_15,\n\tconcat(cast((remain30/device_v*100) as decimal(10,2)),'%') day_30\nfrom user_remain_view\n```\n\ncast()函数将（任何类型的）值转换为指定的数据类型。\n\n```sql\n-- cast(值 as 数据类型)\n-- 将值转换为DATE数据类型：\nSELECT CAST(\"2017-08-29\" AS DATE); \n```\n\ndecimal数据类型，decimal是比dobule类型精度更高的浮点类型\n\n```sql\ndecimal(p, d)\n-- p表示有效位数\n-- d是表示小数点后的位数\n```\n\n#### RFM\n\n- 统计出所有用户的r值、f值、m值，各个值取平均值，以高于或低于平均值为标准评价用户质量。\n\n- RFM八大用户分类：\n\n  ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-13_15-57-06.jpg)\n\n**R（recency) 最近一次购买**\n\n- R ，统计每个用户的r值——统计每个用户最近的发生购买的日期——统计每个用户最近的购买日期和标准日期的天数差——按天数差给每个用户打分，得分就是每个用户r值。\n\n```sql\n-- 按user_id分组，找出每个用户最近一次发生购买的日期\ndrop view if exists user_recency;\ncreate view user_recency as\nselect user_id, max(dates) recency_date \nfrom temp_trade \nwhere behavior_type = 2 \ngroup by user_id \norder by recency_date desc\n\n-- 假设2019-12-18是统计日期，计算每个用户的最近购买日期和统计日期差多少天，按天数打分，打分就是r值\ncreate view r_level as\nselect \n\tuser_id, \n\trecency_date, \n\tdatediff('2019-12-18',recency_date) recen_num,\n\t(case\n\t\twhen datediff('2019-12-18',recency_date) <=2 then 5\n\t\twhen datediff('2019-12-18',recency_date) <=4 then 4\n\t\twhen datediff('2019-12-18',recency_date) <=6 then 3\n\t\twhen datediff('2019-12-18',recency_date) <=8 then 2\n\t\telse 1 end\n\t) r_value\nfrom user_recency\n```\n\n**F（frequency）购买频率**\n\n- F ，统计一定时间范围内（本案例中为整张表时间范围）每个用户发生购买的记录数，对记录数打分，分值就是F值 \n\n```sql\ndrop view if exists user_buy_fre_view;\ncreate view user_buy_fre_view as\nselect user_id,count(user_id) buy_frequency\nfrom temp_trade \nwhere behavior_type = 2\ngroup by user_id\n\ncreate view f_level as\nselect user_id, buy_frequency,\n\t(case\n\t\twhen buy_frequency <=2 then 1\n\t\twhen buy_frequency <=4 then 2\n\t\twhen buy_frequency <=6 then 3\n\t\twhen buy_frequency <=8 then 4\n\t\telse 5 end\n\t)f_value\nfrom user_buy_fre_view\n```\n\n**M（monetary）购买金额**\n\n本案例数据中没有消费金额数据，所以本案例中不统计M指标。\n\n用R、F值建立4大用户分类。（因为只有2个指标，每个指标有2种结果，组合就是2^2次方，4个结果。如果是3个指标，就是2^3次方，8个结果）\n\n**整合结果**\n\n本次数据中通过最近消费(R)和消费频率(F)建立RFM模型\n\n- 重要高价值客户：指最近一次消费较近而且消费频率较高的客户\n- 重要唤回客户：指最近一次消费较远且消费频率较高的客户\n- 重要深耕客户：指最近一次消费较近且消费频率较低的客户 \n- 重要挽留客户：指最近一次消费较远且消费频率较低的客户\n\n我们按照最近一次消费的均值和消费频率的均值定高低界限。\n\n```sql\n-- 求R、F均值\nselect avg(r_value) r_avg from r_level -- 2.7939\nselect avg(f_value) f_avg from f_level -- 2.2606\n\nselect r_level.user_id, r_value, f_value,\n( case \n\twhen r_value >2.7939 and f_value > 2.2606 then '重要高价值客户'\n\twhen r_value <2.7939 and f_value > 2.2606 then '重要换回客户'\n\twhen r_value >2.7939 and f_value < 2.2606 then '重要深耕客户'\n\twhen r_value <2.7939 and f_value < 2.2606 then '重要挽留客户'\n\tend\n\t) user_class\nfrom r_level, f_level\nwhere r_level.user_id = f_level.user_id\n```\n\n### 商品指标\n\n本案例数据中没有商品金额，因此只能从现有的数据中寻找分析指标：\n\n商品id，用户行为类型(1-曝光、2-购买、3-加入购物⻋、4-加入收藏夹)，品类id\n\n两个维度：商品维度和品类维度\n\n- 商品维度\n\n  商品点击量（曝光量），收藏量，加购量，购买次数，购买转化（该商品的所有用户中有购买转化的用户比）\n\n  ```sql\n  -- 商品\n  select \n  \titem_id, \n  \tcount(if(behavior_type=1,item_id,null)),\n  \tsum(if(behavior_type=1,1,0)) pv,\n  \tsum(if(behavior_type=4,1,0)) fav,\n  \tsum(if(behavior_type=3,1,0)) cart,\n  \tsum(if(behavior_type=2,1,0)) buy,\n  \tcount(distinct if(behavior_type=2,user_id,null))/count(distinct user_id) buy_rate\n  \tfrom temp_trade group by item_id\n  ```\n\n- 品类维度\n\n  品类点击量（曝光量），收藏量，加购量，购买次数，购买转化（该商品品类的所有用户中有购买转化的用户比)\n\n  ```sql\n  -- 品类 \n  select \n  \titem_category, \n  \tcount(if(behavior_type=1,item_category,null)),\n  \tsum(if(behavior_type=1,1,0)) pv,\n  \tsum(if(behavior_type=4,1,0)) fav,\n  \tsum(if(behavior_type=3,1,0)) cart,\n  \tsum(if(behavior_type=2,1,0)) buy,\n  \tcount(distinct if(behavior_type=2,user_id,null))/count(distinct user_id) buy_rate\n  \tfrom temp_trade group by item_category\n  ```\n\n### 平台指标\n\n两个维度\n\n- 平台维度：平台每日的点击次数、收藏次数、加购次数、购买次数、购买转化\n\n  ```sql\n  \tselect \n  \t\tdates, \n  \t\tsum(if(behavior_type=1,1,0)) pv,\n  \t\tsum(if(behavior_type=4,1,0)) fav,\n  \t\tsum(if(behavior_type=3,1,0)) cart,\n  \t\tsum(if(behavior_type=2,1,0)) buy,\n  \t\tcount(distinct if(behavior_type=2,user_id,null))/count(distinct user_id) buy_rate\n  \tfrom temp_trade \n  \tgroup by dates\n  ```\n\n- 用户路径维度：\n\n  用户行为路径是针对某一个用户购买某一件商品。\n\n  ```sql\n  drop view if exists path_base_view;\n  create view path_base_view as\n  select a.*\n  from(\n  select \n  \tuser_id,item_id,\n  \tlag(behavior_type,4) over(partition by user_id,item_id order by date_time) lag4,\n  \tlag(behavior_type,3) over(partition by user_id,item_id order by date_time) lag3,\n  \tlag(behavior_type,2) over(partition by user_id,item_id order by date_time) lag2,\n  \tlag(behavior_type,1) over(partition by user_id,item_id order by date_time) lag1,\n  \tbehavior_type,\n  \trank() over(partition by user_id,item_id order by date_time desc) rank_number\n  from temp_trade\n  )a\n  where a.behavior_type = 2 and a.rank_number = 1 -- 只统计每个用户商品分组中，最后一次购买的记录\n  \n  select \n  \tconcat(ifnull(lag4,'空'),'-',ifnull(lag3,'空'),'-',ifnull(lag2,'空'),'-',ifnull(lag1,'空'),'-',behavior_type),\n  \tcount(distinct user_id)\n  from path_base_view\n  group by concat(ifnull(lag4,'空'),'-',ifnull(lag3,'空'),'-',ifnull(lag2,'空'),'-',ifnull(lag1,'空'),'-',behavior_type)\n  ```\n\n  ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-14_15-25-13.jpg)\n\n  为什么要分析用户行为路径？\n\n  根据分析结果可以看到，空-空-空-空-2 这个路径的用户是最多的，也就是直接购买涉及的用户最多。这也反映出加入购物车、收藏等功能大家用的少。\n\n  那在进行产品体验优化的时候就应该考虑，应该把购物车、收藏等功能丰富一下，看看怎么优化一下，让大家把它给用起来。\n\n  为什么要让大家把购物车、收藏功能用起来呢。试想一下，你可能直接购买了一个商品，然后就去支付。是你也支付了，也在平台消费了，但是你毕竟买的是一个商品。如果有购物车功能，并且大家把它都用起来的话，就如同你去超市推了一个购物车，我们不由自主的就想往购物车里放更多的商品，那当你最终购买的时候，相比于你花了好几分钟时间只够买了一个商品，给平台带来的利益更大。\n\n# 案例二 招聘网站岗位数据分析\n\n## 项目背景\n\n某线下培训机构 打算开设数据分析培训课程。需要对数据分析岗位的市场需求、就业情况、岗位技能做深入调研。\n\n公司内已开设学科有：游戏、运维。\n\n数据分析岗位的各项指标与已有学科进行对比。\n\n本次数据范围，仅针对北上广深四个一线城市进行分析。\n\n## 确认问题与目标拆解\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-14_15-54-59.jpg)\n\n","source":"_posts/【数据分析】第二阶段：MySQL数据分时实战（三）.md","raw":"---\ntitle: 【数据分析】第二阶段：MySQL数据分时实战（三）\ndate: 2021-05-11 11:14:17\ntags:\n- 数据分析\ncategories:\n- 学习笔记\ndescription: MySQL项目实战\n---\n\n# 案例一 基于**MySQL**的电商用户、商品、平台价值分析\n\n电商行业，从早年粗放式经营，到现在精细化运营。随平台数据量积累，通过数据分析挖掘消费者潜在需求。\n\n人-货-场 指标体系。人-用户，货-商品，场-平台。\n\n探索用户行为规律，寻找高价值用户（消费频率高，消费金额高）；分析商品特征，寻找高贡献商品（成交量大，利润高）；分析产品功能，优化产品路径。\n\n## 确认问题\n\n通过对用户行为数据进行分析，解决以下问题：\n\n- 基于漏斗模型的用户购买流程各环节分析指标，确定各个环节的转换率，便于找到需要改进的 环节。（优化产品）\n- 找出热销商品，研究热销商品特点。（找到热门产品）\n- 基于RFM模型找出核心付费用户群，对这部分用户进行精准营销。（找到高价值用户）\n\n## 搭建指标\n\n用户-商品-平台\n\n### 用户指标\n\n- 基础指标：uv、pv、dv（浏览深度）、留存率\n- RFM模型\n\n#### UV\n\nunique vistor，一定时间内访问网站的用户数总和。\n\n```sql\nselect \n\tdates,\n\t-- 统计每一天的用户数总和，使用count对user_id计数，其中可能存在一个用户有多次记录，因此去重\n\tcount(distinct user_id) uv,\n\tcount(if(behavior_type = 1, user_id, null)) pv, \n\tcount(if(behavior_type = 1, user_id, null)) / count(distinct user_id) dv\nfrom temp_trade\ngroup by dates -- 案例中要求计算每日pv、uv、dv，因此按日期分组\n```\n\n#### PV\n\npage view，一定时间内所有用户每次访问网站的页数总和。代表网站的用户粘性非常高，PV高网站的跳出率就低，说明网站内容更被用户喜欢。\n\n```sql\nselect \n\tdates,\n\tcount(distinct user_id) uv, \n\t-- 统计每天每个用户浏览网站的页数的总和，同一个用户在一天不同时间段多次浏览网页也被计算在内，因此不需要去重。\n\t-- 本案例中一条behavior_type=1（曝光）的记录视为用户浏览了一个页面，因此对一天中曝光的user_id计数。\n\tcount(if(behavior_type = 1, user_id, null)) pv, \n\tcount(if(behavior_type = 1, user_id, null)) / count(distinct user_id) dv\nfrom temp_trade\ngroup by dates -- 案例中要求计算每日pv、uv、dv，因此按日期分组\n```\n\n#### DV\n\nvisit depth，浏览深度（访问深度）。dv = pv / uv。用户在一次浏览网站的过程中浏览了网站的页数。如果用户一次性的浏览了你的网站的页数越多，那么就基本上可以认定，你的网站有他感兴趣的东西。用户访问网站的深度用数据可以理解为网站平均访问的页面数，就是pv和uv的比值，这个比值越大，用户体验度越好，网站的粘性也越高。\n\n#### 留存、留存率\n\n留存：相对于基准日活跃用户数量，n天后返回的用户数量。\n\n**⚠️注意：留存计算的是n天后返回的用户数量，而不是n天后的用户数量。**\n\n**比如，基准日有10个用户，次日也有10个，但其中8个用户是基准日的，剩下两个2个是新用户。次日留存是8而不是10。**\n\n留存率：n天后返回的用户数/基准日活跃用户数*100%\n\n留存率是用于反映网站、互联网应用或网络游戏的运营情况的统计指标，其具体含义为在统计周期（周/月）内，每日活跃用户数在第N日仍启动该App的用户数占比的平均值。其中N通常取2、3、7、14、30，分别对应次日留存率、三日留存率、周留存率、半月留存率和月留存率。留存率常用于反映用户粘性，当N取值越大、留存率越高时，用户粘性越高。\n\n先计算各日留存，进而就可以求出各日留存率。\n\n**❌错误思路：统计出每日活跃用户数，再按照日期筛选出对应日期的活跃用户数。**\n\n```sql\n-- 先对源数据按日期分组，然后count每日的user_id并去重，得到每日的活跃用户数。\ncreate view wrong1 as\nselect dates, count(distinct user_id) device_v\nfrom temp_trade\ngroup by dates\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_18-47-58.jpg)\n\n```sql\n-- 然后根据需求，筛选出对应日期的活跃用户数即可。\nselect \n\tdates _dates, device_v,\n\t(select device_v from wrong1 where dates = date_add(_dates,interval 1 day)) day_1,\n\t(select device_v from wrong1 where dates = date_add(_dates,interval 2 day)) day_2,\n\t(select device_v from wrong1 where dates = date_add(_dates,interval 3 day)) day_3,\n\t(select device_v from wrong1 where dates = date_add(_dates,interval 7 day)) day_7\nfrom wrong1\n```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_19-12-56.jpg)\n\n**错误原因：**\n\n> 第一步统计每日活跃用户数看似正确，但这并不能计算出留存。\n>\n> 比如，计算出1号有100个用户，2号有100个用户，那么1号的次日留存就是2号的100吗？并不是。\n>\n> 留存计算的是相对于基准日，n天后返回的用户数。重点在“返回”二字。基准日1号有100个用户，次日2号100个用户中，可能有80个是1号100个用户中的，剩下20个是2号新增的用户。所以1号的次日留存只有80，而不是100。\n>\n> 所以计算留存，并不是简单的统计出每日的活跃用户数，然后按照日期筛选。\n>\n> 而是要统计1号的user_id，在这批user_id中看2号出现了多少个、3号出现了多少个。再统计2号的user_id、3号的user_id...以此类推。\n\n**✅正确思路：统计每个日期有多少user_id，再统计每个日期的所有user_id在之后的2日、3日、...n日中出现的个数。**\n\n1. ```sql\n   select user_id, dates from temp_trade group by user_id,dates\n   -- 按user_id,dates分组，得到全部日期-每个日期的全部活跃用户(无重复) 结果集\n   ```\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_22-42-45.jpg) ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_22-43-07.jpg)\n\n2. ```sql\n   select *\n   from \n   (select user_id, dates from temp_trade group by user_id,dates) a \n   left join \n   (select user_id, dates from temp_trade group by user_id,dates) b \n   on a.user_id = b.user_id\n   -- 1结果集on user_id自关联，得到全部活跃用户-每个用户全部活跃日期-某个用户某一个活跃日期-某个用户全部活跃日期\n   ```\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_22-52-09.jpg)\n\n3. ```sql\n   select *\n   from \n   (select user_id, dates from temp_trade group by user_id,dates) a \n   left join \n   (select user_id, dates from temp_trade group by user_id,dates) b \n   on a.user_id = b.user_id\n   where b.dates >= a.dates\n   -- where过滤，得到全部活跃用户-每个用户全部活跃日期-某个用户某一个活跃日期-某个用户在该日期之后的全部活跃日期\n   ```\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_23-02-23.jpg)\n\n4. ```sql\n   select \n   \ta.dates,\n   \tcount(distinct a.user_id) device_v\n   from \n   (select user_id, dates from temp_trade group by user_id,dates) a\n   left join \n   (select user_id, dates from temp_trade group by user_id,dates) b \n   on a.user_id = b.user_id\n   where b.dates >= a.dates\n   group by a.dates\n   -- 按日期分组，每个分组就是-每个日期全部活跃用户-每个用户大于该日期的全部活跃日期\n   -- count(distinct a.user_id) 统计每个日期的活跃用户数，即基准日活跃用户数\n   ```\n\n   ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_23-06-28.jpg)\n\n5. ```sql\n   select \n   \ta.dates,\n   \tcount(distinct a.user_id) device_v,\n   \tcount(if(datediff(b.dates,a.dates)=1,a.user_id,null)) remain1\n   from \n   (select user_id, dates from temp_trade group by user_id,dates) a\n   left join \n   (select user_id, dates from temp_trade group by user_id,dates) b \n   on a.user_id = b.user_id\n   where b.dates >= a.dates\n   group by a.dates\n   -- 每个分组-每个日期全部活跃用户-每个用户大于该日期的全部活跃日期-每个用户大于该日期1天的记录-每个日期1天后还有多少用户\n   ```\n\n6. 以此类推\n\n   ```sql\n   create view user_remain_view as\n   select \n   \ta.dates,\n   \tcount(distinct a.user_id) device_v,\n   \tcount(if(datediff(b.dates,a.dates)=1,a.user_id,null)) remain1,\n   \tcount(if(datediff(b.dates,a.dates)=2,a.user_id,null)) remain2,\n   \tcount(if(datediff(b.dates,a.dates)=3,a.user_id,null)) remain3,\n   \tcount(if(datediff(b.dates,a.dates)=4,a.user_id,null)) remain4,\n   \tcount(if(datediff(b.dates,a.dates)=5,a.user_id,null)) remain5,\n   \tcount(if(datediff(b.dates,a.dates)=6,a.user_id,null)) remain6,\n   \tcount(if(datediff(b.dates,a.dates)=7,a.user_id,null)) remain7,\n   \tcount(if(datediff(b.dates,a.dates)=15,a.user_id,null)) remain15,\n   \tcount(if(datediff(b.dates,a.dates)=30,a.user_id,null)) remain30\n   from correct1 a left join correct1 b \n   on a.user_id = b.user_id\n   where b.dates >= a.dates\n   group by a.dates\n   ```\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-13_14-28-07.jpg)\n\n留存率\n\n```sql\nselect \n\tdates, \n\tdevice_v,\n\tconcat(cast((remain1/device_v*100) as decimal(10,2)),'%') day_1,\n\tconcat(cast((remain2/device_v*100) as decimal(10,2)),'%') day_2,\n\tconcat(cast((remain3/device_v*100) as decimal(10,2)),'%') day_3,\n\tconcat(cast((remain4/device_v*100) as decimal(10,2)),'%') day_4,\n\tconcat(cast((remain5/device_v*100) as decimal(10,2)),'%') day_5,\n\tconcat(cast((remain6/device_v*100) as decimal(10,2)),'%') day_6,\n\tconcat(cast((remain7/device_v*100) as decimal(10,2)),'%') day_7,\n\tconcat(cast((remain15/device_v*100) as decimal(10,2)),'%') day_15,\n\tconcat(cast((remain30/device_v*100) as decimal(10,2)),'%') day_30\nfrom user_remain_view\n```\n\ncast()函数将（任何类型的）值转换为指定的数据类型。\n\n```sql\n-- cast(值 as 数据类型)\n-- 将值转换为DATE数据类型：\nSELECT CAST(\"2017-08-29\" AS DATE); \n```\n\ndecimal数据类型，decimal是比dobule类型精度更高的浮点类型\n\n```sql\ndecimal(p, d)\n-- p表示有效位数\n-- d是表示小数点后的位数\n```\n\n#### RFM\n\n- 统计出所有用户的r值、f值、m值，各个值取平均值，以高于或低于平均值为标准评价用户质量。\n\n- RFM八大用户分类：\n\n  ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-13_15-57-06.jpg)\n\n**R（recency) 最近一次购买**\n\n- R ，统计每个用户的r值——统计每个用户最近的发生购买的日期——统计每个用户最近的购买日期和标准日期的天数差——按天数差给每个用户打分，得分就是每个用户r值。\n\n```sql\n-- 按user_id分组，找出每个用户最近一次发生购买的日期\ndrop view if exists user_recency;\ncreate view user_recency as\nselect user_id, max(dates) recency_date \nfrom temp_trade \nwhere behavior_type = 2 \ngroup by user_id \norder by recency_date desc\n\n-- 假设2019-12-18是统计日期，计算每个用户的最近购买日期和统计日期差多少天，按天数打分，打分就是r值\ncreate view r_level as\nselect \n\tuser_id, \n\trecency_date, \n\tdatediff('2019-12-18',recency_date) recen_num,\n\t(case\n\t\twhen datediff('2019-12-18',recency_date) <=2 then 5\n\t\twhen datediff('2019-12-18',recency_date) <=4 then 4\n\t\twhen datediff('2019-12-18',recency_date) <=6 then 3\n\t\twhen datediff('2019-12-18',recency_date) <=8 then 2\n\t\telse 1 end\n\t) r_value\nfrom user_recency\n```\n\n**F（frequency）购买频率**\n\n- F ，统计一定时间范围内（本案例中为整张表时间范围）每个用户发生购买的记录数，对记录数打分，分值就是F值 \n\n```sql\ndrop view if exists user_buy_fre_view;\ncreate view user_buy_fre_view as\nselect user_id,count(user_id) buy_frequency\nfrom temp_trade \nwhere behavior_type = 2\ngroup by user_id\n\ncreate view f_level as\nselect user_id, buy_frequency,\n\t(case\n\t\twhen buy_frequency <=2 then 1\n\t\twhen buy_frequency <=4 then 2\n\t\twhen buy_frequency <=6 then 3\n\t\twhen buy_frequency <=8 then 4\n\t\telse 5 end\n\t)f_value\nfrom user_buy_fre_view\n```\n\n**M（monetary）购买金额**\n\n本案例数据中没有消费金额数据，所以本案例中不统计M指标。\n\n用R、F值建立4大用户分类。（因为只有2个指标，每个指标有2种结果，组合就是2^2次方，4个结果。如果是3个指标，就是2^3次方，8个结果）\n\n**整合结果**\n\n本次数据中通过最近消费(R)和消费频率(F)建立RFM模型\n\n- 重要高价值客户：指最近一次消费较近而且消费频率较高的客户\n- 重要唤回客户：指最近一次消费较远且消费频率较高的客户\n- 重要深耕客户：指最近一次消费较近且消费频率较低的客户 \n- 重要挽留客户：指最近一次消费较远且消费频率较低的客户\n\n我们按照最近一次消费的均值和消费频率的均值定高低界限。\n\n```sql\n-- 求R、F均值\nselect avg(r_value) r_avg from r_level -- 2.7939\nselect avg(f_value) f_avg from f_level -- 2.2606\n\nselect r_level.user_id, r_value, f_value,\n( case \n\twhen r_value >2.7939 and f_value > 2.2606 then '重要高价值客户'\n\twhen r_value <2.7939 and f_value > 2.2606 then '重要换回客户'\n\twhen r_value >2.7939 and f_value < 2.2606 then '重要深耕客户'\n\twhen r_value <2.7939 and f_value < 2.2606 then '重要挽留客户'\n\tend\n\t) user_class\nfrom r_level, f_level\nwhere r_level.user_id = f_level.user_id\n```\n\n### 商品指标\n\n本案例数据中没有商品金额，因此只能从现有的数据中寻找分析指标：\n\n商品id，用户行为类型(1-曝光、2-购买、3-加入购物⻋、4-加入收藏夹)，品类id\n\n两个维度：商品维度和品类维度\n\n- 商品维度\n\n  商品点击量（曝光量），收藏量，加购量，购买次数，购买转化（该商品的所有用户中有购买转化的用户比）\n\n  ```sql\n  -- 商品\n  select \n  \titem_id, \n  \tcount(if(behavior_type=1,item_id,null)),\n  \tsum(if(behavior_type=1,1,0)) pv,\n  \tsum(if(behavior_type=4,1,0)) fav,\n  \tsum(if(behavior_type=3,1,0)) cart,\n  \tsum(if(behavior_type=2,1,0)) buy,\n  \tcount(distinct if(behavior_type=2,user_id,null))/count(distinct user_id) buy_rate\n  \tfrom temp_trade group by item_id\n  ```\n\n- 品类维度\n\n  品类点击量（曝光量），收藏量，加购量，购买次数，购买转化（该商品品类的所有用户中有购买转化的用户比)\n\n  ```sql\n  -- 品类 \n  select \n  \titem_category, \n  \tcount(if(behavior_type=1,item_category,null)),\n  \tsum(if(behavior_type=1,1,0)) pv,\n  \tsum(if(behavior_type=4,1,0)) fav,\n  \tsum(if(behavior_type=3,1,0)) cart,\n  \tsum(if(behavior_type=2,1,0)) buy,\n  \tcount(distinct if(behavior_type=2,user_id,null))/count(distinct user_id) buy_rate\n  \tfrom temp_trade group by item_category\n  ```\n\n### 平台指标\n\n两个维度\n\n- 平台维度：平台每日的点击次数、收藏次数、加购次数、购买次数、购买转化\n\n  ```sql\n  \tselect \n  \t\tdates, \n  \t\tsum(if(behavior_type=1,1,0)) pv,\n  \t\tsum(if(behavior_type=4,1,0)) fav,\n  \t\tsum(if(behavior_type=3,1,0)) cart,\n  \t\tsum(if(behavior_type=2,1,0)) buy,\n  \t\tcount(distinct if(behavior_type=2,user_id,null))/count(distinct user_id) buy_rate\n  \tfrom temp_trade \n  \tgroup by dates\n  ```\n\n- 用户路径维度：\n\n  用户行为路径是针对某一个用户购买某一件商品。\n\n  ```sql\n  drop view if exists path_base_view;\n  create view path_base_view as\n  select a.*\n  from(\n  select \n  \tuser_id,item_id,\n  \tlag(behavior_type,4) over(partition by user_id,item_id order by date_time) lag4,\n  \tlag(behavior_type,3) over(partition by user_id,item_id order by date_time) lag3,\n  \tlag(behavior_type,2) over(partition by user_id,item_id order by date_time) lag2,\n  \tlag(behavior_type,1) over(partition by user_id,item_id order by date_time) lag1,\n  \tbehavior_type,\n  \trank() over(partition by user_id,item_id order by date_time desc) rank_number\n  from temp_trade\n  )a\n  where a.behavior_type = 2 and a.rank_number = 1 -- 只统计每个用户商品分组中，最后一次购买的记录\n  \n  select \n  \tconcat(ifnull(lag4,'空'),'-',ifnull(lag3,'空'),'-',ifnull(lag2,'空'),'-',ifnull(lag1,'空'),'-',behavior_type),\n  \tcount(distinct user_id)\n  from path_base_view\n  group by concat(ifnull(lag4,'空'),'-',ifnull(lag3,'空'),'-',ifnull(lag2,'空'),'-',ifnull(lag1,'空'),'-',behavior_type)\n  ```\n\n  ![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-14_15-25-13.jpg)\n\n  为什么要分析用户行为路径？\n\n  根据分析结果可以看到，空-空-空-空-2 这个路径的用户是最多的，也就是直接购买涉及的用户最多。这也反映出加入购物车、收藏等功能大家用的少。\n\n  那在进行产品体验优化的时候就应该考虑，应该把购物车、收藏等功能丰富一下，看看怎么优化一下，让大家把它给用起来。\n\n  为什么要让大家把购物车、收藏功能用起来呢。试想一下，你可能直接购买了一个商品，然后就去支付。是你也支付了，也在平台消费了，但是你毕竟买的是一个商品。如果有购物车功能，并且大家把它都用起来的话，就如同你去超市推了一个购物车，我们不由自主的就想往购物车里放更多的商品，那当你最终购买的时候，相比于你花了好几分钟时间只够买了一个商品，给平台带来的利益更大。\n\n# 案例二 招聘网站岗位数据分析\n\n## 项目背景\n\n某线下培训机构 打算开设数据分析培训课程。需要对数据分析岗位的市场需求、就业情况、岗位技能做深入调研。\n\n公司内已开设学科有：游戏、运维。\n\n数据分析岗位的各项指标与已有学科进行对比。\n\n本次数据范围，仅针对北上广深四个一线城市进行分析。\n\n## 确认问题与目标拆解\n\n![](https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-14_15-54-59.jpg)\n\n","slug":"【数据分析】第二阶段：MySQL数据分时实战（三）","published":1,"updated":"2021-05-14T07:57:29.744Z","_id":"ckold8fi40000ryt4ew24et5m","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"案例一-基于MySQL的电商用户、商品、平台价值分析\"><a href=\"#案例一-基于MySQL的电商用户、商品、平台价值分析\" class=\"headerlink\" title=\"案例一 基于MySQL的电商用户、商品、平台价值分析\"></a>案例一 基于<strong>MySQL</strong>的电商用户、商品、平台价值分析</h1><p>电商行业，从早年粗放式经营，到现在精细化运营。随平台数据量积累，通过数据分析挖掘消费者潜在需求。</p>\n<p>人-货-场 指标体系。人-用户，货-商品，场-平台。</p>\n<p>探索用户行为规律，寻找高价值用户（消费频率高，消费金额高）；分析商品特征，寻找高贡献商品（成交量大，利润高）；分析产品功能，优化产品路径。</p>\n<h2 id=\"确认问题\"><a href=\"#确认问题\" class=\"headerlink\" title=\"确认问题\"></a>确认问题</h2><p>通过对用户行为数据进行分析，解决以下问题：</p>\n<ul>\n<li>基于漏斗模型的用户购买流程各环节分析指标，确定各个环节的转换率，便于找到需要改进的 环节。（优化产品）</li>\n<li>找出热销商品，研究热销商品特点。（找到热门产品）</li>\n<li>基于RFM模型找出核心付费用户群，对这部分用户进行精准营销。（找到高价值用户）</li>\n</ul>\n<h2 id=\"搭建指标\"><a href=\"#搭建指标\" class=\"headerlink\" title=\"搭建指标\"></a>搭建指标</h2><p>用户-商品-平台</p>\n<h3 id=\"用户指标\"><a href=\"#用户指标\" class=\"headerlink\" title=\"用户指标\"></a>用户指标</h3><ul>\n<li>基础指标：uv、pv、dv（浏览深度）、留存率</li>\n<li>RFM模型</li>\n</ul>\n<h4 id=\"UV\"><a href=\"#UV\" class=\"headerlink\" title=\"UV\"></a>UV</h4><p>unique vistor，一定时间内访问网站的用户数总和。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates,</span><br><span class=\"line\">\t<span class=\"comment\">-- 统计每一天的用户数总和，使用count对user_id计数，其中可能存在一个用户有多次记录，因此去重</span></span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) uv,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type <span class=\"operator\">=</span> <span class=\"number\">1</span>, user_id, <span class=\"keyword\">null</span>)) pv, </span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type <span class=\"operator\">=</span> <span class=\"number\">1</span>, user_id, <span class=\"keyword\">null</span>)) <span class=\"operator\">/</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) dv</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> dates <span class=\"comment\">-- 案例中要求计算每日pv、uv、dv，因此按日期分组</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"PV\"><a href=\"#PV\" class=\"headerlink\" title=\"PV\"></a>PV</h4><p>page view，一定时间内所有用户每次访问网站的页数总和。代表网站的用户粘性非常高，PV高网站的跳出率就低，说明网站内容更被用户喜欢。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) uv, </span><br><span class=\"line\">\t<span class=\"comment\">-- 统计每天每个用户浏览网站的页数的总和，同一个用户在一天不同时间段多次浏览网页也被计算在内，因此不需要去重。</span></span><br><span class=\"line\">\t<span class=\"comment\">-- 本案例中一条behavior_type=1（曝光）的记录视为用户浏览了一个页面，因此对一天中曝光的user_id计数。</span></span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type <span class=\"operator\">=</span> <span class=\"number\">1</span>, user_id, <span class=\"keyword\">null</span>)) pv, </span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type <span class=\"operator\">=</span> <span class=\"number\">1</span>, user_id, <span class=\"keyword\">null</span>)) <span class=\"operator\">/</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) dv</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> dates <span class=\"comment\">-- 案例中要求计算每日pv、uv、dv，因此按日期分组</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"DV\"><a href=\"#DV\" class=\"headerlink\" title=\"DV\"></a>DV</h4><p>visit depth，浏览深度（访问深度）。dv = pv / uv。用户在一次浏览网站的过程中浏览了网站的页数。如果用户一次性的浏览了你的网站的页数越多，那么就基本上可以认定，你的网站有他感兴趣的东西。用户访问网站的深度用数据可以理解为网站平均访问的页面数，就是pv和uv的比值，这个比值越大，用户体验度越好，网站的粘性也越高。</p>\n<h4 id=\"留存、留存率\"><a href=\"#留存、留存率\" class=\"headerlink\" title=\"留存、留存率\"></a>留存、留存率</h4><p>留存：相对于基准日活跃用户数量，n天后返回的用户数量。</p>\n<p><strong>⚠️注意：留存计算的是n天后返回的用户数量，而不是n天后的用户数量。</strong></p>\n<p><strong>比如，基准日有10个用户，次日也有10个，但其中8个用户是基准日的，剩下两个2个是新用户。次日留存是8而不是10。</strong></p>\n<p>留存率：n天后返回的用户数/基准日活跃用户数*100%</p>\n<p>留存率是用于反映网站、互联网应用或网络游戏的运营情况的统计指标，其具体含义为在统计周期（周/月）内，每日活跃用户数在第N日仍启动该App的用户数占比的平均值。其中N通常取2、3、7、14、30，分别对应次日留存率、三日留存率、周留存率、半月留存率和月留存率。留存率常用于反映用户粘性，当N取值越大、留存率越高时，用户粘性越高。</p>\n<p>先计算各日留存，进而就可以求出各日留存率。</p>\n<p><strong>❌错误思路：统计出每日活跃用户数，再按照日期筛选出对应日期的活跃用户数。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 先对源数据按日期分组，然后count每日的user_id并去重，得到每日的活跃用户数。</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> wrong1 <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> dates, <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) device_v</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> dates</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_18-47-58.jpg\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 然后根据需求，筛选出对应日期的活跃用户数即可。</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates _dates, device_v,</span><br><span class=\"line\">\t(<span class=\"keyword\">select</span> device_v <span class=\"keyword\">from</span> wrong1 <span class=\"keyword\">where</span> dates <span class=\"operator\">=</span> date_add(_dates,<span class=\"type\">interval</span> <span class=\"number\">1</span> <span class=\"keyword\">day</span>)) day_1,</span><br><span class=\"line\">\t(<span class=\"keyword\">select</span> device_v <span class=\"keyword\">from</span> wrong1 <span class=\"keyword\">where</span> dates <span class=\"operator\">=</span> date_add(_dates,<span class=\"type\">interval</span> <span class=\"number\">2</span> <span class=\"keyword\">day</span>)) day_2,</span><br><span class=\"line\">\t(<span class=\"keyword\">select</span> device_v <span class=\"keyword\">from</span> wrong1 <span class=\"keyword\">where</span> dates <span class=\"operator\">=</span> date_add(_dates,<span class=\"type\">interval</span> <span class=\"number\">3</span> <span class=\"keyword\">day</span>)) day_3,</span><br><span class=\"line\">\t(<span class=\"keyword\">select</span> device_v <span class=\"keyword\">from</span> wrong1 <span class=\"keyword\">where</span> dates <span class=\"operator\">=</span> date_add(_dates,<span class=\"type\">interval</span> <span class=\"number\">7</span> <span class=\"keyword\">day</span>)) day_7</span><br><span class=\"line\"><span class=\"keyword\">from</span> wrong1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_19-12-56.jpg\"></p>\n<p><strong>错误原因：</strong></p>\n<blockquote>\n<p>第一步统计每日活跃用户数看似正确，但这并不能计算出留存。</p>\n<p>比如，计算出1号有100个用户，2号有100个用户，那么1号的次日留存就是2号的100吗？并不是。</p>\n<p>留存计算的是相对于基准日，n天后返回的用户数。重点在“返回”二字。基准日1号有100个用户，次日2号100个用户中，可能有80个是1号100个用户中的，剩下20个是2号新增的用户。所以1号的次日留存只有80，而不是100。</p>\n<p>所以计算留存，并不是简单的统计出每日的活跃用户数，然后按照日期筛选。</p>\n<p>而是要统计1号的user_id，在这批user_id中看2号出现了多少个、3号出现了多少个。再统计2号的user_id、3号的user_id…以此类推。</p>\n</blockquote>\n<p><strong>✅正确思路：统计每个日期有多少user_id，再统计每个日期的所有user_id在之后的2日、3日、…n日中出现的个数。</strong></p>\n<ol>\n<li><p>```sql<br>select user_id, dates from temp_trade group by user_id,dates<br>– 按user_id,dates分组，得到全部日期-每个日期的全部活跃用户(无重复) 结果集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   ![](https:&#x2F;&#x2F;gitee.com&#x2F;ethan-H&#x2F;imghost&#x2F;raw&#x2F;master&#x2F;blog&#x2F;Xnip2021-05-12_22-42-45.jpg) ![](https:&#x2F;&#x2F;gitee.com&#x2F;ethan-H&#x2F;imghost&#x2F;raw&#x2F;master&#x2F;blog&#x2F;Xnip2021-05-12_22-43-07.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">2. &#96;&#96;&#96;sql</span><br><span class=\"line\">   select *</span><br><span class=\"line\">   from </span><br><span class=\"line\">   (select user_id, dates from temp_trade group by user_id,dates) a </span><br><span class=\"line\">   left join </span><br><span class=\"line\">   (select user_id, dates from temp_trade group by user_id,dates) b </span><br><span class=\"line\">   on a.user_id &#x3D; b.user_id</span><br><span class=\"line\">   -- 1结果集on user_id自关联，得到全部活跃用户-每个用户全部活跃日期-某个用户某一个活跃日期-某个用户全部活跃日期</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_22-52-09.jpg\"></p>\n</li>\n<li><p>```sql<br>select *<br>from<br>(select user_id, dates from temp_trade group by user_id,dates) a<br>left join<br>(select user_id, dates from temp_trade group by user_id,dates) b<br>on a.user_id = b.user_id<br>where b.dates &gt;= a.dates<br>– where过滤，得到全部活跃用户-每个用户全部活跃日期-某个用户某一个活跃日期-某个用户在该日期之后的全部活跃日期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   ![](https:&#x2F;&#x2F;gitee.com&#x2F;ethan-H&#x2F;imghost&#x2F;raw&#x2F;master&#x2F;blog&#x2F;Xnip2021-05-12_23-02-23.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">4. &#96;&#96;&#96;sql</span><br><span class=\"line\">   select </span><br><span class=\"line\">   \ta.dates,</span><br><span class=\"line\">   \tcount(distinct a.user_id) device_v</span><br><span class=\"line\">   from </span><br><span class=\"line\">   (select user_id, dates from temp_trade group by user_id,dates) a</span><br><span class=\"line\">   left join </span><br><span class=\"line\">   (select user_id, dates from temp_trade group by user_id,dates) b </span><br><span class=\"line\">   on a.user_id &#x3D; b.user_id</span><br><span class=\"line\">   where b.dates &gt;&#x3D; a.dates</span><br><span class=\"line\">   group by a.dates</span><br><span class=\"line\">   -- 按日期分组，每个分组就是-每个日期全部活跃用户-每个用户大于该日期的全部活跃日期</span><br><span class=\"line\">   -- count(distinct a.user_id) 统计每个日期的活跃用户数，即基准日活跃用户数</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_23-06-28.jpg\"></p>\n</li>\n<li><p>```sql<br>select </p>\n<pre><code>a.dates,\ncount(distinct a.user_id) device_v,\ncount(if(datediff(b.dates,a.dates)=1,a.user_id,null)) remain1\n</code></pre>\n<p>from<br>(select user_id, dates from temp_trade group by user_id,dates) a<br>left join<br>(select user_id, dates from temp_trade group by user_id,dates) b<br>on a.user_id = b.user_id<br>where b.dates &gt;= a.dates<br>group by a.dates<br>– 每个分组-每个日期全部活跃用户-每个用户大于该日期的全部活跃日期-每个用户大于该日期1天的记录-每个日期1天后还有多少用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">6. 以此类推</span><br><span class=\"line\"></span><br><span class=\"line\">   &#96;&#96;&#96;sql</span><br><span class=\"line\">   create view user_remain_view as</span><br><span class=\"line\">   select </span><br><span class=\"line\">   \ta.dates,</span><br><span class=\"line\">   \tcount(distinct a.user_id) device_v,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;1,a.user_id,null)) remain1,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;2,a.user_id,null)) remain2,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;3,a.user_id,null)) remain3,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;4,a.user_id,null)) remain4,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;5,a.user_id,null)) remain5,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;6,a.user_id,null)) remain6,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;7,a.user_id,null)) remain7,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;15,a.user_id,null)) remain15,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;30,a.user_id,null)) remain30</span><br><span class=\"line\">   from correct1 a left join correct1 b </span><br><span class=\"line\">   on a.user_id &#x3D; b.user_id</span><br><span class=\"line\">   where b.dates &gt;&#x3D; a.dates</span><br><span class=\"line\">   group by a.dates</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-13_14-28-07.jpg\"></p>\n<p>留存率</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates, </span><br><span class=\"line\">\tdevice_v,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain1<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_1,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain2<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_2,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain3<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_3,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain4<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_4,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain5<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_5,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain6<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_6,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain7<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_7,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain15<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_15,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain30<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_30</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_remain_view</span><br></pre></td></tr></table></figure>\n\n<p>cast()函数将（任何类型的）值转换为指定的数据类型。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- cast(值 as 数据类型)</span></span><br><span class=\"line\"><span class=\"comment\">-- 将值转换为DATE数据类型：</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">CAST</span>(&quot;2017-08-29&quot; <span class=\"keyword\">AS</span> <span class=\"type\">DATE</span>); </span><br></pre></td></tr></table></figure>\n\n<p>decimal数据类型，decimal是比dobule类型精度更高的浮点类型</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">decimal</span>(p, d)</span><br><span class=\"line\"><span class=\"comment\">-- p表示有效位数</span></span><br><span class=\"line\"><span class=\"comment\">-- d是表示小数点后的位数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RFM\"><a href=\"#RFM\" class=\"headerlink\" title=\"RFM\"></a>RFM</h4><ul>\n<li><p>统计出所有用户的r值、f值、m值，各个值取平均值，以高于或低于平均值为标准评价用户质量。</p>\n</li>\n<li><p>RFM八大用户分类：</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-13_15-57-06.jpg\"></p>\n</li>\n</ul>\n<p><strong>R（recency) 最近一次购买</strong></p>\n<ul>\n<li>R ，统计每个用户的r值——统计每个用户最近的发生购买的日期——统计每个用户最近的购买日期和标准日期的天数差——按天数差给每个用户打分，得分就是每个用户r值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 按user_id分组，找出每个用户最近一次发生购买的日期</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> if <span class=\"keyword\">exists</span> user_recency;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> user_recency <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> user_id, <span class=\"built_in\">max</span>(dates) recency_date </span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade </span><br><span class=\"line\"><span class=\"keyword\">where</span> behavior_type <span class=\"operator\">=</span> <span class=\"number\">2</span> </span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> user_id </span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> recency_date <span class=\"keyword\">desc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 假设2019-12-18是统计日期，计算每个用户的最近购买日期和统计日期差多少天，按天数打分，打分就是r值</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> r_level <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tuser_id, </span><br><span class=\"line\">\trecency_date, </span><br><span class=\"line\">\tdatediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) recen_num,</span><br><span class=\"line\">\t(<span class=\"keyword\">case</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> datediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) <span class=\"operator\">&lt;=</span><span class=\"number\">2</span> <span class=\"keyword\">then</span> <span class=\"number\">5</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> datediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) <span class=\"operator\">&lt;=</span><span class=\"number\">4</span> <span class=\"keyword\">then</span> <span class=\"number\">4</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> datediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) <span class=\"operator\">&lt;=</span><span class=\"number\">6</span> <span class=\"keyword\">then</span> <span class=\"number\">3</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> datediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) <span class=\"operator\">&lt;=</span><span class=\"number\">8</span> <span class=\"keyword\">then</span> <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"number\">1</span> <span class=\"keyword\">end</span></span><br><span class=\"line\">\t) r_value</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_recency</span><br></pre></td></tr></table></figure>\n\n<p><strong>F（frequency）购买频率</strong></p>\n<ul>\n<li>F ，统计一定时间范围内（本案例中为整张表时间范围）每个用户发生购买的记录数，对记录数打分，分值就是F值 </li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> if <span class=\"keyword\">exists</span> user_buy_fre_view;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> user_buy_fre_view <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> user_id,<span class=\"built_in\">count</span>(user_id) buy_frequency</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade </span><br><span class=\"line\"><span class=\"keyword\">where</span> behavior_type <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> user_id</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> f_level <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> user_id, buy_frequency,</span><br><span class=\"line\">\t(<span class=\"keyword\">case</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> buy_frequency <span class=\"operator\">&lt;=</span><span class=\"number\">2</span> <span class=\"keyword\">then</span> <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> buy_frequency <span class=\"operator\">&lt;=</span><span class=\"number\">4</span> <span class=\"keyword\">then</span> <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> buy_frequency <span class=\"operator\">&lt;=</span><span class=\"number\">6</span> <span class=\"keyword\">then</span> <span class=\"number\">3</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> buy_frequency <span class=\"operator\">&lt;=</span><span class=\"number\">8</span> <span class=\"keyword\">then</span> <span class=\"number\">4</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"number\">5</span> <span class=\"keyword\">end</span></span><br><span class=\"line\">\t)f_value</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_buy_fre_view</span><br></pre></td></tr></table></figure>\n\n<p><strong>M（monetary）购买金额</strong></p>\n<p>本案例数据中没有消费金额数据，所以本案例中不统计M指标。</p>\n<p>用R、F值建立4大用户分类。（因为只有2个指标，每个指标有2种结果，组合就是2^2次方，4个结果。如果是3个指标，就是2^3次方，8个结果）</p>\n<p><strong>整合结果</strong></p>\n<p>本次数据中通过最近消费(R)和消费频率(F)建立RFM模型</p>\n<ul>\n<li>重要高价值客户：指最近一次消费较近而且消费频率较高的客户</li>\n<li>重要唤回客户：指最近一次消费较远且消费频率较高的客户</li>\n<li>重要深耕客户：指最近一次消费较近且消费频率较低的客户 </li>\n<li>重要挽留客户：指最近一次消费较远且消费频率较低的客户</li>\n</ul>\n<p>我们按照最近一次消费的均值和消费频率的均值定高低界限。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 求R、F均值</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">avg</span>(r_value) r_avg <span class=\"keyword\">from</span> r_level <span class=\"comment\">-- 2.7939</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">avg</span>(f_value) f_avg <span class=\"keyword\">from</span> f_level <span class=\"comment\">-- 2.2606</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> r_level.user_id, r_value, f_value,</span><br><span class=\"line\">( <span class=\"keyword\">case</span> </span><br><span class=\"line\">\t<span class=\"keyword\">when</span> r_value <span class=\"operator\">&gt;</span><span class=\"number\">2.7939</span> <span class=\"keyword\">and</span> f_value <span class=\"operator\">&gt;</span> <span class=\"number\">2.2606</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;重要高价值客户&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">when</span> r_value <span class=\"operator\">&lt;</span><span class=\"number\">2.7939</span> <span class=\"keyword\">and</span> f_value <span class=\"operator\">&gt;</span> <span class=\"number\">2.2606</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;重要换回客户&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">when</span> r_value <span class=\"operator\">&gt;</span><span class=\"number\">2.7939</span> <span class=\"keyword\">and</span> f_value <span class=\"operator\">&lt;</span> <span class=\"number\">2.2606</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;重要深耕客户&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">when</span> r_value <span class=\"operator\">&lt;</span><span class=\"number\">2.7939</span> <span class=\"keyword\">and</span> f_value <span class=\"operator\">&lt;</span> <span class=\"number\">2.2606</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;重要挽留客户&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t) user_class</span><br><span class=\"line\"><span class=\"keyword\">from</span> r_level, f_level</span><br><span class=\"line\"><span class=\"keyword\">where</span> r_level.user_id <span class=\"operator\">=</span> f_level.user_id</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"商品指标\"><a href=\"#商品指标\" class=\"headerlink\" title=\"商品指标\"></a>商品指标</h3><p>本案例数据中没有商品金额，因此只能从现有的数据中寻找分析指标：</p>\n<p>商品id，用户行为类型(1-曝光、2-购买、3-加入购物⻋、4-加入收藏夹)，品类id</p>\n<p>两个维度：商品维度和品类维度</p>\n<ul>\n<li><p>商品维度</p>\n<p>商品点击量（曝光量），收藏量，加购量，购买次数，购买转化（该商品的所有用户中有购买转化的用户比）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 商品</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\titem_id, </span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,item_id,<span class=\"keyword\">null</span>)),</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) pv,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) fav,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) cart,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) buy,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,user_id,<span class=\"keyword\">null</span>))<span class=\"operator\">/</span><span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) buy_rate</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> temp_trade <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> item_id</span><br></pre></td></tr></table></figure></li>\n<li><p>品类维度</p>\n<p>品类点击量（曝光量），收藏量，加购量，购买次数，购买转化（该商品品类的所有用户中有购买转化的用户比)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 品类 </span></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\titem_category, </span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,item_category,<span class=\"keyword\">null</span>)),</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) pv,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) fav,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) cart,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) buy,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,user_id,<span class=\"keyword\">null</span>))<span class=\"operator\">/</span><span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) buy_rate</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> temp_trade <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> item_category</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"平台指标\"><a href=\"#平台指标\" class=\"headerlink\" title=\"平台指标\"></a>平台指标</h3><p>两个维度</p>\n<ul>\n<li><p>平台维度：平台每日的点击次数、收藏次数、加购次数、购买次数、购买转化</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates, </span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) pv,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) fav,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) cart,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) buy,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,user_id,<span class=\"keyword\">null</span>))<span class=\"operator\">/</span><span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) buy_rate</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade </span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> dates</span><br></pre></td></tr></table></figure></li>\n<li><p>用户路径维度：</p>\n<p>用户行为路径是针对某一个用户购买某一件商品。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> if <span class=\"keyword\">exists</span> path_base_view;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> path_base_view <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> a.<span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">from</span>(</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tuser_id,item_id,</span><br><span class=\"line\">\t<span class=\"built_in\">lag</span>(behavior_type,<span class=\"number\">4</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time) lag4,</span><br><span class=\"line\">\t<span class=\"built_in\">lag</span>(behavior_type,<span class=\"number\">3</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time) lag3,</span><br><span class=\"line\">\t<span class=\"built_in\">lag</span>(behavior_type,<span class=\"number\">2</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time) lag2,</span><br><span class=\"line\">\t<span class=\"built_in\">lag</span>(behavior_type,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time) lag1,</span><br><span class=\"line\">\tbehavior_type,</span><br><span class=\"line\">\t<span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time <span class=\"keyword\">desc</span>) rank_number</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade</span><br><span class=\"line\">)a</span><br><span class=\"line\"><span class=\"keyword\">where</span> a.behavior_type <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">and</span> a.rank_number <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"comment\">-- 只统计每个用户商品分组中，最后一次购买的记录</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tconcat(ifnull(lag4,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag3,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag2,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag1,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,behavior_type),</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id)</span><br><span class=\"line\"><span class=\"keyword\">from</span> path_base_view</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> concat(ifnull(lag4,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag3,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag2,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag1,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,behavior_type)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-14_15-25-13.jpg\"></p>\n<p>为什么要分析用户行为路径？</p>\n<p>根据分析结果可以看到，空-空-空-空-2 这个路径的用户是最多的，也就是直接购买涉及的用户最多。这也反映出加入购物车、收藏等功能大家用的少。</p>\n<p>那在进行产品体验优化的时候就应该考虑，应该把购物车、收藏等功能丰富一下，看看怎么优化一下，让大家把它给用起来。</p>\n<p>为什么要让大家把购物车、收藏功能用起来呢。试想一下，你可能直接购买了一个商品，然后就去支付。是你也支付了，也在平台消费了，但是你毕竟买的是一个商品。如果有购物车功能，并且大家把它都用起来的话，就如同你去超市推了一个购物车，我们不由自主的就想往购物车里放更多的商品，那当你最终购买的时候，相比于你花了好几分钟时间只够买了一个商品，给平台带来的利益更大。</p>\n</li>\n</ul>\n<h1 id=\"案例二-招聘网站岗位数据分析\"><a href=\"#案例二-招聘网站岗位数据分析\" class=\"headerlink\" title=\"案例二 招聘网站岗位数据分析\"></a>案例二 招聘网站岗位数据分析</h1><h2 id=\"项目背景\"><a href=\"#项目背景\" class=\"headerlink\" title=\"项目背景\"></a>项目背景</h2><p>某线下培训机构 打算开设数据分析培训课程。需要对数据分析岗位的市场需求、就业情况、岗位技能做深入调研。</p>\n<p>公司内已开设学科有：游戏、运维。</p>\n<p>数据分析岗位的各项指标与已有学科进行对比。</p>\n<p>本次数据范围，仅针对北上广深四个一线城市进行分析。</p>\n<h2 id=\"确认问题与目标拆解\"><a href=\"#确认问题与目标拆解\" class=\"headerlink\" title=\"确认问题与目标拆解\"></a>确认问题与目标拆解</h2><p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-14_15-54-59.jpg\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"案例一-基于MySQL的电商用户、商品、平台价值分析\"><a href=\"#案例一-基于MySQL的电商用户、商品、平台价值分析\" class=\"headerlink\" title=\"案例一 基于MySQL的电商用户、商品、平台价值分析\"></a>案例一 基于<strong>MySQL</strong>的电商用户、商品、平台价值分析</h1><p>电商行业，从早年粗放式经营，到现在精细化运营。随平台数据量积累，通过数据分析挖掘消费者潜在需求。</p>\n<p>人-货-场 指标体系。人-用户，货-商品，场-平台。</p>\n<p>探索用户行为规律，寻找高价值用户（消费频率高，消费金额高）；分析商品特征，寻找高贡献商品（成交量大，利润高）；分析产品功能，优化产品路径。</p>\n<h2 id=\"确认问题\"><a href=\"#确认问题\" class=\"headerlink\" title=\"确认问题\"></a>确认问题</h2><p>通过对用户行为数据进行分析，解决以下问题：</p>\n<ul>\n<li>基于漏斗模型的用户购买流程各环节分析指标，确定各个环节的转换率，便于找到需要改进的 环节。（优化产品）</li>\n<li>找出热销商品，研究热销商品特点。（找到热门产品）</li>\n<li>基于RFM模型找出核心付费用户群，对这部分用户进行精准营销。（找到高价值用户）</li>\n</ul>\n<h2 id=\"搭建指标\"><a href=\"#搭建指标\" class=\"headerlink\" title=\"搭建指标\"></a>搭建指标</h2><p>用户-商品-平台</p>\n<h3 id=\"用户指标\"><a href=\"#用户指标\" class=\"headerlink\" title=\"用户指标\"></a>用户指标</h3><ul>\n<li>基础指标：uv、pv、dv（浏览深度）、留存率</li>\n<li>RFM模型</li>\n</ul>\n<h4 id=\"UV\"><a href=\"#UV\" class=\"headerlink\" title=\"UV\"></a>UV</h4><p>unique vistor，一定时间内访问网站的用户数总和。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates,</span><br><span class=\"line\">\t<span class=\"comment\">-- 统计每一天的用户数总和，使用count对user_id计数，其中可能存在一个用户有多次记录，因此去重</span></span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) uv,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type <span class=\"operator\">=</span> <span class=\"number\">1</span>, user_id, <span class=\"keyword\">null</span>)) pv, </span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type <span class=\"operator\">=</span> <span class=\"number\">1</span>, user_id, <span class=\"keyword\">null</span>)) <span class=\"operator\">/</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) dv</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> dates <span class=\"comment\">-- 案例中要求计算每日pv、uv、dv，因此按日期分组</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"PV\"><a href=\"#PV\" class=\"headerlink\" title=\"PV\"></a>PV</h4><p>page view，一定时间内所有用户每次访问网站的页数总和。代表网站的用户粘性非常高，PV高网站的跳出率就低，说明网站内容更被用户喜欢。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) uv, </span><br><span class=\"line\">\t<span class=\"comment\">-- 统计每天每个用户浏览网站的页数的总和，同一个用户在一天不同时间段多次浏览网页也被计算在内，因此不需要去重。</span></span><br><span class=\"line\">\t<span class=\"comment\">-- 本案例中一条behavior_type=1（曝光）的记录视为用户浏览了一个页面，因此对一天中曝光的user_id计数。</span></span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type <span class=\"operator\">=</span> <span class=\"number\">1</span>, user_id, <span class=\"keyword\">null</span>)) pv, </span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type <span class=\"operator\">=</span> <span class=\"number\">1</span>, user_id, <span class=\"keyword\">null</span>)) <span class=\"operator\">/</span> <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) dv</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> dates <span class=\"comment\">-- 案例中要求计算每日pv、uv、dv，因此按日期分组</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"DV\"><a href=\"#DV\" class=\"headerlink\" title=\"DV\"></a>DV</h4><p>visit depth，浏览深度（访问深度）。dv = pv / uv。用户在一次浏览网站的过程中浏览了网站的页数。如果用户一次性的浏览了你的网站的页数越多，那么就基本上可以认定，你的网站有他感兴趣的东西。用户访问网站的深度用数据可以理解为网站平均访问的页面数，就是pv和uv的比值，这个比值越大，用户体验度越好，网站的粘性也越高。</p>\n<h4 id=\"留存、留存率\"><a href=\"#留存、留存率\" class=\"headerlink\" title=\"留存、留存率\"></a>留存、留存率</h4><p>留存：相对于基准日活跃用户数量，n天后返回的用户数量。</p>\n<p><strong>⚠️注意：留存计算的是n天后返回的用户数量，而不是n天后的用户数量。</strong></p>\n<p><strong>比如，基准日有10个用户，次日也有10个，但其中8个用户是基准日的，剩下两个2个是新用户。次日留存是8而不是10。</strong></p>\n<p>留存率：n天后返回的用户数/基准日活跃用户数*100%</p>\n<p>留存率是用于反映网站、互联网应用或网络游戏的运营情况的统计指标，其具体含义为在统计周期（周/月）内，每日活跃用户数在第N日仍启动该App的用户数占比的平均值。其中N通常取2、3、7、14、30，分别对应次日留存率、三日留存率、周留存率、半月留存率和月留存率。留存率常用于反映用户粘性，当N取值越大、留存率越高时，用户粘性越高。</p>\n<p>先计算各日留存，进而就可以求出各日留存率。</p>\n<p><strong>❌错误思路：统计出每日活跃用户数，再按照日期筛选出对应日期的活跃用户数。</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 先对源数据按日期分组，然后count每日的user_id并去重，得到每日的活跃用户数。</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> wrong1 <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> dates, <span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) device_v</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> dates</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_18-47-58.jpg\"></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 然后根据需求，筛选出对应日期的活跃用户数即可。</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates _dates, device_v,</span><br><span class=\"line\">\t(<span class=\"keyword\">select</span> device_v <span class=\"keyword\">from</span> wrong1 <span class=\"keyword\">where</span> dates <span class=\"operator\">=</span> date_add(_dates,<span class=\"type\">interval</span> <span class=\"number\">1</span> <span class=\"keyword\">day</span>)) day_1,</span><br><span class=\"line\">\t(<span class=\"keyword\">select</span> device_v <span class=\"keyword\">from</span> wrong1 <span class=\"keyword\">where</span> dates <span class=\"operator\">=</span> date_add(_dates,<span class=\"type\">interval</span> <span class=\"number\">2</span> <span class=\"keyword\">day</span>)) day_2,</span><br><span class=\"line\">\t(<span class=\"keyword\">select</span> device_v <span class=\"keyword\">from</span> wrong1 <span class=\"keyword\">where</span> dates <span class=\"operator\">=</span> date_add(_dates,<span class=\"type\">interval</span> <span class=\"number\">3</span> <span class=\"keyword\">day</span>)) day_3,</span><br><span class=\"line\">\t(<span class=\"keyword\">select</span> device_v <span class=\"keyword\">from</span> wrong1 <span class=\"keyword\">where</span> dates <span class=\"operator\">=</span> date_add(_dates,<span class=\"type\">interval</span> <span class=\"number\">7</span> <span class=\"keyword\">day</span>)) day_7</span><br><span class=\"line\"><span class=\"keyword\">from</span> wrong1</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_19-12-56.jpg\"></p>\n<p><strong>错误原因：</strong></p>\n<blockquote>\n<p>第一步统计每日活跃用户数看似正确，但这并不能计算出留存。</p>\n<p>比如，计算出1号有100个用户，2号有100个用户，那么1号的次日留存就是2号的100吗？并不是。</p>\n<p>留存计算的是相对于基准日，n天后返回的用户数。重点在“返回”二字。基准日1号有100个用户，次日2号100个用户中，可能有80个是1号100个用户中的，剩下20个是2号新增的用户。所以1号的次日留存只有80，而不是100。</p>\n<p>所以计算留存，并不是简单的统计出每日的活跃用户数，然后按照日期筛选。</p>\n<p>而是要统计1号的user_id，在这批user_id中看2号出现了多少个、3号出现了多少个。再统计2号的user_id、3号的user_id…以此类推。</p>\n</blockquote>\n<p><strong>✅正确思路：统计每个日期有多少user_id，再统计每个日期的所有user_id在之后的2日、3日、…n日中出现的个数。</strong></p>\n<ol>\n<li><p>```sql<br>select user_id, dates from temp_trade group by user_id,dates<br>– 按user_id,dates分组，得到全部日期-每个日期的全部活跃用户(无重复) 结果集</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   ![](https:&#x2F;&#x2F;gitee.com&#x2F;ethan-H&#x2F;imghost&#x2F;raw&#x2F;master&#x2F;blog&#x2F;Xnip2021-05-12_22-42-45.jpg) ![](https:&#x2F;&#x2F;gitee.com&#x2F;ethan-H&#x2F;imghost&#x2F;raw&#x2F;master&#x2F;blog&#x2F;Xnip2021-05-12_22-43-07.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">2. &#96;&#96;&#96;sql</span><br><span class=\"line\">   select *</span><br><span class=\"line\">   from </span><br><span class=\"line\">   (select user_id, dates from temp_trade group by user_id,dates) a </span><br><span class=\"line\">   left join </span><br><span class=\"line\">   (select user_id, dates from temp_trade group by user_id,dates) b </span><br><span class=\"line\">   on a.user_id &#x3D; b.user_id</span><br><span class=\"line\">   -- 1结果集on user_id自关联，得到全部活跃用户-每个用户全部活跃日期-某个用户某一个活跃日期-某个用户全部活跃日期</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_22-52-09.jpg\"></p>\n</li>\n<li><p>```sql<br>select *<br>from<br>(select user_id, dates from temp_trade group by user_id,dates) a<br>left join<br>(select user_id, dates from temp_trade group by user_id,dates) b<br>on a.user_id = b.user_id<br>where b.dates &gt;= a.dates<br>– where过滤，得到全部活跃用户-每个用户全部活跃日期-某个用户某一个活跃日期-某个用户在该日期之后的全部活跃日期</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">   ![](https:&#x2F;&#x2F;gitee.com&#x2F;ethan-H&#x2F;imghost&#x2F;raw&#x2F;master&#x2F;blog&#x2F;Xnip2021-05-12_23-02-23.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">4. &#96;&#96;&#96;sql</span><br><span class=\"line\">   select </span><br><span class=\"line\">   \ta.dates,</span><br><span class=\"line\">   \tcount(distinct a.user_id) device_v</span><br><span class=\"line\">   from </span><br><span class=\"line\">   (select user_id, dates from temp_trade group by user_id,dates) a</span><br><span class=\"line\">   left join </span><br><span class=\"line\">   (select user_id, dates from temp_trade group by user_id,dates) b </span><br><span class=\"line\">   on a.user_id &#x3D; b.user_id</span><br><span class=\"line\">   where b.dates &gt;&#x3D; a.dates</span><br><span class=\"line\">   group by a.dates</span><br><span class=\"line\">   -- 按日期分组，每个分组就是-每个日期全部活跃用户-每个用户大于该日期的全部活跃日期</span><br><span class=\"line\">   -- count(distinct a.user_id) 统计每个日期的活跃用户数，即基准日活跃用户数</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-12_23-06-28.jpg\"></p>\n</li>\n<li><p>```sql<br>select </p>\n<pre><code>a.dates,\ncount(distinct a.user_id) device_v,\ncount(if(datediff(b.dates,a.dates)=1,a.user_id,null)) remain1\n</code></pre>\n<p>from<br>(select user_id, dates from temp_trade group by user_id,dates) a<br>left join<br>(select user_id, dates from temp_trade group by user_id,dates) b<br>on a.user_id = b.user_id<br>where b.dates &gt;= a.dates<br>group by a.dates<br>– 每个分组-每个日期全部活跃用户-每个用户大于该日期的全部活跃日期-每个用户大于该日期1天的记录-每个日期1天后还有多少用户</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">6. 以此类推</span><br><span class=\"line\"></span><br><span class=\"line\">   &#96;&#96;&#96;sql</span><br><span class=\"line\">   create view user_remain_view as</span><br><span class=\"line\">   select </span><br><span class=\"line\">   \ta.dates,</span><br><span class=\"line\">   \tcount(distinct a.user_id) device_v,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;1,a.user_id,null)) remain1,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;2,a.user_id,null)) remain2,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;3,a.user_id,null)) remain3,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;4,a.user_id,null)) remain4,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;5,a.user_id,null)) remain5,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;6,a.user_id,null)) remain6,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;7,a.user_id,null)) remain7,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;15,a.user_id,null)) remain15,</span><br><span class=\"line\">   \tcount(if(datediff(b.dates,a.dates)&#x3D;30,a.user_id,null)) remain30</span><br><span class=\"line\">   from correct1 a left join correct1 b </span><br><span class=\"line\">   on a.user_id &#x3D; b.user_id</span><br><span class=\"line\">   where b.dates &gt;&#x3D; a.dates</span><br><span class=\"line\">   group by a.dates</span><br></pre></td></tr></table></figure></li>\n</ol>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-13_14-28-07.jpg\"></p>\n<p>留存率</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates, </span><br><span class=\"line\">\tdevice_v,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain1<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_1,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain2<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_2,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain3<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_3,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain4<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_4,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain5<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_5,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain6<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_6,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain7<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_7,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain15<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_15,</span><br><span class=\"line\">\tconcat(<span class=\"built_in\">cast</span>((remain30<span class=\"operator\">/</span>device_v<span class=\"operator\">*</span><span class=\"number\">100</span>) <span class=\"keyword\">as</span> <span class=\"type\">decimal</span>(<span class=\"number\">10</span>,<span class=\"number\">2</span>)),<span class=\"string\">&#x27;%&#x27;</span>) day_30</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_remain_view</span><br></pre></td></tr></table></figure>\n\n<p>cast()函数将（任何类型的）值转换为指定的数据类型。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- cast(值 as 数据类型)</span></span><br><span class=\"line\"><span class=\"comment\">-- 将值转换为DATE数据类型：</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"built_in\">CAST</span>(&quot;2017-08-29&quot; <span class=\"keyword\">AS</span> <span class=\"type\">DATE</span>); </span><br></pre></td></tr></table></figure>\n\n<p>decimal数据类型，decimal是比dobule类型精度更高的浮点类型</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">decimal</span>(p, d)</span><br><span class=\"line\"><span class=\"comment\">-- p表示有效位数</span></span><br><span class=\"line\"><span class=\"comment\">-- d是表示小数点后的位数</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RFM\"><a href=\"#RFM\" class=\"headerlink\" title=\"RFM\"></a>RFM</h4><ul>\n<li><p>统计出所有用户的r值、f值、m值，各个值取平均值，以高于或低于平均值为标准评价用户质量。</p>\n</li>\n<li><p>RFM八大用户分类：</p>\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-13_15-57-06.jpg\"></p>\n</li>\n</ul>\n<p><strong>R（recency) 最近一次购买</strong></p>\n<ul>\n<li>R ，统计每个用户的r值——统计每个用户最近的发生购买的日期——统计每个用户最近的购买日期和标准日期的天数差——按天数差给每个用户打分，得分就是每个用户r值。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 按user_id分组，找出每个用户最近一次发生购买的日期</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> if <span class=\"keyword\">exists</span> user_recency;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> user_recency <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> user_id, <span class=\"built_in\">max</span>(dates) recency_date </span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade </span><br><span class=\"line\"><span class=\"keyword\">where</span> behavior_type <span class=\"operator\">=</span> <span class=\"number\">2</span> </span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> user_id </span><br><span class=\"line\"><span class=\"keyword\">order</span> <span class=\"keyword\">by</span> recency_date <span class=\"keyword\">desc</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 假设2019-12-18是统计日期，计算每个用户的最近购买日期和统计日期差多少天，按天数打分，打分就是r值</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> r_level <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tuser_id, </span><br><span class=\"line\">\trecency_date, </span><br><span class=\"line\">\tdatediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) recen_num,</span><br><span class=\"line\">\t(<span class=\"keyword\">case</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> datediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) <span class=\"operator\">&lt;=</span><span class=\"number\">2</span> <span class=\"keyword\">then</span> <span class=\"number\">5</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> datediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) <span class=\"operator\">&lt;=</span><span class=\"number\">4</span> <span class=\"keyword\">then</span> <span class=\"number\">4</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> datediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) <span class=\"operator\">&lt;=</span><span class=\"number\">6</span> <span class=\"keyword\">then</span> <span class=\"number\">3</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> datediff(<span class=\"string\">&#x27;2019-12-18&#x27;</span>,recency_date) <span class=\"operator\">&lt;=</span><span class=\"number\">8</span> <span class=\"keyword\">then</span> <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"number\">1</span> <span class=\"keyword\">end</span></span><br><span class=\"line\">\t) r_value</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_recency</span><br></pre></td></tr></table></figure>\n\n<p><strong>F（frequency）购买频率</strong></p>\n<ul>\n<li>F ，统计一定时间范围内（本案例中为整张表时间范围）每个用户发生购买的记录数，对记录数打分，分值就是F值 </li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> if <span class=\"keyword\">exists</span> user_buy_fre_view;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> user_buy_fre_view <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> user_id,<span class=\"built_in\">count</span>(user_id) buy_frequency</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade </span><br><span class=\"line\"><span class=\"keyword\">where</span> behavior_type <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> user_id</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> f_level <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> user_id, buy_frequency,</span><br><span class=\"line\">\t(<span class=\"keyword\">case</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> buy_frequency <span class=\"operator\">&lt;=</span><span class=\"number\">2</span> <span class=\"keyword\">then</span> <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> buy_frequency <span class=\"operator\">&lt;=</span><span class=\"number\">4</span> <span class=\"keyword\">then</span> <span class=\"number\">2</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> buy_frequency <span class=\"operator\">&lt;=</span><span class=\"number\">6</span> <span class=\"keyword\">then</span> <span class=\"number\">3</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> buy_frequency <span class=\"operator\">&lt;=</span><span class=\"number\">8</span> <span class=\"keyword\">then</span> <span class=\"number\">4</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> <span class=\"number\">5</span> <span class=\"keyword\">end</span></span><br><span class=\"line\">\t)f_value</span><br><span class=\"line\"><span class=\"keyword\">from</span> user_buy_fre_view</span><br></pre></td></tr></table></figure>\n\n<p><strong>M（monetary）购买金额</strong></p>\n<p>本案例数据中没有消费金额数据，所以本案例中不统计M指标。</p>\n<p>用R、F值建立4大用户分类。（因为只有2个指标，每个指标有2种结果，组合就是2^2次方，4个结果。如果是3个指标，就是2^3次方，8个结果）</p>\n<p><strong>整合结果</strong></p>\n<p>本次数据中通过最近消费(R)和消费频率(F)建立RFM模型</p>\n<ul>\n<li>重要高价值客户：指最近一次消费较近而且消费频率较高的客户</li>\n<li>重要唤回客户：指最近一次消费较远且消费频率较高的客户</li>\n<li>重要深耕客户：指最近一次消费较近且消费频率较低的客户 </li>\n<li>重要挽留客户：指最近一次消费较远且消费频率较低的客户</li>\n</ul>\n<p>我们按照最近一次消费的均值和消费频率的均值定高低界限。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 求R、F均值</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">avg</span>(r_value) r_avg <span class=\"keyword\">from</span> r_level <span class=\"comment\">-- 2.7939</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"built_in\">avg</span>(f_value) f_avg <span class=\"keyword\">from</span> f_level <span class=\"comment\">-- 2.2606</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> r_level.user_id, r_value, f_value,</span><br><span class=\"line\">( <span class=\"keyword\">case</span> </span><br><span class=\"line\">\t<span class=\"keyword\">when</span> r_value <span class=\"operator\">&gt;</span><span class=\"number\">2.7939</span> <span class=\"keyword\">and</span> f_value <span class=\"operator\">&gt;</span> <span class=\"number\">2.2606</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;重要高价值客户&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">when</span> r_value <span class=\"operator\">&lt;</span><span class=\"number\">2.7939</span> <span class=\"keyword\">and</span> f_value <span class=\"operator\">&gt;</span> <span class=\"number\">2.2606</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;重要换回客户&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">when</span> r_value <span class=\"operator\">&gt;</span><span class=\"number\">2.7939</span> <span class=\"keyword\">and</span> f_value <span class=\"operator\">&lt;</span> <span class=\"number\">2.2606</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;重要深耕客户&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">when</span> r_value <span class=\"operator\">&lt;</span><span class=\"number\">2.7939</span> <span class=\"keyword\">and</span> f_value <span class=\"operator\">&lt;</span> <span class=\"number\">2.2606</span> <span class=\"keyword\">then</span> <span class=\"string\">&#x27;重要挽留客户&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t) user_class</span><br><span class=\"line\"><span class=\"keyword\">from</span> r_level, f_level</span><br><span class=\"line\"><span class=\"keyword\">where</span> r_level.user_id <span class=\"operator\">=</span> f_level.user_id</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"商品指标\"><a href=\"#商品指标\" class=\"headerlink\" title=\"商品指标\"></a>商品指标</h3><p>本案例数据中没有商品金额，因此只能从现有的数据中寻找分析指标：</p>\n<p>商品id，用户行为类型(1-曝光、2-购买、3-加入购物⻋、4-加入收藏夹)，品类id</p>\n<p>两个维度：商品维度和品类维度</p>\n<ul>\n<li><p>商品维度</p>\n<p>商品点击量（曝光量），收藏量，加购量，购买次数，购买转化（该商品的所有用户中有购买转化的用户比）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 商品</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\titem_id, </span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,item_id,<span class=\"keyword\">null</span>)),</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) pv,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) fav,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) cart,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) buy,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,user_id,<span class=\"keyword\">null</span>))<span class=\"operator\">/</span><span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) buy_rate</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> temp_trade <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> item_id</span><br></pre></td></tr></table></figure></li>\n<li><p>品类维度</p>\n<p>品类点击量（曝光量），收藏量，加购量，购买次数，购买转化（该商品品类的所有用户中有购买转化的用户比)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 品类 </span></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\titem_category, </span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,item_category,<span class=\"keyword\">null</span>)),</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) pv,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) fav,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) cart,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) buy,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,user_id,<span class=\"keyword\">null</span>))<span class=\"operator\">/</span><span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) buy_rate</span><br><span class=\"line\">\t<span class=\"keyword\">from</span> temp_trade <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> item_category</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"平台指标\"><a href=\"#平台指标\" class=\"headerlink\" title=\"平台指标\"></a>平台指标</h3><p>两个维度</p>\n<ul>\n<li><p>平台维度：平台每日的点击次数、收藏次数、加购次数、购买次数、购买转化</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tdates, </span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) pv,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) fav,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">3</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) cart,</span><br><span class=\"line\">\t<span class=\"built_in\">sum</span>(if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>)) buy,</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> if(behavior_type<span class=\"operator\">=</span><span class=\"number\">2</span>,user_id,<span class=\"keyword\">null</span>))<span class=\"operator\">/</span><span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id) buy_rate</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade </span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> dates</span><br></pre></td></tr></table></figure></li>\n<li><p>用户路径维度：</p>\n<p>用户行为路径是针对某一个用户购买某一件商品。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">view</span> if <span class=\"keyword\">exists</span> path_base_view;</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> path_base_view <span class=\"keyword\">as</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> a.<span class=\"operator\">*</span></span><br><span class=\"line\"><span class=\"keyword\">from</span>(</span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tuser_id,item_id,</span><br><span class=\"line\">\t<span class=\"built_in\">lag</span>(behavior_type,<span class=\"number\">4</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time) lag4,</span><br><span class=\"line\">\t<span class=\"built_in\">lag</span>(behavior_type,<span class=\"number\">3</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time) lag3,</span><br><span class=\"line\">\t<span class=\"built_in\">lag</span>(behavior_type,<span class=\"number\">2</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time) lag2,</span><br><span class=\"line\">\t<span class=\"built_in\">lag</span>(behavior_type,<span class=\"number\">1</span>) <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time) lag1,</span><br><span class=\"line\">\tbehavior_type,</span><br><span class=\"line\">\t<span class=\"built_in\">rank</span>() <span class=\"keyword\">over</span>(<span class=\"keyword\">partition</span> <span class=\"keyword\">by</span> user_id,item_id <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> date_time <span class=\"keyword\">desc</span>) rank_number</span><br><span class=\"line\"><span class=\"keyword\">from</span> temp_trade</span><br><span class=\"line\">)a</span><br><span class=\"line\"><span class=\"keyword\">where</span> a.behavior_type <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">and</span> a.rank_number <span class=\"operator\">=</span> <span class=\"number\">1</span> <span class=\"comment\">-- 只统计每个用户商品分组中，最后一次购买的记录</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> </span><br><span class=\"line\">\tconcat(ifnull(lag4,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag3,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag2,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag1,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,behavior_type),</span><br><span class=\"line\">\t<span class=\"built_in\">count</span>(<span class=\"keyword\">distinct</span> user_id)</span><br><span class=\"line\"><span class=\"keyword\">from</span> path_base_view</span><br><span class=\"line\"><span class=\"keyword\">group</span> <span class=\"keyword\">by</span> concat(ifnull(lag4,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag3,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag2,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,ifnull(lag1,<span class=\"string\">&#x27;空&#x27;</span>),<span class=\"string\">&#x27;-&#x27;</span>,behavior_type)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-14_15-25-13.jpg\"></p>\n<p>为什么要分析用户行为路径？</p>\n<p>根据分析结果可以看到，空-空-空-空-2 这个路径的用户是最多的，也就是直接购买涉及的用户最多。这也反映出加入购物车、收藏等功能大家用的少。</p>\n<p>那在进行产品体验优化的时候就应该考虑，应该把购物车、收藏等功能丰富一下，看看怎么优化一下，让大家把它给用起来。</p>\n<p>为什么要让大家把购物车、收藏功能用起来呢。试想一下，你可能直接购买了一个商品，然后就去支付。是你也支付了，也在平台消费了，但是你毕竟买的是一个商品。如果有购物车功能，并且大家把它都用起来的话，就如同你去超市推了一个购物车，我们不由自主的就想往购物车里放更多的商品，那当你最终购买的时候，相比于你花了好几分钟时间只够买了一个商品，给平台带来的利益更大。</p>\n</li>\n</ul>\n<h1 id=\"案例二-招聘网站岗位数据分析\"><a href=\"#案例二-招聘网站岗位数据分析\" class=\"headerlink\" title=\"案例二 招聘网站岗位数据分析\"></a>案例二 招聘网站岗位数据分析</h1><h2 id=\"项目背景\"><a href=\"#项目背景\" class=\"headerlink\" title=\"项目背景\"></a>项目背景</h2><p>某线下培训机构 打算开设数据分析培训课程。需要对数据分析岗位的市场需求、就业情况、岗位技能做深入调研。</p>\n<p>公司内已开设学科有：游戏、运维。</p>\n<p>数据分析岗位的各项指标与已有学科进行对比。</p>\n<p>本次数据范围，仅针对北上广深四个一线城市进行分析。</p>\n<h2 id=\"确认问题与目标拆解\"><a href=\"#确认问题与目标拆解\" class=\"headerlink\" title=\"确认问题与目标拆解\"></a>确认问题与目标拆解</h2><p><img src=\"https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-14_15-54-59.jpg\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckohezbo70007wct4b2le0ggg","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbod000fwct4dgux2tzj"},{"post_id":"ckohezbnz0001wct43mj341h4","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbof000kwct4delhehgs"},{"post_id":"ckohezbo80008wct46l96flbf","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbon000nwct4goy9gh3k"},{"post_id":"ckohezbob000cwct49socgh05","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezboq000swct4azruey5p"},{"post_id":"ckohezbo30003wct4hkpq7nd0","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbor000vwct42s0063kw"},{"post_id":"ckohezbod000ewct4fochg6as","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbos000zwct48d2q6w2e"},{"post_id":"ckohezbo60006wct4aeh45isf","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbou0012wct4hil0hm3c"},{"post_id":"ckohezbon000mwct447984lhe","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbov0015wct484rw1iax"},{"post_id":"ckohezbop000rwct4bypn30jr","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbox0019wct4fo6zhszo"},{"post_id":"ckohezbor000uwct4e5bbe8r5","category_id":"ckohezboo000owct41bp9di30","_id":"ckohezboy001bwct46v1p1vcl"},{"post_id":"ckohezbof000jwct4able14mu","category_id":"ckohezboo000owct41bp9di30","_id":"ckohezboz001ewct4heymaxv1"},{"post_id":"ckohezbot0011wct4a1eph1zw","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbp0001hwct4h3u0cqc4"},{"post_id":"ckohezbou0014wct47z5chj0v","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbp1001jwct4htuqh1nl"},{"post_id":"ckohezbow0017wct45v1k9lr0","category_id":"ckohezbou0013wct4giv6hoc2","_id":"ckohezbp1001lwct4gkx14zr8"},{"post_id":"ckohezbos000xwct4bzjza46l","category_id":"ckohezbou0013wct4giv6hoc2","_id":"ckohezbp2001nwct46vjvahhy"},{"post_id":"ckohezbox001awct4dpft9lb1","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbp2001pwct4ggfk5lo2"},{"post_id":"ckohezboz001dwct4evecg8t2","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbp2001qwct4exlu750v"},{"post_id":"ckohezbp0001gwct4bk9cgqwh","category_id":"ckohezbou0013wct4giv6hoc2","_id":"ckohezbp3001twct45h1c29h5"},{"post_id":"ckohezbpr0023wct44wd602ly","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbpu0028wct4gnp42vrr"},{"post_id":"ckohezbps0024wct43sumehbt","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbpu0029wct44nc182z3"},{"post_id":"ckohezbps0026wct47rgwhdbv","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbpv002bwct47p57bqqn"},{"post_id":"ckohezbq8002fwct4hlnae7s4","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbq9002hwct4d5aa0h3d"},{"post_id":"ckohezbrh002iwct46vzibe8b","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckohezbrn002kwct4adum082l"},{"post_id":"ckold8fi40000ryt4ew24et5m","category_id":"ckohezbo40004wct44xkz40ix","_id":"ckold8fi70002ryt4ghgl4h7j"}],"PostTag":[{"post_id":"ckohezbo70007wct4b2le0ggg","tag_id":"ckohezbo60005wct427l2234p","_id":"ckohezbob000bwct4awjdg0vc"},{"post_id":"ckohezbnz0001wct43mj341h4","tag_id":"ckohezbo60005wct427l2234p","_id":"ckohezboc000dwct4d6pm6e81"},{"post_id":"ckohezbo80008wct46l96flbf","tag_id":"ckohezbo60005wct427l2234p","_id":"ckohezboe000iwct4bccwgzdq"},{"post_id":"ckohezbob000cwct49socgh05","tag_id":"ckohezbo60005wct427l2234p","_id":"ckohezbom000lwct405tjb3hf"},{"post_id":"ckohezbo30003wct4hkpq7nd0","tag_id":"ckohezbo60005wct427l2234p","_id":"ckohezbop000qwct43mulhfee"},{"post_id":"ckohezbod000ewct4fochg6as","tag_id":"ckohezbo60005wct427l2234p","_id":"ckohezboq000twct4dilz6i0j"},{"post_id":"ckohezbo60006wct4aeh45isf","tag_id":"ckohezbo60005wct427l2234p","_id":"ckohezbos000wwct4hpowdafs"},{"post_id":"ckohezbof000jwct4able14mu","tag_id":"ckohezboo000pwct4asn0egtk","_id":"ckohezbot0010wct48gaf5xd3"},{"post_id":"ckohezbon000mwct447984lhe","tag_id":"ckohezbos000ywct4fpm24woo","_id":"ckohezbox0018wct42k9v7jrk"},{"post_id":"ckohezbop000rwct4bypn30jr","tag_id":"ckohezbov0016wct4gmsa536a","_id":"ckohezboz001fwct4hglj3ya1"},{"post_id":"ckohezbor000uwct4e5bbe8r5","tag_id":"ckohezboy001cwct4cx33d6xe","_id":"ckohezbp1001kwct43vw52sxd"},{"post_id":"ckohezbos000xwct4bzjza46l","tag_id":"ckohezbp1001iwct47uahezq4","_id":"ckohezbp2001owct4ghcp00d0"},{"post_id":"ckohezbot0011wct4a1eph1zw","tag_id":"ckohezbp2001mwct492lld7fl","_id":"ckohezbp3001swct460am5v3r"},{"post_id":"ckohezbou0014wct47z5chj0v","tag_id":"ckohezbp2001mwct492lld7fl","_id":"ckohezbp3001vwct40h0m2nub"},{"post_id":"ckohezbow0017wct45v1k9lr0","tag_id":"ckohezbp1001iwct47uahezq4","_id":"ckohezbp4001xwct41t7q5yhz"},{"post_id":"ckohezbox001awct4dpft9lb1","tag_id":"ckohezbp2001mwct492lld7fl","_id":"ckohezbp4001zwct4b9xdbtxq"},{"post_id":"ckohezboz001dwct4evecg8t2","tag_id":"ckohezbp2001mwct492lld7fl","_id":"ckohezbp40021wct4553y7y5z"},{"post_id":"ckohezbp0001gwct4bk9cgqwh","tag_id":"ckohezbp40020wct414tt6gae","_id":"ckohezbp50022wct4amr1g7h1"},{"post_id":"ckohezbpr0023wct44wd602ly","tag_id":"ckohezbo60005wct427l2234p","_id":"ckohezbps0025wct49wbf2wry"},{"post_id":"ckohezbps0024wct43sumehbt","tag_id":"ckohezbp1001iwct47uahezq4","_id":"ckohezbpv002cwct41tlx7ipp"},{"post_id":"ckohezbps0024wct43sumehbt","tag_id":"ckohezbpu0027wct4aubvhrcd","_id":"ckohezbpv002dwct47cy74z48"},{"post_id":"ckohezbps0026wct47rgwhdbv","tag_id":"ckohezbpu002awct4aygycpyn","_id":"ckohezbpw002ewct4gczw9423"},{"post_id":"ckohezbq8002fwct4hlnae7s4","tag_id":"ckohezbp2001mwct492lld7fl","_id":"ckohezbq9002gwct4ao2qbwan"},{"post_id":"ckohezbrh002iwct46vzibe8b","tag_id":"ckohezbp1001iwct47uahezq4","_id":"ckohezbru002lwct4665fcknv"},{"post_id":"ckohezbrh002iwct46vzibe8b","tag_id":"ckohezbri002jwct46ux77s4c","_id":"ckohezbrv002mwct4gxcrf73k"},{"post_id":"ckold8fi40000ryt4ew24et5m","tag_id":"ckohezbp2001mwct492lld7fl","_id":"ckold8fi70001ryt4bzktcmcs"}],"Tag":[{"name":"Angular","_id":"ckohezbo60005wct427l2234p"},{"name":"hexo","_id":"ckohezboo000pwct4asn0egtk"},{"name":"Rxjs","_id":"ckohezbos000ywct4fpm24woo"},{"name":"typeScript","_id":"ckohezbov0016wct4gmsa536a"},{"name":"Node","_id":"ckohezboy001cwct4cx33d6xe"},{"name":"javaScript","_id":"ckohezbp1001iwct47uahezq4"},{"name":"数据分析","_id":"ckohezbp2001mwct492lld7fl"},{"name":"WeUI","_id":"ckohezbp40020wct414tt6gae"},{"name":"ES6","_id":"ckohezbpu0027wct4aubvhrcd"},{"name":"git","_id":"ckohezbpu002awct4aygycpyn"},{"name":"ES5","_id":"ckohezbri002jwct46ux77s4c"}]}}