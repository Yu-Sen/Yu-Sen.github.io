<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;yu-sen.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Mist&quot;,&quot;version&quot;:&quot;8.4.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:true,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:false,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script>
<meta name="description" content="窗口函数、索引、视图">
<meta property="og:type" content="article">
<meta property="og:title" content="【数据分析】第二阶段：MySQL数据分析实战（二）">
<meta property="og:url" content="https://yu-sen.github.io/20210508224642/index.html">
<meta property="og:site_name" content="昱森笔记">
<meta property="og:description" content="窗口函数、索引、视图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_18-26-26.jpg">
<meta property="og:image" content="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_21-42-58.jpg">
<meta property="og:image" content="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_22-54-39.jpg">
<meta property="og:image" content="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-07-31.jpg">
<meta property="og:image" content="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-08-38.jpg">
<meta property="og:image" content="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-09-15.jpg">
<meta property="article:published_time" content="2021-05-08T14:46:42.000Z">
<meta property="article:modified_time" content="2021-06-13T16:42:47.977Z">
<meta property="article:author" content="昱森">
<meta property="article:tag" content="数据分析">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_18-26-26.jpg">


<link rel="canonical" href="https://yu-sen.github.io/20210508224642/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;yu-sen.github.io&#x2F;20210508224642&#x2F;&quot;,&quot;path&quot;:&quot;20210508224642&#x2F;&quot;,&quot;title&quot;:&quot;【数据分析】第二阶段：MySQL数据分析实战（二）&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>【数据分析】第二阶段：MySQL数据分析实战（二） | 昱森笔记</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">昱森笔记</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">窗口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.</span> <span class="nav-text">聚合类窗口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%AF%E8%AE%A1%E8%AE%A1%E7%AE%97"><span class="nav-number">1.1.1.</span> <span class="nav-text">累计计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">排序窗口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rank%E3%80%81dense-rank%E3%80%81row-number"><span class="nav-number">1.2.1.</span> <span class="nav-text">rank、dense_rank、row_number</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ntile"><span class="nav-number">1.2.2.</span> <span class="nav-text">ntile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%8F%E7%A7%BB%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">偏移分析函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lag%E3%80%81lead"><span class="nav-number">1.3.1.</span> <span class="nav-text">lag、lead</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">2.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">常见索引分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-primary-key"><span class="nav-number">2.2.</span> <span class="nav-text">主键索引(primary key)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95-unique"><span class="nav-number">2.3.</span> <span class="nav-text">唯一索引(unique)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95-normal-index"><span class="nav-number">2.4.</span> <span class="nav-text">普通索引(normal index)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">2.5.</span> <span class="nav-text">复合索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-number">2.6.</span> <span class="nav-text">删除索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">3.</span> <span class="nav-text">视图</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E2%80%94%E2%80%94%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">作业——知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%95%99%E5%AD%98"><span class="nav-number">4.1.</span> <span class="nav-text">留存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%A8%E5%90%8C%E6%AF%94"><span class="nav-number">4.2.</span> <span class="nav-text">周同比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E5%8F%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">平台模式</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="昱森"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">昱森</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yu-sen.github.io/20210508224642/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="昱森">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="昱森笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【数据分析】第二阶段：MySQL数据分析实战（二）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-08 22:46:42" itemprop="dateCreated datePublished" datetime="2021-05-08T22:46:42+08:00">2021-05-08</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-06-14 00:42:47" itemprop="dateModified" datetime="2021-06-14T00:42:47+08:00">2021-06-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

            <div class="post-description">窗口函数、索引、视图</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p>窗口函数（也叫分析函数），从MySQL8.0开始支持。</p>
<p>窗口在数据中限定出一个范围，函数对这个范围内的集合进行统计。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名() over(子句)</span><br></pre></td></tr></table></figure>

<p>over就是窗口，通过子句限定窗口的范围，函数在该范围内执行。</p>
<p>over中的子句具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名() over(partition by 分组字段1,分组字段2... order by &lt;排序字段&gt; rows between &lt;范围起始行数&gt; and &lt;范围结束行数&gt;)</span><br></pre></td></tr></table></figure>

<p><strong>⚠️注意：</strong></p>
<ul>
<li><strong>子句间<em>没有</em>逗号，间隔</strong></li>
<li><strong>over子句中多个字段用逗号，分割，不是用and</strong></li>
</ul>
<p>具体示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 选出D1行至D2行的记录集合，在该集合内，按照B分组，按照C排序，最后每一组对A求和</span><br><span class="line">sum(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...) </span><br><span class="line">avg(...A...) over(partition by ...B... order by ...C... rows between ...D1... and ...D2...)</span><br><span class="line"></span><br><span class="line">A: 需要被加工的字段名称 </span><br><span class="line">B: 分组的字段名称</span><br><span class="line">C: 排序的字段名称</span><br><span class="line">D: 计算的行数范围</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rows between 2 preceding(在..之前) and current row # 范围：当前查询位置的前2行——当前行，共3行</span><br><span class="line">rows between unbounded(无限) preceding(在..之前) and current row # 范围：当前查询位置的前所有行——当前行</span><br><span class="line">rows between current row and unbounded(无限) following(在...之后) # 范围：当前查询位置的当前行——之后的所有行</span><br><span class="line">rows between 3 preceding and current row # 范围：当前查询位置的前3行——当前行，共4行</span><br><span class="line">rows between 3 preceding and 1 following # 范围：当前查询位置的前3行——后1行，共5行</span><br></pre></td></tr></table></figure>

<ul>
<li>当不指定rows between时，窗口规范默认是：该partition分组中rows between unbounded preceding and current row</li>
<li>当不指定order by 和 rows between时, 窗口规范默认是：该partition分组中rows between unbounded preceding and unbounded following</li>
<li>当不指定partition时，order by的作用范围是整个数据表；指定partition时，order by的作用范围是当前分组</li>
<li>当over子句中什么都不写时，窗口规范默认是整张表全部数据</li>
</ul>
<p><strong>⚠️注意：where优先级&gt;over，where是对源数据进行过滤，过滤后的结果集再执行over或group by等操作。</strong></p>
<h2 id="聚合类窗口函数"><a href="#聚合类窗口函数" class="headerlink" title="聚合类窗口函数"></a>聚合类窗口函数</h2><ul>
<li>sum()</li>
<li>count()</li>
<li>avg()</li>
<li>Max()</li>
<li>min()</li>
</ul>
<p>窗口函数下的聚合函数 和 普通场景下的聚合函数区别：</p>
<p>普通场景下的聚合函数是将多条记录聚合为一条**(多到一)<strong>；窗口函数下是每条记录都会执 行，有几条记录执行完还是几条</strong>(多到多)**。</p>
<h3 id="累计计算"><a href="#累计计算" class="headerlink" title="累计计算"></a>累计计算</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 需求<span class="number">1</span>：查询出<span class="number">2019</span>年每月的支付总额和当年累积支付总额</span><br><span class="line"><span class="keyword">select</span> a._month, a._pay_mount_sum, <span class="built_in">sum</span>(a._pay_mount_sum) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> a._month)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">month</span>(pay_time) <span class="keyword">as</span> _month, <span class="built_in">sum</span>(pay_amount) <span class="keyword">as</span> _pay_mount_sum</span><br><span class="line">	<span class="keyword">from</span> user_trade</span><br><span class="line">	<span class="keyword">where</span> <span class="keyword">year</span>(pay_time) <span class="operator">=</span> <span class="number">2019</span></span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">month</span>(pay_time)</span><br><span class="line">)a</span><br><span class="line"></span><br><span class="line"># ❌错误写法</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">month</span>(pay_time), <span class="built_in">sum</span>(pay_amount)，<span class="built_in">sum</span>(<span class="built_in">sum</span>(pay_amount)) <span class="keyword">over</span>(<span class="keyword">month</span>(pay_time))</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(pay_time) <span class="operator">=</span> <span class="number">2019</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">month</span>(pay_time)</span><br><span class="line"># 这么写的想法：<span class="keyword">group</span> <span class="keyword">by</span>分组已经取得了月份、每个月支付总额，那么再直接用窗口函数就能取得每个月的累计支付总额</span><br><span class="line"># 错误原因：<span class="keyword">group</span> <span class="keyword">by</span>只是完成了按月分组，必须还要完成<span class="keyword">select</span> <span class="keyword">month</span>(pay_time), <span class="built_in">sum</span>(pay_amount)才能获取最终的数据集，如果在 <span class="keyword">select</span>中加入窗口函数，此时并没有取得数据集，窗口函数也就无法执行。所以需要子查询的方式，先让<span class="keyword">group</span> <span class="keyword">by</span>完成<span class="keyword">select</span>取得数据集，再将数 据集作为表通过子查询执行窗口函数</span><br><span class="line"></span><br><span class="line"># 需求<span class="number">2</span>：查询出<span class="number">2018</span><span class="number">-2019</span>年每月的支付总额和当年累积支付总额</span><br><span class="line"><span class="keyword">select</span> a._year,a._month,<span class="built_in">sum</span>(a.pay_amount_sum) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> a._year <span class="keyword">order</span> <span class="keyword">by</span> a._month)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">year</span>(pay_time) _year, <span class="keyword">month</span>(pay_time) _month, <span class="built_in">sum</span>(pay_amount) pay_amount_sum</span><br><span class="line">	<span class="keyword">from</span> user_trade</span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">year</span>(pay_time), <span class="keyword">month</span>(pay_time)</span><br><span class="line">	<span class="keyword">having</span> _year <span class="keyword">in</span> (<span class="number">2018</span>,<span class="number">2019</span>)</span><br><span class="line">	<span class="keyword">order</span> <span class="keyword">by</span> _year, _month</span><br><span class="line">)a</span><br><span class="line"></span><br><span class="line"># 需求<span class="number">3</span>: 查询出<span class="number">2019</span>年每个月的近三月移动平均支付金额</span><br><span class="line"><span class="keyword">select</span> a._month, a._pay_amount, <span class="built_in">avg</span>(a._pay_amount) <span class="keyword">over</span>(<span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">2</span> preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>)</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">month</span>(pay_time) _month, <span class="built_in">sum</span>(pay_amount) _pay_amount</span><br><span class="line">	<span class="keyword">from</span> user_trade</span><br><span class="line">	<span class="keyword">where</span> <span class="keyword">year</span>(pay_time) <span class="operator">=</span> <span class="number">2019</span></span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> _month</span><br><span class="line">	<span class="keyword">order</span> <span class="keyword">by</span> _month</span><br><span class="line">)a</span><br></pre></td></tr></table></figure>

<h2 id="排序窗口函数"><a href="#排序窗口函数" class="headerlink" title="排序窗口函数"></a>排序窗口函数</h2><h3 id="rank、dense-rank、row-number"><a href="#rank、dense-rank、row-number" class="headerlink" title="rank、dense_rank、row_number"></a>rank、dense_rank、row_number</h3><ul>
<li>rank() over(partition by &lt;分组字段&gt; order by &lt;排序字段&gt;)，返回排序后的排名（并列排名占用名次）</li>
<li>Dense_rank() over(partition by &lt;分组字段&gt; order by &lt;排序字段&gt;)，返回排序后的排名（并列排名不占用名次）</li>
<li>Row_number() over(partition by &lt;分组字段&gt; order by &lt;排序字段&gt;)，返回排序后的行号（从1开始）</li>
</ul>
<p>⚠️这三种排序函数不需要参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 语法</span><br><span class="line">row_number(无参数) over(......) </span><br><span class="line">rank(无参数) over(......) </span><br><span class="line">dense_rank(无参数) over(......)</span><br><span class="line"></span><br><span class="line">在rank()函数，如果有并列情况，会占用下一个名次的位置，比如，成绩为100的学生有三个并列第一，那么99分的学生是第二名，通过rank()函数，名次是：1,1,1,4；</span><br><span class="line"></span><br><span class="line">在dense()函数中，如果有并列的情况，不会占用下一个名词，同用上个例子，名次是：1,1,1,2；</span><br><span class="line"></span><br><span class="line">在row_number()函数中，会忽略并列的情况，同用上述例子，名次是：1,2,3,4;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 需求<span class="number">5</span>: <span class="number">2020</span>年<span class="number">1</span>月，购买商品品类数的用户排名</span><br><span class="line"># 本案例中 不需要先子查询再对子查询结果使用排序函数。要考虑两个问题，一是所使用的函数是在生成数据集的同时就能使用，还是要生成完毕才可以使用；二是在使用函数的时，是否已经生成了数据集。</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	user_name,</span><br><span class="line">	<span class="comment">-- 这里使用distinct去重，因为一个用户可能在不同的时间购买了同一个品类的商品</span></span><br><span class="line">	<span class="built_in">count</span>( <span class="keyword">DISTINCT</span> goods_category ) goods_c_count,</span><br><span class="line">	<span class="built_in">row_number</span>() <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>( <span class="keyword">DISTINCT</span> goods_category ) ) _row_number,</span><br><span class="line">	<span class="built_in">rank</span>() <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>( <span class="keyword">DISTINCT</span> goods_category ) ) _rank,</span><br><span class="line">	<span class="built_in">dense_rank</span>() <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>( <span class="keyword">DISTINCT</span> goods_category ) ) _dense_rank </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	user_trade </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">YEAR</span> ( pay_time ) <span class="operator">=</span> <span class="number">2020</span> </span><br><span class="line">	<span class="keyword">AND</span> <span class="keyword">MONTH</span> ( pay_time ) <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	user_name</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_18-26-26.jpg"></p>
<h3 id="ntile"><a href="#ntile" class="headerlink" title="ntile"></a>ntile</h3><ul>
<li>ntile(n) over(partition by &lt;分组字段A&gt; order by &lt;排序字段B&gt;)</li>
</ul>
<p><strong>n</strong>:切分的片数<br><strong>A</strong>:分组的字段名称<br><strong>B</strong>:排序的字段名称</p>
<p>ntile(<strong>n</strong>)，用于将分组数据按照顺序切分成n片，返回当前切片值。</p>
<p>Ntile(n) over(partition by &lt;分组字段A&gt; order by &lt;排序字段B&gt;)函数简单的说，就是对各分组（没有分组就是整张表）的数据，先按照order by字段排序，然后分成n组，然后按照排序给每个组排名。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 需求<span class="number">6</span>: 查询出将<span class="number">2020</span>年<span class="number">2</span>月的支付用户，按照支付金额分成<span class="number">5</span>组后的结果</span><br><span class="line"><span class="keyword">select</span> user_name, <span class="built_in">sum</span>(pay_amount) pay_amount, <span class="built_in">ntile</span>(<span class="number">5</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(pay_amount) <span class="keyword">desc</span>)level</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(pay_time) <span class="operator">=</span> <span class="number">2020</span></span><br><span class="line"><span class="keyword">and</span> <span class="keyword">month</span>(pay_time) <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_21-42-58.jpg"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 需求<span class="number">7</span>：查询出<span class="number">2020</span>年支付金额排名前<span class="number">30</span><span class="operator">%</span>的所有用户</span><br><span class="line"><span class="keyword">select</span> a.user_name, a.pay_amount, a.level</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">	<span class="keyword">select</span> user_name, <span class="built_in">sum</span>(pay_amount)pay_amount, <span class="built_in">ntile</span>(<span class="number">10</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">sum</span>(pay_amount) <span class="keyword">desc</span>) level</span><br><span class="line">	<span class="keyword">from</span> user_trade</span><br><span class="line">	<span class="keyword">where</span> <span class="keyword">year</span>(pay_time) <span class="operator">=</span> <span class="number">2020</span></span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> user_name</span><br><span class="line">)a</span><br><span class="line"><span class="keyword">where</span> a.level <span class="operator">&lt;</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="偏移分析函数"><a href="#偏移分析函数" class="headerlink" title="偏移分析函数"></a>偏移分析函数</h2><h3 id="lag、lead"><a href="#lag、lead" class="headerlink" title="lag、lead"></a>lag、lead</h3><p>lag() 函数，允许您向上偏移多行并从当前行访问偏移行的数据</p>
<p>lead() 函数，允许您向下看多行并从当前行访问偏移行的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 向上偏移</span><br><span class="line">lag(&lt;expression&gt;[,offset[, default_value]]) over (partition by expr... order by expr [asc|desc]...) </span><br><span class="line"># 向下偏移</span><br><span class="line">lead(&lt;expression&gt;[,offset[, default_value]]) over (partition by expr... order by expr [asc|desc]...) </span><br></pre></td></tr></table></figure>

<p>执行到当前分组的某一行时，返回偏移offset行的行的expression字段的值，如果偏移量超过了分组或窗口范围，返回default_value。</p>
<p>如果不写offset参数，默认偏移1行。</p>
<p>如果不写default_value参数，默认值为null。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> user_name,pay_time,</span><br><span class="line">       <span class="built_in">lag</span>(pay_time,<span class="number">1</span>,pay_time) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name <span class="keyword">order</span> <span class="keyword">by</span> pay_time) lag1,</span><br><span class="line">			<span class="comment">-- 没有传入偏移量，那么默认就是1，找不到的话，此处也没有给默认值，为 null</span></span><br><span class="line">			 <span class="built_in">lag</span>(pay_time) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name <span class="keyword">order</span> <span class="keyword">by</span> pay_time)lag1_s,</span><br><span class="line">       <span class="built_in">lag</span>(pay_time,<span class="number">2</span>,pay_time) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name <span class="keyword">order</span> <span class="keyword">by</span> pay_time) lag2,</span><br><span class="line">       <span class="built_in">lag</span>(pay_time,<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name <span class="keyword">order</span> <span class="keyword">by</span> pay_time)lag2_s</span><br><span class="line"><span class="keyword">FROM</span> user_trade</span><br><span class="line"><span class="keyword">WHERE</span> user_name <span class="keyword">in</span> (<span class="string">&#x27;King&#x27;</span>,<span class="string">&#x27;West&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-09_22-54-39.jpg"></p>
<p><strong>在实际应用当中，若要用到取今天和昨天的某字段差值时，Lag和Lead函数的应用就显得尤为重要。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 需求<span class="number">10</span>: 查询出支付时间间隔超过<span class="number">100</span>天的用户数</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> a.user_name)</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">	<span class="keyword">select</span> </span><br><span class="line">  	user_name,pay_time, </span><br><span class="line">  	<span class="built_in">lead</span>(pay_time,<span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name <span class="keyword">order</span> <span class="keyword">by</span> pay_time) lead_time </span><br><span class="line">	<span class="keyword">from</span> user_trade</span><br><span class="line">)a</span><br><span class="line"><span class="keyword">where</span> a.lead_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">and</span> datediff(a.lead_time,a.pay_time) <span class="operator">&gt;</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 需求<span class="number">11</span>: 查询出每年支付时间间隔最长的用户</span><br><span class="line"># ✅</span><br><span class="line"><span class="keyword">select</span> b.user_name, <span class="keyword">year</span>(b.pay_time), b.diff_time</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">		<span class="keyword">select</span> </span><br><span class="line">			a.user_name, a.pay_time, </span><br><span class="line">			a.lead_time, datediff(a.lead_time,a.pay_time) diff_time, </span><br><span class="line">			<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">year</span>(a.pay_time) <span class="keyword">order</span> <span class="keyword">by</span> datediff(a.lead_time,a.pay_time) <span class="keyword">desc</span>) _rank</span><br><span class="line">		<span class="keyword">from</span> (</span><br><span class="line">			<span class="keyword">select</span> user_name, pay_time, <span class="built_in">lead</span>(pay_time,<span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name, <span class="keyword">year</span>(pay_time) <span class="keyword">order</span> <span class="keyword">by</span> pay_time) lead_time</span><br><span class="line">			<span class="keyword">from</span> user_trade</span><br><span class="line">		)a</span><br><span class="line">		<span class="keyword">where</span> a.lead_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">	)b</span><br><span class="line">	<span class="keyword">where</span> b._rank <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># ❌，错误原因：</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在第2层子查询计算出了每年每个用户的支付间隔后，外套一层查询，并按年分组，然后用max（）选出每组，也就是每年间隔时间最长的人，</span></span><br><span class="line"><span class="comment">这时发现，在select中只有max(b.diff_time)时不会报错，但加上b.user_name就会报错。</span></span><br><span class="line"><span class="comment">这时因为，一年中存在多个用户的支付时间间隔并列最长，这时max(b.diff_time)会默认返回第一个(还是随机一个），但是user_name有多个，系统不知道该返回哪个，就会报错了。</span></span><br><span class="line"><span class="comment">所以这里不能用max，应该用rank()函数，这样就考虑到了并列最大的情况。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> b.user_name, <span class="built_in">max</span>(b.diff_time)</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">	<span class="keyword">select</span> a.user_name, a.pay_time, a.lead_time, datediff(a.lead_time,a.pay_time) diff_time</span><br><span class="line">	<span class="keyword">from</span> (</span><br><span class="line">		<span class="keyword">select</span> user_name, pay_time, <span class="built_in">lead</span>(pay_time,<span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name, <span class="keyword">year</span>(pay_time) <span class="keyword">order</span> <span class="keyword">by</span> pay_time) lead_time</span><br><span class="line">		<span class="keyword">from</span> user_trade</span><br><span class="line">	)a</span><br><span class="line">	<span class="keyword">where</span> a.lead_time <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">)b</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">year</span>(b.pay_time)</span><br></pre></td></tr></table></figure>

<p><strong>max()并列最大错误测试：</strong></p>
<p>测试表数据</p>
<p><img src="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-07-31.jpg"></p>
<p>只select max()不报错</p>
<p><img src="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-08-38.jpg"></p>
<p>select user_id报错</p>
<p><img src="https://gitee.com/ethan-H/imghost/raw/master/blog/Xnip2021-05-10_00-09-15.jpg"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>聚合窗口函数 不能 在第一次select时同时执行，必须先select完毕，结果集再作为新表通过子查询使用聚合窗口函数。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 报错❌</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">	<span class="keyword">month</span>(pay_time) <span class="keyword">as</span> _month, </span><br><span class="line">	<span class="built_in">sum</span>(pay_amount) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">month</span>(pay_time))</span><br><span class="line"><span class="keyword">from</span> user_trade</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(pay_time) <span class="operator">=</span> <span class="number">2019</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">month</span>(pay_time)</span><br><span class="line"></span><br><span class="line"># 正确✅</span><br><span class="line"><span class="keyword">select</span> a._month, a._pay_mount_sum, <span class="built_in">sum</span>(a._pay_amount_sum) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> a._month)</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">month</span>(pay_time) <span class="keyword">as</span> _month, <span class="built_in">sum</span>(pay_amount) <span class="keyword">as</span> _pay_amount_sum</span><br><span class="line">	<span class="keyword">from</span> user_trade</span><br><span class="line">	<span class="keyword">where</span> <span class="keyword">year</span>(pay_time) <span class="operator">=</span> <span class="number">2019</span></span><br><span class="line">	<span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">month</span>(pay_time)</span><br><span class="line">)a</span><br></pre></td></tr></table></figure>

<ul>
<li>排序窗口函数、偏移分析函数 可以 在第一次select时同时执行。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># ✅</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	user_name,</span><br><span class="line">	<span class="built_in">count</span>( <span class="keyword">DISTINCT</span> goods_category ) goods_c_count,</span><br><span class="line">	<span class="built_in">row_number</span>() <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>( <span class="keyword">DISTINCT</span> goods_category ) ) _row_number,</span><br><span class="line">	<span class="built_in">rank</span>() <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>( <span class="keyword">DISTINCT</span> goods_category ) ) _rank,</span><br><span class="line">	<span class="built_in">dense_rank</span>() <span class="keyword">over</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">count</span>( <span class="keyword">DISTINCT</span> goods_category ) ) _dense_rank </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	user_trade </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">YEAR</span> ( pay_time ) <span class="operator">=</span> <span class="number">2020</span> </span><br><span class="line">	<span class="keyword">AND</span> <span class="keyword">MONTH</span> ( pay_time ) <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	user_name</span><br><span class="line">	</span><br><span class="line"># ✅</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"> 	user_name,pay_time, </span><br><span class="line"> 	<span class="built_in">lead</span>(pay_time,<span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_name <span class="keyword">order</span> <span class="keyword">by</span> pay_time) lead_time </span><br><span class="line"><span class="keyword">from</span> user_trade</span><br></pre></td></tr></table></figure>

<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>字典的目录就是一种索引机制，提高检索的效率。</p>
<ul>
<li>索引可以提升查询速度，会影响where和order by。</li>
<li>索引是针对字段的，需要添加到字段上。给某一列添加索引的时候，数据库会将这一列的数据进行提取、转换、再存储。存储下来的数据就是索引。当查询的时候，会先查询索引数据，能够更快速的找到相关信息。</li>
<li>索引在大量数据场景下效果明显。</li>
</ul>
<h2 id="常见索引分类"><a href="#常见索引分类" class="headerlink" title="常见索引分类"></a>常见索引分类</h2><ul>
<li><p>从索引的存储结构划分:B Tree索引、Hash索引、fulltext全文索引、R Tree索引(了解) </p>
</li>
<li><p><strong>从应用层次划分:主键索引、唯一索引、普通索引、复合索引</strong> </p>
</li>
<li><p>从索引的键值(字段)类型划分:主键索引、辅助索引(二级索引) </p>
</li>
<li><p>从索引数据和内容数据逻辑关系划分:聚集索引(聚簇索引)、非聚集索引(非聚簇索 引)</p>
</li>
</ul>
<h2 id="主键索引-primary-key"><a href="#主键索引-primary-key" class="headerlink" title="主键索引(primary key)"></a>主键索引(primary key)</h2><ul>
<li>数据表添加主键的时候，会自动穿件逐渐索引，主键索引也是一种唯一索引。</li>
<li>一个表可以没有主见，但最多只能有一个主键，且主键是唯一的、不能为Null。</li>
<li>根据主键进行where条件查询，效率高。</li>
</ul>
<h2 id="唯一索引-unique"><a href="#唯一索引-unique" class="headerlink" title="唯一索引(unique)"></a>唯一索引(unique)</h2><p>特点：索引列的值只能出现一次，不能重复，保证唯一。</p>
<p>在许多场合，人们创建唯一索引不是为了提高查询速度，而是为了避免数据重复。（使用唯一约束效果相同）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 创建表的时候直接添加唯一索引</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名( </span><br><span class="line">  列名 类型(长度),</span><br><span class="line">	<span class="keyword">UNIQUE</span> [索引名称] (列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 在已有的表上创建索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index 索引名 <span class="keyword">on</span> 表名(列名[长度])</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index index_dname <span class="keyword">on</span> test_index(dname);</span><br><span class="line"></span><br><span class="line"># 修改表结构添加索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> 索引名( 列名 )</span><br></pre></td></tr></table></figure>

<h2 id="普通索引-normal-index"><a href="#普通索引-normal-index" class="headerlink" title="普通索引(normal index)"></a>普通索引(normal index)</h2><p>普通索引的唯一任务是加快检索的速度。一般为需要where条件查询或order by排序的列添加普通索引。</p>
<p>普通索引不要求数据唯一、非空。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在已有的表上创建索引</span><br><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名[长度])</span><br><span class="line"></span><br><span class="line"># 修改表结构添加索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> index 索引名 (列名)</span><br></pre></td></tr></table></figure>

<h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>创建普通索引时，同时写入多个字段。</p>
<p>复合索引一般用在，需要对多个字段进行where条件查询或order by排序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 在已有的表上创建索引</span><br><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>,...)</span><br><span class="line"></span><br><span class="line"># 修改表结构添加索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> index 索引名 (列名<span class="number">1</span>， 列名<span class="number">2</span>,...)</span><br></pre></td></tr></table></figure>

<p>⚠️注意：创建复合索引时要注意字段顺序，创建索引时字段的顺序，要和查询条件中字段的顺序保持一致。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> 字段<span class="number">1</span><span class="operator">=</span>‘’ <span class="keyword">and</span> 字段<span class="number">2</span><span class="operator">=</span>‘’	<span class="comment">-- 字段1，字段2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(字段<span class="number">1</span>, 字段<span class="number">2</span>) <span class="comment">-- 字段1，字段2；不能写成 字段2，字段1</span></span><br></pre></td></tr></table></figure>

<p>⚠️注意：区别复合索引和多个单列索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 复合索引</span><br><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名<span class="number">1</span>, 列名<span class="number">2</span>) <span class="comment">-- 字段顺序要和查询条件中保持一致</span></span><br><span class="line"></span><br><span class="line"># 多个单列索引</span><br><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名<span class="number">1</span>) <span class="comment">-- 不需要考虑字段顺序</span></span><br><span class="line"><span class="keyword">create</span> index 索引名 <span class="keyword">on</span> 表名(列名<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index 索引名;</span><br></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>概念：</p>
<ul>
<li>视图是一种虚拟表。（与之对应的是实体表，比如通过create语句创建的表）</li>
<li>视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。</li>
<li> 向视图提供数据内容的语句为 SELECT 语句, 可以将视图理解为存储起来的 SELECT 语句。</li>
<li>视图向用户提供基表（实体表或者其他视图）数据的另一种表现形式。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> 视图名 [(column_list)] <span class="keyword">as</span> <span class="keyword">select</span>语句;</span><br><span class="line"><span class="keyword">view</span>: 表示视图</span><br><span class="line">column_list: 可选参数，表示属性清单，指定视图中各个属性的名称，默认情况下，与 <span class="keyword">SELECT</span>语句中查询的属性相同</span><br><span class="line"><span class="keyword">as</span> : 表示视图要执行的操作</span><br><span class="line"><span class="keyword">select</span>语句: 向视图提供数据内容</span><br></pre></td></tr></table></figure>

<p>作用：</p>
<ul>
<li>权限控制时可以使用</li>
<li>简化复杂的多表查询</li>
</ul>
<p>sql中视图的概念类似于编程中封装函数的概念，将一段复杂的sql语句封装成一个视图，之后只需通过引用视图名进行查询就能得到结果。并且可以决定从视图中只查询某几个字段的数据，做到权限控制，就像函数可以指定返回的值一样。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 需求<span class="number">1</span>: 查询各个分类下的商品平均价格</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> cp_view <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> category c</span><br><span class="line"><span class="keyword">join</span> products p</span><br><span class="line"><span class="keyword">on</span> c.cid <span class="operator">=</span> p.category_id; <span class="comment">-- 注意这里必须有分号;结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> cname, <span class="built_in">avg</span>(price)</span><br><span class="line"><span class="keyword">from</span> cp_view</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cname</span><br><span class="line"></span><br><span class="line"># 普通写法</span><br><span class="line"><span class="keyword">select</span> cname, <span class="built_in">avg</span>(price)</span><br><span class="line"><span class="keyword">from</span> products p <span class="keyword">left</span> <span class="keyword">join</span> category c</span><br><span class="line"><span class="keyword">on</span> p.category_id <span class="operator">=</span> c.cid</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> c.cname</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 需求<span class="number">2</span>: 查询鞋服分类下最贵的商品的全部信息</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> cp_view2 <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> c.cid, c.cname, p.pid,p.pname, p.price, p.flag, <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> c.cname <span class="keyword">order</span> <span class="keyword">by</span> p.price <span class="keyword">desc</span>) _rank</span><br><span class="line"><span class="keyword">from</span> products p <span class="keyword">left</span> <span class="keyword">join</span> category c </span><br><span class="line"><span class="keyword">on</span> p.category_id <span class="operator">=</span> c.cid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> cp_view2 <span class="keyword">where</span> cname <span class="operator">=</span> <span class="string">&#x27;鞋服&#x27;</span> <span class="keyword">and</span> _rank <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># 普通写法</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> c.cid, c.cname, p.pid,p.pname, p.price, p.flag, <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> c.cname <span class="keyword">order</span> <span class="keyword">by</span> p.price <span class="keyword">desc</span>) _rank</span><br><span class="line"><span class="keyword">from</span> products p <span class="keyword">left</span> <span class="keyword">join</span> category c </span><br><span class="line"><span class="keyword">on</span> p.category_id <span class="operator">=</span> c.cid </span><br><span class="line">)a</span><br><span class="line"><span class="keyword">where</span> a.cname <span class="operator">=</span> <span class="string">&#x27;鞋服&#x27;</span> <span class="keyword">and</span> a._rank <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>视图和表的区别：</p>
<ul>
<li>视图是建立在表的基础上，表存储数据库中的数据，而视图只是做一个数据的展示 。</li>
<li>通过视图不能改变表中数据(一般情况下视图中的数据都是表中的列 经过计算得到的结果, 不允许更新)。</li>
<li> 删除视图，表不受影响，而删除表，视图不再起作用。</li>
</ul>
<h1 id="作业——知识点"><a href="#作业——知识点" class="headerlink" title="作业——知识点"></a>作业——知识点</h1><h2 id="留存"><a href="#留存" class="headerlink" title="留存"></a>留存</h2><p>留存：指基准日到APP的用户在之后的n日当天返回APP的人数。</p>
<p>留存率 = 基准日之后的n天当日返回的用户数 / 基准日的用户数 * 100%。</p>
<p>留存代表一个用户愿意再次使用你的产品;而一个产品能够被用户再次使用，意味着这个产品是能够满</p>
<p>足用户长期需求的，能够让用户产生一定粘性的产品。</p>
<p>活跃用户 = 新增用户 + 留存用户</p>
<p>如今互联网产品大多为免费产品，依靠持续的广告转化、用户持续的购买转化、用户持续的会员付费来维持收益。</p>
<p>持续的广告转化、购买、会员付费，我们就 需要每天都有一定量的用户来完成以上过程，也就是说我们需要我们的产品每天都是有活跃用户的。</p>
<p>从活跃用户的构成，我们就知道怎么维持我们的活跃用户规模：一方面持续有新用户流入，另一方 面持续有留存用户留存。</p>
<p>为什么留存用户重要?部分有过从业经验的同学应该知道，产品的自然新增用户是比较少的，如果 我们仅靠产品自然用户增长，那么必然我们的活跃用户量级会非常小，虽然能够获得收益，但是这部分 收益很可能养不起我们的公司;但是如果我们想要用购买新用户的方式获得持续的较大规模的用户池， 又会产生比较大的成本，这样做容易亏本。所以我们需要新增留存两手抓;想方设法留住我们新增的用 户，让其长期地在我们的产品内产生价值，这样做，比起单做新增，在成本和效果上都是要好的。</p>
<p><strong>留存的主要应用场景有两个：</strong></p>
<ul>
<li><p>一个是产品整体视角的持续留存情况;也就是我们需要定期分析用户在产品的留存是否维持在一个正常 的范围，有没有突然地涨跌情况，如果有的话问题出在哪里，为什么会出现这样的问题，如何解决留存 异常的问题。遇到这类问题首先需要确定的是整体用户的留存异常还是个别群体用户的留存异常，如果 是整体用户的留存异常，我们需要分析我们的产品是否发生异常，可以通过用户的行为路径确定异常产 品位置;如果是个别用户的留存异常，需要通过用户拆解的方法来定位有异常的用户群体，然后通过这 类用户的特征来分析问题原因。</p>
</li>
<li><p>一个是新增用户视角的每批新增用户留存情况。一般出现在计算投放ROI的场景，也就是我们投放一批 用户，能够给我们带来多少收益。我们会用这些用户的“整个生命周期能够带来的收入”(LTV)去除以 “投放时的支出”来计算我们的ROI。“整个生命周期能够带来的收入”计算的是引入一批新用户，当用户完 全流失时，这部分用户所带来的所有收入。但是有时我们需要提前预估新用户在整个生命周期能够带来 的收入，我们就需要首先用留存来估计用户的生命周期，然后用估计出的生命周期再去计算用户的整个 生命周期能够带来的收入。</p>
</li>
</ul>
<p><strong>什么企业不关心留存：</strong> </p>
<p>需要用户产生持续活跃，持续转化，持续消费的企业都关心用户的留存。那么，什么样的企业不关心用户留存?</p>
<ul>
<li><p>部分线下企业存在数据难以获取的问题，所以对留存关注比较少，比如线下的商场，除非用户产生购买 行为，否则很难探知用户在什么情况下有回流。</p>
</li>
<li><p>部分存在一锤子买卖的企业也不太关心留存，比如说用户在一次买断商品后再也不会产生后续购买或价 值转化行为，这类企业也不怎么关注留存。比如PC单机游戏;比如一次付费的工具类产品(线上线下类 工具都存在这个情况)。</p>
</li>
</ul>
<h2 id="周同比"><a href="#周同比" class="headerlink" title="周同比"></a>周同比</h2><p>周同比：周同比适用于以周为周期变动的数据，用于观察每天的数据较上周同一天的数据变化。</p>
<p>现有互联网数据多以周为周期变动，一周内每一天的数据都有其特点:</p>
<ul>
<li><p>如工作类APP，周一会是每一周的高峰，然后向周五逐渐递减，周五到周六又会有一个锐减的过 程，周日与周六趋于平缓;</p>
</li>
<li><p>如娱乐类APP，周一会较周末锐减，然后向周四逐渐递减，周五会有一个跃升的过程，周六会再次 跃升，周日会较周六下降;</p>
</li>
</ul>
<p>一般遇到这样的变动趋势，如果单纯的分析每一天较上一天的变动情况，就容易分析出错误结论。所 以，在我们分析带有周期类数据时，一定要先将周期提炼出来，使用周期的同比数据做分析，会得出更 有价值，更加准确的结论。</p>
<h2 id="平台模式"><a href="#平台模式" class="headerlink" title="平台模式"></a>平台模式</h2><p>如今的大多数内容APP都是以平台模式运营的。</p>
<p>什么叫做平台模式?</p>
<p>比如我们现在能接触到的大多数内容产品“抖音”、“Bilibili”、“微博”、“今日头条”等等。我们使用到的这个 APP，是由APP的制作公司提供的，也就是这个APP会有几个主要的页面，每个页面怎么引导用户进入内 容页面，播放内容的方式有哪些、内容间切换会用什么方式等等，都是我们的APP制作公司决定的;而 我们在这个APP里看到的大多数内容，都是由内容作者提供的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" rel="tag"># 数据分析</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/20210507225731/" rel="prev" title="统计学笔记">
                  <i class="fa fa-chevron-left"></i> 统计学笔记
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/20210511111417/" rel="next" title="【数据分析】第二阶段：MySQL数据分时实战（三）">
                  【数据分析】第二阶段：MySQL数据分时实战（三） <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">昱森</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
